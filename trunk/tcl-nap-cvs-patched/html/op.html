<?xml version="1.0" encoding="iso-8859-1"?>
<!-- $Id: op.html,v 1.27 2006/02/08 06:00:01 dav480 Exp $ -->
<html>
  <head>
    <meta name="generator"
    content="HTML Tidy for Windows (vers 1 September 2005), see www.w3.org" />
    <title>NAP Operators</title>
  </head>
  <body>
  <center>
    <h2>Operators</h2>
  </center>
  <h3>Table of Contents</h3>
  <ol>
    <li>
      <a href="#Precedence">Operators and Precedence</a>
    </li>
    <li>
      <a href="#Assignment">Assignment Operator &quot;<code>=</code>&quot;</a>
    </li>
    <li>
      <a href="#Link">Link Operator &quot;<code>,</code>&quot;</a>
    </li>
    <li>
      <a href="#AP">Arithmetic Progression Operators &quot;<code>..</code>&quot; and &quot;<code>...</code>&quot;</a>
    </li>
    <li>
      <a href="#Concatenation">Concatenation Operators &quot;<code>//</code>&quot; and &quot;<code>///</code>&quot;</a>
    </li>
    <li>
      <a href="#Inverse:Indexing">Inverse Indexing Operators &quot;<code>@</code>&quot;, &quot;<code>@@</code>&quot; and &quot;<code>@@@</code>&quot;</a>
      <ol>
        <li>
          <a href="#Interpolated:Subscript">Interpolated Subscript
          &quot;<code>@</code>&quot;</a>
        </li>
        <li>
          <a href="#Subscript:of:Closest">Subscript of Closest &quot;<code>@@</code>&quot;</a>
        </li>
        <li>
          <a href="#Subscript:of:Match">Subscript of Match &quot;<code>@@@</code>&quot;</a>
        </li>
      </ol>
    </li>
    <li>
      <a href="#Tally">Tally Unary Operator &quot;<code>#</code>&quot;</a>
    </li>
    <li>
      <a href="#Replicate">Replicate Binary Operator &quot;<code>#</code>&quot;</a>
    </li>
    <li>
      <a href="#Remainder">Remainder Operator &quot;<code>%</code>&quot;</a>
    </li>
    <li>
      <a href="#Sorting">Unary Sorting Operators &quot;<code>&lt;=</code>&quot; and &quot;<code>&gt;=</code>&quot;</a>
    </li>
  </ol>
  <h3>
    <a name="Precedence">Operators and Precedence</a>
  </h3>
  <p>The following table is essentially a superset of 
  <b>Table 5.2</b> in Ousterhout&#39;s 1994 classic 
  <cite>Tcl and the Tk Toolkit</cite>. As there, groups of operators
  between horizontal lines have the same precedence; higher groups have
  higher precedence.</p>
  <p>Operators are left-associative unless specified otherwise. For
  example, 
  <code>**</code> is right-associative, as shown by:</p>
  <pre>
% [nap &quot;10 ** 2 ** 3&quot;]
1e+08
</pre>
  <p>The nature of operands is indicated as follows:
  <br />
  <var>a</var> and 
  <var>b</var> represent general arrays.
  <br />
  <var>x</var>, 
  <var>y</var> and 
  <var>z</var> represent scalars.
  <br />
  <var>u</var> and 
  <var>v</var> represent vectors.
  <br />
  <var>A</var> and 
  <var>B</var> represent matrices.
  <br />
  <var>n</var> represents a Tcl name, which may include namespaces.
  <br />
  <var>p</var> represents a boxed vector of pointers to arrays 
  <var>a
  <sub>0</sub></var>, 
  <var>a
  <sub>1</sub></var>, 
  <var>a
  <sub>2</sub></var>, &#8230;</p>
  <p>&#39;AP&#39; means 
  <em>arithmetic progression</em>.</p>
  <table>
    <colgroup span="1"></colgroup>
    <colgroup span="1"></colgroup>
    <tr>
      <td>
        <hr />
      </td>
      <td>
        <hr />
      </td>
    </tr>
    <tr>
      <th align="left">Syntax</th>
      <th align="left">Result</th>
    </tr>
    <tr>
      <td>
        <hr />
      </td>
      <td>
        <hr />
      </td>
    </tr>
    <tr valign="bottom">
      <td>
        <var>a</var>
        <code>**</code>
        <var>b</var>
      </td>
      <td>
      <var>a
      <sup>b</sup></var>. Right-associative</td>
    </tr>
    <tr>
      <td>
        <hr />
      </td>
      <td>
        <hr />
      </td>
    </tr>
    <tr valign="top">
      <td>
        <code>+</code>
        <var>a</var>
      </td>
      <td>New copy of 
      <var>a</var></td>
    </tr>
    <tr valign="top">
      <td>
        <code>-</code>
        <var>a</var>
      </td>
      <td>Negative of 
      <var>a</var></td>
    </tr>
    <tr valign="top">
      <td>
        <code>!</code>
        <var>a</var>
      </td>
      <td>Logical NOT: 1 if 
      <var>a</var> is zero, else 0</td>
    </tr>
    <tr valign="top">
      <td>
        <code>|</code>
        <var>a</var>
      </td>
      <td>Absolute value of 
      <var>a</var> = 
      <code>abs(</code>
      <var>a</var>
      <code>)</code></td>
    </tr>
    <tr valign="top">
      <td>
        <code>^</code>
        <var>a</var>
      </td>
      <td>Nearest integer to 
      <var>a</var> = 
      <code>i32(nint(</code>
      <var>a</var>
      <code>))</code></td>
    </tr>
    <tr valign="top">
      <td>
        <code>&lt;</code>
        <var>a</var>
      </td>
      <td>Largest integer not greater than 
      <var>a</var> = 
      <code>i32(floor(</code>
      <var>a</var>
      <code>))</code></td>
    </tr>
    <tr valign="top">
      <td>
        <code>&gt;</code>
        <var>a</var>
      </td>
      <td>Smallest integer not less than 
      <var>a</var> = 
      <code>i32(ceil(</code>
      <var>a</var>
      <code>))</code></td>
    </tr>
    <tr valign="top">
      <td>
        <code>~</code>
        <var>a</var>
      </td>
      <td>Bit-wise complement of 
      <var>a</var></td>
    </tr>
    <tr valign="top">
      <td>
        <code>#</code>
        <var>a</var>
      </td>
      <td>Frequencies of values 0, 1, 2, &#8230;</td>
    </tr>
    <tr valign="top">
      <td>
        <code>@</code>
        <var>a</var>
      </td>
      <td>Indirect subscript</td>
    </tr>
    <tr valign="top">
      <td>
        <code>@@</code>
        <var>a</var>
      </td>
      <td>Indirect subscript</td>
    </tr>
    <tr valign="top">
      <td>
        <code>&lt;=</code>
        <var>u</var>
      </td>
      <td>Permutation vector 
      <var>v</var> such that 
      <var>u</var>
      <code>(</code>
      <var>v</var>
      <code>)</code> is in ascending order</td>
    </tr>
    <tr valign="top">
      <td>
        <code>&gt;=</code>
        <var>u</var>
      </td>
      <td>Permutation vector 
      <var>v</var> such that 
      <var>u</var>
      <code>(</code>
      <var>v</var>
      <code>)</code> is in descending order</td>
    </tr>
    <tr>
      <td>
        <hr />
      </td>
      <td>
        <hr />
      </td>
    </tr>
    <tr valign="top">
      <td>
        <var>v</var>
        <code>@</code>
        <var>b</var>
      </td>
      <td>smallest 
      <var>s</var> such that 
      <var>v
      <sub>s</sub>=b</var></td>
    </tr>
    <tr valign="top">
      <td>
        <var>v</var>
        <code>@@</code>
        <var>b</var>
      </td>
      <td>
      <code>i32</code> 
      <var>s</var> for which |
      <var>v
      <sub>s</sub>-b</var>| is least</td>
    </tr>
    <tr valign="top">
      <td>
        <var>v</var>
        <code>@@@</code>
        <var>b</var>
      </td>
      <td>smallest 
      <code>i32</code> 
      <var>s</var> for which 
      <var>v
      <sub>s</sub>=b</var></td>
    </tr>
    <tr>
      <td>
        <hr />
      </td>
      <td>
        <hr />
      </td>
    </tr>
    <tr valign="top">
      <td>
        <var>u</var>
        <code>#</code>
        <var>v</var>
      </td>
      <td>
      <var>u</var> copies of 
      <var>v</var></td>
    </tr>
    <tr valign="top">
      <td>
        <var>p</var>
        <code>#</code>
        <var>b</var>
      </td>
      <td>Cross-product replication</td>
    </tr>
    <tr>
      <td>
        <hr />
      </td>
      <td>
        <hr />
      </td>
    </tr>
    <tr valign="top">
      <td>
        <var>u</var>
        <code>.</code>
        <var>v</var>
      </td>
      <td>(
      <var>u</var> and 
      <var>v</var> vectors) Scalar (dot) product</td>
    </tr>
    <tr valign="top">
      <td>
        <var>A</var>
        <code>.</code>
        <var>B</var>
      </td>
      <td>(
      <var>A</var> and 
      <var>B</var> matrices) Matrix product</td>
    </tr>
    <tr>
      <td>
        <hr />
      </td>
      <td>
        <hr />
      </td>
    </tr>
    <tr valign="top">
      <td>
        <var>a</var>
        <code>*</code>
        <var>b</var>
      </td>
      <td>
      <var>a</var> × 
      <var>b</var></td>
    </tr>
    <tr valign="top">
      <td>
        <var>a</var>
        <code>/</code>
        <var>b</var>
      </td>
      <td>
      <var>a</var> ÷ 
      <var>b</var></td>
    </tr>
    <tr valign="top">
      <td>
        <var>a</var>
        <code>%</code>
        <var>b</var>
      </td>
      <td>Remainder after dividing 
      <var>a</var> by 
      <var>b</var></td>
    </tr>
    <tr>
      <td>
        <hr />
      </td>
      <td>
        <hr />
      </td>
    </tr>
    <tr valign="top">
      <td>
        <var>a</var>
        <code>+</code>
        <var>b</var>
      </td>
      <td>
      <var>a</var> + 
      <var>b</var></td>
    </tr>
    <tr valign="top">
      <td>
        <var>a</var>
        <code>-</code>
        <var>b</var>
      </td>
      <td>
      <var>a</var> &#8722; 
      <var>b</var></td>
    </tr>
    <tr>
      <td>
        <hr />
      </td>
      <td>
        <hr />
      </td>
    </tr>
    <tr valign="top">
      <td>
        <var>a</var>
        <code>&lt;&lt;</code>
        <var>b</var>
      </td>
      <td>Left-shift 
      <var>a</var> by 
      <var>b</var> bits</td>
    </tr>
    <tr valign="top">
      <td>
        <var>a</var>
        <code>&gt;&gt;</code>
        <var>b</var>
      </td>
      <td>Right-shift 
      <var>a</var> by 
      <var>b</var> bits</td>
    </tr>
    <tr>
      <td>
        <hr />
      </td>
      <td>
        <hr />
      </td>
    </tr>
    <tr valign="top">
      <td>
        <var>a</var>
        <code>&lt;&lt;&lt;</code>
        <var>b</var>
      </td>
      <td>Lesser of 
      <var>a</var> and 
      <var>b</var></td>
    </tr>
    <tr valign="top">
      <td>
        <var>a</var>
        <code>&gt;&gt;&gt;</code>
        <var>b</var>
      </td>
      <td>Greater of 
      <var>a</var> and 
      <var>b</var></td>
    </tr>
    <tr>
      <td>
        <hr />
      </td>
      <td>
        <hr />
      </td>
    </tr>
    <tr valign="top">
      <td>
        <var>a</var>
        <code>&lt;</code>
        <var>b</var>
      </td>
      <td>1 if 
      <var>a</var> &lt; 
      <var>b</var>, else 0</td>
    </tr>
    <tr valign="top">
      <td>
        <var>a</var>
        <code>&gt;</code>
        <var>b</var>
      </td>
      <td>1 if 
      <var>a</var> &gt; 
      <var>b</var>, else 0</td>
    </tr>
    <tr valign="top">
      <td>
        <var>a</var>
        <code>&lt;=</code>
        <var>b</var>
      </td>
      <td>1 if 
      <var>a</var> &#8804; 
      <var>b</var>, else 0</td>
    </tr>
    <tr valign="top">
      <td>
        <var>a</var>
        <code>&gt;=</code>
        <var>b</var>
      </td>
      <td>1 if 
      <var>a</var> &#8805; 
      <var>b</var>, else 0</td>
    </tr>
    <tr>
      <td>
        <hr />
      </td>
      <td>
        <hr />
      </td>
    </tr>
    <tr valign="top">
      <td>
        <var>a</var>
        <code>==</code>
        <var>b</var>
      </td>
      <td>1 if 
      <var>a</var> = 
      <var>b</var>, else 0</td>
    </tr>
    <tr valign="top">
      <td>
        <var>a</var>
        <code>!=</code>
        <var>b</var>
      </td>
      <td>1 if 
      <var>a</var> &#8800; 
      <var>b</var>, else 0</td>
    </tr>
    <tr>
      <td>
        <hr />
      </td>
      <td>
        <hr />
      </td>
    </tr>
    <tr valign="top">
      <td>
        <var>a</var>
        <code>&amp;</code>
        <var>b</var>
      </td>
      <td>Bit-wise AND of 
      <var>a</var> and 
      <var>b</var></td>
    </tr>
    <tr>
      <td>
        <hr />
      </td>
      <td>
        <hr />
      </td>
    </tr>
    <tr valign="top">
      <td>
        <var>a</var>
        <code>^</code>
        <var>b</var>
      </td>
      <td>Bit-wise exclusive OR of 
      <var>a</var> and 
      <var>b</var></td>
    </tr>
    <tr>
      <td>
        <hr />
      </td>
      <td>
        <hr />
      </td>
    </tr>
    <tr valign="top">
      <td>
        <var>a</var>
        <code>|</code>
        <var>b</var>
      </td>
      <td>Bit-wise OR of 
      <var>a</var> and 
      <var>b</var></td>
    </tr>
    <tr>
      <td>
        <hr />
      </td>
      <td>
        <hr />
      </td>
    </tr>
    <tr valign="top">
      <td>
        <var>a</var>
        <code>&amp;&amp;</code>
        <var>b</var>
      </td>
      <td>Logical AND: 1 if 
      <var>a</var> &#8800; 0 and 
      <var>b</var> &#8800; 0, else 0</td>
    </tr>
    <tr>
      <td>
        <hr />
      </td>
      <td>
        <hr />
      </td>
    </tr>
    <tr valign="top">
      <td>
        <var>a</var>
        <code>||</code>
        <var>b</var>
      </td>
      <td>Logical OR: 1 if 
      <var>a</var> &#8800; 0 or 
      <var>b</var> &#8800; 0, else 0</td>
    </tr>
    <tr>
      <td>
        <hr />
      </td>
      <td>
        <hr />
      </td>
    </tr>
    <tr valign="top">
      <td>
        <var>x</var>
        <code>..</code>
        <var>y</var>
      </td>
      <td>AP from 
      <var>x</var> to 
      <var>y</var> in steps of 
      <code>+1</code> or 
      <code>-1</code></td>
    </tr>
    <tr valign="top">
      <td>
        <var>x</var>
        <code>..</code>
        <var>y</var>
        <code>...</code>
        <var>z</var>
      </td>
      <td>AP from 
      <var>x</var> to 
      <var>y</var> in steps of 
      <var>z</var></td>
    </tr>
    <tr valign="top">
      <td>
        <var>x</var>
        <code>...</code>
        <var>y</var>
        <code>..</code>
        <var>z</var>
      </td>
      <td>AP from 
      <var>y</var> to 
      <var>z</var> with 
      <var>x</var> elements</td>
    </tr>
    <tr>
      <td>
        <hr />
      </td>
      <td>
        <hr />
      </td>
    </tr>
    <tr valign="top">
      <td>
        <var>a</var>
        <code>?</code>
        <var>b</var>
        <code>:</code>
        <var>c</var>
      </td>
      <td>Choice: if 
      <var>a</var> &#8800; 0 then 
      <var>b</var>, else 
      <var>c</var></td>
    </tr>
    <tr>
      <td>
        <hr />
      </td>
      <td>
        <hr />
      </td>
    </tr>
    <tr valign="top">
      <td>
        <var>a</var>
        <code>//</code>
        <var>b</var>
      </td>
      <td>Concatenate along existing dimension</td>
    </tr>
    <tr valign="top">
      <td>
        <var>a</var>
        <code>///</code>
        <var>b</var>
      </td>
      <td>Concatenate along new dimension</td>
    </tr>
    <tr>
      <td>
        <hr />
      </td>
      <td>
        <hr />
      </td>
    </tr>
    <tr valign="top">
      <td>[
      <var>a</var>]
      <code>,</code>[
      <var>b</var>]</td>
      <td>Boxed vector pointing to 
      <var>a</var> and 
      <var>b</var> (unless already boxed)
      <br />If 
      <var>a</var> or 
      <var>b</var> is already boxed then concatenate it</td>
    </tr>
    <tr>
      <td>
        <hr />
      </td>
      <td>
        <hr />
      </td>
    </tr>
    <tr valign="top">
      <td>
        <var>n</var>
        <code>=</code>
        <var>a</var>
      </td>
      <td>Result is 
      <var>a</var>. Right-associative
      <br />Side Effect: Set 
      <var>n</var> to OOC-name of 
      <var>a</var></td>
    </tr>
    <tr>
      <td>
        <hr />
      </td>
      <td>
        <hr />
      </td>
    </tr>
  </table>
  <h3>
    <a name="Assignment">Assignment Operator &quot;<code>=</code>&quot;</a>
  </h3>
  <p>The &quot;<code>nap</code>&quot; command (unlike &quot;<code>expr</code>&quot;) allows the assignment operator &quot;<code>=</code>&quot;. The left-hand operand must be a Tcl name, which
  is used to define a Tcl variable whose (string) value is set to the
  OOC-name of the right-hand operand. The assignment operator has a
  result like any other operator. This result is the value of the
  right-hand operand. This is shown in the following:</p>
  <pre>
% nap &quot;a = (b = 6) + 2&quot;
::NAP::15-15
% $b
6
% $a
8
</pre>
  <p>The assignment operator has the lowest precedence and is
  right-associative, allowing expressions such as:</p>
  <pre>
% nap &quot;a = 3 + b = {1.5 0}&quot;
::NAP::16-16
% $b
1.5 0
% $a
4.5 3
</pre>
  <h3>
    <a name="Link">Link Operator &quot;<code>,</code>&quot;</a>
  </h3>
  <p>The link operator &quot;<code>,</code>&quot; produces a boxed vector pointing to the
  operands. A common use of &quot;<code>,</code>&quot; is to pass multiple arguments to a function. For
  example the logarithm function 
  <code>log</code> takes an optional second argument specifying 
  <var>base</var>, as in:</p>
  <pre>
% [nap &quot;log(32, 2)&quot;]
5
</pre>
  <p>The operator &quot;<code>,</code>&quot; is also used in 
  <em>cross-product indexing</em>, as discussed in the section 
  <a href="indexing.html">NAP Indexing</a>.</p>
  <p>The left-hand operand of &quot;<code>,</code>&quot; generates one boxed vector and the right-hand
  operand generates another. These two boxed vectors are concatenated
  to form the result, which is also a boxed vector. If the data-type of
  an operand is not boxed then it generates a single-element boxed
  vector pointing to it. If an operand is a boxed vector then it
  generates a copy of itself. If an operand is a boxed scalar then it
  is treated as a boxed vector with a single element. If an operand is
  absent (NULL) then it generates a single-element (whose value is 0,
  the missing-value) boxed vector.</p>
  <h3>
    <a name="AP">Arithmetic Progression Operators &quot;<code>..</code>&quot; and &quot;<code>...</code>&quot;</a>
  </h3>
  <p>The operator &quot;<code>..</code>&quot; generates an arithmetic progression. If both
  operands are simple numeric scalars then the step size is +1 or
  &#8722;1, the left-hand operand specifies the first value and the
  right-hand operand specifies the final value. For example:</p>
  <pre>
% [nap &quot;3 .. 6&quot;]
3 4 5 6
% [nap &quot;6 .. 3&quot;]
6 5 4 3
% [nap &quot;1.8 .. -1.2&quot;]
1.8 0.8 -0.2 -1.2
</pre>
If the difference between the operands is not an integral
multiple of the step size then the final step is smaller than the
preceding steps. This is shown by:
  <pre>
% [nap &quot;2.3 .. 5.9&quot;]
2.3 3.3 4.3 5.3 5.9
</pre>
  <p>The right-hand operand can be a boxed two-element vector pointing
  to the final value and the step size. Such a boxed operand is usually
  generated using the operator &quot;<code>...</code>&quot;, as in:</p>
  <pre>
% [nap &quot;3 .. 9 ... 2&quot;]
3 5 7 9
% [nap &quot;0 .. -1.6 ... -0.5&quot;]
0 -0.5 -1 -1.5 -1.6
</pre>
  <p>The left-hand operand can be a boxed two-element vector pointing
  to the number of elements and the first value. Such a boxed operand
  is also usually generated using the operator &quot;<code>...</code>&quot;, as in:</p>
  <pre>
% [nap &quot;5 ... 1 .. 7&quot;]
1 2.5 4 5.5 7
</pre>
It is not legal for both operands to be boxed. It is legal to
specify a non-integral number of elements, as in:
  <pre>
% [nap &quot;3.5 ... 2 .. 12&quot;]
2 6 10 12
</pre>
Note that 3.5 elements means 2.5 steps. There are two full steps
of 4, followed by a half step of 2. When the left-hand operand is boxed
the step size is calculated using (
  <var>final</var>&#160;&#8722;&#160;
  <var>first</var>)/(
  <var>n</var>&#160;&#8722;&#160;1), where 
  <var>n</var> is the number of elements.
  <p>The data-type of the result depends on the data-types of 
  <var>first</var>, 
  <var>final</var> and 
  <var>step</var>. For example:</p>
  <pre>
% [nap &quot;1 .. 7.0 ... 2&quot;] all
::NAP::262-262  f64  MissingValue: NaN  References: 0  Unit: (NULL)
Dimension 0   Size: 4      Name: (NULL)    Coordinate-variable: (NULL)
Value:
1 3 5 7
</pre>
  <h3>
    <a name="Concatenation">Concatenation Operators &quot;<code>//</code>&quot; and &quot;<code>///</code>&quot;</a>
  </h3>
  <p>The following example illustrates the difference between &quot;<code>//</code>&quot; and &quot;<code>///</code>&quot; with vector operands:</p>
  <pre>
% [nap &quot;{5 2} // {9 8}&quot;]
5 2 9 8
% [nap &quot;{5 2} /// {9 8}&quot;]
5 2
9 8
</pre>
  <p>The following example illustrates the difference between &quot;<code>//</code>&quot; and &quot;<code>///</code>&quot; with matrix operands:</p>
  <pre>
% [nap &quot;{{6 2 1}{0 9 4}} // {{7 2 7}{3 3 8}}&quot;] all
::NAP::29-29  i32  MissingValue: -2147483648  References: 0  Unit:
(NULL)
Dimension 0   Size: 4      Name: (NULL)    Coordinate-variable: (NULL)
Dimension 1   Size: 3      Name: (NULL)    Coordinate-variable: (NULL)
Value:
6 2 1
0 9 4
7 2 7
3 3 8
% [nap &quot;{{6 2 1}{0 9 4}} /// {{7 2 7}{3 3 8}}&quot;] all
::NAP::35-35  i32  MissingValue: -2147483648  References: 0  Unit:
(NULL)
Dimension 0   Size: 2      Name: (NULL)    Coordinate-variable: (NULL)
Dimension 1   Size: 2      Name: (NULL)    Coordinate-variable: (NULL)
Dimension 2   Size: 3      Name: (NULL)    Coordinate-variable: (NULL)
Value:
6 2 1
0 9 4

7 2 7
3 3 8
</pre>
  <p>Note that &quot;<code>//</code>&quot; concatenates along the most significant
  existing dimension, whereas &quot;<code>///</code>&quot; concatenates along a new dimension. This new
  dimension is of size 2 and is more significant that the existing
  dimensions.</p>
  <p>The above examples had operands with identical shapes and
  data-types. It is obviously desirable to allow the operands of &quot;<code>//</code>&quot; to have different sized leading (most
  significant) dimensions. NAP does allow this, as shown by:</p>
  <pre>
% [nap &quot;&#39;Hello&#39; // &#39; world.&#39;&quot;]
Hello world.
% [nap &quot;{{6 2 1}{0 9 4}} // {{7 2 7}}&quot;]
6 2 1
0 9 4
7 2 7
</pre>
  <p>In fact, both operators allow any combination of shapes. Operands
  of &quot;<code>///</code>&quot; are reshaped to the same shape. Operands of
  &quot;<code>//</code>&quot; are reshaped so all dimensions except the
  leading one have the same size. The following examples illustrate
  this reshaping process (with data-type conversion when required):</p>
  <pre>
% [nap &quot;{{6 2 1}{0 9 4}} // {7 2 7}&quot;]
6 2 1
0 9 4
7 2 7
% [nap &quot;{{6 2 1}{0 9 4}} // 3.0&quot;] all
::NAP::142-142  f64  MissingValue: NaN  References: 0  Unit: (NULL)
Dimension 0   Size: 3      Name: (NULL)    Coordinate-variable: (NULL)
Dimension 1   Size: 3      Name: (NULL)    Coordinate-variable: (NULL)
Value:
6 2 1
0 9 4
3 3 3
% [nap &quot;{{6 2 1}{0 9 4}} /// 3.0&quot;] all
::NAP::148-148  f64  MissingValue: NaN  References: 0  Unit: (NULL)
Dimension 0   Size: 2      Name: (NULL)    Coordinate-variable: (NULL)
Dimension 1   Size: 2      Name: (NULL)    Coordinate-variable: (NULL)
Dimension 2   Size: 3      Name: (NULL)    Coordinate-variable: (NULL)
Value:
6 2 1
0 9 4

3 3 3
3 3 3
</pre>
  <h3>
    <a name="Inverse:Indexing">Inverse Indexing Operators &quot;<code>@</code>&quot;, &quot;<code>@@</code>&quot; and &quot;<code>@@@</code>&quot;</a>
  </h3>
  <p>These three operators all take an optional vector left-hand
  operand. (The &quot;<code>@</code>&quot; operator also allows the left-hand operand to
  have a rank greater than 1.) The result is a subscript of this
  vector. The left-hand operand defaults to the coordinate-variable of
  the dimension (only relevant to 
  <a href="indexing.html#indirect:indexing">indirect indexing</a>).</p>
  <p>The right-hand operand is attached to the result using its 
  <a href="nao.html"> <em>link slot</em> </a>. This enables the right-hand operand to be automatically used as
  a coordinate variable if the result is directly used as an index.
  Note that the results of operators/functions do not normally retain
  any links in their operands/arguments, so this only applies to 
  <em>direct</em> use. (The right-hand operand would not be an
  appropriate coordinate variable if there were further arithmetic
  prior to indexing.)</p>
  <h4>
    <a name="Interpolated:Subscript">Interpolated Subscript &quot;<code>@</code>&quot;</a>
  </h4>The result of 
  <var>v</var>
  <code>@</code>
  <var>b</var> is the smallest (possibly fractional) 
  <code>f32</code> subscript 
  <var>s</var> such that 
  <var>v</var>
  <code>(</code>
  <var>s</var>
  <code>)==</code>
  <var>b</var>. For example:
  <pre>
% [nap &quot;{1.5 3.4 3.6 4} @ 3.5&quot;]
1.5
% [nap &quot;{1.5 3.4 3.6 4} @ 3.7&quot;]
2.25
</pre>
  <p>Note that 3.5 is halfway between 3.4 (subscript 1) and 3.6
  (subscript 2), so the first result is 1.5. Similarly, 3.7 is
  quarter-way between 3.6 (subscript 2) and 4 (subscript 3), so the
  second result is 2.25.</p>
  <p>Combining these two examples into one:</p>
  <pre>
% [nap &quot;{1.5 3.4 3.6 4} @ {3.5 3.7}&quot;]
1.5 2.25
</pre>
  <p>We can check this result by using it as an index:</p>
  <pre>
% [nap &quot;{1.5 3.4 3.6 4}({1.5 2.25})&quot;]
3.5 3.7
</pre>
  <p>The following example has multiple exact matches. In this case the
  result is defined as the mean of the matching subscripts.</p>
  <pre>
% [nap &quot;{1.3 6.5 6.5 7.1} @ 6.5&quot;]
1.5
</pre>
  <p>The following example shows how extrapolation is used to define
  the result when the right-hand operand is outside the range of the
  left-hand operand:</p>
  <pre>
% [nap &quot;{-1 0 2} @ {-2 5}&quot;]
-1 3.5
</pre>
  <p>Such extrapolation can be prevented by adding end points with
  missing or infinite values, as in:</p>
  <pre>
% [nap &quot;{_ -1 0 2 _} @ {-2 -1 2 5}&quot;]
_ 1 3 _
% [nap &quot;{-1i -1 0 2 1i} @ {-2 -1 2 5}&quot;]
1 1 3 3
</pre>
  <p>The effect of other missing values is shown by:</p>
  <pre>
% [nap &quot;{_ 2 4 _ 6 8 _} @ (1 .. 9)&quot;] value
_ 1 1.5 2 _ 4 4.5 5 _
</pre>
  <p>If the left-hand operand is not monotonic (sorted) then the result
  is defined by the first match, as in:</p>
  <pre>
% [nap &quot;{2 4 5 3} @ (1 .. 6)&quot;]
-0.5 0 0.5 1 2 _
</pre>
  <p>The left-hand operand can have a rank greater than 1. In this case
  the search takes place over the most significant dimension (0) of the
  left-hand operand. The following example searches down each column
  for the value 
  <code>0.7</code>.</p>
  <pre>
% nap &quot;mat = {
    {0.3 0.1 0.9}
    {0.5 0.5 0.8}
    {0.6 0.1 0.6}
    {0.8 0.0   _}
}&quot;
::NAP::157-157
% [nap &quot;mat @ 0.7&quot;]
2.5 _ 1.5
</pre>
  <p>Thus this combines the effect of the following three commands.</p>
  <pre>
% [nap &quot;{0.3 0.5 0.6 0.8} @ 0.7&quot;]
2.5
% [nap &quot;{0.1 0.5 0.1 0.0} @ 0.7&quot;]
_
% [nap &quot;{0.9 0.8 0.6 _} @ 0.7&quot;]
1.5
</pre>
  <p>The right-hand operand can have any rank, but trailing dimensions
  (excluding dimension 0 of the left-hand operand) must match. The
  following example has a right-hand operand with the same number (3)
  of columns as 
  <code>mat</code>.</p>
  <pre>
% [nap &quot;mat @ {{0.7 0.7 0.7}{0.4 0.5 0.8}}&quot;]
2.5   _ 1.5
0.5 1.0 1.0
</pre>
  <p>The following 3D array contains ocean temperature data for 4
  depths, 2 latitudes and 3 longitudes. Note that some (shallower)
  points have missing values at the deepest level. For each (latitude,
  longitude) point, we want to find the depth (subscript) corresponding
  to a temperature of 10 degrees. The missing value in the result
  corresponds to an oceanic column whose minimum temperature is 12.</p>
  <pre>
% nap &quot;temperature = {
    {{11 12 13}{11 11 12}}
    {{ 9  9 13}{11  8 10}}
    {{ 8 10 12}{ 9  8 10}}
    {{ 6  2  _}{ 5  _  _}}
}&quot;
% [nap &quot;temperature @ 10&quot;]
0.500000 0.666667        _
1.500000 0.333333 1.000000
</pre>
  <h4>
    <a name="Subscript:of:Closest">Subscript of Closest &quot;<code>@@</code>&quot;</a>
  </h4>
  <p>The result of 
  <var>v</var>
  <code>@@</code>
  <var>b</var> is the 
  <code>i32</code> subscript 
  <var>s</var> for which 
  <code>abs(</code>
  <var>v</var>
  <code>(</code>
  <var>s</var>
  <code>)-</code>
  <var>b</var>
  <code>)</code> is least. For example:</p>
  <pre>
% [nap &quot;{1.5 3.4 0 2.4 -1 0} @@ {2 -99}&quot;]
3 4
</pre>
Element 3 has the value 2.4, which is the closest to 2. Element 4
has the value -1, which is the closest to -99.
  <p>The following example shows how the right-hand operand becomes the
  coordinate variable if the result is used directly as an index, but
  not if there is further arithmetic.</p>
  <pre>
% nap &quot;coarse = {4 8 7}&quot;
::NAP::14-14
% nap &quot;time = {2 3 5}&quot;
::NAP::16-16
% $coarse set coo time
% [nap &quot;fine = coarse(time@@(2.4 .. 4.6 ... 0.2))&quot;] value
4 8 8 8 8 8 8 8 8 7 7 7
% [$fine coo] value; # Display coordinate variable
2.4 2.6 2.8 3 3.2 3.4 3.6 3.8 4 4.2 4.4 4.6
% [nap &quot;fine = coarse(time@@(2.4 .. 4.6 ... 0.2)+1)&quot;] value;
# Do further arithmetic
8 7 7 7 7 7 7 7 7 4 4 4
% [$fine coo] value; # Display coordinate variable
3 5 5 5 5 5 5 5 5 2 2 2
</pre>
  <h4>
    <a name="Subscript:of:Match">Subscript of Match &quot;<code>@@@</code>&quot;</a>
  </h4>
  <p>The result of 
  <var>v</var>
  <code>@@@</code>
  <var>b</var> is the smallest 
  <code>i32</code> subscript 
  <var>s</var> for which 
  <var>v</var>
  <code>(</code>
  <var>s</var>
  <code>)==</code>
  <var>b</var>. For example:</p>
  <pre>
% [nap &quot;{3 2 9 2 0 3} @@@ {0 3 2}&quot;]
4 0 1
</pre>
  <p>Element 4 is the only 0, element 0 is the first 3 and element 1 is
  the first 2.</p>
  <p>The following example shows that this operator can be used with
  character data:</p>
  <pre>
% [nap &#39;hello world&#39; @@@ &#39;wol&#39;]
6 4 2
</pre>
  <h3>
    <a name="Tally">Tally Unary Operator &quot;<code>#</code>&quot;</a>
  </h3>
  <p>Unary &quot;<code>#</code>&quot; produces a frequency table. It tallies the
  number of 0s, 1s, 2s, &#8230;, as in the following:</p>
  <pre>
% [nap &quot;#{2 5 4 5 2 -3 0 2}&quot;]
1 0 3 0 1 2
</pre>
  <p>There is one zero, no ones, three twos, no threes, one four and
  two fives. Note that the negative value (
  <code>-3</code>) is ignored.</p>
  <p>If the operand has more than 1 dimension then the result has the
  same shape, except that the size of the first dimension is changed to
  
  <var>m</var>+1, where 
  <var>m</var> is the maximum value. Each element of the result is a
  frequency tallied over the first dimension. For example:</p>
  <pre>
% [nap &quot;{{2 5 4 5}{2 -3 0 2}}&quot;]
 2  5  4  5
 2 -3  0  2
% [nap &quot;#{{2 5 4 5}{2 -3 0 2}}&quot;]
0 0 1 0
0 0 0 0
2 0 0 1
0 0 0 0
0 0 1 0
0 1 0 1
</pre>
  <p>If the operand is boxed and points to 
  <var>n</var> arrays (which each have the same number of elements)
  then the result is the 
  <var>n</var>-dimensional array of joint frequencies. For example:</p>
  <pre>
% [nap &quot;#({2 1 1 0 1},{1 1 3 2 1})&quot;]
0 0 1 0
0 2 0 1
0 1 0 0
</pre>
  <p>The boxed operand defines the five pairs (2,1), (1,1), (1,3),
  (0,2) and (1,1). The above result gives the frequencies of these
  pairs.</p>
  <h3>
    <a name="Replicate">Replicate Binary Operator &quot;<code>#</code>&quot;</a>
  </h3>
  <p>
  <code>#</code> can appear within array constants, as in:</p>
  <pre>
% [nap &quot;{7 3#8 0}&quot;]
7 8 8 8 0
</pre>
  <p>The 
  <code>#</code> operator has a related meaning, as shown by:</p>
  <pre>
% [nap &quot;3#8&quot;]
8 8 8
% [nap &quot;{4 1 0 2} # {7 12 9 8}&quot;] value
7 7 7 7 12 8 8
</pre>
  <p>Each element of the left-hand operand defines the number of
  replications of the corresponding element of the right-hand operand.
  The operands can be vectors or scalars. The result is a vector.</p>
  <p>Note that one can use this operator to select from a vector those
  elements which satisfy some condition. The following example selects
  the even elements:</p>
  <pre>
% nap &quot;x = {9 1 0 2 3 -8 0}&quot;
::NAP::286-286
% [nap &quot;(x % 2 == 0) # x&quot;]
0 2 -8 0
</pre>
  <p>This works because the left-hand operand is:</p>
  <pre>
% [nap &quot;(x % 2 == 0)&quot;] value
0 0 1 1 0 1 1
</pre>
  <p>If the right-hand operand 
  <var>b</var> is multidimensional then the left-hand operand must be a
  boxed vector pointing to a vector corresponding to each dimension of 
  <var>b</var>. For example:</p>
  <pre>
% nap &quot;mat = reshape(1 .. 12, {3 4})&quot;
::NAP::316-316
% $mat
 1  2  3  4
 5  6  7  8
 9 10 11 12
% [nap &quot;({2 0 1},{3 2 0 1}) # mat&quot;]
 1  1  1  2  2  4
 1  1  1  2  2  4
 9  9  9 10 10 12
</pre>
  <p>This is equivalent to using the following cross-product index:</p>
  <pre>
% [nap &quot;mat({0 0 2},{0 0 0 1 1 3})&quot;]
 1  1  1  2  2  4
 1  1  1  2  2  4
 9  9  9 10 10 12
</pre>
  <h3>
    <a name="Remainder">Remainder Operator &quot;<code>%</code>&quot;</a>
  </h3>The value of the remainder 
  <var>r</var> = 
  <var>a</var> 
  <code>%</code> 
  <var>b</var> is defined for all real 
  <var>a</var> and 
  <var>b</var> so that:
  <br />if 
  <var>b</var> &gt; 0 then 0 &#8804; 
  <var>r</var> &lt; 
  <var>b</var>
  <br />if 
  <var>b</var> = 0 then 
  <var>r</var> = 0
  <br />if 
  <var>b</var> &lt; 0 then 
  <var>b</var> &lt; 
  <var>r</var> &#8804; 0
  <br />if 
  <var>a</var> &#8805; 0 and b = &#8734; then 
  <var>r</var> = 
  <var>a</var>
  <br />if 
  <var>a</var> &#8804; 0 and b = &#8722;&#8734; then 
  <var>r</var> = 
  <var>a</var>
  <br />if 
  <var>a</var> &lt; 0 and b = &#8734; then 
  <var>r</var> = &#8734;
  <br />if 
  <var>a</var> &gt; 0 and b = &#8722;&#8734; then 
  <var>r</var> = &#8722;&#8734;.
  <br />Thus:
  <pre>
% [nap &quot;0.7 % {0.3 0 -0.3}&quot;]
0.1 0 -0.2
% [nap &quot;{7 0 -7} % 1if32&quot;]
7 0 Inf
% [nap &quot;{7 0 -7} % -1if32&quot;]
-Inf 0 -7
</pre>
  <h3>
    <a name="Sorting"> Unary Sorting Operators &quot;<code>&lt;=</code>&quot; and &quot;<code>&gt;=</code>&quot;</a>
  </h3>These operators are applied to vectors to produce the
  permutation vector which (when applied as its index) sorts the
  argument into ascending or descending order.
  <p>Thus 
  <var>u</var>=
  <var>v</var>
  <code>(&lt;=</code>
  <var>v</var>
  <code>)</code> is sorted into ascending order, so that 
  <var>u
  <sub>0</sub> &#8804; u
  <sub>1</sub> &#8804; u
  <sub>2</sub> &#8804;</var> &#8230;
  <br />and 
  <var>u</var>=
  <var>v</var>
  <code>(&gt;=</code>
  <var>v</var>
  <code>)</code> is sorted into descending order, so that 
  <var>u
  <sub>0</sub> &#8805; u
  <sub>1</sub> &#8805; u
  <sub>2</sub> &#8805;</var> &#8230;</p>
  <p>The floating-point value 
  <em>NaN</em> is treated as less than negative infinity. The current
  version treats other missing values as having their numeric value.
  (This may change in future versions.)</p>
  <p>The following examples illustrate these two operators and the
  related 
  <a href="function.html#change:shape:or:order">function <code>sort()</code></a>:</p>
  <pre>
% [nap &quot;x = {1.5 -1i 0 _ 9 _ 0 1i -2 1}&quot;] value
1.5 -Inf 0 _ 9 _ 0 Inf -2 1
% [nap &quot;pv = &lt;= x&quot;] value; # permutation vector
3 5 1 8 6 2 9 0 4 7
% [nap &quot;x(pv)&quot;] value; # ascending order
_ _ -Inf -2 0 0 1 1.5 9 Inf
% [nap &quot;sort(x)&quot;] value; # same result
_ _ -Inf -2 0 0 1 1.5 9 Inf
% [nap &quot;x(&gt;= x)&quot;] value; # descending order
Inf 9 1.5 1 0 0 -2 -Inf _ _
</pre>
  <table width="100%" border="0" cellspacing="0" cellpadding="2"
  bgcolor="#737B9C">
    <tr>
      <td align="center">
        <font color="#FFFFFF" size="-2">
          <span class="titlebar">
          <b>Author:</b> 
          <a href="http://sourceforge.net/users/dav480/">Harvey
          Davies</a> &#160; &#160; &#160; © 2002, CSIRO Australia.
          &#160; &#160; &#160; 
          <a href="http://www.csiro.au/legalnotices/disclaimer.html">Legal
          Notice and Disclaimer</a>
          <br />
          <b>CVS Version Details:</b> $Id: op.html,v 1.19 2005/09/30
          01:40:07 dav480 Exp $</span>
        </font>
      </td>
    </tr>
  </table></body>
</html>
