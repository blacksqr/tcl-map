diff -rNc gdal-1.6.1/configure.in gdal-1.6.1-patched/configure.in
*** gdal-1.6.1/configure.in	2009-04-14 19:29:35.000000000 +0300
--- gdal-1.6.1-patched/configure.in	2009-06-30 15:43:37.000000000 +0300
***************
*** 2218,2223 ****
--- 2218,2237 ----
  fi
  
  dnl ---------------------------------------------------------------------------
+ dnl Tcl bindings.
+ dnl ---------------------------------------------------------------------------
+ 
+ AC_ARG_WITH(tcl,[  --with-tcl            Enable Tcl bindings],,)
+ 
+ AC_MSG_CHECKING([for tcl bindings])
+ if test "$with_tcl" = "yes" ; then
+   BINDINGS="tcl $BINDINGS"
+   AC_MSG_RESULT([enabled])
+ else
+   AC_MSG_RESULT([disabled])
+ fi
+ 
+ dnl ---------------------------------------------------------------------------
  dnl NG Python bindings.
  dnl ---------------------------------------------------------------------------
  
diff -rNc gdal-1.6.1/m4/tcl.m4 gdal-1.6.1-patched/m4/tcl.m4
*** gdal-1.6.1/m4/tcl.m4	1970-01-01 02:00:00.000000000 +0200
--- gdal-1.6.1-patched/m4/tcl.m4	2009-06-30 15:56:31.000000000 +0300
***************
*** 0 ****
--- 1,4068 ----
+ # tcl.m4 --
+ #
+ #	This file provides a set of autoconf macros to help TEA-enable
+ #	a Tcl extension.
+ #
+ # Copyright (c) 1999-2000 Ajuba Solutions.
+ # Copyright (c) 2002-2005 ActiveState Corporation.
+ #
+ # See the file "license.terms" for information on usage and redistribution
+ # of this file, and for a DISCLAIMER OF ALL WARRANTIES.
+ #
+ # RCS: @(#) $Id: tcl.m4,v 1.2 2008/04/13 16:08:24 alsterg Exp $
+ 
+ AC_PREREQ(2.57)
+ 
+ dnl TEA extensions pass us the version of TEA they think they
+ dnl are compatible with (must be set in TEA_INIT below)
+ dnl TEA_VERSION="3.6"
+ 
+ # Possible values for key variables defined:
+ #
+ # TEA_WINDOWINGSYSTEM - win32 aqua x11 (mirrors 'tk windowingsystem')
+ # TEA_PLATFORM        - windows unix
+ #
+ 
+ #------------------------------------------------------------------------
+ # TEA_PATH_TCLCONFIG --
+ #
+ #	Locate the tclConfig.sh file and perform a sanity check on
+ #	the Tcl compile flags
+ #
+ # Arguments:
+ #	none
+ #
+ # Results:
+ #
+ #	Adds the following arguments to configure:
+ #		--with-tcl=...
+ #
+ #	Defines the following vars:
+ #		TCL_BIN_DIR	Full path to the directory containing
+ #				the tclConfig.sh file
+ #------------------------------------------------------------------------
+ 
+ AC_DEFUN([TEA_PATH_TCLCONFIG], [
+     dnl TEA specific: Make sure we are initialized
+     AC_REQUIRE([TEA_INIT])
+     #
+     # Ok, lets find the tcl configuration
+     # First, look for one uninstalled.
+     # the alternative search directory is invoked by --with-tcl
+     #
+ 
+     if test x"${no_tcl}" = x ; then
+ 	# we reset no_tcl in case something fails here
+ 	no_tcl=true
+ 	AC_ARG_WITH(tcl,
+ 	    AC_HELP_STRING([--with-tcl],
+ 		[directory containing tcl configuration (tclConfig.sh)]),
+ 	    with_tclconfig=${withval})
+ 	AC_MSG_CHECKING([for Tcl configuration])
+ 	AC_CACHE_VAL(ac_cv_c_tclconfig,[
+ 
+ 	    # First check to see if --with-tcl was specified.
+ 	    if test x"${with_tclconfig}" != x ; then
+ 		case ${with_tclconfig} in
+ 		    */tclConfig.sh )
+ 			if test -f ${with_tclconfig}; then
+ 			    AC_MSG_WARN([--with-tcl argument should refer to directory containing tclConfig.sh, not to tclConfig.sh itself])
+ 			    with_tclconfig=`echo ${with_tclconfig} | sed 's!/tclConfig\.sh$!!'`
+ 			fi ;;
+ 		esac
+ 		if test -f "${with_tclconfig}/tclConfig.sh" ; then
+ 		    ac_cv_c_tclconfig=`(cd ${with_tclconfig}; pwd)`
+ 		else
+ 		    AC_MSG_ERROR([${with_tclconfig} directory doesn't contain tclConfig.sh])
+ 		fi
+ 	    fi
+ 
+ 	    # then check for a private Tcl installation
+ 	    if test x"${ac_cv_c_tclconfig}" = x ; then
+ 		for i in \
+ 			../tcl \
+ 			`ls -dr ../tcl[[8-9]].[[0-9]].[[0-9]]* 2>/dev/null` \
+ 			`ls -dr ../tcl[[8-9]].[[0-9]] 2>/dev/null` \
+ 			`ls -dr ../tcl[[8-9]].[[0-9]]* 2>/dev/null` \
+ 			../../tcl \
+ 			`ls -dr ../../tcl[[8-9]].[[0-9]].[[0-9]]* 2>/dev/null` \
+ 			`ls -dr ../../tcl[[8-9]].[[0-9]] 2>/dev/null` \
+ 			`ls -dr ../../tcl[[8-9]].[[0-9]]* 2>/dev/null` \
+ 			../../../tcl \
+ 			`ls -dr ../../../tcl[[8-9]].[[0-9]].[[0-9]]* 2>/dev/null` \
+ 			`ls -dr ../../../tcl[[8-9]].[[0-9]] 2>/dev/null` \
+ 			`ls -dr ../../../tcl[[8-9]].[[0-9]]* 2>/dev/null` ; do
+ 		    if test -f "$i/unix/tclConfig.sh" ; then
+ 			ac_cv_c_tclconfig=`(cd $i/unix; pwd)`
+ 			break
+ 		    fi
+ 		done
+ 	    fi
+ 
+ 	    # on Darwin, check in Framework installation locations
+ 	    if test "`uname -s`" = "Darwin" -a x"${ac_cv_c_tclconfig}" = x ; then
+ 		for i in `ls -d ~/Library/Frameworks 2>/dev/null` \
+ 			`ls -d /Library/Frameworks 2>/dev/null` \
+ 			`ls -d /Network/Library/Frameworks 2>/dev/null` \
+ 			`ls -d /System/Library/Frameworks 2>/dev/null` \
+ 			; do
+ 		    if test -f "$i/Tcl.framework/tclConfig.sh" ; then
+ 			ac_cv_c_tclconfig=`(cd $i/Tcl.framework; pwd)`
+ 			break
+ 		    fi
+ 		done
+ 	    fi
+ 
+ 	    # TEA specific: on Windows, check in common installation locations
+ 	    if test "${TEA_PLATFORM}" = "windows" \
+ 		-a x"${ac_cv_c_tclconfig}" = x ; then
+ 		for i in `ls -d C:/Tcl/lib 2>/dev/null` \
+ 			`ls -d C:/Progra~1/Tcl/lib 2>/dev/null` \
+ 			; do
+ 		    if test -f "$i/tclConfig.sh" ; then
+ 			ac_cv_c_tclconfig=`(cd $i; pwd)`
+ 			break
+ 		    fi
+ 		done
+ 	    fi
+ 
+ 	    # check in a few common install locations
+ 	    if test x"${ac_cv_c_tclconfig}" = x ; then
+ 		for i in `ls -d ${libdir} 2>/dev/null` \
+ 			`ls -d ${exec_prefix}/lib 2>/dev/null` \
+ 			`ls -d ${prefix}/lib 2>/dev/null` \
+ 			`ls -d /usr/local/lib 2>/dev/null` \
+ 			`ls -d /usr/contrib/lib 2>/dev/null` \
+ 			`ls -d /usr/lib 2>/dev/null` \
+ 			; do
+ 		    if test -f "$i/tclConfig.sh" ; then
+ 			ac_cv_c_tclconfig=`(cd $i; pwd)`
+ 			break
+ 		    fi
+ 		done
+ 	    fi
+ 
+ 	    # check in a few other private locations
+ 	    if test x"${ac_cv_c_tclconfig}" = x ; then
+ 		for i in \
+ 			${srcdir}/../tcl \
+ 			`ls -dr ${srcdir}/../tcl[[8-9]].[[0-9]].[[0-9]]* 2>/dev/null` \
+ 			`ls -dr ${srcdir}/../tcl[[8-9]].[[0-9]] 2>/dev/null` \
+ 			`ls -dr ${srcdir}/../tcl[[8-9]].[[0-9]]* 2>/dev/null` ; do
+ 		    if test -f "$i/unix/tclConfig.sh" ; then
+ 		    ac_cv_c_tclconfig=`(cd $i/unix; pwd)`
+ 		    break
+ 		fi
+ 		done
+ 	    fi
+ 	])
+ 
+ 	if test x"${ac_cv_c_tclconfig}" = x ; then
+ 	    TCL_BIN_DIR="# no Tcl configs found"
+ 	    AC_MSG_WARN([Can't find Tcl configuration definitions])
+ 	    exit 0
+ 	else
+ 	    no_tcl=
+ 	    TCL_BIN_DIR=${ac_cv_c_tclconfig}
+ 	    AC_MSG_RESULT([found ${TCL_BIN_DIR}/tclConfig.sh])
+ 	fi
+     fi
+ ])
+ 
+ #------------------------------------------------------------------------
+ # TEA_PATH_TKCONFIG --
+ #
+ #	Locate the tkConfig.sh file
+ #
+ # Arguments:
+ #	none
+ #
+ # Results:
+ #
+ #	Adds the following arguments to configure:
+ #		--with-tk=...
+ #
+ #	Defines the following vars:
+ #		TK_BIN_DIR	Full path to the directory containing
+ #				the tkConfig.sh file
+ #------------------------------------------------------------------------
+ 
+ AC_DEFUN([TEA_PATH_TKCONFIG], [
+     #
+     # Ok, lets find the tk configuration
+     # First, look for one uninstalled.
+     # the alternative search directory is invoked by --with-tk
+     #
+ 
+     if test x"${no_tk}" = x ; then
+ 	# we reset no_tk in case something fails here
+ 	no_tk=true
+ 	AC_ARG_WITH(tk,
+ 	    AC_HELP_STRING([--with-tk],
+ 		[directory containing tk configuration (tkConfig.sh)]),
+ 	    with_tkconfig=${withval})
+ 	AC_MSG_CHECKING([for Tk configuration])
+ 	AC_CACHE_VAL(ac_cv_c_tkconfig,[
+ 
+ 	    # First check to see if --with-tkconfig was specified.
+ 	    if test x"${with_tkconfig}" != x ; then
+ 		case ${with_tkconfig} in
+ 		    */tkConfig.sh )
+ 			if test -f ${with_tkconfig}; then
+ 			    AC_MSG_WARN([--with-tk argument should refer to directory containing tkConfig.sh, not to tkConfig.sh itself])
+ 			    with_tkconfig=`echo ${with_tkconfig} | sed 's!/tkConfig\.sh$!!'`
+ 			fi ;;
+ 		esac
+ 		if test -f "${with_tkconfig}/tkConfig.sh" ; then
+ 		    ac_cv_c_tkconfig=`(cd ${with_tkconfig}; pwd)`
+ 		else
+ 		    AC_MSG_ERROR([${with_tkconfig} directory doesn't contain tkConfig.sh])
+ 		fi
+ 	    fi
+ 
+ 	    # then check for a private Tk library
+ 	    if test x"${ac_cv_c_tkconfig}" = x ; then
+ 		for i in \
+ 			../tk \
+ 			`ls -dr ../tk[[8-9]].[[0-9]].[[0-9]]* 2>/dev/null` \
+ 			`ls -dr ../tk[[8-9]].[[0-9]] 2>/dev/null` \
+ 			`ls -dr ../tk[[8-9]].[[0-9]]* 2>/dev/null` \
+ 			../../tk \
+ 			`ls -dr ../../tk[[8-9]].[[0-9]].[[0-9]]* 2>/dev/null` \
+ 			`ls -dr ../../tk[[8-9]].[[0-9]] 2>/dev/null` \
+ 			`ls -dr ../../tk[[8-9]].[[0-9]]* 2>/dev/null` \
+ 			../../../tk \
+ 			`ls -dr ../../../tk[[8-9]].[[0-9]].[[0-9]]* 2>/dev/null` \
+ 			`ls -dr ../../../tk[[8-9]].[[0-9]] 2>/dev/null` \
+ 			`ls -dr ../../../tk[[8-9]].[[0-9]]* 2>/dev/null` ; do
+ 		    if test -f "$i/unix/tkConfig.sh" ; then
+ 			ac_cv_c_tkconfig=`(cd $i/unix; pwd)`
+ 			break
+ 		    fi
+ 		done
+ 	    fi
+ 
+ 	    # on Darwin, check in Framework installation locations
+ 	    if test "`uname -s`" = "Darwin" -a x"${ac_cv_c_tkconfig}" = x ; then
+ 		for i in `ls -d ~/Library/Frameworks 2>/dev/null` \
+ 			`ls -d /Library/Frameworks 2>/dev/null` \
+ 			`ls -d /Network/Library/Frameworks 2>/dev/null` \
+ 			`ls -d /System/Library/Frameworks 2>/dev/null` \
+ 			; do
+ 		    if test -f "$i/Tk.framework/tkConfig.sh" ; then
+ 			ac_cv_c_tkconfig=`(cd $i/Tk.framework; pwd)`
+ 			break
+ 		    fi
+ 		done
+ 	    fi
+ 
+ 	    # check in a few common install locations
+ 	    if test x"${ac_cv_c_tkconfig}" = x ; then
+ 		for i in `ls -d ${libdir} 2>/dev/null` \
+ 			`ls -d ${exec_prefix}/lib 2>/dev/null` \
+ 			`ls -d ${prefix}/lib 2>/dev/null` \
+ 			`ls -d /usr/local/lib 2>/dev/null` \
+ 			`ls -d /usr/contrib/lib 2>/dev/null` \
+ 			`ls -d /usr/lib 2>/dev/null` \
+ 			; do
+ 		    if test -f "$i/tkConfig.sh" ; then
+ 			ac_cv_c_tkconfig=`(cd $i; pwd)`
+ 			break
+ 		    fi
+ 		done
+ 	    fi
+ 
+ 	    # TEA specific: on Windows, check in common installation locations
+ 	    if test "${TEA_PLATFORM}" = "windows" \
+ 		-a x"${ac_cv_c_tkconfig}" = x ; then
+ 		for i in `ls -d C:/Tcl/lib 2>/dev/null` \
+ 			`ls -d C:/Progra~1/Tcl/lib 2>/dev/null` \
+ 			; do
+ 		    if test -f "$i/tkConfig.sh" ; then
+ 			ac_cv_c_tkconfig=`(cd $i; pwd)`
+ 			break
+ 		    fi
+ 		done
+ 	    fi
+ 
+ 	    # check in a few other private locations
+ 	    if test x"${ac_cv_c_tkconfig}" = x ; then
+ 		for i in \
+ 			${srcdir}/../tk \
+ 			`ls -dr ${srcdir}/../tk[[8-9]].[[0-9]].[[0-9]]* 2>/dev/null` \
+ 			`ls -dr ${srcdir}/../tk[[8-9]].[[0-9]] 2>/dev/null` \
+ 			`ls -dr ${srcdir}/../tk[[8-9]].[[0-9]]* 2>/dev/null` ; do
+ 		    if test -f "$i/unix/tkConfig.sh" ; then
+ 			ac_cv_c_tkconfig=`(cd $i/unix; pwd)`
+ 			break
+ 		    fi
+ 		done
+ 	    fi
+ 	])
+ 
+ 	if test x"${ac_cv_c_tkconfig}" = x ; then
+ 	    TK_BIN_DIR="# no Tk configs found"
+ 	    AC_MSG_WARN([Can't find Tk configuration definitions])
+ 	    exit 0
+ 	else
+ 	    no_tk=
+ 	    TK_BIN_DIR=${ac_cv_c_tkconfig}
+ 	    AC_MSG_RESULT([found ${TK_BIN_DIR}/tkConfig.sh])
+ 	fi
+     fi
+ ])
+ 
+ #------------------------------------------------------------------------
+ # TEA_LOAD_TCLCONFIG --
+ #
+ #	Load the tclConfig.sh file
+ #
+ # Arguments:
+ #	
+ #	Requires the following vars to be set:
+ #		TCL_BIN_DIR
+ #
+ # Results:
+ #
+ #	Subst the following vars:
+ #		TCL_BIN_DIR
+ #		TCL_SRC_DIR
+ #		TCL_LIB_FILE
+ #
+ #------------------------------------------------------------------------
+ 
+ AC_DEFUN([TEA_LOAD_TCLCONFIG], [
+     AC_MSG_CHECKING([for existence of ${TCL_BIN_DIR}/tclConfig.sh])
+ 
+     if test -f "${TCL_BIN_DIR}/tclConfig.sh" ; then
+         AC_MSG_RESULT([loading])
+ 	. "${TCL_BIN_DIR}/tclConfig.sh"
+     else
+         AC_MSG_RESULT([could not find ${TCL_BIN_DIR}/tclConfig.sh])
+     fi
+ 
+     # eval is required to do the TCL_DBGX substitution
+     eval "TCL_LIB_FILE=\"${TCL_LIB_FILE}\""
+     eval "TCL_STUB_LIB_FILE=\"${TCL_STUB_LIB_FILE}\""
+ 
+     # If the TCL_BIN_DIR is the build directory (not the install directory),
+     # then set the common variable name to the value of the build variables.
+     # For example, the variable TCL_LIB_SPEC will be set to the value
+     # of TCL_BUILD_LIB_SPEC. An extension should make use of TCL_LIB_SPEC
+     # instead of TCL_BUILD_LIB_SPEC since it will work with both an
+     # installed and uninstalled version of Tcl.
+     if test -f "${TCL_BIN_DIR}/Makefile" ; then
+         TCL_LIB_SPEC=${TCL_BUILD_LIB_SPEC}
+         TCL_STUB_LIB_SPEC=${TCL_BUILD_STUB_LIB_SPEC}
+         TCL_STUB_LIB_PATH=${TCL_BUILD_STUB_LIB_PATH}
+     elif test "`uname -s`" = "Darwin"; then
+ 	# If Tcl was built as a framework, attempt to use the libraries
+ 	# from the framework at the given location so that linking works
+ 	# against Tcl.framework installed in an arbitary location.
+ 	case ${TCL_DEFS} in
+ 	    *TCL_FRAMEWORK*)
+ 		if test -f "${TCL_BIN_DIR}/${TCL_LIB_FILE}"; then
+ 		    for i in "`cd ${TCL_BIN_DIR}; pwd`" \
+ 			     "`cd ${TCL_BIN_DIR}/../..; pwd`"; do
+ 			if test "`basename "$i"`" = "${TCL_LIB_FILE}.framework"; then
+ 			    TCL_LIB_SPEC="-F`dirname "$i"` -framework ${TCL_LIB_FILE}"
+ 			    break
+ 			fi
+ 		    done
+ 		fi
+ 		if test -f "${TCL_BIN_DIR}/${TCL_STUB_LIB_FILE}"; then
+ 		    TCL_STUB_LIB_SPEC="-L${TCL_BIN_DIR} ${TCL_STUB_LIB_FLAG}"
+ 		    TCL_STUB_LIB_PATH="${TCL_BIN_DIR}/${TCL_STUB_LIB_FILE}"
+ 		fi
+ 		;;
+ 	esac
+     fi
+ 
+     # eval is required to do the TCL_DBGX substitution
+     eval "TCL_LIB_FLAG=\"${TCL_LIB_FLAG}\""
+     eval "TCL_LIB_SPEC=\"${TCL_LIB_SPEC}\""
+     eval "TCL_STUB_LIB_FLAG=\"${TCL_STUB_LIB_FLAG}\""
+     eval "TCL_STUB_LIB_SPEC=\"${TCL_STUB_LIB_SPEC}\""
+ 
+     AC_SUBST(TCL_VERSION)
+     AC_SUBST(TCL_BIN_DIR)
+     AC_SUBST(TCL_SRC_DIR)
+ 
+     AC_SUBST(TCL_LIB_FILE)
+     AC_SUBST(TCL_LIB_FLAG)
+     AC_SUBST(TCL_LIB_SPEC)
+ 
+     AC_SUBST(TCL_STUB_LIB_FILE)
+     AC_SUBST(TCL_STUB_LIB_FLAG)
+     AC_SUBST(TCL_STUB_LIB_SPEC)
+ 
+     # TEA specific:
+     AC_SUBST(TCL_LIBS)
+     AC_SUBST(TCL_DEFS)
+     AC_SUBST(TCL_EXTRA_CFLAGS)
+     AC_SUBST(TCL_LD_FLAGS)
+     AC_SUBST(TCL_SHLIB_LD_LIBS)
+ ])
+ 
+ #------------------------------------------------------------------------
+ # TEA_LOAD_TKCONFIG --
+ #
+ #	Load the tkConfig.sh file
+ #
+ # Arguments:
+ #	
+ #	Requires the following vars to be set:
+ #		TK_BIN_DIR
+ #
+ # Results:
+ #
+ #	Sets the following vars that should be in tkConfig.sh:
+ #		TK_BIN_DIR
+ #------------------------------------------------------------------------
+ 
+ AC_DEFUN([TEA_LOAD_TKCONFIG], [
+     AC_MSG_CHECKING([for existence of ${TK_BIN_DIR}/tkConfig.sh])
+ 
+     if test -f "${TK_BIN_DIR}/tkConfig.sh" ; then
+         AC_MSG_RESULT([loading])
+ 	. "${TK_BIN_DIR}/tkConfig.sh"
+     else
+         AC_MSG_RESULT([could not find ${TK_BIN_DIR}/tkConfig.sh])
+     fi
+ 
+     # eval is required to do the TK_DBGX substitution
+     eval "TK_LIB_FILE=\"${TK_LIB_FILE}\""
+     eval "TK_STUB_LIB_FILE=\"${TK_STUB_LIB_FILE}\""
+ 
+     # If the TK_BIN_DIR is the build directory (not the install directory),
+     # then set the common variable name to the value of the build variables.
+     # For example, the variable TK_LIB_SPEC will be set to the value
+     # of TK_BUILD_LIB_SPEC. An extension should make use of TK_LIB_SPEC
+     # instead of TK_BUILD_LIB_SPEC since it will work with both an
+     # installed and uninstalled version of Tcl.
+     if test -f "${TK_BIN_DIR}/Makefile" ; then
+         TK_LIB_SPEC=${TK_BUILD_LIB_SPEC}
+         TK_STUB_LIB_SPEC=${TK_BUILD_STUB_LIB_SPEC}
+         TK_STUB_LIB_PATH=${TK_BUILD_STUB_LIB_PATH}
+     elif test "`uname -s`" = "Darwin"; then
+ 	# If Tk was built as a framework, attempt to use the libraries
+ 	# from the framework at the given location so that linking works
+ 	# against Tk.framework installed in an arbitary location.
+ 	case ${TK_DEFS} in
+ 	    *TK_FRAMEWORK*)
+ 		if test -f "${TK_BIN_DIR}/${TK_LIB_FILE}"; then
+ 		    for i in "`cd ${TK_BIN_DIR}; pwd`" \
+ 			     "`cd ${TK_BIN_DIR}/../..; pwd`"; do
+ 			if test "`basename "$i"`" = "${TK_LIB_FILE}.framework"; then
+ 			    TK_LIB_SPEC="-F`dirname "$i"` -framework ${TK_LIB_FILE}"
+ 			    break
+ 			fi
+ 		    done
+ 		fi
+ 		if test -f "${TK_BIN_DIR}/${TK_STUB_LIB_FILE}"; then
+ 		    TK_STUB_LIB_SPEC="-L${TK_BIN_DIR} ${TK_STUB_LIB_FLAG}"
+ 		    TK_STUB_LIB_PATH="${TK_BIN_DIR}/${TK_STUB_LIB_FILE}"
+ 		fi
+ 		;;
+ 	esac
+     fi
+ 
+     # eval is required to do the TK_DBGX substitution
+     eval "TK_LIB_FLAG=\"${TK_LIB_FLAG}\""
+     eval "TK_LIB_SPEC=\"${TK_LIB_SPEC}\""
+     eval "TK_STUB_LIB_FLAG=\"${TK_STUB_LIB_FLAG}\""
+     eval "TK_STUB_LIB_SPEC=\"${TK_STUB_LIB_SPEC}\""
+ 
+     # TEA specific: Ensure windowingsystem is defined
+     if test "${TEA_PLATFORM}" = "unix" ; then
+ 	case ${TK_DEFS} in
+ 	    *MAC_OSX_TK*)
+ 		AC_DEFINE(MAC_OSX_TK, 1, [Are we building against Mac OS X TkAqua?])
+ 		TEA_WINDOWINGSYSTEM="aqua"
+ 		;;
+ 	    *)
+ 		TEA_WINDOWINGSYSTEM="x11"
+ 		;;
+ 	esac
+     elif test "${TEA_PLATFORM}" = "windows" ; then
+ 	TEA_WINDOWINGSYSTEM="win32"
+     fi
+ 
+     AC_SUBST(TK_VERSION)
+     AC_SUBST(TK_BIN_DIR)
+     AC_SUBST(TK_SRC_DIR)
+ 
+     AC_SUBST(TK_LIB_FILE)
+     AC_SUBST(TK_LIB_FLAG)
+     AC_SUBST(TK_LIB_SPEC)
+ 
+     AC_SUBST(TK_STUB_LIB_FILE)
+     AC_SUBST(TK_STUB_LIB_FLAG)
+     AC_SUBST(TK_STUB_LIB_SPEC)
+ 
+     # TEA specific:
+     AC_SUBST(TK_LIBS)
+     AC_SUBST(TK_XINCLUDES)
+ ])
+ 
+ #------------------------------------------------------------------------
+ # TEA_PROG_TCLSH
+ #	Determine the fully qualified path name of the tclsh executable
+ #	in the Tcl build directory or the tclsh installed in a bin
+ #	directory. This macro will correctly determine the name
+ #	of the tclsh executable even if tclsh has not yet been
+ #	built in the build directory. The tclsh found is always
+ #	associated with a tclConfig.sh file. This tclsh should be used
+ #	only for running extension test cases. It should never be
+ #	or generation of files (like pkgIndex.tcl) at build time.
+ #
+ # Arguments
+ #	none
+ #
+ # Results
+ #	Subst's the following values:
+ #		TCLSH_PROG
+ #------------------------------------------------------------------------
+ 
+ AC_DEFUN([TEA_PROG_TCLSH], [
+     AC_MSG_CHECKING([for tclsh])
+     if test -f "${TCL_BIN_DIR}/Makefile" ; then
+         # tclConfig.sh is in Tcl build directory
+         if test "${TEA_PLATFORM}" = "windows"; then
+             TCLSH_PROG="${TCL_BIN_DIR}/tclsh${TCL_MAJOR_VERSION}${TCL_MINOR_VERSION}${TCL_DBGX}${EXEEXT}"
+         else
+             TCLSH_PROG="${TCL_BIN_DIR}/tclsh"
+         fi
+     else
+         # tclConfig.sh is in install location
+         if test "${TEA_PLATFORM}" = "windows"; then
+             TCLSH_PROG="tclsh${TCL_MAJOR_VERSION}${TCL_MINOR_VERSION}${TCL_DBGX}${EXEEXT}"
+         else
+             TCLSH_PROG="tclsh${TCL_MAJOR_VERSION}.${TCL_MINOR_VERSION}${TCL_DBGX}"
+         fi
+         list="`ls -d ${TCL_BIN_DIR}/../bin 2>/dev/null` \
+               `ls -d ${TCL_BIN_DIR}/..     2>/dev/null` \
+               `ls -d ${TCL_PREFIX}/bin     2>/dev/null`"
+         for i in $list ; do
+             if test -f "$i/${TCLSH_PROG}" ; then
+                 REAL_TCL_BIN_DIR="`cd "$i"; pwd`/"
+                 break
+             fi
+         done
+         TCLSH_PROG="${REAL_TCL_BIN_DIR}${TCLSH_PROG}"
+     fi
+     AC_MSG_RESULT([${TCLSH_PROG}])
+     AC_SUBST(TCLSH_PROG)
+ ])
+ 
+ #------------------------------------------------------------------------
+ # TEA_PROG_WISH
+ #	Determine the fully qualified path name of the wish executable
+ #	in the Tk build directory or the wish installed in a bin
+ #	directory. This macro will correctly determine the name
+ #	of the wish executable even if wish has not yet been
+ #	built in the build directory. The wish found is always
+ #	associated with a tkConfig.sh file. This wish should be used
+ #	only for running extension test cases. It should never be
+ #	or generation of files (like pkgIndex.tcl) at build time.
+ #
+ # Arguments
+ #	none
+ #
+ # Results
+ #	Subst's the following values:
+ #		WISH_PROG
+ #------------------------------------------------------------------------
+ 
+ AC_DEFUN([TEA_PROG_WISH], [
+     AC_MSG_CHECKING([for wish])
+     if test -f "${TK_BIN_DIR}/Makefile" ; then
+         # tkConfig.sh is in Tk build directory
+         if test "${TEA_PLATFORM}" = "windows"; then
+             WISH_PROG="${TK_BIN_DIR}/wish${TK_MAJOR_VERSION}${TK_MINOR_VERSION}${TK_DBGX}${EXEEXT}"
+         else
+             WISH_PROG="${TK_BIN_DIR}/wish"
+         fi
+     else
+         # tkConfig.sh is in install location
+         if test "${TEA_PLATFORM}" = "windows"; then
+             WISH_PROG="wish${TK_MAJOR_VERSION}${TK_MINOR_VERSION}${TK_DBGX}${EXEEXT}"
+         else
+             WISH_PROG="wish${TK_MAJOR_VERSION}.${TK_MINOR_VERSION}${TK_DBGX}"
+         fi
+         list="`ls -d ${TK_BIN_DIR}/../bin 2>/dev/null` \
+               `ls -d ${TK_BIN_DIR}/..     2>/dev/null` \
+               `ls -d ${TK_PREFIX}/bin     2>/dev/null`"
+         for i in $list ; do
+             if test -f "$i/${WISH_PROG}" ; then
+                 REAL_TK_BIN_DIR="`cd "$i"; pwd`/"
+                 break
+             fi
+         done
+         WISH_PROG="${REAL_TK_BIN_DIR}${WISH_PROG}"
+     fi
+     AC_MSG_RESULT([${WISH_PROG}])
+     AC_SUBST(WISH_PROG)
+ ])
+ 
+ #------------------------------------------------------------------------
+ # TEA_ENABLE_SHARED --
+ #
+ #	Allows the building of shared libraries
+ #
+ # Arguments:
+ #	none
+ #	
+ # Results:
+ #
+ #	Adds the following arguments to configure:
+ #		--enable-shared=yes|no
+ #
+ #	Defines the following vars:
+ #		STATIC_BUILD	Used for building import/export libraries
+ #				on Windows.
+ #
+ #	Sets the following vars:
+ #		SHARED_BUILD	Value of 1 or 0
+ #------------------------------------------------------------------------
+ 
+ AC_DEFUN([TEA_ENABLE_SHARED], [
+     AC_MSG_CHECKING([how to build libraries])
+     AC_ARG_ENABLE(shared,
+ 	AC_HELP_STRING([--enable-shared],
+ 	    [build and link with shared libraries (default: on)]),
+ 	[tcl_ok=$enableval], [tcl_ok=yes])
+ 
+     if test "${enable_shared+set}" = set; then
+ 	enableval="$enable_shared"
+ 	tcl_ok=$enableval
+     else
+ 	tcl_ok=yes
+     fi
+ 
+     if test "$tcl_ok" = "yes" ; then
+ 	AC_MSG_RESULT([shared])
+ 	SHARED_BUILD=1
+     else
+ 	AC_MSG_RESULT([static])
+ 	SHARED_BUILD=0
+ 	AC_DEFINE(STATIC_BUILD, 1, [Is this a static build?])
+     fi
+     AC_SUBST(SHARED_BUILD)
+ ])
+ 
+ #------------------------------------------------------------------------
+ # TEA_ENABLE_THREADS --
+ #
+ #	Specify if thread support should be enabled.  If "yes" is specified
+ #	as an arg (optional), threads are enabled by default, "no" means
+ #	threads are disabled.  "yes" is the default.
+ #
+ #	TCL_THREADS is checked so that if you are compiling an extension
+ #	against a threaded core, your extension must be compiled threaded
+ #	as well.
+ #
+ #	Note that it is legal to have a thread enabled extension run in a
+ #	threaded or non-threaded Tcl core, but a non-threaded extension may
+ #	only run in a non-threaded Tcl core.
+ #
+ # Arguments:
+ #	none
+ #	
+ # Results:
+ #
+ #	Adds the following arguments to configure:
+ #		--enable-threads
+ #
+ #	Sets the following vars:
+ #		THREADS_LIBS	Thread library(s)
+ #
+ #	Defines the following vars:
+ #		TCL_THREADS
+ #		_REENTRANT
+ #		_THREAD_SAFE
+ #
+ #------------------------------------------------------------------------
+ 
+ AC_DEFUN([TEA_ENABLE_THREADS], [
+     AC_ARG_ENABLE(threads,
+ 	AC_HELP_STRING([--enable-threads],
+ 	    [build with threads]),
+ 	[tcl_ok=$enableval], [tcl_ok=yes])
+ 
+     if test "${enable_threads+set}" = set; then
+ 	enableval="$enable_threads"
+ 	tcl_ok=$enableval
+     else
+ 	tcl_ok=yes
+     fi
+ 
+     if test "$tcl_ok" = "yes" -o "${TCL_THREADS}" = 1; then
+ 	TCL_THREADS=1
+ 
+ 	if test "${TEA_PLATFORM}" != "windows" ; then
+ 	    # We are always OK on Windows, so check what this platform wants:
+     
+ 	    # USE_THREAD_ALLOC tells us to try the special thread-based
+ 	    # allocator that significantly reduces lock contention
+ 	    AC_DEFINE(USE_THREAD_ALLOC, 1,
+ 		[Do we want to use the threaded memory allocator?])
+ 	    AC_DEFINE(_REENTRANT, 1, [Do we want the reentrant OS API?])
+ 	    if test "`uname -s`" = "SunOS" ; then
+ 		AC_DEFINE(_POSIX_PTHREAD_SEMANTICS, 1,
+ 			[Do we really want to follow the standard? Yes we do!])
+ 	    fi
+ 	    AC_DEFINE(_THREAD_SAFE, 1, [Do we want the thread-safe OS API?])
+ 	    AC_CHECK_LIB(pthread,pthread_mutex_init,tcl_ok=yes,tcl_ok=no)
+ 	    if test "$tcl_ok" = "no"; then
+ 		# Check a little harder for __pthread_mutex_init in the same
+ 		# library, as some systems hide it there until pthread.h is
+ 		# defined.  We could alternatively do an AC_TRY_COMPILE with
+ 		# pthread.h, but that will work with libpthread really doesn't
+ 		# exist, like AIX 4.2.  [Bug: 4359]
+ 		AC_CHECK_LIB(pthread, __pthread_mutex_init,
+ 		    tcl_ok=yes, tcl_ok=no)
+ 	    fi
+ 
+ 	    if test "$tcl_ok" = "yes"; then
+ 		# The space is needed
+ 		THREADS_LIBS=" -lpthread"
+ 	    else
+ 		AC_CHECK_LIB(pthreads, pthread_mutex_init,
+ 		    tcl_ok=yes, tcl_ok=no)
+ 		if test "$tcl_ok" = "yes"; then
+ 		    # The space is needed
+ 		    THREADS_LIBS=" -lpthreads"
+ 		else
+ 		    AC_CHECK_LIB(c, pthread_mutex_init,
+ 			tcl_ok=yes, tcl_ok=no)
+ 		    if test "$tcl_ok" = "no"; then
+ 			AC_CHECK_LIB(c_r, pthread_mutex_init,
+ 			    tcl_ok=yes, tcl_ok=no)
+ 			if test "$tcl_ok" = "yes"; then
+ 			    # The space is needed
+ 			    THREADS_LIBS=" -pthread"
+ 			else
+ 			    TCL_THREADS=0
+ 			    AC_MSG_WARN([Do not know how to find pthread lib on your system - thread support disabled])
+ 			fi
+ 		    fi
+ 		fi
+ 	    fi
+ 	fi
+     else
+ 	TCL_THREADS=0
+     fi
+     # Do checking message here to not mess up interleaved configure output
+     AC_MSG_CHECKING([for building with threads])
+     if test "${TCL_THREADS}" = 1; then
+ 	AC_DEFINE(TCL_THREADS, 1, [Are we building with threads enabled?])
+ 	AC_MSG_RESULT([yes (default)])
+     else
+ 	AC_MSG_RESULT([no])
+     fi
+     # TCL_THREADS sanity checking.  See if our request for building with
+     # threads is the same as the way Tcl was built.  If not, warn the user.
+     case ${TCL_DEFS} in
+ 	*THREADS=1*)
+ 	    if test "${TCL_THREADS}" = "0"; then
+ 		AC_MSG_WARN([
+     Building ${PACKAGE_NAME} without threads enabled, but building against Tcl
+     that IS thread-enabled.  It is recommended to use --enable-threads.])
+ 	    fi
+ 	    ;;
+ 	*)
+ 	    if test "${TCL_THREADS}" = "1"; then
+ 		AC_MSG_WARN([
+     --enable-threads requested, but building against a Tcl that is NOT
+     thread-enabled.  This is an OK configuration that will also run in
+     a thread-enabled core.])
+ 	    fi
+ 	    ;;
+     esac
+     AC_SUBST(TCL_THREADS)
+ ])
+ 
+ #------------------------------------------------------------------------
+ # TEA_ENABLE_SYMBOLS --
+ #
+ #	Specify if debugging symbols should be used.
+ #	Memory (TCL_MEM_DEBUG) debugging can also be enabled.
+ #
+ # Arguments:
+ #	none
+ #	
+ #	TEA varies from core Tcl in that C|LDFLAGS_DEFAULT receives
+ #	the value of C|LDFLAGS_OPTIMIZE|DEBUG already substituted.
+ #	Requires the following vars to be set in the Makefile:
+ #		CFLAGS_DEFAULT
+ #		LDFLAGS_DEFAULT
+ #	
+ # Results:
+ #
+ #	Adds the following arguments to configure:
+ #		--enable-symbols
+ #
+ #	Defines the following vars:
+ #		CFLAGS_DEFAULT	Sets to $(CFLAGS_DEBUG) if true
+ #				Sets to $(CFLAGS_OPTIMIZE) if false
+ #		LDFLAGS_DEFAULT	Sets to $(LDFLAGS_DEBUG) if true
+ #				Sets to $(LDFLAGS_OPTIMIZE) if false
+ #		DBGX		Formerly used as debug library extension;
+ #				always blank now.
+ #
+ #------------------------------------------------------------------------
+ 
+ AC_DEFUN([TEA_ENABLE_SYMBOLS], [
+     dnl TEA specific: Make sure we are initialized
+     AC_REQUIRE([TEA_CONFIG_CFLAGS])
+     AC_MSG_CHECKING([for build with symbols])
+     AC_ARG_ENABLE(symbols,
+ 	AC_HELP_STRING([--enable-symbols],
+ 	    [build with debugging symbols (default: off)]),
+ 	[tcl_ok=$enableval], [tcl_ok=no])
+     DBGX=""
+     if test "$tcl_ok" = "no"; then
+ 	CFLAGS_DEFAULT="${CFLAGS_OPTIMIZE}"
+ 	LDFLAGS_DEFAULT="${LDFLAGS_OPTIMIZE}"
+ 	AC_MSG_RESULT([no])
+     else
+ 	CFLAGS_DEFAULT="${CFLAGS_DEBUG}"
+ 	LDFLAGS_DEFAULT="${LDFLAGS_DEBUG}"
+ 	if test "$tcl_ok" = "yes"; then
+ 	    AC_MSG_RESULT([yes (standard debugging)])
+ 	fi
+     fi
+     # TEA specific:
+     if test "${TEA_PLATFORM}" != "windows" ; then
+ 	LDFLAGS_DEFAULT="${LDFLAGS}"
+     fi
+     AC_SUBST(CFLAGS_DEFAULT)
+     AC_SUBST(LDFLAGS_DEFAULT)
+     AC_SUBST(TCL_DBGX)
+ 
+     if test "$tcl_ok" = "mem" -o "$tcl_ok" = "all"; then
+ 	AC_DEFINE(TCL_MEM_DEBUG, 1, [Is memory debugging enabled?])
+     fi
+ 
+     if test "$tcl_ok" != "yes" -a "$tcl_ok" != "no"; then
+ 	if test "$tcl_ok" = "all"; then
+ 	    AC_MSG_RESULT([enabled symbols mem debugging])
+ 	else
+ 	    AC_MSG_RESULT([enabled $tcl_ok debugging])
+ 	fi
+     fi
+ ])
+ 
+ #------------------------------------------------------------------------
+ # TEA_ENABLE_LANGINFO --
+ #
+ #	Allows use of modern nl_langinfo check for better l10n.
+ #	This is only relevant for Unix.
+ #
+ # Arguments:
+ #	none
+ #	
+ # Results:
+ #
+ #	Adds the following arguments to configure:
+ #		--enable-langinfo=yes|no (default is yes)
+ #
+ #	Defines the following vars:
+ #		HAVE_LANGINFO	Triggers use of nl_langinfo if defined.
+ #
+ #------------------------------------------------------------------------
+ 
+ AC_DEFUN([TEA_ENABLE_LANGINFO], [
+     AC_ARG_ENABLE(langinfo,
+ 	AC_HELP_STRING([--enable-langinfo],
+ 	    [use nl_langinfo if possible to determine encoding at startup, otherwise use old heuristic (default: on)]),
+ 	[langinfo_ok=$enableval], [langinfo_ok=yes])
+ 
+     HAVE_LANGINFO=0
+     if test "$langinfo_ok" = "yes"; then
+ 	AC_CHECK_HEADER(langinfo.h,[langinfo_ok=yes],[langinfo_ok=no])
+     fi
+     AC_MSG_CHECKING([whether to use nl_langinfo])
+     if test "$langinfo_ok" = "yes"; then
+ 	AC_CACHE_VAL(tcl_cv_langinfo_h, [
+ 	    AC_TRY_COMPILE([#include <langinfo.h>], [nl_langinfo(CODESET);],
+ 		    [tcl_cv_langinfo_h=yes],[tcl_cv_langinfo_h=no])])
+ 	AC_MSG_RESULT([$tcl_cv_langinfo_h])
+ 	if test $tcl_cv_langinfo_h = yes; then
+ 	    AC_DEFINE(HAVE_LANGINFO, 1, [Do we have nl_langinfo()?])
+ 	fi
+     else 
+ 	AC_MSG_RESULT([$langinfo_ok])
+     fi
+ ])
+ 
+ #--------------------------------------------------------------------
+ # TEA_CONFIG_SYSTEM
+ #
+ #	Determine what the system is (some things cannot be easily checked
+ #	on a feature-driven basis, alas). This can usually be done via the
+ #	"uname" command, but there are a few systems, like Next, where
+ #	this doesn't work.
+ #
+ # Arguments:
+ #	none
+ #
+ # Results:
+ #	Defines the following var:
+ #
+ #	system -	System/platform/version identification code.
+ #
+ #--------------------------------------------------------------------
+ 
+ AC_DEFUN([TEA_CONFIG_SYSTEM], [
+     AC_CACHE_CHECK([system version], tcl_cv_sys_version, [
+ 	# TEA specific:
+ 	if test "${TEA_PLATFORM}" = "windows" ; then
+ 	    tcl_cv_sys_version=windows
+ 	elif test -f /usr/lib/NextStep/software_version; then
+ 	    tcl_cv_sys_version=NEXTSTEP-`awk '/3/,/3/' /usr/lib/NextStep/software_version`
+ 	else
+ 	    tcl_cv_sys_version=`uname -s`-`uname -r`
+ 	    if test "$?" -ne 0 ; then
+ 		AC_MSG_WARN([can't find uname command])
+ 		tcl_cv_sys_version=unknown
+ 	    else
+ 		# Special check for weird MP-RAS system (uname returns weird
+ 		# results, and the version is kept in special file).
+ 
+ 		if test -r /etc/.relid -a "X`uname -n`" = "X`uname -s`" ; then
+ 		    tcl_cv_sys_version=MP-RAS-`awk '{print $[3]}' /etc/.relid`
+ 		fi
+ 		if test "`uname -s`" = "AIX" ; then
+ 		    tcl_cv_sys_version=AIX-`uname -v`.`uname -r`
+ 		fi
+ 	    fi
+ 	fi
+     ])
+     system=$tcl_cv_sys_version
+ ])
+ 
+ #--------------------------------------------------------------------
+ # TEA_CONFIG_CFLAGS
+ #
+ #	Try to determine the proper flags to pass to the compiler
+ #	for building shared libraries and other such nonsense.
+ #
+ # Arguments:
+ #	none
+ #
+ # Results:
+ #
+ #	Defines and substitutes the following vars:
+ #
+ #       DL_OBJS -       Name of the object file that implements dynamic
+ #                       loading for Tcl on this system.
+ #       DL_LIBS -       Library file(s) to include in tclsh and other base
+ #                       applications in order for the "load" command to work.
+ #       LDFLAGS -      Flags to pass to the compiler when linking object
+ #                       files into an executable application binary such
+ #                       as tclsh.
+ #       LD_SEARCH_FLAGS-Flags to pass to ld, such as "-R /usr/local/tcl/lib",
+ #                       that tell the run-time dynamic linker where to look
+ #                       for shared libraries such as libtcl.so.  Depends on
+ #                       the variable LIB_RUNTIME_DIR in the Makefile. Could
+ #                       be the same as CC_SEARCH_FLAGS if ${CC} is used to link.
+ #       CC_SEARCH_FLAGS-Flags to pass to ${CC}, such as "-Wl,-rpath,/usr/local/tcl/lib",
+ #                       that tell the run-time dynamic linker where to look
+ #                       for shared libraries such as libtcl.so.  Depends on
+ #                       the variable LIB_RUNTIME_DIR in the Makefile.
+ #       SHLIB_CFLAGS -  Flags to pass to cc when compiling the components
+ #                       of a shared library (may request position-independent
+ #                       code, among other things).
+ #       SHLIB_LD -      Base command to use for combining object files
+ #                       into a shared library.
+ #       SHLIB_LD_LIBS - Dependent libraries for the linker to scan when
+ #                       creating shared libraries.  This symbol typically
+ #                       goes at the end of the "ld" commands that build
+ #                       shared libraries. The value of the symbol is
+ #                       "${LIBS}" if all of the dependent libraries should
+ #                       be specified when creating a shared library.  If
+ #                       dependent libraries should not be specified (as on
+ #                       SunOS 4.x, where they cause the link to fail, or in
+ #                       general if Tcl and Tk aren't themselves shared
+ #                       libraries), then this symbol has an empty string
+ #                       as its value.
+ #       SHLIB_SUFFIX -  Suffix to use for the names of dynamically loadable
+ #                       extensions.  An empty string means we don't know how
+ #                       to use shared libraries on this platform.
+ #       LIB_SUFFIX -    Specifies everything that comes after the "libfoo"
+ #                       in a static or shared library name, using the $VERSION variable
+ #                       to put the version in the right place.  This is used
+ #                       by platforms that need non-standard library names.
+ #                       Examples:  ${VERSION}.so.1.1 on NetBSD, since it needs
+ #                       to have a version after the .so, and ${VERSION}.a
+ #                       on AIX, since a shared library needs to have
+ #                       a .a extension whereas shared objects for loadable
+ #                       extensions have a .so extension.  Defaults to
+ #                       ${VERSION}${SHLIB_SUFFIX}.
+ #       TCL_NEEDS_EXP_FILE -
+ #                       1 means that an export file is needed to link to a
+ #                       shared library.
+ #       TCL_EXP_FILE -  The name of the installed export / import file which
+ #                       should be used to link to the Tcl shared library.
+ #                       Empty if Tcl is unshared.
+ #       TCL_BUILD_EXP_FILE -
+ #                       The name of the built export / import file which
+ #                       should be used to link to the Tcl shared library.
+ #                       Empty if Tcl is unshared.
+ #	CFLAGS_DEBUG -
+ #			Flags used when running the compiler in debug mode
+ #	CFLAGS_OPTIMIZE -
+ #			Flags used when running the compiler in optimize mode
+ #	CFLAGS -	Additional CFLAGS added as necessary (usually 64-bit)
+ #
+ #--------------------------------------------------------------------
+ 
+ AC_DEFUN([TEA_CONFIG_CFLAGS], [
+     dnl TEA specific: Make sure we are initialized
+     AC_REQUIRE([TEA_INIT])
+ 
+     # Step 0.a: Enable 64 bit support?
+ 
+     AC_MSG_CHECKING([if 64bit support is requested])
+     AC_ARG_ENABLE(64bit,
+ 	AC_HELP_STRING([--enable-64bit],
+ 	    [enable 64bit support (default: off)]),
+ 	[do64bit=$enableval], [do64bit=no])
+     AC_MSG_RESULT([$do64bit])
+ 
+     # Step 0.b: Enable Solaris 64 bit VIS support?
+ 
+     AC_MSG_CHECKING([if 64bit Sparc VIS support is requested])
+     AC_ARG_ENABLE(64bit-vis,
+ 	AC_HELP_STRING([--enable-64bit-vis],
+ 	    [enable 64bit Sparc VIS support (default: off)]),
+ 	[do64bitVIS=$enableval], [do64bitVIS=no])
+     AC_MSG_RESULT([$do64bitVIS])
+     # Force 64bit on with VIS
+     AS_IF([test "$do64bitVIS" = "yes"], [do64bit=yes])
+ 
+     # Step 0.c: Check if visibility support is available. Do this here so
+     # that platform specific alternatives can be used below if this fails.
+ 
+     AC_CACHE_CHECK([if compiler supports visibility "hidden"],
+ 	tcl_cv_cc_visibility_hidden, [
+ 	hold_cflags=$CFLAGS; CFLAGS="$CFLAGS -Werror"
+ 	AC_TRY_LINK([
+ 	    extern __attribute__((__visibility__("hidden"))) void f(void);
+ 	    void f(void) {}], [f();], tcl_cv_cc_visibility_hidden=yes,
+ 	    tcl_cv_cc_visibility_hidden=no)
+ 	CFLAGS=$hold_cflags])
+     AS_IF([test $tcl_cv_cc_visibility_hidden = yes], [
+ 	AC_DEFINE(MODULE_SCOPE,
+ 	    [extern __attribute__((__visibility__("hidden")))],
+ 	    [Compiler support for module scope symbols])
+     ])
+ 
+     # Step 0.d: Disable -rpath support?
+ 
+     AC_MSG_CHECKING([if rpath support is requested])
+     AC_ARG_ENABLE(rpath,
+ 	AC_HELP_STRING([--disable-rpath],
+ 	    [disable rpath support (default: on)]),
+ 	[doRpath=$enableval], [doRpath=yes])
+     AC_MSG_RESULT([$doRpath])
+ 
+     # TEA specific: Cross-compiling options for Windows/CE builds?
+ 
+     AS_IF([test "${TEA_PLATFORM}" = windows], [
+ 	AC_MSG_CHECKING([if Windows/CE build is requested])
+ 	AC_ARG_ENABLE(wince,
+ 	    AC_HELP_STRING([--enable-wince],
+ 		[enable Win/CE support (where applicable)]),
+ 	    [doWince=$enableval], [doWince=no])
+ 	AC_MSG_RESULT([$doWince])
+     ])
+ 
+     # Step 1: set the variable "system" to hold the name and version number
+     # for the system.
+ 
+     TEA_CONFIG_SYSTEM
+ 
+     # Step 2: check for existence of -ldl library.  This is needed because
+     # Linux can use either -ldl or -ldld for dynamic loading.
+ 
+     AC_CHECK_LIB(dl, dlopen, have_dl=yes, have_dl=no)
+ 
+     # Require ranlib early so we can override it in special cases below.
+ 
+     AC_REQUIRE([AC_PROG_RANLIB])
+ 
+     # Step 3: set configuration options based on system name and version.
+     # This is similar to Tcl's unix/tcl.m4 except that we've added a
+     # "windows" case.
+ 
+     do64bit_ok=no
+     LDFLAGS_ORIG="$LDFLAGS"
+     # When ld needs options to work in 64-bit mode, put them in
+     # LDFLAGS_ARCH so they eventually end up in LDFLAGS even if [load]
+     # is disabled by the user. [Bug 1016796]
+     LDFLAGS_ARCH=""
+     TCL_EXPORT_FILE_SUFFIX=""
+     UNSHARED_LIB_SUFFIX=""
+     # TEA specific: use PACKAGE_VERSION instead of VERSION
+     TCL_TRIM_DOTS='`echo ${PACKAGE_VERSION} | tr -d .`'
+     ECHO_VERSION='`echo ${PACKAGE_VERSION}`'
+     TCL_LIB_VERSIONS_OK=ok
+     CFLAGS_DEBUG=-g
+     CFLAGS_OPTIMIZE=-O
+     AS_IF([test "$GCC" = yes], [
+ 	# TEA specific:
+ 	CFLAGS_OPTIMIZE=-O2
+ 	CFLAGS_WARNING="-Wall -Wno-implicit-int"
+     ], [CFLAGS_WARNING=""])
+     TCL_NEEDS_EXP_FILE=0
+     TCL_BUILD_EXP_FILE=""
+     TCL_EXP_FILE=""
+ dnl FIXME: Replace AC_CHECK_PROG with AC_CHECK_TOOL once cross compiling is fixed.
+ dnl AC_CHECK_TOOL(AR, ar)
+     AC_CHECK_PROG(AR, ar, ar)
+     STLIB_LD='${AR} cr'
+     LD_LIBRARY_PATH_VAR="LD_LIBRARY_PATH"
+     case $system in
+ 	# TEA specific:
+ 	windows)
+ 	    # This is a 2-stage check to make sure we have the 64-bit SDK
+ 	    # We have to know where the SDK is installed.
+ 	    # This magic is based on MS Platform SDK for Win2003 SP1 - hobbs
+ 	    # MACHINE is IX86 for LINK, but this is used by the manifest,
+ 	    # which requires x86|amd64|ia64.
+ 	    MACHINE="X86"
+ 	    if test "$do64bit" != "no" ; then
+ 		if test "x${MSSDK}x" = "xx" ; then
+ 		    MSSDK="C:/Progra~1/Microsoft Platform SDK"
+ 		fi
+ 		MSSDK=`echo "$MSSDK" | sed -e  's!\\\!/!g'`
+ 		PATH64=""
+ 		case "$do64bit" in
+ 		    amd64|x64|yes)
+ 			MACHINE="AMD64" ; # default to AMD64 64-bit build
+ 			PATH64="${MSSDK}/Bin/Win64/x86/AMD64"
+ 			;;
+ 		    ia64)
+ 			MACHINE="IA64"
+ 			PATH64="${MSSDK}/Bin/Win64"
+ 			;;
+ 		esac
+ 		if test ! -d "${PATH64}" ; then
+ 		    AC_MSG_WARN([Could not find 64-bit $MACHINE SDK to enable 64bit mode])
+ 		    AC_MSG_WARN([Ensure latest Platform SDK is installed])
+ 		    do64bit="no"
+ 		else
+ 		    AC_MSG_RESULT([   Using 64-bit $MACHINE mode])
+ 		    do64bit_ok="yes"
+ 		fi
+ 	    fi
+ 
+ 	    if test "$doWince" != "no" ; then
+ 		if test "$do64bit" != "no" ; then
+ 		    AC_MSG_ERROR([Windows/CE and 64-bit builds incompatible])
+ 		fi
+ 		if test "$GCC" = "yes" ; then
+ 		    AC_MSG_ERROR([Windows/CE and GCC builds incompatible])
+ 		fi
+ 		TEA_PATH_CELIB
+ 		# Set defaults for common evc4/PPC2003 setup
+ 		# Currently Tcl requires 300+, possibly 420+ for sockets
+ 		CEVERSION=420; 		# could be 211 300 301 400 420 ...
+ 		TARGETCPU=ARMV4;	# could be ARMV4 ARM MIPS SH3 X86 ...
+ 		ARCH=ARM;		# could be ARM MIPS X86EM ...
+ 		PLATFORM="Pocket PC 2003"; # or "Pocket PC 2002"
+ 		if test "$doWince" != "yes"; then
+ 		    # If !yes then the user specified something
+ 		    # Reset ARCH to allow user to skip specifying it
+ 		    ARCH=
+ 		    eval `echo $doWince | awk -F, '{ \
+ 	    if (length([$]1)) { printf "CEVERSION=\"%s\"\n", [$]1; \
+ 	    if ([$]1 < 400)   { printf "PLATFORM=\"Pocket PC 2002\"\n" } }; \
+ 	    if (length([$]2)) { printf "TARGETCPU=\"%s\"\n", toupper([$]2) }; \
+ 	    if (length([$]3)) { printf "ARCH=\"%s\"\n", toupper([$]3) }; \
+ 	    if (length([$]4)) { printf "PLATFORM=\"%s\"\n", [$]4 }; \
+ 		    }'`
+ 		    if test "x${ARCH}" = "x" ; then
+ 			ARCH=$TARGETCPU;
+ 		    fi
+ 		fi
+ 		OSVERSION=WCE$CEVERSION;
+ 	    	if test "x${WCEROOT}" = "x" ; then
+ 			WCEROOT="C:/Program Files/Microsoft eMbedded C++ 4.0"
+ 		    if test ! -d "${WCEROOT}" ; then
+ 			WCEROOT="C:/Program Files/Microsoft eMbedded Tools"
+ 		    fi
+ 		fi
+ 		if test "x${SDKROOT}" = "x" ; then
+ 		    SDKROOT="C:/Program Files/Windows CE Tools"
+ 		    if test ! -d "${SDKROOT}" ; then
+ 			SDKROOT="C:/Windows CE Tools"
+ 		    fi
+ 		fi
+ 		WCEROOT=`echo "$WCEROOT" | sed -e 's!\\\!/!g'`
+ 		SDKROOT=`echo "$SDKROOT" | sed -e 's!\\\!/!g'`
+ 		if test ! -d "${SDKROOT}/${OSVERSION}/${PLATFORM}/Lib/${TARGETCPU}" \
+ 		    -o ! -d "${WCEROOT}/EVC/${OSVERSION}/bin"; then
+ 		    AC_MSG_ERROR([could not find PocketPC SDK or target compiler to enable WinCE mode [$CEVERSION,$TARGETCPU,$ARCH,$PLATFORM]])
+ 		    doWince="no"
+ 		else
+ 		    # We could PATH_NOSPACE these, but that's not important,
+ 		    # as long as we quote them when used.
+ 		    CEINCLUDE="${SDKROOT}/${OSVERSION}/${PLATFORM}/include"
+ 		    if test -d "${CEINCLUDE}/${TARGETCPU}" ; then
+ 			CEINCLUDE="${CEINCLUDE}/${TARGETCPU}"
+ 		    fi
+ 		    CELIBPATH="${SDKROOT}/${OSVERSION}/${PLATFORM}/Lib/${TARGETCPU}"
+     		fi
+ 	    fi
+ 
+ 	    if test "$GCC" != "yes" ; then
+ 	        if test "${SHARED_BUILD}" = "0" ; then
+ 		    runtime=-MT
+ 	        else
+ 		    runtime=-MD
+ 	        fi
+ 
+                 if test "$do64bit" != "no" ; then
+ 		    # All this magic is necessary for the Win64 SDK RC1 - hobbs
+ 		    CC="\"${PATH64}/cl.exe\""
+ 		    CFLAGS="${CFLAGS} -I\"${MSSDK}/Include\" -I\"${MSSDK}/Include/crt\" -I\"${MSSDK}/Include/crt/sys\""
+ 		    RC="\"${MSSDK}/bin/rc.exe\""
+ 		    lflags="-nologo -MACHINE:${MACHINE} -LIBPATH:\"${MSSDK}/Lib/${MACHINE}\""
+ 		    LINKBIN="\"${PATH64}/link.exe\""
+ 		    CFLAGS_DEBUG="-nologo -Zi -Od -W3 ${runtime}d"
+ 		    CFLAGS_OPTIMIZE="-nologo -O2 -W2 ${runtime}"
+ 		    # Avoid 'unresolved external symbol __security_cookie'
+ 		    # errors, c.f. http://support.microsoft.com/?id=894573
+ 		    TEA_ADD_LIBS([bufferoverflowU.lib])
+ 		elif test "$doWince" != "no" ; then
+ 		    CEBINROOT="${WCEROOT}/EVC/${OSVERSION}/bin"
+ 		    if test "${TARGETCPU}" = "X86"; then
+ 			CC="\"${CEBINROOT}/cl.exe\""
+ 		    else
+ 			CC="\"${CEBINROOT}/cl${ARCH}.exe\""
+ 		    fi
+ 		    CFLAGS="$CFLAGS -I\"${CELIB_DIR}/inc\" -I\"${CEINCLUDE}\""
+ 		    RC="\"${WCEROOT}/Common/EVC/bin/rc.exe\""
+ 		    arch=`echo ${ARCH} | awk '{print tolower([$]0)}'`
+ 		    defs="${ARCH} _${ARCH}_ ${arch} PALM_SIZE _MT _WINDOWS"
+ 		    if test "${SHARED_BUILD}" = "1" ; then
+ 			# Static CE builds require static celib as well
+ 		    	defs="${defs} _DLL"
+ 		    fi
+ 		    for i in $defs ; do
+ 			AC_DEFINE_UNQUOTED($i, 1, [WinCE def ]$i)
+ 		    done
+ 		    AC_DEFINE_UNQUOTED(_WIN32_WCE, $CEVERSION, [_WIN32_WCE version])
+ 		    AC_DEFINE_UNQUOTED(UNDER_CE, $CEVERSION, [UNDER_CE version])
+ 		    CFLAGS_DEBUG="-nologo -Zi -Od"
+ 		    CFLAGS_OPTIMIZE="-nologo -Ox"
+ 		    lversion=`echo ${CEVERSION} | sed -e 's/\(.\)\(..\)/\1\.\2/'`
+ 		    lflags="-MACHINE:${ARCH} -LIBPATH:\"${CELIBPATH}\" -subsystem:windowsce,${lversion} -nologo"
+ 		    LINKBIN="\"${CEBINROOT}/link.exe\""
+ 		    AC_SUBST(CELIB_DIR)
+ 		else
+ 		    RC="rc"
+ 		    lflags="-nologo"
+     		    LINKBIN="link"
+ 		    CFLAGS_DEBUG="-nologo -Z7 -Od -W3 -WX ${runtime}d"
+ 		    CFLAGS_OPTIMIZE="-nologo -O2 -W2 ${runtime}"
+ 		fi
+ 	    fi
+ 
+ 	    if test "$GCC" = "yes"; then
+ 		# mingw gcc mode
+ 		RC="windres"
+ 		CFLAGS_DEBUG="-g"
+ 		CFLAGS_OPTIMIZE="-O2 -fomit-frame-pointer"
+ 		SHLIB_LD="$CC -shared"
+ 		UNSHARED_LIB_SUFFIX='${TCL_TRIM_DOTS}.a'
+ 		LDFLAGS_CONSOLE="-wl,--subsystem,console ${lflags}"
+ 		LDFLAGS_WINDOW="-wl,--subsystem,windows ${lflags}"
+ 	    else
+ 		SHLIB_LD="${LINKBIN} -dll ${lflags}"
+ 		# link -lib only works when -lib is the first arg
+ 		STLIB_LD="${LINKBIN} -lib ${lflags}"
+ 		UNSHARED_LIB_SUFFIX='${TCL_TRIM_DOTS}.lib'
+ 		PATHTYPE=-w
+ 		# For information on what debugtype is most useful, see:
+ 		# http://msdn.microsoft.com/library/en-us/dnvc60/html/gendepdebug.asp
+ 		# This essentially turns it all on.
+ 		LDFLAGS_DEBUG="-debug:full -debugtype:both -warn:2"
+ 		LDFLAGS_OPTIMIZE="-release"
+ 		if test "$doWince" != "no" ; then
+ 		    LDFLAGS_CONSOLE="-link ${lflags}"
+ 		    LDFLAGS_WINDOW=${LDFLAGS_CONSOLE}
+ 		else
+ 		    LDFLAGS_CONSOLE="-link -subsystem:console ${lflags}"
+ 		    LDFLAGS_WINDOW="-link -subsystem:windows ${lflags}"
+ 		fi
+ 	    fi
+ 
+ 	    SHLIB_LD_LIBS='${LIBS}'
+ 	    SHLIB_SUFFIX=".dll"
+ 	    SHARED_LIB_SUFFIX='${TCL_TRIM_DOTS}.dll'
+ 
+ 	    TCL_LIB_VERSIONS_OK=nodots
+ 	    # Bogus to avoid getting this turned off
+ 	    DL_OBJS="tclLoadNone.obj"
+     	    ;;
+ 	AIX-*)
+ 	    AS_IF([test "${TCL_THREADS}" = "1" -a "$GCC" != "yes"], [
+ 		# AIX requires the _r compiler when gcc isn't being used
+ 		case "${CC}" in
+ 		    *_r)
+ 			# ok ...
+ 			;;
+ 		    *)
+ 			CC=${CC}_r
+ 			;;
+ 		esac
+ 		AC_MSG_RESULT([Using $CC for compiling with threads])
+ 	    ])
+ 	    LIBS="$LIBS -lc"
+ 	    SHLIB_CFLAGS=""
+ 	    SHLIB_LD_LIBS='${LIBS}'
+ 	    SHLIB_SUFFIX=".so"
+ 
+ 	    DL_OBJS="tclLoadDl.o"
+ 	    LD_LIBRARY_PATH_VAR="LIBPATH"
+ 
+ 	    # Check to enable 64-bit flags for compiler/linker on AIX 4+
+ 	    AS_IF([test "$do64bit" = yes -a "`uname -v`" -gt 3], [
+ 		AS_IF([test "$GCC" = yes], [
+ 		    AC_MSG_WARN([64bit mode not supported with GCC on $system])
+ 		], [
+ 		    do64bit_ok=yes
+ 		    CFLAGS="$CFLAGS -q64"
+ 		    LDFLAGS_ARCH="-q64"
+ 		    RANLIB="${RANLIB} -X64"
+ 		    AR="${AR} -X64"
+ 		    SHLIB_LD_FLAGS="-b64"
+ 		])
+ 	    ])
+ 
+ 	    AS_IF([test "`uname -m`" = ia64], [
+ 		# AIX-5 uses ELF style dynamic libraries on IA-64, but not PPC
+ 		SHLIB_LD="/usr/ccs/bin/ld -G -z text"
+ 		# AIX-5 has dl* in libc.so
+ 		DL_LIBS=""
+ 		AS_IF([test "$GCC" = yes], [
+ 		    CC_SEARCH_FLAGS='-Wl,-R,${LIB_RUNTIME_DIR}'
+ 		], [
+ 		    CC_SEARCH_FLAGS='-R${LIB_RUNTIME_DIR}'
+ 		])
+ 		LD_SEARCH_FLAGS='-R ${LIB_RUNTIME_DIR}'
+ 	    ], [
+ 		AS_IF([test "$GCC" = yes], [SHLIB_LD='${CC} -shared'], [
+ 		    SHLIB_LD="/bin/ld -bhalt:4 -bM:SRE -bE:lib.exp -H512 -T512 -bnoentry"
+ 		])
+ 		SHLIB_LD="${TCL_SRC_DIR}/unix/ldAix ${SHLIB_LD} ${SHLIB_LD_FLAGS}"
+ 		DL_LIBS="-ldl"
+ 		CC_SEARCH_FLAGS='-L${LIB_RUNTIME_DIR}'
+ 		LD_SEARCH_FLAGS=${CC_SEARCH_FLAGS}
+ 		TCL_NEEDS_EXP_FILE=1
+ 		# TEA specific: use PACKAGE_VERSION instead of VERSION
+ 		TCL_EXPORT_FILE_SUFFIX='${PACKAGE_VERSION}.exp'
+ 	    ])
+ 
+ 	    # AIX v<=4.1 has some different flags than 4.2+
+ 	    AS_IF([test "$system" = "AIX-4.1" -o "`uname -v`" -lt 4], [
+ 		AC_LIBOBJ([tclLoadAix])
+ 		DL_LIBS="-lld"
+ 	    ])
+ 
+ 	    # On AIX <=v4 systems, libbsd.a has to be linked in to support
+ 	    # non-blocking file IO.  This library has to be linked in after
+ 	    # the MATH_LIBS or it breaks the pow() function.  The way to
+ 	    # insure proper sequencing, is to add it to the tail of MATH_LIBS.
+ 	    # This library also supplies gettimeofday.
+ 	    #
+ 	    # AIX does not have a timezone field in struct tm. When the AIX
+ 	    # bsd library is used, the timezone global and the gettimeofday
+ 	    # methods are to be avoided for timezone deduction instead, we
+ 	    # deduce the timezone by comparing the localtime result on a
+ 	    # known GMT value.
+ 
+ 	    AC_CHECK_LIB(bsd, gettimeofday, libbsd=yes, libbsd=no)
+ 	    AS_IF([test $libbsd = yes], [
+ 	    	MATH_LIBS="$MATH_LIBS -lbsd"
+ 	    	AC_DEFINE(USE_DELTA_FOR_TZ, 1, [Do we need a special AIX hack for timezones?])
+ 	    ])
+ 	    ;;
+ 	BeOS*)
+ 	    SHLIB_CFLAGS="-fPIC"
+ 	    SHLIB_LD='${CC} -nostart'
+ 	    SHLIB_LD_LIBS='${LIBS}'
+ 	    SHLIB_SUFFIX=".so"
+ 	    DL_OBJS="tclLoadDl.o"
+ 	    DL_LIBS="-ldl"
+ 
+ 	    #-----------------------------------------------------------
+ 	    # Check for inet_ntoa in -lbind, for BeOS (which also needs
+ 	    # -lsocket, even if the network functions are in -lnet which
+ 	    # is always linked to, for compatibility.
+ 	    #-----------------------------------------------------------
+ 	    AC_CHECK_LIB(bind, inet_ntoa, [LIBS="$LIBS -lbind -lsocket"])
+ 	    ;;
+ 	BSD/OS-2.1*|BSD/OS-3*)
+ 	    SHLIB_CFLAGS=""
+ 	    SHLIB_LD="shlicc -r"
+ 	    SHLIB_LD_LIBS='${LIBS}'
+ 	    SHLIB_SUFFIX=".so"
+ 	    DL_OBJS="tclLoadDl.o"
+ 	    DL_LIBS="-ldl"
+ 	    CC_SEARCH_FLAGS=""
+ 	    LD_SEARCH_FLAGS=""
+ 	    ;;
+ 	BSD/OS-4.*)
+ 	    SHLIB_CFLAGS="-export-dynamic -fPIC"
+ 	    SHLIB_LD='${CC} -shared'
+ 	    SHLIB_LD_LIBS='${LIBS}'
+ 	    SHLIB_SUFFIX=".so"
+ 	    DL_OBJS="tclLoadDl.o"
+ 	    DL_LIBS="-ldl"
+ 	    LDFLAGS="$LDFLAGS -export-dynamic"
+ 	    CC_SEARCH_FLAGS=""
+ 	    LD_SEARCH_FLAGS=""
+ 	    ;;
+ 	dgux*)
+ 	    SHLIB_CFLAGS="-K PIC"
+ 	    SHLIB_LD='${CC} -G'
+ 	    SHLIB_LD_LIBS=""
+ 	    SHLIB_SUFFIX=".so"
+ 	    DL_OBJS="tclLoadDl.o"
+ 	    DL_LIBS="-ldl"
+ 	    CC_SEARCH_FLAGS=""
+ 	    LD_SEARCH_FLAGS=""
+ 	    ;;
+ 	HP-UX-*.11.*)
+ 	    # Use updated header definitions where possible
+ 	    AC_DEFINE(_XOPEN_SOURCE_EXTENDED, 1, [Do we want to use the XOPEN network library?])
+ 	    # TEA specific: Needed by Tcl, but not most extensions
+ 	    #AC_DEFINE(_XOPEN_SOURCE, 1, [Do we want to use the XOPEN network library?])
+ 	    #LIBS="$LIBS -lxnet"               # Use the XOPEN network library
+ 
+ 	    AS_IF([test "`uname -m`" = ia64], [
+ 		SHLIB_SUFFIX=".so"
+ 		# Use newer C++ library for C++ extensions
+ 		#if test "$GCC" != "yes" ; then
+ 		#   CPPFLAGS="-AA"
+ 		#fi
+ 	    ], [
+ 		SHLIB_SUFFIX=".sl"
+ 	    ])
+ 	    AC_CHECK_LIB(dld, shl_load, tcl_ok=yes, tcl_ok=no)
+ 	    AS_IF([test "$tcl_ok" = yes], [
+ 		SHLIB_CFLAGS="+z"
+ 		SHLIB_LD="ld -b"
+ 		SHLIB_LD_LIBS='${LIBS}'
+ 		DL_OBJS="tclLoadShl.o"
+ 		DL_LIBS="-ldld"
+ 		LDFLAGS="$LDFLAGS -Wl,-E"
+ 		CC_SEARCH_FLAGS='-Wl,+s,+b,${LIB_RUNTIME_DIR}:.'
+ 		LD_SEARCH_FLAGS='+s +b ${LIB_RUNTIME_DIR}:.'
+ 		LD_LIBRARY_PATH_VAR="SHLIB_PATH"
+ 	    ])
+ 	    AS_IF([test "$GCC" = yes], [
+ 		SHLIB_LD='${CC} -shared'
+ 		SHLIB_LD_LIBS='${LIBS}'
+ 		LD_SEARCH_FLAGS=${CC_SEARCH_FLAGS}
+ 	    ])
+ 
+ 	    # Users may want PA-RISC 1.1/2.0 portable code - needs HP cc
+ 	    #CFLAGS="$CFLAGS +DAportable"
+ 
+ 	    # Check to enable 64-bit flags for compiler/linker
+ 	    AS_IF([test "$do64bit" = "yes"], [
+ 		AS_IF([test "$GCC" = yes], [
+ 		    case `${CC} -dumpmachine` in
+ 			hppa64*)
+ 			    # 64-bit gcc in use.  Fix flags for GNU ld.
+ 			    do64bit_ok=yes
+ 			    SHLIB_LD='${CC} -shared'
+ 			    SHLIB_LD_LIBS='${LIBS}'
+ 			    AS_IF([test $doRpath = yes], [
+ 				CC_SEARCH_FLAGS='-Wl,-rpath,${LIB_RUNTIME_DIR}'])
+ 			    LD_SEARCH_FLAGS=${CC_SEARCH_FLAGS}
+ 			    ;;
+ 			*)
+ 			    AC_MSG_WARN([64bit mode not supported with GCC on $system])
+ 			    ;;
+ 		    esac
+ 		], [
+ 		    do64bit_ok=yes
+ 		    CFLAGS="$CFLAGS +DD64"
+ 		    LDFLAGS_ARCH="+DD64"
+ 		])
+ 	    ]) ;;
+ 	HP-UX-*.08.*|HP-UX-*.09.*|HP-UX-*.10.*)
+ 	    SHLIB_SUFFIX=".sl"
+ 	    AC_CHECK_LIB(dld, shl_load, tcl_ok=yes, tcl_ok=no)
+ 	    AS_IF([test "$tcl_ok" = yes], [
+ 		SHLIB_CFLAGS="+z"
+ 		SHLIB_LD="ld -b"
+ 		SHLIB_LD_LIBS=""
+ 		DL_OBJS="tclLoadShl.o"
+ 		DL_LIBS="-ldld"
+ 		LDFLAGS="$LDFLAGS -Wl,-E"
+ 		CC_SEARCH_FLAGS='-Wl,+s,+b,${LIB_RUNTIME_DIR}:.'
+ 		LD_SEARCH_FLAGS='+s +b ${LIB_RUNTIME_DIR}:.'
+ 		LD_LIBRARY_PATH_VAR="SHLIB_PATH"
+ 	    ]) ;;
+ 	IRIX-5.*)
+ 	    SHLIB_CFLAGS=""
+ 	    SHLIB_LD="ld -shared -rdata_shared"
+ 	    SHLIB_LD_LIBS='${LIBS}'
+ 	    SHLIB_SUFFIX=".so"
+ 	    DL_OBJS="tclLoadDl.o"
+ 	    DL_LIBS=""
+ 	    AS_IF([test $doRpath = yes], [
+ 		CC_SEARCH_FLAGS='-Wl,-rpath,${LIB_RUNTIME_DIR}'
+ 		LD_SEARCH_FLAGS='-rpath ${LIB_RUNTIME_DIR}'])
+ 	    ;;
+ 	IRIX-6.*)
+ 	    SHLIB_CFLAGS=""
+ 	    SHLIB_LD="ld -n32 -shared -rdata_shared"
+ 	    SHLIB_LD_LIBS='${LIBS}'
+ 	    SHLIB_SUFFIX=".so"
+ 	    DL_OBJS="tclLoadDl.o"
+ 	    DL_LIBS=""
+ 	    AS_IF([test $doRpath = yes], [
+ 		CC_SEARCH_FLAGS='-Wl,-rpath,${LIB_RUNTIME_DIR}'
+ 		LD_SEARCH_FLAGS='-rpath ${LIB_RUNTIME_DIR}'])
+ 	    AS_IF([test "$GCC" = yes], [
+ 		CFLAGS="$CFLAGS -mabi=n32"
+ 		LDFLAGS="$LDFLAGS -mabi=n32"
+ 	    ], [
+ 		case $system in
+ 		    IRIX-6.3)
+ 			# Use to build 6.2 compatible binaries on 6.3.
+ 			CFLAGS="$CFLAGS -n32 -D_OLD_TERMIOS"
+ 			;;
+ 		    *)
+ 			CFLAGS="$CFLAGS -n32"
+ 			;;
+ 		esac
+ 		LDFLAGS="$LDFLAGS -n32"
+ 	    ])
+ 	    ;;
+ 	IRIX64-6.*)
+ 	    SHLIB_CFLAGS=""
+ 	    SHLIB_LD="ld -n32 -shared -rdata_shared"
+ 	    SHLIB_LD_LIBS='${LIBS}'
+ 	    SHLIB_SUFFIX=".so"
+ 	    DL_OBJS="tclLoadDl.o"
+ 	    DL_LIBS=""
+ 	    AS_IF([test $doRpath = yes], [
+ 		CC_SEARCH_FLAGS='-Wl,-rpath,${LIB_RUNTIME_DIR}'
+ 		LD_SEARCH_FLAGS='-rpath ${LIB_RUNTIME_DIR}'])
+ 
+ 	    # Check to enable 64-bit flags for compiler/linker
+ 
+ 	    AS_IF([test "$do64bit" = yes], [
+ 	        AS_IF([test "$GCC" = yes], [
+ 	            AC_MSG_WARN([64bit mode not supported by gcc])
+ 	        ], [
+ 	            do64bit_ok=yes
+ 	            SHLIB_LD="ld -64 -shared -rdata_shared"
+ 	            CFLAGS="$CFLAGS -64"
+ 	            LDFLAGS_ARCH="-64"
+ 	        ])
+ 	    ])
+ 	    ;;
+ 	Linux*)
+ 	    SHLIB_CFLAGS="-fPIC"
+ 	    SHLIB_LD_LIBS='${LIBS}'
+ 	    SHLIB_SUFFIX=".so"
+ 
+ 	    # TEA specific:
+ 	    CFLAGS_OPTIMIZE="-O2 -fomit-frame-pointer"
+ 	    # egcs-2.91.66 on Redhat Linux 6.0 generates lots of warnings 
+ 	    # when you inline the string and math operations.  Turn this off to
+ 	    # get rid of the warnings.
+ 	    #CFLAGS_OPTIMIZE="${CFLAGS_OPTIMIZE} -D__NO_STRING_INLINES -D__NO_MATH_INLINES"
+ 
+ 	    # TEA specific: use LDFLAGS_DEFAULT instead of LDFLAGS
+ 	    SHLIB_LD='${CC} -shared ${CFLAGS} ${LDFLAGS_DEFAULT}'
+ 	    DL_OBJS="tclLoadDl.o"
+ 	    DL_LIBS="-ldl"
+ 	    LDFLAGS="$LDFLAGS -Wl,--export-dynamic"
+ 	    AS_IF([test $doRpath = yes], [
+ 		CC_SEARCH_FLAGS='-Wl,-rpath,${LIB_RUNTIME_DIR}'])
+ 	    LD_SEARCH_FLAGS=${CC_SEARCH_FLAGS}
+ 	    AS_IF([test "`uname -m`" = "alpha"], [CFLAGS="$CFLAGS -mieee"])
+ 	    AS_IF([test $do64bit = yes], [
+ 		AC_CACHE_CHECK([if compiler accepts -m64 flag], tcl_cv_cc_m64, [
+ 		    hold_cflags=$CFLAGS
+ 		    CFLAGS="$CFLAGS -m64"
+ 		    AC_TRY_LINK(,, tcl_cv_cc_m64=yes, tcl_cv_cc_m64=no)
+ 		    CFLAGS=$hold_cflags])
+ 		AS_IF([test $tcl_cv_cc_m64 = yes], [
+ 		    CFLAGS="$CFLAGS -m64"
+ 		    do64bit_ok=yes
+ 		])
+ 	   ])
+ 
+ 	    # The combo of gcc + glibc has a bug related to inlining of
+ 	    # functions like strtod(). The -fno-builtin flag should address
+ 	    # this problem but it does not work. The -fno-inline flag is kind
+ 	    # of overkill but it works. Disable inlining only when one of the
+ 	    # files in compat/*.c is being linked in.
+ 
+ 	    AS_IF([test x"${USE_COMPAT}" != x],[CFLAGS="$CFLAGS -fno-inline"])
+ 
+ 	    ;;
+ 	GNU*)
+ 	    SHLIB_CFLAGS="-fPIC"
+ 	    SHLIB_LD_LIBS='${LIBS}'
+ 	    SHLIB_SUFFIX=".so"
+ 
+ 	    SHLIB_LD='${CC} -shared'
+ 	    DL_OBJS=""
+ 	    DL_LIBS="-ldl"
+ 	    LDFLAGS="$LDFLAGS -Wl,--export-dynamic"
+ 	    CC_SEARCH_FLAGS=""
+ 	    LD_SEARCH_FLAGS=""
+ 	    AS_IF([test "`uname -m`" = "alpha"], [CFLAGS="$CFLAGS -mieee"])
+ 	    ;;
+ 	Lynx*)
+ 	    SHLIB_CFLAGS="-fPIC"
+ 	    SHLIB_LD_LIBS='${LIBS}'
+ 	    SHLIB_SUFFIX=".so"
+ 	    CFLAGS_OPTIMIZE=-02
+ 	    SHLIB_LD='${CC} -shared'
+ 	    DL_OBJS="tclLoadDl.o"
+ 	    DL_LIBS="-mshared -ldl"
+ 	    LD_FLAGS="-Wl,--export-dynamic"
+ 	    AS_IF([test $doRpath = yes], [
+ 		CC_SEARCH_FLAGS='-Wl,-rpath,${LIB_RUNTIME_DIR}'
+ 		LD_SEARCH_FLAGS='-Wl,-rpath,${LIB_RUNTIME_DIR}'])
+ 	    ;;
+ 	MP-RAS-02*)
+ 	    SHLIB_CFLAGS="-K PIC"
+ 	    SHLIB_LD='${CC} -G'
+ 	    SHLIB_LD_LIBS=""
+ 	    SHLIB_SUFFIX=".so"
+ 	    DL_OBJS="tclLoadDl.o"
+ 	    DL_LIBS="-ldl"
+ 	    CC_SEARCH_FLAGS=""
+ 	    LD_SEARCH_FLAGS=""
+ 	    ;;
+ 	MP-RAS-*)
+ 	    SHLIB_CFLAGS="-K PIC"
+ 	    SHLIB_LD='${CC} -G'
+ 	    SHLIB_LD_LIBS=""
+ 	    SHLIB_SUFFIX=".so"
+ 	    DL_OBJS="tclLoadDl.o"
+ 	    DL_LIBS="-ldl"
+ 	    LDFLAGS="$LDFLAGS -Wl,-Bexport"
+ 	    CC_SEARCH_FLAGS=""
+ 	    LD_SEARCH_FLAGS=""
+ 	    ;;
+ 	NetBSD-1.*|FreeBSD-[[1-2]].*)
+ 	    SHLIB_CFLAGS="-fPIC"
+ 	    SHLIB_LD="ld -Bshareable -x"
+ 	    SHLIB_LD_LIBS='${LIBS}'
+ 	    SHLIB_SUFFIX=".so"
+ 	    DL_OBJS="tclLoadDl.o"
+ 	    DL_LIBS=""
+ 	    AS_IF([test $doRpath = yes], [
+ 		CC_SEARCH_FLAGS='-Wl,-rpath,${LIB_RUNTIME_DIR}'
+ 		LD_SEARCH_FLAGS='-rpath ${LIB_RUNTIME_DIR}'])
+ 	    AC_CACHE_CHECK([for ELF], tcl_cv_ld_elf, [
+ 		AC_EGREP_CPP(yes, [
+ #ifdef __ELF__
+ 	yes
+ #endif
+ 		], tcl_cv_ld_elf=yes, tcl_cv_ld_elf=no)])
+ 	    AS_IF([test $tcl_cv_ld_elf = yes], [
+ 		SHARED_LIB_SUFFIX='${TCL_TRIM_DOTS}.so'
+ 	    ], [
+ 		SHARED_LIB_SUFFIX='${TCL_TRIM_DOTS}.so.1.0'
+ 	    ])
+ 
+ 	    # Ancient FreeBSD doesn't handle version numbers with dots.
+ 
+ 	    UNSHARED_LIB_SUFFIX='${TCL_TRIM_DOTS}.a'
+ 	    TCL_LIB_VERSIONS_OK=nodots
+ 	    ;;
+ 	OpenBSD-*)
+ 	    SHLIB_CFLAGS="-fPIC"
+ 	    SHLIB_LD='${CC} -shared ${SHLIB_CFLAGS}'
+ 	    SHLIB_LD_LIBS='${LIBS}'
+ 	    SHLIB_SUFFIX=".so"
+ 	    DL_OBJS="tclLoadDl.o"
+ 	    DL_LIBS=""
+ 	    AS_IF([test $doRpath = yes], [
+ 		CC_SEARCH_FLAGS='-Wl,-rpath,${LIB_RUNTIME_DIR}'])
+ 	    LD_SEARCH_FLAGS=${CC_SEARCH_FLAGS}
+ 	    SHARED_LIB_SUFFIX='${TCL_TRIM_DOTS}.so.1.0'
+ 	    AC_CACHE_CHECK([for ELF], tcl_cv_ld_elf, [
+ 		AC_EGREP_CPP(yes, [
+ #ifdef __ELF__
+ 	yes
+ #endif
+ 		], tcl_cv_ld_elf=yes, tcl_cv_ld_elf=no)])
+ 	    AS_IF([test $tcl_cv_ld_elf = yes], [
+ 		LDFLAGS=-Wl,-export-dynamic
+ 	    ], [LDFLAGS=""])
+ 
+ 	    # OpenBSD doesn't do version numbers with dots.
+ 	    UNSHARED_LIB_SUFFIX='${TCL_TRIM_DOTS}.a'
+ 	    TCL_LIB_VERSIONS_OK=nodots
+ 	    ;;
+ 	NetBSD-*|FreeBSD-*)
+ 	    # FreeBSD 3.* and greater have ELF.
+ 	    # NetBSD 2.* has ELF and can use 'cc -shared' to build shared libs
+ 	    SHLIB_CFLAGS="-fPIC"
+ 	    SHLIB_LD='${CC} -shared ${SHLIB_CFLAGS}'
+ 	    SHLIB_LD_LIBS='${LIBS}'
+ 	    SHLIB_SUFFIX=".so"
+ 	    DL_OBJS="tclLoadDl.o"
+ 	    DL_LIBS=""
+ 	    LDFLAGS="$LDFLAGS -export-dynamic"
+ 	    AS_IF([test $doRpath = yes], [
+ 		CC_SEARCH_FLAGS='-Wl,-rpath,${LIB_RUNTIME_DIR}'])
+ 	    LD_SEARCH_FLAGS=${CC_SEARCH_FLAGS}
+ 	    AS_IF([test "${TCL_THREADS}" = "1"], [
+ 		# The -pthread needs to go in the CFLAGS, not LIBS
+ 		LIBS=`echo $LIBS | sed s/-pthread//`
+ 		CFLAGS="$CFLAGS -pthread"
+ 	    	LDFLAGS="$LDFLAGS -pthread"
+ 	    ])
+ 	    case $system in
+ 	    FreeBSD-3.*)
+ 	    	# FreeBSD-3 doesn't handle version numbers with dots.
+ 	    	UNSHARED_LIB_SUFFIX='${TCL_TRIM_DOTS}.a'
+ 	    	SHARED_LIB_SUFFIX='${TCL_TRIM_DOTS}.so'
+ 	    	TCL_LIB_VERSIONS_OK=nodots
+ 		;;
+ 	    esac
+ 	    ;;
+ 	Darwin-*)
+ 	    CFLAGS_OPTIMIZE="-Os"
+ 	    SHLIB_CFLAGS="-fno-common"
+ 	    # To avoid discrepancies between what headers configure sees during
+ 	    # preprocessing tests and compiling tests, move any -isysroot and
+ 	    # -mmacosx-version-min flags from CFLAGS to CPPFLAGS:
+ 	    CPPFLAGS="${CPPFLAGS} `echo " ${CFLAGS}" | \
+ 		awk 'BEGIN {FS=" +-";ORS=" "}; {for (i=2;i<=NF;i++) \
+ 		if ([$]i~/^(isysroot|mmacosx-version-min)/) print "-"[$]i}'`"
+ 	    CFLAGS="`echo " ${CFLAGS}" | \
+ 		awk 'BEGIN {FS=" +-";ORS=" "}; {for (i=2;i<=NF;i++) \
+ 		if (!([$]i~/^(isysroot|mmacosx-version-min)/)) print "-"[$]i}'`"
+ 	    AS_IF([test $do64bit = yes], [
+ 		case `arch` in
+ 		    ppc)
+ 			AC_CACHE_CHECK([if compiler accepts -arch ppc64 flag],
+ 				tcl_cv_cc_arch_ppc64, [
+ 			    hold_cflags=$CFLAGS
+ 			    CFLAGS="$CFLAGS -arch ppc64 -mpowerpc64 -mcpu=G5"
+ 			    AC_TRY_LINK(,, tcl_cv_cc_arch_ppc64=yes,
+ 				    tcl_cv_cc_arch_ppc64=no)
+ 			    CFLAGS=$hold_cflags])
+ 			AS_IF([test $tcl_cv_cc_arch_ppc64 = yes], [
+ 			    CFLAGS="$CFLAGS -arch ppc64 -mpowerpc64 -mcpu=G5"
+ 			    do64bit_ok=yes
+ 			]);;
+ 		    i386)
+ 			AC_CACHE_CHECK([if compiler accepts -arch x86_64 flag],
+ 				tcl_cv_cc_arch_x86_64, [
+ 			    hold_cflags=$CFLAGS
+ 			    CFLAGS="$CFLAGS -arch x86_64"
+ 			    AC_TRY_LINK(,, tcl_cv_cc_arch_x86_64=yes,
+ 				    tcl_cv_cc_arch_x86_64=no)
+ 			    CFLAGS=$hold_cflags])
+ 			AS_IF([test $tcl_cv_cc_arch_x86_64 = yes], [
+ 			    CFLAGS="$CFLAGS -arch x86_64"
+ 			    do64bit_ok=yes
+ 			]);;
+ 		    *)
+ 			AC_MSG_WARN([Don't know how enable 64-bit on architecture `arch`]);;
+ 		esac
+ 	    ], [
+ 		# Check for combined 32-bit and 64-bit fat build
+ 		AS_IF([echo "$CFLAGS " |grep -E -q -- '-arch (ppc64|x86_64) ' \
+ 		    && echo "$CFLAGS " |grep -E -q -- '-arch (ppc|i386) '], [
+ 		    fat_32_64=yes])
+ 	    ])
+ 	    # TEA specific: use LDFLAGS_DEFAULT instead of LDFLAGS
+ 	    SHLIB_LD='${CC} -dynamiclib ${CFLAGS} ${LDFLAGS_DEFAULT}'
+ 	    AC_CACHE_CHECK([if ld accepts -single_module flag], tcl_cv_ld_single_module, [
+ 		hold_ldflags=$LDFLAGS
+ 		LDFLAGS="$LDFLAGS -dynamiclib -Wl,-single_module"
+ 		AC_TRY_LINK(, [int i;], tcl_cv_ld_single_module=yes, tcl_cv_ld_single_module=no)
+ 		LDFLAGS=$hold_ldflags])
+ 	    AS_IF([test $tcl_cv_ld_single_module = yes], [
+ 		SHLIB_LD="${SHLIB_LD} -Wl,-single_module"
+ 	    ])
+ 	    SHLIB_LD_LIBS='${LIBS}'
+ 	    SHLIB_SUFFIX=".dylib"
+ 	    DL_OBJS="tclLoadDyld.o"
+ 	    DL_LIBS=""
+ 	    # Don't use -prebind when building for Mac OS X 10.4 or later only:
+ 	    AS_IF([test "`echo "${MACOSX_DEPLOYMENT_TARGET}" | awk -F '10\\.' '{print int([$]2)}'`" -lt 4 -a \
+ 		"`echo "${CPPFLAGS}" | awk -F '-mmacosx-version-min=10\\.' '{print int([$]2)}'`" -lt 4], [
+ 		LDFLAGS="$LDFLAGS -prebind"])
+ 	    LDFLAGS="$LDFLAGS -headerpad_max_install_names"
+ 	    AC_CACHE_CHECK([if ld accepts -search_paths_first flag],
+ 		    tcl_cv_ld_search_paths_first, [
+ 		hold_ldflags=$LDFLAGS
+ 		LDFLAGS="$LDFLAGS -Wl,-search_paths_first"
+ 		AC_TRY_LINK(, [int i;], tcl_cv_ld_search_paths_first=yes,
+ 			tcl_cv_ld_search_paths_first=no)
+ 		LDFLAGS=$hold_ldflags])
+ 	    AS_IF([test $tcl_cv_ld_search_paths_first = yes], [
+ 		LDFLAGS="$LDFLAGS -Wl,-search_paths_first"
+ 	    ])
+ 	    AS_IF([test "$tcl_cv_cc_visibility_hidden" != yes], [
+ 		AC_DEFINE(MODULE_SCOPE, [__private_extern__],
+ 		    [Compiler support for module scope symbols])
+ 	    ])
+ 	    CC_SEARCH_FLAGS=""
+ 	    LD_SEARCH_FLAGS=""
+ 	    LD_LIBRARY_PATH_VAR="DYLD_LIBRARY_PATH"
+ 	    # TEA specific: for combined 32 & 64 bit fat builds of Tk
+ 	    # extensions, verify that 64-bit build is possible.
+ 	    AS_IF([test "$fat_32_64" = yes && test -n "${TK_BIN_DIR}"], [
+ 		AS_IF([test "${TEA_WINDOWINGSYSTEM}" = x11], [
+ 		    AC_CACHE_CHECK([for 64-bit X11], tcl_cv_lib_x11_64, [
+ 			for v in CFLAGS CPPFLAGS LDFLAGS; do
+ 			    eval 'hold_'$v'="$'$v'";'$v'="`echo "$'$v' "|sed -e "s/-arch ppc / /g" -e "s/-arch i386 / /g"`"'
+ 			done
+ 			CPPFLAGS="$CPPFLAGS -I/usr/X11R6/include"
+ 			LDFLAGS="$LDFLAGS -L/usr/X11R6/lib -lX11"
+ 			AC_TRY_LINK([#include <X11/Xlib.h>], [XrmInitialize();],
+ 			    tcl_cv_lib_x11_64=yes, tcl_cv_lib_x11_64=no)
+ 			for v in CFLAGS CPPFLAGS LDFLAGS; do
+ 			    eval $v'="$hold_'$v'"'
+ 			done])
+ 		])
+ 		# remove 64-bit arch flags from CFLAGS et al. if configuration
+ 		# does not support 64-bit.
+ 		AS_IF([test "${TEA_WINDOWINGSYSTEM}" = aqua -o "$tcl_cv_lib_x11_64" = no], [
+ 		    AC_MSG_NOTICE([Removing 64-bit architectures from compiler & linker flags])
+ 		    for v in CFLAGS CPPFLAGS LDFLAGS; do
+ 			eval $v'="`echo "$'$v' "|sed -e "s/-arch ppc64 / /g" -e "s/-arch x86_64 / /g"`"'
+ 		    done])
+ 	    ])
+ 	    ;;
+ 	NEXTSTEP-*)
+ 	    SHLIB_CFLAGS=""
+ 	    SHLIB_LD='${CC} -nostdlib -r'
+ 	    SHLIB_LD_LIBS=""
+ 	    SHLIB_SUFFIX=".so"
+ 	    DL_OBJS="tclLoadNext.o"
+ 	    DL_LIBS=""
+ 	    CC_SEARCH_FLAGS=""
+ 	    LD_SEARCH_FLAGS=""
+ 	    ;;
+ 	OS/390-*)
+ 	    CFLAGS_OPTIMIZE=""		# Optimizer is buggy
+ 	    AC_DEFINE(_OE_SOCKETS, 1,	# needed in sys/socket.h
+ 		[Should OS/390 do the right thing with sockets?])
+ 	    ;;      
+ 	OSF1-1.0|OSF1-1.1|OSF1-1.2)
+ 	    # OSF/1 1.[012] from OSF, and derivatives, including Paragon OSF/1
+ 	    SHLIB_CFLAGS=""
+ 	    # Hack: make package name same as library name
+ 	    SHLIB_LD='ld -R -export $@:'
+ 	    SHLIB_LD_LIBS=""
+ 	    SHLIB_SUFFIX=".so"
+ 	    DL_OBJS="tclLoadOSF.o"
+ 	    DL_LIBS=""
+ 	    CC_SEARCH_FLAGS=""
+ 	    LD_SEARCH_FLAGS=""
+ 	    ;;
+ 	OSF1-1.*)
+ 	    # OSF/1 1.3 from OSF using ELF, and derivatives, including AD2
+ 	    SHLIB_CFLAGS="-fPIC"
+ 	    AS_IF([test "$SHARED_BUILD" = 1], [SHLIB_LD="ld -shared"], [
+ 	        SHLIB_LD="ld -non_shared"
+ 	    ])
+ 	    SHLIB_LD_LIBS=""
+ 	    SHLIB_SUFFIX=".so"
+ 	    DL_OBJS="tclLoadDl.o"
+ 	    DL_LIBS=""
+ 	    CC_SEARCH_FLAGS=""
+ 	    LD_SEARCH_FLAGS=""
+ 	    ;;
+ 	OSF1-V*)
+ 	    # Digital OSF/1
+ 	    SHLIB_CFLAGS=""
+ 	    AS_IF([test "$SHARED_BUILD" = 1], [
+ 	        SHLIB_LD='ld -shared -expect_unresolved "*"'
+ 	    ], [
+ 	        SHLIB_LD='ld -non_shared -expect_unresolved "*"'
+ 	    ])
+ 	    SHLIB_LD_LIBS=""
+ 	    SHLIB_SUFFIX=".so"
+ 	    DL_OBJS="tclLoadDl.o"
+ 	    DL_LIBS=""
+ 	    AS_IF([test $doRpath = yes], [
+ 		CC_SEARCH_FLAGS='-Wl,-rpath,${LIB_RUNTIME_DIR}'
+ 		LD_SEARCH_FLAGS='-rpath ${LIB_RUNTIME_DIR}'])
+ 	    AS_IF([test "$GCC" = yes], [CFLAGS="$CFLAGS -mieee"], [
+ 		CFLAGS="$CFLAGS -DHAVE_TZSET -std1 -ieee"])
+ 	    # see pthread_intro(3) for pthread support on osf1, k.furukawa
+ 	    AS_IF([test "${TCL_THREADS}" = 1], [
+ 		CFLAGS="$CFLAGS -DHAVE_PTHREAD_ATTR_SETSTACKSIZE"
+ 		CFLAGS="$CFLAGS -DTCL_THREAD_STACK_MIN=PTHREAD_STACK_MIN*64"
+ 		LIBS=`echo $LIBS | sed s/-lpthreads//`
+ 		AS_IF([test "$GCC" = yes], [
+ 		    LIBS="$LIBS -lpthread -lmach -lexc"
+ 		], [
+ 		    CFLAGS="$CFLAGS -pthread"
+ 		    LDFLAGS="$LDFLAGS -pthread"
+ 		])
+ 	    ])
+ 	    ;;
+ 	QNX-6*)
+ 	    # QNX RTP
+ 	    # This may work for all QNX, but it was only reported for v6.
+ 	    SHLIB_CFLAGS="-fPIC"
+ 	    SHLIB_LD="ld -Bshareable -x"
+ 	    SHLIB_LD_LIBS=""
+ 	    SHLIB_SUFFIX=".so"
+ 	    DL_OBJS="tclLoadDl.o"
+ 	    # dlopen is in -lc on QNX
+ 	    DL_LIBS=""
+ 	    CC_SEARCH_FLAGS=""
+ 	    LD_SEARCH_FLAGS=""
+ 	    ;;
+ 	SCO_SV-3.2*)
+ 	    # Note, dlopen is available only on SCO 3.2.5 and greater. However,
+ 	    # this test works, since "uname -s" was non-standard in 3.2.4 and
+ 	    # below.
+ 	    AS_IF([test "$GCC" = yes], [
+ 	    	SHLIB_CFLAGS="-fPIC -melf"
+ 	    	LDFLAGS="$LDFLAGS -melf -Wl,-Bexport"
+ 	    ], [
+ 	    	SHLIB_CFLAGS="-Kpic -belf"
+ 	    	LDFLAGS="$LDFLAGS -belf -Wl,-Bexport"
+ 	    ])
+ 	    SHLIB_LD="ld -G"
+ 	    SHLIB_LD_LIBS=""
+ 	    SHLIB_SUFFIX=".so"
+ 	    DL_OBJS="tclLoadDl.o"
+ 	    DL_LIBS=""
+ 	    CC_SEARCH_FLAGS=""
+ 	    LD_SEARCH_FLAGS=""
+ 	    ;;
+ 	SINIX*5.4*)
+ 	    SHLIB_CFLAGS="-K PIC"
+ 	    SHLIB_LD='${CC} -G'
+ 	    SHLIB_LD_LIBS=""
+ 	    SHLIB_SUFFIX=".so"
+ 	    DL_OBJS="tclLoadDl.o"
+ 	    DL_LIBS="-ldl"
+ 	    CC_SEARCH_FLAGS=""
+ 	    LD_SEARCH_FLAGS=""
+ 	    ;;
+ 	SunOS-4*)
+ 	    SHLIB_CFLAGS="-PIC"
+ 	    SHLIB_LD="ld"
+ 	    SHLIB_LD_LIBS=""
+ 	    SHLIB_SUFFIX=".so"
+ 	    DL_OBJS="tclLoadDl.o"
+ 	    DL_LIBS="-ldl"
+ 	    CC_SEARCH_FLAGS='-L${LIB_RUNTIME_DIR}'
+ 	    LD_SEARCH_FLAGS=${CC_SEARCH_FLAGS}
+ 
+ 	    # SunOS can't handle version numbers with dots in them in library
+ 	    # specs, like -ltcl7.5, so use -ltcl75 instead.  Also, it
+ 	    # requires an extra version number at the end of .so file names.
+ 	    # So, the library has to have a name like libtcl75.so.1.0
+ 
+ 	    SHARED_LIB_SUFFIX='${TCL_TRIM_DOTS}.so.1.0'
+ 	    UNSHARED_LIB_SUFFIX='${TCL_TRIM_DOTS}.a'
+ 	    TCL_LIB_VERSIONS_OK=nodots
+ 	    ;;
+ 	SunOS-5.[[0-6]])
+ 	    # Careful to not let 5.10+ fall into this case
+ 
+ 	    # Note: If _REENTRANT isn't defined, then Solaris
+ 	    # won't define thread-safe library routines.
+ 
+ 	    AC_DEFINE(_REENTRANT, 1, [Do we want the reentrant OS API?])
+ 	    AC_DEFINE(_POSIX_PTHREAD_SEMANTICS, 1,
+ 		[Do we really want to follow the standard? Yes we do!])
+ 
+ 	    SHLIB_CFLAGS="-KPIC"
+ 
+ 	    # Note: need the LIBS below, otherwise Tk won't find Tcl's
+ 	    # symbols when dynamically loaded into tclsh.
+ 
+ 	    SHLIB_LD_LIBS='${LIBS}'
+ 	    SHLIB_SUFFIX=".so"
+ 	    DL_OBJS="tclLoadDl.o"
+ 	    DL_LIBS="-ldl"
+ 	    AS_IF([test "$GCC" = yes], [
+ 		SHLIB_LD='${CC} -shared'
+ 		CC_SEARCH_FLAGS='-Wl,-R,${LIB_RUNTIME_DIR}'
+ 		LD_SEARCH_FLAGS=${CC_SEARCH_FLAGS}
+ 	    ], [
+ 		SHLIB_LD="/usr/ccs/bin/ld -G -z text"
+ 		CC_SEARCH_FLAGS='-R ${LIB_RUNTIME_DIR}'
+ 		LD_SEARCH_FLAGS=${CC_SEARCH_FLAGS}
+ 	    ])
+ 	    ;;
+ 	SunOS-5*)
+ 	    # Note: If _REENTRANT isn't defined, then Solaris
+ 	    # won't define thread-safe library routines.
+ 
+ 	    AC_DEFINE(_REENTRANT, 1, [Do we want the reentrant OS API?])
+ 	    AC_DEFINE(_POSIX_PTHREAD_SEMANTICS, 1,
+ 		[Do we really want to follow the standard? Yes we do!])
+ 
+ 	    SHLIB_CFLAGS="-KPIC"
+ 
+ 	    # Check to enable 64-bit flags for compiler/linker
+ 	    AS_IF([test "$do64bit" = yes], [
+ 		arch=`isainfo`
+ 		AS_IF([test "$arch" = "sparcv9 sparc"], [
+ 		    AS_IF([test "$GCC" = yes], [
+ 			AS_IF([test "`${CC} -dumpversion | awk -F. '{print [$]1}'`" -lt 3], [
+ 			    AC_MSG_WARN([64bit mode not supported with GCC < 3.2 on $system])
+ 			], [
+ 			    do64bit_ok=yes
+ 			    CFLAGS="$CFLAGS -m64 -mcpu=v9"
+ 			    LDFLAGS="$LDFLAGS -m64 -mcpu=v9"
+ 			    SHLIB_CFLAGS="-fPIC"
+ 			])
+ 		    ], [
+ 			do64bit_ok=yes
+ 			AS_IF([test "$do64bitVIS" = yes], [
+ 			    CFLAGS="$CFLAGS -xarch=v9a"
+ 			    LDFLAGS_ARCH="-xarch=v9a"
+ 			], [
+ 			    CFLAGS="$CFLAGS -xarch=v9"
+ 			    LDFLAGS_ARCH="-xarch=v9"
+ 			])
+ 			# Solaris 64 uses this as well
+ 			#LD_LIBRARY_PATH_VAR="LD_LIBRARY_PATH_64"
+ 		    ])
+ 		], [AS_IF([test "$arch" = "amd64 i386"], [
+ 		    AS_IF([test "$GCC" = yes], [
+ 			AC_MSG_WARN([64bit mode not supported with GCC on $system])
+ 		    ], [
+ 			do64bit_ok=yes
+ 			CFLAGS="$CFLAGS -xarch=amd64"
+ 			LDFLAGS="$LDFLAGS -xarch=amd64"
+ 		    ])
+ 		], [AC_MSG_WARN([64bit mode not supported for $arch])])])
+ 	    ])
+ 	    
+ 	    # Note: need the LIBS below, otherwise Tk won't find Tcl's
+ 	    # symbols when dynamically loaded into tclsh.
+ 
+ 	    SHLIB_LD_LIBS='${LIBS}'
+ 	    SHLIB_SUFFIX=".so"
+ 	    DL_OBJS="tclLoadDl.o"
+ 	    DL_LIBS="-ldl"
+ 	    AS_IF([test "$GCC" = yes], [
+ 		SHLIB_LD='${CC} -shared'
+ 		CC_SEARCH_FLAGS='-Wl,-R,${LIB_RUNTIME_DIR}'
+ 		LD_SEARCH_FLAGS=${CC_SEARCH_FLAGS}
+ 		AS_IF([test "$do64bit_ok" = yes], [
+ 		    # We need to specify -static-libgcc or we need to
+ 		    # add the path to the sparv9 libgcc.
+ 		    # JH: static-libgcc is necessary for core Tcl, but may
+ 		    # not be necessary for extensions.
+ 		    SHLIB_LD="$SHLIB_LD -m64 -mcpu=v9 -static-libgcc"
+ 		    # for finding sparcv9 libgcc, get the regular libgcc
+ 		    # path, remove so name and append 'sparcv9'
+ 		    #v9gcclibdir="`gcc -print-file-name=libgcc_s.so` | ..."
+ 		    #CC_SEARCH_FLAGS="${CC_SEARCH_FLAGS},-R,$v9gcclibdir"
+ 		])
+ 	    ], [
+ 		case $system in
+ 		    SunOS-5.[[1-9]][[0-9]]*)
+ 			SHLIB_LD='${CC} -G -z text';;
+ 		    *)
+ 			SHLIB_LD='/usr/ccs/bin/ld -G -z text';;
+ 		esac
+ 		CC_SEARCH_FLAGS='-Wl,-R,${LIB_RUNTIME_DIR}'
+ 		LD_SEARCH_FLAGS='-R ${LIB_RUNTIME_DIR}'
+ 	    ])
+ 	    ;;
+ 	UNIX_SV* | UnixWare-5*)
+ 	    SHLIB_CFLAGS="-KPIC"
+ 	    SHLIB_LD='${CC} -G'
+ 	    SHLIB_LD_LIBS=""
+ 	    SHLIB_SUFFIX=".so"
+ 	    DL_OBJS="tclLoadDl.o"
+ 	    DL_LIBS="-ldl"
+ 	    # Some UNIX_SV* systems (unixware 1.1.2 for example) have linkers
+ 	    # that don't grok the -Bexport option.  Test that it does.
+ 	    AC_CACHE_CHECK([for ld accepts -Bexport flag], tcl_cv_ld_Bexport, [
+ 		hold_ldflags=$LDFLAGS
+ 		LDFLAGS="$LDFLAGS -Wl,-Bexport"
+ 		AC_TRY_LINK(, [int i;], tcl_cv_ld_Bexport=yes, tcl_cv_ld_Bexport=no)
+ 	        LDFLAGS=$hold_ldflags])
+ 	    AS_IF([test $tcl_cv_ld_Bexport = yes], [
+ 		LDFLAGS="$LDFLAGS -Wl,-Bexport"
+ 	    ])
+ 	    CC_SEARCH_FLAGS=""
+ 	    LD_SEARCH_FLAGS=""
+ 	    ;;
+     esac
+ 
+     AS_IF([test "$do64bit" = yes -a "$do64bit_ok" = no], [
+ 	AC_MSG_WARN([64bit support being disabled -- don't know magic for this platform])
+     ])
+ 
+ dnl # Add any CPPFLAGS set in the environment to our CFLAGS, but delay doing so
+ dnl # until the end of configure, as configure's compile and link tests use
+ dnl # both CPPFLAGS and CFLAGS (unlike our compile and link) but configure's
+ dnl # preprocessing tests use only CPPFLAGS.
+     AC_CONFIG_COMMANDS_PRE([CFLAGS="${CFLAGS} ${CPPFLAGS}"; CPPFLAGS=""])
+ 
+     # Step 4: disable dynamic loading if requested via a command-line switch.
+ 
+     AC_ARG_ENABLE(load,
+ 	AC_HELP_STRING([--enable-load],
+ 	    [allow dynamic loading and "load" command (default: on)]),
+ 	[tcl_ok=$enableval], [tcl_ok=yes])
+     AS_IF([test "$tcl_ok" = no], [DL_OBJS=""])
+ 
+     AS_IF([test "x$DL_OBJS" != x], [BUILD_DLTEST="\$(DLTEST_TARGETS)"], [
+ 	AC_MSG_WARN([Can't figure out how to do dynamic loading or shared libraries on this system.])
+ 	SHLIB_CFLAGS=""
+ 	SHLIB_LD=""
+ 	SHLIB_SUFFIX=""
+ 	DL_OBJS="tclLoadNone.o"
+ 	DL_LIBS=""
+ 	LDFLAGS="$LDFLAGS_ORIG"
+ 	CC_SEARCH_FLAGS=""
+ 	LD_SEARCH_FLAGS=""
+ 	BUILD_DLTEST=""
+     ])
+     LDFLAGS="$LDFLAGS $LDFLAGS_ARCH"
+ 
+     # If we're running gcc, then change the C flags for compiling shared
+     # libraries to the right flags for gcc, instead of those for the
+     # standard manufacturer compiler.
+ 
+     AS_IF([test "$DL_OBJS" != "tclLoadNone.o" -a "$GCC" = yes], [
+ 	case $system in
+ 	    AIX-*) ;;
+ 	    BSD/OS*) ;;
+ 	    IRIX*) ;;
+ 	    NetBSD-*|FreeBSD-*) ;;
+ 	    Darwin-*) ;;
+ 	    SCO_SV-3.2*) ;;
+ 	    *) SHLIB_CFLAGS="-fPIC" ;;
+ 	esac])
+ 
+     AS_IF([test "$SHARED_LIB_SUFFIX" = ""], [
+ 	# TEA specific: use PACKAGE_VERSION instead of VERSION
+ 	SHARED_LIB_SUFFIX='${PACKAGE_VERSION}${SHLIB_SUFFIX}'])
+     AS_IF([test "$UNSHARED_LIB_SUFFIX" = ""], [
+ 	# TEA specific: use PACKAGE_VERSION instead of VERSION
+ 	UNSHARED_LIB_SUFFIX='${PACKAGE_VERSION}.a'])
+ 
+     AC_SUBST(DL_LIBS)
+ 
+     AC_SUBST(CFLAGS_DEBUG)
+     AC_SUBST(CFLAGS_OPTIMIZE)
+     AC_SUBST(CFLAGS_WARNING)
+ 
+     AC_SUBST(STLIB_LD)
+     AC_SUBST(SHLIB_LD)
+ 
+     AC_SUBST(SHLIB_LD_LIBS)
+     AC_SUBST(SHLIB_CFLAGS)
+ 
+     AC_SUBST(LD_LIBRARY_PATH_VAR)
+ 
+     # These must be called after we do the basic CFLAGS checks and
+     # verify any possible 64-bit or similar switches are necessary
+     TEA_TCL_EARLY_FLAGS
+     TEA_TCL_64BIT_FLAGS
+ ])
+ 
+ #--------------------------------------------------------------------
+ # TEA_SERIAL_PORT
+ #
+ #	Determine which interface to use to talk to the serial port.
+ #	Note that #include lines must begin in leftmost column for
+ #	some compilers to recognize them as preprocessor directives,
+ #	and some build environments have stdin not pointing at a
+ #	pseudo-terminal (usually /dev/null instead.)
+ #
+ # Arguments:
+ #	none
+ #	
+ # Results:
+ #
+ #	Defines only one of the following vars:
+ #		HAVE_SYS_MODEM_H
+ #		USE_TERMIOS
+ #		USE_TERMIO
+ #		USE_SGTTY
+ #
+ #--------------------------------------------------------------------
+ 
+ AC_DEFUN([TEA_SERIAL_PORT], [
+     AC_CHECK_HEADERS(sys/modem.h)
+     AC_CACHE_CHECK([termios vs. termio vs. sgtty], tcl_cv_api_serial, [
+     AC_TRY_RUN([
+ #include <termios.h>
+ 
+ int main() {
+     struct termios t;
+     if (tcgetattr(0, &t) == 0) {
+ 	cfsetospeed(&t, 0);
+ 	t.c_cflag |= PARENB | PARODD | CSIZE | CSTOPB;
+ 	return 0;
+     }
+     return 1;
+ }], tcl_cv_api_serial=termios, tcl_cv_api_serial=no, tcl_cv_api_serial=no)
+     if test $tcl_cv_api_serial = no ; then
+ 	AC_TRY_RUN([
+ #include <termio.h>
+ 
+ int main() {
+     struct termio t;
+     if (ioctl(0, TCGETA, &t) == 0) {
+ 	t.c_cflag |= CBAUD | PARENB | PARODD | CSIZE | CSTOPB;
+ 	return 0;
+     }
+     return 1;
+ }], tcl_cv_api_serial=termio, tcl_cv_api_serial=no, tcl_cv_api_serial=no)
+     fi
+     if test $tcl_cv_api_serial = no ; then
+ 	AC_TRY_RUN([
+ #include <sgtty.h>
+ 
+ int main() {
+     struct sgttyb t;
+     if (ioctl(0, TIOCGETP, &t) == 0) {
+ 	t.sg_ospeed = 0;
+ 	t.sg_flags |= ODDP | EVENP | RAW;
+ 	return 0;
+     }
+     return 1;
+ }], tcl_cv_api_serial=sgtty, tcl_cv_api_serial=no, tcl_cv_api_serial=no)
+     fi
+     if test $tcl_cv_api_serial = no ; then
+ 	AC_TRY_RUN([
+ #include <termios.h>
+ #include <errno.h>
+ 
+ int main() {
+     struct termios t;
+     if (tcgetattr(0, &t) == 0
+ 	|| errno == ENOTTY || errno == ENXIO || errno == EINVAL) {
+ 	cfsetospeed(&t, 0);
+ 	t.c_cflag |= PARENB | PARODD | CSIZE | CSTOPB;
+ 	return 0;
+     }
+     return 1;
+ }], tcl_cv_api_serial=termios, tcl_cv_api_serial=no, tcl_cv_api_serial=no)
+     fi
+     if test $tcl_cv_api_serial = no; then
+ 	AC_TRY_RUN([
+ #include <termio.h>
+ #include <errno.h>
+ 
+ int main() {
+     struct termio t;
+     if (ioctl(0, TCGETA, &t) == 0
+ 	|| errno == ENOTTY || errno == ENXIO || errno == EINVAL) {
+ 	t.c_cflag |= CBAUD | PARENB | PARODD | CSIZE | CSTOPB;
+ 	return 0;
+     }
+     return 1;
+     }], tcl_cv_api_serial=termio, tcl_cv_api_serial=no, tcl_cv_api_serial=no)
+     fi
+     if test $tcl_cv_api_serial = no; then
+ 	AC_TRY_RUN([
+ #include <sgtty.h>
+ #include <errno.h>
+ 
+ int main() {
+     struct sgttyb t;
+     if (ioctl(0, TIOCGETP, &t) == 0
+ 	|| errno == ENOTTY || errno == ENXIO || errno == EINVAL) {
+ 	t.sg_ospeed = 0;
+ 	t.sg_flags |= ODDP | EVENP | RAW;
+ 	return 0;
+     }
+     return 1;
+ }], tcl_cv_api_serial=sgtty, tcl_cv_api_serial=none, tcl_cv_api_serial=none)
+     fi])
+     case $tcl_cv_api_serial in
+ 	termios) AC_DEFINE(USE_TERMIOS, 1, [Use the termios API for serial lines]);;
+ 	termio)  AC_DEFINE(USE_TERMIO, 1, [Use the termio API for serial lines]);;
+ 	sgtty)   AC_DEFINE(USE_SGTTY, 1, [Use the sgtty API for serial lines]);;
+     esac
+ ])
+ 
+ #--------------------------------------------------------------------
+ # TEA_MISSING_POSIX_HEADERS
+ #
+ #	Supply substitutes for missing POSIX header files.  Special
+ #	notes:
+ #	    - stdlib.h doesn't define strtol, strtoul, or
+ #	      strtod insome versions of SunOS
+ #	    - some versions of string.h don't declare procedures such
+ #	      as strstr
+ #
+ # Arguments:
+ #	none
+ #	
+ # Results:
+ #
+ #	Defines some of the following vars:
+ #		NO_DIRENT_H
+ #		NO_ERRNO_H
+ #		NO_VALUES_H
+ #		HAVE_LIMITS_H or NO_LIMITS_H
+ #		NO_STDLIB_H
+ #		NO_STRING_H
+ #		NO_SYS_WAIT_H
+ #		NO_DLFCN_H
+ #		HAVE_SYS_PARAM_H
+ #
+ #		HAVE_STRING_H ?
+ #
+ # tkUnixPort.h checks for HAVE_LIMITS_H, so do both HAVE and
+ # CHECK on limits.h
+ #--------------------------------------------------------------------
+ 
+ AC_DEFUN([TEA_MISSING_POSIX_HEADERS], [
+     AC_CACHE_CHECK([dirent.h], tcl_cv_dirent_h, [
+     AC_TRY_LINK([#include <sys/types.h>
+ #include <dirent.h>], [
+ #ifndef _POSIX_SOURCE
+ #   ifdef __Lynx__
+ 	/*
+ 	 * Generate compilation error to make the test fail:  Lynx headers
+ 	 * are only valid if really in the POSIX environment.
+ 	 */
+ 
+ 	missing_procedure();
+ #   endif
+ #endif
+ DIR *d;
+ struct dirent *entryPtr;
+ char *p;
+ d = opendir("foobar");
+ entryPtr = readdir(d);
+ p = entryPtr->d_name;
+ closedir(d);
+ ], tcl_cv_dirent_h=yes, tcl_cv_dirent_h=no)])
+ 
+     if test $tcl_cv_dirent_h = no; then
+ 	AC_DEFINE(NO_DIRENT_H, 1, [Do we have <dirent.h>?])
+     fi
+ 
+     # TEA specific:
+     AC_CHECK_HEADER(errno.h, , [AC_DEFINE(NO_ERRNO_H, 1, [Do we have <errno.h>?])])
+     AC_CHECK_HEADER(float.h, , [AC_DEFINE(NO_FLOAT_H, 1, [Do we have <float.h>?])])
+     AC_CHECK_HEADER(values.h, , [AC_DEFINE(NO_VALUES_H, 1, [Do we have <values.h>?])])
+     AC_CHECK_HEADER(limits.h,
+ 	[AC_DEFINE(HAVE_LIMITS_H, 1, [Do we have <limits.h>?])],
+ 	[AC_DEFINE(NO_LIMITS_H, 1, [Do we have <limits.h>?])])
+     AC_CHECK_HEADER(stdlib.h, tcl_ok=1, tcl_ok=0)
+     AC_EGREP_HEADER(strtol, stdlib.h, , tcl_ok=0)
+     AC_EGREP_HEADER(strtoul, stdlib.h, , tcl_ok=0)
+     AC_EGREP_HEADER(strtod, stdlib.h, , tcl_ok=0)
+     if test $tcl_ok = 0; then
+ 	AC_DEFINE(NO_STDLIB_H, 1, [Do we have <stdlib.h>?])
+     fi
+     AC_CHECK_HEADER(string.h, tcl_ok=1, tcl_ok=0)
+     AC_EGREP_HEADER(strstr, string.h, , tcl_ok=0)
+     AC_EGREP_HEADER(strerror, string.h, , tcl_ok=0)
+ 
+     # See also memmove check below for a place where NO_STRING_H can be
+     # set and why.
+ 
+     if test $tcl_ok = 0; then
+ 	AC_DEFINE(NO_STRING_H, 1, [Do we have <string.h>?])
+     fi
+ 
+     AC_CHECK_HEADER(sys/wait.h, , [AC_DEFINE(NO_SYS_WAIT_H, 1, [Do we have <sys/wait.h>?])])
+     AC_CHECK_HEADER(dlfcn.h, , [AC_DEFINE(NO_DLFCN_H, 1, [Do we have <dlfcn.h>?])])
+ 
+     # OS/390 lacks sys/param.h (and doesn't need it, by chance).
+     AC_HAVE_HEADERS(sys/param.h)
+ ])
+ 
+ #--------------------------------------------------------------------
+ # TEA_PATH_X
+ #
+ #	Locate the X11 header files and the X11 library archive.  Try
+ #	the ac_path_x macro first, but if it doesn't find the X stuff
+ #	(e.g. because there's no xmkmf program) then check through
+ #	a list of possible directories.  Under some conditions the
+ #	autoconf macro will return an include directory that contains
+ #	no include files, so double-check its result just to be safe.
+ #
+ #	This should be called after TEA_CONFIG_CFLAGS as setting the
+ #	LIBS line can confuse some configure macro magic.
+ #
+ # Arguments:
+ #	none
+ #	
+ # Results:
+ #
+ #	Sets the following vars:
+ #		XINCLUDES
+ #		XLIBSW
+ #		PKG_LIBS (appends to)
+ #
+ #--------------------------------------------------------------------
+ 
+ AC_DEFUN([TEA_PATH_X], [
+     if test "${TEA_WINDOWINGSYSTEM}" = "x11" ; then
+ 	TEA_PATH_UNIX_X
+     fi
+ ])
+ 
+ AC_DEFUN([TEA_PATH_UNIX_X], [
+     AC_PATH_X
+     not_really_there=""
+     if test "$no_x" = ""; then
+ 	if test "$x_includes" = ""; then
+ 	    AC_TRY_CPP([#include <X11/XIntrinsic.h>], , not_really_there="yes")
+ 	else
+ 	    if test ! -r $x_includes/X11/Intrinsic.h; then
+ 		not_really_there="yes"
+ 	    fi
+ 	fi
+     fi
+     if test "$no_x" = "yes" -o "$not_really_there" = "yes"; then
+ 	AC_MSG_CHECKING([for X11 header files])
+ 	found_xincludes="no"
+ 	AC_TRY_CPP([#include <X11/Intrinsic.h>], found_xincludes="yes", found_xincludes="no")
+ 	if test "$found_xincludes" = "no"; then
+ 	    dirs="/usr/unsupported/include /usr/local/include /usr/X386/include /usr/X11R6/include /usr/X11R5/include /usr/include/X11R5 /usr/include/X11R4 /usr/openwin/include /usr/X11/include /usr/sww/include"
+ 	    for i in $dirs ; do
+ 		if test -r $i/X11/Intrinsic.h; then
+ 		    AC_MSG_RESULT([$i])
+ 		    XINCLUDES=" -I$i"
+ 		    found_xincludes="yes"
+ 		    break
+ 		fi
+ 	    done
+ 	fi
+     else
+ 	if test "$x_includes" != ""; then
+ 	    XINCLUDES="-I$x_includes"
+ 	    found_xincludes="yes"
+ 	fi
+     fi
+     if test found_xincludes = "no"; then
+ 	AC_MSG_RESULT([couldn't find any!])
+     fi
+ 
+     if test "$no_x" = yes; then
+ 	AC_MSG_CHECKING([for X11 libraries])
+ 	XLIBSW=nope
+ 	dirs="/usr/unsupported/lib /usr/local/lib /usr/X386/lib /usr/X11R6/lib /usr/X11R5/lib /usr/lib/X11R5 /usr/lib/X11R4 /usr/openwin/lib /usr/X11/lib /usr/sww/X11/lib"
+ 	for i in $dirs ; do
+ 	    if test -r $i/libX11.a -o -r $i/libX11.so -o -r $i/libX11.sl; then
+ 		AC_MSG_RESULT([$i])
+ 		XLIBSW="-L$i -lX11"
+ 		x_libraries="$i"
+ 		break
+ 	    fi
+ 	done
+     else
+ 	if test "$x_libraries" = ""; then
+ 	    XLIBSW=-lX11
+ 	else
+ 	    XLIBSW="-L$x_libraries -lX11"
+ 	fi
+     fi
+     if test "$XLIBSW" = nope ; then
+ 	AC_CHECK_LIB(Xwindow, XCreateWindow, XLIBSW=-lXwindow)
+     fi
+     if test "$XLIBSW" = nope ; then
+ 	AC_MSG_RESULT([could not find any!  Using -lX11.])
+ 	XLIBSW=-lX11
+     fi
+     # TEA specific:
+     if test x"${XLIBSW}" != x ; then
+ 	PKG_LIBS="${PKG_LIBS} ${XLIBSW}"
+     fi
+ ])
+ 
+ #--------------------------------------------------------------------
+ # TEA_BLOCKING_STYLE
+ #
+ #	The statements below check for systems where POSIX-style
+ #	non-blocking I/O (O_NONBLOCK) doesn't work or is unimplemented. 
+ #	On these systems (mostly older ones), use the old BSD-style
+ #	FIONBIO approach instead.
+ #
+ # Arguments:
+ #	none
+ #	
+ # Results:
+ #
+ #	Defines some of the following vars:
+ #		HAVE_SYS_IOCTL_H
+ #		HAVE_SYS_FILIO_H
+ #		USE_FIONBIO
+ #		O_NONBLOCK
+ #
+ #--------------------------------------------------------------------
+ 
+ AC_DEFUN([TEA_BLOCKING_STYLE], [
+     AC_CHECK_HEADERS(sys/ioctl.h)
+     AC_CHECK_HEADERS(sys/filio.h)
+     TEA_CONFIG_SYSTEM
+     AC_MSG_CHECKING([FIONBIO vs. O_NONBLOCK for nonblocking I/O])
+     case $system in
+ 	# There used to be code here to use FIONBIO under AIX.  However, it
+ 	# was reported that FIONBIO doesn't work under AIX 3.2.5.  Since
+ 	# using O_NONBLOCK seems fine under AIX 4.*, I removed the FIONBIO
+ 	# code (JO, 5/31/97).
+ 
+ 	OSF*)
+ 	    AC_DEFINE(USE_FIONBIO, 1, [Should we use FIONBIO?])
+ 	    AC_MSG_RESULT([FIONBIO])
+ 	    ;;
+ 	SunOS-4*)
+ 	    AC_DEFINE(USE_FIONBIO, 1, [Should we use FIONBIO?])
+ 	    AC_MSG_RESULT([FIONBIO])
+ 	    ;;
+ 	*)
+ 	    AC_MSG_RESULT([O_NONBLOCK])
+ 	    ;;
+     esac
+ ])
+ 
+ #--------------------------------------------------------------------
+ # TEA_TIME_HANLDER
+ #
+ #	Checks how the system deals with time.h, what time structures
+ #	are used on the system, and what fields the structures have.
+ #
+ # Arguments:
+ #	none
+ #	
+ # Results:
+ #
+ #	Defines some of the following vars:
+ #		USE_DELTA_FOR_TZ
+ #		HAVE_TM_GMTOFF
+ #		HAVE_TM_TZADJ
+ #		HAVE_TIMEZONE_VAR
+ #
+ #--------------------------------------------------------------------
+ 
+ AC_DEFUN([TEA_TIME_HANDLER], [
+     AC_CHECK_HEADERS(sys/time.h)
+     AC_HEADER_TIME
+     AC_STRUCT_TIMEZONE
+ 
+     AC_CHECK_FUNCS(gmtime_r localtime_r)
+ 
+     AC_CACHE_CHECK([tm_tzadj in struct tm], tcl_cv_member_tm_tzadj, [
+ 	AC_TRY_COMPILE([#include <time.h>], [struct tm tm; tm.tm_tzadj;],
+ 	    tcl_cv_member_tm_tzadj=yes, tcl_cv_member_tm_tzadj=no)])
+     if test $tcl_cv_member_tm_tzadj = yes ; then
+ 	AC_DEFINE(HAVE_TM_TZADJ, 1, [Should we use the tm_tzadj field of struct tm?])
+     fi
+ 
+     AC_CACHE_CHECK([tm_gmtoff in struct tm], tcl_cv_member_tm_gmtoff, [
+ 	AC_TRY_COMPILE([#include <time.h>], [struct tm tm; tm.tm_gmtoff;],
+ 	    tcl_cv_member_tm_gmtoff=yes, tcl_cv_member_tm_gmtoff=no)])
+     if test $tcl_cv_member_tm_gmtoff = yes ; then
+ 	AC_DEFINE(HAVE_TM_GMTOFF, 1, [Should we use the tm_gmtoff field of struct tm?])
+     fi
+ 
+     #
+     # Its important to include time.h in this check, as some systems
+     # (like convex) have timezone functions, etc.
+     #
+     AC_CACHE_CHECK([long timezone variable], tcl_cv_timezone_long, [
+ 	AC_TRY_COMPILE([#include <time.h>],
+ 	    [extern long timezone;
+ 	    timezone += 1;
+ 	    exit (0);],
+ 	    tcl_cv_timezone_long=yes, tcl_cv_timezone_long=no)])
+     if test $tcl_cv_timezone_long = yes ; then
+ 	AC_DEFINE(HAVE_TIMEZONE_VAR, 1, [Should we use the global timezone variable?])
+     else
+ 	#
+ 	# On some systems (eg IRIX 6.2), timezone is a time_t and not a long.
+ 	#
+ 	AC_CACHE_CHECK([time_t timezone variable], tcl_cv_timezone_time, [
+ 	    AC_TRY_COMPILE([#include <time.h>],
+ 		[extern time_t timezone;
+ 		timezone += 1;
+ 		exit (0);],
+ 		tcl_cv_timezone_time=yes, tcl_cv_timezone_time=no)])
+ 	if test $tcl_cv_timezone_time = yes ; then
+ 	    AC_DEFINE(HAVE_TIMEZONE_VAR, 1, [Should we use the global timezone variable?])
+ 	fi
+     fi
+ ])
+ 
+ #--------------------------------------------------------------------
+ # TEA_BUGGY_STRTOD
+ #
+ #	Under Solaris 2.4, strtod returns the wrong value for the
+ #	terminating character under some conditions.  Check for this
+ #	and if the problem exists use a substitute procedure
+ #	"fixstrtod" (provided by Tcl) that corrects the error.
+ #	Also, on Compaq's Tru64 Unix 5.0,
+ #	strtod(" ") returns 0.0 instead of a failure to convert.
+ #
+ # Arguments:
+ #	none
+ #	
+ # Results:
+ #
+ #	Might defines some of the following vars:
+ #		strtod (=fixstrtod)
+ #
+ #--------------------------------------------------------------------
+ 
+ AC_DEFUN([TEA_BUGGY_STRTOD], [
+     AC_CHECK_FUNC(strtod, tcl_strtod=1, tcl_strtod=0)
+     if test "$tcl_strtod" = 1; then
+ 	AC_CACHE_CHECK([for Solaris2.4/Tru64 strtod bugs], tcl_cv_strtod_buggy,[
+ 	    AC_TRY_RUN([
+ 		extern double strtod();
+ 		int main() {
+ 		    char *infString="Inf", *nanString="NaN", *spaceString=" ";
+ 		    char *term;
+ 		    double value;
+ 		    value = strtod(infString, &term);
+ 		    if ((term != infString) && (term[-1] == 0)) {
+ 			exit(1);
+ 		    }
+ 		    value = strtod(nanString, &term);
+ 		    if ((term != nanString) && (term[-1] == 0)) {
+ 			exit(1);
+ 		    }
+ 		    value = strtod(spaceString, &term);
+ 		    if (term == (spaceString+1)) {
+ 			exit(1);
+ 		    }
+ 		    exit(0);
+ 		}], tcl_cv_strtod_buggy=ok, tcl_cv_strtod_buggy=buggy,
+ 		    tcl_cv_strtod_buggy=buggy)])
+ 	if test "$tcl_cv_strtod_buggy" = buggy; then
+ 	    AC_LIBOBJ([fixstrtod])
+ 	    USE_COMPAT=1
+ 	    AC_DEFINE(strtod, fixstrtod, [Do we want to use the strtod() in compat?])
+ 	fi
+     fi
+ ])
+ 
+ #--------------------------------------------------------------------
+ # TEA_TCL_LINK_LIBS
+ #
+ #	Search for the libraries needed to link the Tcl shell.
+ #	Things like the math library (-lm) and socket stuff (-lsocket vs.
+ #	-lnsl) are dealt with here.
+ #
+ # Arguments:
+ #	Requires the following vars to be set in the Makefile:
+ #		DL_LIBS
+ #		LIBS
+ #		MATH_LIBS
+ #	
+ # Results:
+ #
+ #	Subst's the following var:
+ #		TCL_LIBS
+ #		MATH_LIBS
+ #
+ #	Might append to the following vars:
+ #		LIBS
+ #
+ #	Might define the following vars:
+ #		HAVE_NET_ERRNO_H
+ #
+ #--------------------------------------------------------------------
+ 
+ AC_DEFUN([TEA_TCL_LINK_LIBS], [
+     #--------------------------------------------------------------------
+     # On a few very rare systems, all of the libm.a stuff is
+     # already in libc.a.  Set compiler flags accordingly.
+     # Also, Linux requires the "ieee" library for math to work
+     # right (and it must appear before "-lm").
+     #--------------------------------------------------------------------
+ 
+     AC_CHECK_FUNC(sin, MATH_LIBS="", MATH_LIBS="-lm")
+     AC_CHECK_LIB(ieee, main, [MATH_LIBS="-lieee $MATH_LIBS"])
+ 
+     #--------------------------------------------------------------------
+     # Interactive UNIX requires -linet instead of -lsocket, plus it
+     # needs net/errno.h to define the socket-related error codes.
+     #--------------------------------------------------------------------
+ 
+     AC_CHECK_LIB(inet, main, [LIBS="$LIBS -linet"])
+     AC_CHECK_HEADER(net/errno.h, [
+ 	AC_DEFINE(HAVE_NET_ERRNO_H, 1, [Do we have <net/errno.h>?])])
+ 
+     #--------------------------------------------------------------------
+     #	Check for the existence of the -lsocket and -lnsl libraries.
+     #	The order here is important, so that they end up in the right
+     #	order in the command line generated by make.  Here are some
+     #	special considerations:
+     #	1. Use "connect" and "accept" to check for -lsocket, and
+     #	   "gethostbyname" to check for -lnsl.
+     #	2. Use each function name only once:  can't redo a check because
+     #	   autoconf caches the results of the last check and won't redo it.
+     #	3. Use -lnsl and -lsocket only if they supply procedures that
+     #	   aren't already present in the normal libraries.  This is because
+     #	   IRIX 5.2 has libraries, but they aren't needed and they're
+     #	   bogus:  they goof up name resolution if used.
+     #	4. On some SVR4 systems, can't use -lsocket without -lnsl too.
+     #	   To get around this problem, check for both libraries together
+     #	   if -lsocket doesn't work by itself.
+     #--------------------------------------------------------------------
+ 
+     tcl_checkBoth=0
+     AC_CHECK_FUNC(connect, tcl_checkSocket=0, tcl_checkSocket=1)
+     if test "$tcl_checkSocket" = 1; then
+ 	AC_CHECK_FUNC(setsockopt, , [AC_CHECK_LIB(socket, setsockopt,
+ 	    LIBS="$LIBS -lsocket", tcl_checkBoth=1)])
+     fi
+     if test "$tcl_checkBoth" = 1; then
+ 	tk_oldLibs=$LIBS
+ 	LIBS="$LIBS -lsocket -lnsl"
+ 	AC_CHECK_FUNC(accept, tcl_checkNsl=0, [LIBS=$tk_oldLibs])
+     fi
+     AC_CHECK_FUNC(gethostbyname, , [AC_CHECK_LIB(nsl, gethostbyname,
+ 	    [LIBS="$LIBS -lnsl"])])
+     
+     # TEA specific: Don't perform the eval of the libraries here because
+     # DL_LIBS won't be set until we call TEA_CONFIG_CFLAGS
+ 
+     TCL_LIBS='${DL_LIBS} ${LIBS} ${MATH_LIBS}'
+     AC_SUBST(TCL_LIBS)
+     AC_SUBST(MATH_LIBS)
+ ])
+ 
+ #--------------------------------------------------------------------
+ # TEA_TCL_EARLY_FLAGS
+ #
+ #	Check for what flags are needed to be passed so the correct OS
+ #	features are available.
+ #
+ # Arguments:
+ #	None
+ #	
+ # Results:
+ #
+ #	Might define the following vars:
+ #		_ISOC99_SOURCE
+ #		_LARGEFILE64_SOURCE
+ #		_LARGEFILE_SOURCE64
+ #
+ #--------------------------------------------------------------------
+ 
+ AC_DEFUN([TEA_TCL_EARLY_FLAG],[
+     AC_CACHE_VAL([tcl_cv_flag_]translit($1,[A-Z],[a-z]),
+ 	AC_TRY_COMPILE([$2], $3, [tcl_cv_flag_]translit($1,[A-Z],[a-z])=no,
+ 	    AC_TRY_COMPILE([[#define ]$1[ 1
+ ]$2], $3,
+ 		[tcl_cv_flag_]translit($1,[A-Z],[a-z])=yes,
+ 		[tcl_cv_flag_]translit($1,[A-Z],[a-z])=no)))
+     if test ["x${tcl_cv_flag_]translit($1,[A-Z],[a-z])[}" = "xyes"] ; then
+ 	AC_DEFINE($1, 1, [Add the ]$1[ flag when building])
+ 	tcl_flags="$tcl_flags $1"
+     fi
+ ])
+ 
+ AC_DEFUN([TEA_TCL_EARLY_FLAGS],[
+     AC_MSG_CHECKING([for required early compiler flags])
+     tcl_flags=""
+     TEA_TCL_EARLY_FLAG(_ISOC99_SOURCE,[#include <stdlib.h>],
+ 	[char *p = (char *)strtoll; char *q = (char *)strtoull;])
+     TEA_TCL_EARLY_FLAG(_LARGEFILE64_SOURCE,[#include <sys/stat.h>],
+ 	[struct stat64 buf; int i = stat64("/", &buf);])
+     TEA_TCL_EARLY_FLAG(_LARGEFILE_SOURCE64,[#include <sys/stat.h>],
+ 	[char *p = (char *)open64;])
+     if test "x${tcl_flags}" = "x" ; then
+ 	AC_MSG_RESULT([none])
+     else
+ 	AC_MSG_RESULT([${tcl_flags}])
+     fi
+ ])
+ 
+ #--------------------------------------------------------------------
+ # TEA_TCL_64BIT_FLAGS
+ #
+ #	Check for what is defined in the way of 64-bit features.
+ #
+ # Arguments:
+ #	None
+ #	
+ # Results:
+ #
+ #	Might define the following vars:
+ #		TCL_WIDE_INT_IS_LONG
+ #		TCL_WIDE_INT_TYPE
+ #		HAVE_STRUCT_DIRENT64
+ #		HAVE_STRUCT_STAT64
+ #		HAVE_TYPE_OFF64_T
+ #
+ #--------------------------------------------------------------------
+ 
+ AC_DEFUN([TEA_TCL_64BIT_FLAGS], [
+     AC_MSG_CHECKING([for 64-bit integer type])
+     AC_CACHE_VAL(tcl_cv_type_64bit,[
+ 	tcl_cv_type_64bit=none
+ 	# See if the compiler knows natively about __int64
+ 	AC_TRY_COMPILE(,[__int64 value = (__int64) 0;],
+ 	    tcl_type_64bit=__int64, tcl_type_64bit="long long")
+ 	# See if we should use long anyway  Note that we substitute in the
+ 	# type that is our current guess for a 64-bit type inside this check
+ 	# program, so it should be modified only carefully...
+         AC_TRY_COMPILE(,[switch (0) { 
+             case 1: case (sizeof(]${tcl_type_64bit}[)==sizeof(long)): ; 
+         }],tcl_cv_type_64bit=${tcl_type_64bit})])
+     if test "${tcl_cv_type_64bit}" = none ; then
+ 	AC_DEFINE(TCL_WIDE_INT_IS_LONG, 1, [Are wide integers to be implemented with C 'long's?])
+ 	AC_MSG_RESULT([using long])
+     elif test "${tcl_cv_type_64bit}" = "__int64" \
+ 		-a "${TEA_PLATFORM}" = "windows" ; then
+ 	# TEA specific: We actually want to use the default tcl.h checks in
+ 	# this case to handle both TCL_WIDE_INT_TYPE and TCL_LL_MODIFIER*
+ 	AC_MSG_RESULT([using Tcl header defaults])
+     else
+ 	AC_DEFINE_UNQUOTED(TCL_WIDE_INT_TYPE,${tcl_cv_type_64bit},
+ 	    [What type should be used to define wide integers?])
+ 	AC_MSG_RESULT([${tcl_cv_type_64bit}])
+ 
+ 	# Now check for auxiliary declarations
+ 	AC_CACHE_CHECK([for struct dirent64], tcl_cv_struct_dirent64,[
+ 	    AC_TRY_COMPILE([#include <sys/types.h>
+ #include <sys/dirent.h>],[struct dirent64 p;],
+ 		tcl_cv_struct_dirent64=yes,tcl_cv_struct_dirent64=no)])
+ 	if test "x${tcl_cv_struct_dirent64}" = "xyes" ; then
+ 	    AC_DEFINE(HAVE_STRUCT_DIRENT64, 1, [Is 'struct dirent64' in <sys/types.h>?])
+ 	fi
+ 
+ 	AC_CACHE_CHECK([for struct stat64], tcl_cv_struct_stat64,[
+ 	    AC_TRY_COMPILE([#include <sys/stat.h>],[struct stat64 p;
+ ],
+ 		tcl_cv_struct_stat64=yes,tcl_cv_struct_stat64=no)])
+ 	if test "x${tcl_cv_struct_stat64}" = "xyes" ; then
+ 	    AC_DEFINE(HAVE_STRUCT_STAT64, 1, [Is 'struct stat64' in <sys/stat.h>?])
+ 	fi
+ 
+ 	AC_CHECK_FUNCS(open64 lseek64)
+ 	AC_MSG_CHECKING([for off64_t])
+ 	AC_CACHE_VAL(tcl_cv_type_off64_t,[
+ 	    AC_TRY_COMPILE([#include <sys/types.h>],[off64_t offset;
+ ],
+ 		tcl_cv_type_off64_t=yes,tcl_cv_type_off64_t=no)])
+ 	dnl Define HAVE_TYPE_OFF64_T only when the off64_t type and the
+ 	dnl functions lseek64 and open64 are defined.
+ 	if test "x${tcl_cv_type_off64_t}" = "xyes" && \
+ 	        test "x${ac_cv_func_lseek64}" = "xyes" && \
+ 	        test "x${ac_cv_func_open64}" = "xyes" ; then
+ 	    AC_DEFINE(HAVE_TYPE_OFF64_T, 1, [Is off64_t in <sys/types.h>?])
+ 	    AC_MSG_RESULT([yes])
+ 	else
+ 	    AC_MSG_RESULT([no])
+ 	fi
+     fi
+ ])
+ 
+ ##
+ ## Here ends the standard Tcl configuration bits and starts the
+ ## TEA specific functions
+ ##
+ 
+ #------------------------------------------------------------------------
+ # TEA_INIT --
+ #
+ #	Init various Tcl Extension Architecture (TEA) variables.
+ #	This should be the first called TEA_* macro.
+ #
+ # Arguments:
+ #	none
+ #
+ # Results:
+ #
+ #	Defines and substs the following vars:
+ #		CYGPATH
+ #		EXEEXT
+ #	Defines only:
+ #		TEA_VERSION
+ #		TEA_INITED
+ #		TEA_PLATFORM (windows or unix)
+ #
+ # "cygpath" is used on windows to generate native path names for include
+ # files. These variables should only be used with the compiler and linker
+ # since they generate native path names.
+ #
+ # EXEEXT
+ #	Select the executable extension based on the host type.  This
+ #	is a lightweight replacement for AC_EXEEXT that doesn't require
+ #	a compiler.
+ #------------------------------------------------------------------------
+ 
+ AC_DEFUN([TEA_INIT], [
+     # TEA extensions pass this us the version of TEA they think they
+     # are compatible with.
+     TEA_VERSION="3.6"
+ 
+     AC_MSG_CHECKING([for correct TEA configuration])
+     if test x"${PACKAGE_NAME}" = x ; then
+ 	AC_MSG_ERROR([
+ The PACKAGE_NAME variable must be defined by your TEA configure.in])
+     fi
+     if test x"$1" = x ; then
+ 	AC_MSG_ERROR([
+ TEA version not specified.])
+     elif test "$1" != "${TEA_VERSION}" ; then
+ 	AC_MSG_RESULT([warning: requested TEA version "$1", have "${TEA_VERSION}"])
+     else
+ 	AC_MSG_RESULT([ok (TEA ${TEA_VERSION})])
+     fi
+     case "`uname -s`" in
+ 	*win32*|*WIN32*|*CYGWIN_NT*|*CYGWIN_9*|*CYGWIN_ME*|*MINGW32_*)
+ 	    AC_CHECK_PROG(CYGPATH, cygpath, cygpath -w, echo)
+ 	    EXEEXT=".exe"
+ 	    TEA_PLATFORM="windows"
+ 	    ;;
+ 	*)
+ 	    CYGPATH=echo
+ 	    EXEEXT=""
+ 	    TEA_PLATFORM="unix"
+ 	    ;;
+     esac
+ 
+     # Check if exec_prefix is set. If not use fall back to prefix.
+     # Note when adjusted, so that TEA_PREFIX can correct for this.
+     # This is needed for recursive configures, since autoconf propagates
+     # $prefix, but not $exec_prefix (doh!).
+     if test x$exec_prefix = xNONE ; then
+ 	exec_prefix_default=yes
+ 	exec_prefix=$prefix
+     fi
+ 
+     AC_SUBST(EXEEXT)
+     AC_SUBST(CYGPATH)
+ 
+     # This package name must be replaced statically for AC_SUBST to work
+     AC_SUBST(PKG_LIB_FILE)
+     # Substitute STUB_LIB_FILE in case package creates a stub library too.
+     AC_SUBST(PKG_STUB_LIB_FILE)
+ 
+     # We AC_SUBST these here to ensure they are subst'ed,
+     # in case the user doesn't call TEA_ADD_...
+     AC_SUBST(PKG_STUB_SOURCES)
+     AC_SUBST(PKG_STUB_OBJECTS)
+     AC_SUBST(PKG_TCL_SOURCES)
+     AC_SUBST(PKG_HEADERS)
+     AC_SUBST(PKG_INCLUDES)
+     AC_SUBST(PKG_LIBS)
+     AC_SUBST(PKG_CFLAGS)
+ ])
+ 
+ #------------------------------------------------------------------------
+ # TEA_ADD_SOURCES --
+ #
+ #	Specify one or more source files.  Users should check for
+ #	the right platform before adding to their list.
+ #	It is not important to specify the directory, as long as it is
+ #	in the generic, win or unix subdirectory of $(srcdir).
+ #
+ # Arguments:
+ #	one or more file names
+ #
+ # Results:
+ #
+ #	Defines and substs the following vars:
+ #		PKG_SOURCES
+ #		PKG_OBJECTS
+ #------------------------------------------------------------------------
+ AC_DEFUN([TEA_ADD_SOURCES], [
+     vars="$@"
+     for i in $vars; do
+ 	case $i in
+ 	    [\$]*)
+ 		# allow $-var names
+ 		PKG_SOURCES="$PKG_SOURCES $i"
+ 		PKG_OBJECTS="$PKG_OBJECTS $i"
+ 		;;
+ 	    *)
+ 		# check for existence - allows for generic/win/unix VPATH
+ 		# To add more dirs here (like 'src'), you have to update VPATH
+ 		# in Makefile.in as well
+ 		if test ! -f "${srcdir}/$i" -a ! -f "${srcdir}/generic/$i" \
+ 		    -a ! -f "${srcdir}/win/$i" -a ! -f "${srcdir}/unix/$i" \
+ 		    ; then
+ 		    AC_MSG_ERROR([could not find source file '$i'])
+ 		fi
+ 		PKG_SOURCES="$PKG_SOURCES $i"
+ 		# this assumes it is in a VPATH dir
+ 		i=`basename $i`
+ 		# handle user calling this before or after TEA_SETUP_COMPILER
+ 		if test x"${OBJEXT}" != x ; then
+ 		    j="`echo $i | sed -e 's/\.[[^.]]*$//'`.${OBJEXT}"
+ 		else
+ 		    j="`echo $i | sed -e 's/\.[[^.]]*$//'`.\${OBJEXT}"
+ 		fi
+ 		PKG_OBJECTS="$PKG_OBJECTS $j"
+ 		;;
+ 	esac
+     done
+     AC_SUBST(PKG_SOURCES)
+     AC_SUBST(PKG_OBJECTS)
+ ])
+ 
+ #------------------------------------------------------------------------
+ # TEA_ADD_STUB_SOURCES --
+ #
+ #	Specify one or more source files.  Users should check for
+ #	the right platform before adding to their list.
+ #	It is not important to specify the directory, as long as it is
+ #	in the generic, win or unix subdirectory of $(srcdir).
+ #
+ # Arguments:
+ #	one or more file names
+ #
+ # Results:
+ #
+ #	Defines and substs the following vars:
+ #		PKG_STUB_SOURCES
+ #		PKG_STUB_OBJECTS
+ #------------------------------------------------------------------------
+ AC_DEFUN([TEA_ADD_STUB_SOURCES], [
+     vars="$@"
+     for i in $vars; do
+ 	# check for existence - allows for generic/win/unix VPATH
+ 	if test ! -f "${srcdir}/$i" -a ! -f "${srcdir}/generic/$i" \
+ 	    -a ! -f "${srcdir}/win/$i" -a ! -f "${srcdir}/unix/$i" \
+ 	    ; then
+ 	    AC_MSG_ERROR([could not find stub source file '$i'])
+ 	fi
+ 	PKG_STUB_SOURCES="$PKG_STUB_SOURCES $i"
+ 	# this assumes it is in a VPATH dir
+ 	i=`basename $i`
+ 	# handle user calling this before or after TEA_SETUP_COMPILER
+ 	if test x"${OBJEXT}" != x ; then
+ 	    j="`echo $i | sed -e 's/\.[[^.]]*$//'`.${OBJEXT}"
+ 	else
+ 	    j="`echo $i | sed -e 's/\.[[^.]]*$//'`.\${OBJEXT}"
+ 	fi
+ 	PKG_STUB_OBJECTS="$PKG_STUB_OBJECTS $j"
+     done
+     AC_SUBST(PKG_STUB_SOURCES)
+     AC_SUBST(PKG_STUB_OBJECTS)
+ ])
+ 
+ #------------------------------------------------------------------------
+ # TEA_ADD_TCL_SOURCES --
+ #
+ #	Specify one or more Tcl source files.  These should be platform
+ #	independent runtime files.
+ #
+ # Arguments:
+ #	one or more file names
+ #
+ # Results:
+ #
+ #	Defines and substs the following vars:
+ #		PKG_TCL_SOURCES
+ #------------------------------------------------------------------------
+ AC_DEFUN([TEA_ADD_TCL_SOURCES], [
+     vars="$@"
+     for i in $vars; do
+ 	# check for existence, be strict because it is installed
+ 	if test ! -f "${srcdir}/$i" ; then
+ 	    AC_MSG_ERROR([could not find tcl source file '${srcdir}/$i'])
+ 	fi
+ 	PKG_TCL_SOURCES="$PKG_TCL_SOURCES $i"
+     done
+     AC_SUBST(PKG_TCL_SOURCES)
+ ])
+ 
+ #------------------------------------------------------------------------
+ # TEA_ADD_HEADERS --
+ #
+ #	Specify one or more source headers.  Users should check for
+ #	the right platform before adding to their list.
+ #
+ # Arguments:
+ #	one or more file names
+ #
+ # Results:
+ #
+ #	Defines and substs the following vars:
+ #		PKG_HEADERS
+ #------------------------------------------------------------------------
+ AC_DEFUN([TEA_ADD_HEADERS], [
+     vars="$@"
+     for i in $vars; do
+ 	# check for existence, be strict because it is installed
+ 	if test ! -f "${srcdir}/$i" ; then
+ 	    AC_MSG_ERROR([could not find header file '${srcdir}/$i'])
+ 	fi
+ 	PKG_HEADERS="$PKG_HEADERS $i"
+     done
+     AC_SUBST(PKG_HEADERS)
+ ])
+ 
+ #------------------------------------------------------------------------
+ # TEA_ADD_INCLUDES --
+ #
+ #	Specify one or more include dirs.  Users should check for
+ #	the right platform before adding to their list.
+ #
+ # Arguments:
+ #	one or more file names
+ #
+ # Results:
+ #
+ #	Defines and substs the following vars:
+ #		PKG_INCLUDES
+ #------------------------------------------------------------------------
+ AC_DEFUN([TEA_ADD_INCLUDES], [
+     vars="$@"
+     for i in $vars; do
+ 	PKG_INCLUDES="$PKG_INCLUDES $i"
+     done
+     AC_SUBST(PKG_INCLUDES)
+ ])
+ 
+ #------------------------------------------------------------------------
+ # TEA_ADD_LIBS --
+ #
+ #	Specify one or more libraries.  Users should check for
+ #	the right platform before adding to their list.  For Windows,
+ #	libraries provided in "foo.lib" format will be converted to
+ #	"-lfoo" when using GCC (mingw).
+ #
+ # Arguments:
+ #	one or more file names
+ #
+ # Results:
+ #
+ #	Defines and substs the following vars:
+ #		PKG_LIBS
+ #------------------------------------------------------------------------
+ AC_DEFUN([TEA_ADD_LIBS], [
+     vars="$@"
+     for i in $vars; do
+ 	if test "${TEA_PLATFORM}" = "windows" -a "$GCC" = "yes" ; then
+ 	    # Convert foo.lib to -lfoo for GCC.  No-op if not *.lib
+ 	    i=`echo "$i" | sed -e 's/^\([[^-]].*\)\.lib[$]/-l\1/i'`
+ 	fi
+ 	PKG_LIBS="$PKG_LIBS $i"
+     done
+     AC_SUBST(PKG_LIBS)
+ ])
+ 
+ #------------------------------------------------------------------------
+ # TEA_ADD_CFLAGS --
+ #
+ #	Specify one or more CFLAGS.  Users should check for
+ #	the right platform before adding to their list.
+ #
+ # Arguments:
+ #	one or more file names
+ #
+ # Results:
+ #
+ #	Defines and substs the following vars:
+ #		PKG_CFLAGS
+ #------------------------------------------------------------------------
+ AC_DEFUN([TEA_ADD_CFLAGS], [
+     PKG_CFLAGS="$PKG_CFLAGS $@"
+     AC_SUBST(PKG_CFLAGS)
+ ])
+ 
+ #------------------------------------------------------------------------
+ # TEA_PREFIX --
+ #
+ #	Handle the --prefix=... option by defaulting to what Tcl gave
+ #
+ # Arguments:
+ #	none
+ #
+ # Results:
+ #
+ #	If --prefix or --exec-prefix was not specified, $prefix and
+ #	$exec_prefix will be set to the values given to Tcl when it was
+ #	configured.
+ #------------------------------------------------------------------------
+ AC_DEFUN([TEA_PREFIX], [
+     if test "${prefix}" = "NONE"; then
+ 	prefix_default=yes
+ 	if test x"${TCL_PREFIX}" != x; then
+ 	    AC_MSG_NOTICE([--prefix defaulting to TCL_PREFIX ${TCL_PREFIX}])
+ 	    prefix=${TCL_PREFIX}
+ 	else
+ 	    AC_MSG_NOTICE([--prefix defaulting to /usr/local])
+ 	    prefix=/usr/local
+ 	fi
+     fi
+     if test "${exec_prefix}" = "NONE" -a x"${prefix_default}" = x"yes" \
+ 	-o x"${exec_prefix_default}" = x"yes" ; then
+ 	if test x"${TCL_EXEC_PREFIX}" != x; then
+ 	    AC_MSG_NOTICE([--exec-prefix defaulting to TCL_EXEC_PREFIX ${TCL_EXEC_PREFIX}])
+ 	    exec_prefix=${TCL_EXEC_PREFIX}
+ 	else
+ 	    AC_MSG_NOTICE([--exec-prefix defaulting to ${prefix}])
+ 	    exec_prefix=$prefix
+ 	fi
+     fi
+ ])
+ 
+ #------------------------------------------------------------------------
+ # TEA_SETUP_COMPILER_CC --
+ #
+ #	Do compiler checks the way we want.  This is just a replacement
+ #	for AC_PROG_CC in TEA configure.in files to make them cleaner.
+ #
+ # Arguments:
+ #	none
+ #
+ # Results:
+ #
+ #	Sets up CC var and other standard bits we need to make executables.
+ #------------------------------------------------------------------------
+ AC_DEFUN([TEA_SETUP_COMPILER_CC], [
+     # Don't put any macros that use the compiler (e.g. AC_TRY_COMPILE)
+     # in this macro, they need to go into TEA_SETUP_COMPILER instead.
+ 
+     # If the user did not set CFLAGS, set it now to keep
+     # the AC_PROG_CC macro from adding "-g -O2".
+     if test "${CFLAGS+set}" != "set" ; then
+ 	CFLAGS=""
+     fi
+ 
+     AC_PROG_CC
+     AC_PROG_CPP
+ 
+     AC_PROG_INSTALL
+ 
+     #--------------------------------------------------------------------
+     # Checks to see if the make program sets the $MAKE variable.
+     #--------------------------------------------------------------------
+ 
+     AC_PROG_MAKE_SET
+ 
+     #--------------------------------------------------------------------
+     # Find ranlib
+     #--------------------------------------------------------------------
+ 
+     AC_PROG_RANLIB
+ 
+     #--------------------------------------------------------------------
+     # Determines the correct binary file extension (.o, .obj, .exe etc.)
+     #--------------------------------------------------------------------
+ 
+     AC_OBJEXT
+     AC_EXEEXT
+ ])
+ 
+ #------------------------------------------------------------------------
+ # TEA_SETUP_COMPILER --
+ #
+ #	Do compiler checks that use the compiler.  This must go after
+ #	TEA_SETUP_COMPILER_CC, which does the actual compiler check.
+ #
+ # Arguments:
+ #	none
+ #
+ # Results:
+ #
+ #	Sets up CC var and other standard bits we need to make executables.
+ #------------------------------------------------------------------------
+ AC_DEFUN([TEA_SETUP_COMPILER], [
+     # Any macros that use the compiler (e.g. AC_TRY_COMPILE) have to go here.
+     AC_REQUIRE([TEA_SETUP_COMPILER_CC])
+ 
+     #------------------------------------------------------------------------
+     # If we're using GCC, see if the compiler understands -pipe. If so, use it.
+     # It makes compiling go faster.  (This is only a performance feature.)
+     #------------------------------------------------------------------------
+ 
+     if test -z "$no_pipe" -a -n "$GCC"; then
+ 	AC_CACHE_CHECK([if the compiler understands -pipe],
+ 	    tcl_cv_cc_pipe, [
+ 	    hold_cflags=$CFLAGS; CFLAGS="$CFLAGS -pipe"
+ 	    AC_TRY_COMPILE(,, tcl_cv_cc_pipe=yes, tcl_cv_cc_pipe=no)
+ 	    CFLAGS=$hold_cflags])
+ 	if test $tcl_cv_cc_pipe = yes; then
+ 	    CFLAGS="$CFLAGS -pipe"
+ 	fi
+     fi
+ 
+     #--------------------------------------------------------------------
+     # Common compiler flag setup
+     #--------------------------------------------------------------------
+ 
+     AC_C_BIGENDIAN
+     if test "${TEA_PLATFORM}" = "unix" ; then
+ 	TEA_TCL_LINK_LIBS
+ 	TEA_MISSING_POSIX_HEADERS
+ 	# Let the user call this, because if it triggers, they will
+ 	# need a compat/strtod.c that is correct.  Users can also
+ 	# use Tcl_GetDouble(FromObj) instead.
+ 	#TEA_BUGGY_STRTOD
+     fi
+ ])
+ 
+ #------------------------------------------------------------------------
+ # TEA_MAKE_LIB --
+ #
+ #	Generate a line that can be used to build a shared/unshared library
+ #	in a platform independent manner.
+ #
+ # Arguments:
+ #	none
+ #
+ #	Requires:
+ #
+ # Results:
+ #
+ #	Defines the following vars:
+ #	CFLAGS -	Done late here to note disturb other AC macros
+ #       MAKE_LIB -      Command to execute to build the Tcl library;
+ #                       differs depending on whether or not Tcl is being
+ #                       compiled as a shared library.
+ #	MAKE_SHARED_LIB	Makefile rule for building a shared library
+ #	MAKE_STATIC_LIB	Makefile rule for building a static library
+ #	MAKE_STUB_LIB	Makefile rule for building a stub library
+ #------------------------------------------------------------------------
+ 
+ AC_DEFUN([TEA_MAKE_LIB], [
+     if test "${TEA_PLATFORM}" = "windows" -a "$GCC" != "yes"; then
+ 	MAKE_STATIC_LIB="\${STLIB_LD} -out:\[$]@ \$(PKG_OBJECTS)"
+ 	MAKE_SHARED_LIB="\${SHLIB_LD} \${SHLIB_LD_LIBS} \${LDFLAGS_DEFAULT} -out:\[$]@ \$(PKG_OBJECTS)"
+ 	MAKE_STUB_LIB="\${STLIB_LD} -out:\[$]@ \$(PKG_STUB_OBJECTS)"
+     else
+ 	MAKE_STATIC_LIB="\${STLIB_LD} \[$]@ \$(PKG_OBJECTS)"
+ 	MAKE_SHARED_LIB="\${SHLIB_LD} -o \[$]@ \$(PKG_OBJECTS) \${SHLIB_LD_LIBS}"
+ 	MAKE_STUB_LIB="\${STLIB_LD} \[$]@ \$(PKG_STUB_OBJECTS)"
+     fi
+ 
+     if test "${SHARED_BUILD}" = "1" ; then
+ 	MAKE_LIB="${MAKE_SHARED_LIB} "
+     else
+ 	MAKE_LIB="${MAKE_STATIC_LIB} "
+     fi
+ 
+     #--------------------------------------------------------------------
+     # Shared libraries and static libraries have different names.
+     # Use the double eval to make sure any variables in the suffix is
+     # substituted. (@@@ Might not be necessary anymore)
+     #--------------------------------------------------------------------
+ 
+     if test "${TEA_PLATFORM}" = "windows" ; then
+ 	if test "${SHARED_BUILD}" = "1" ; then
+ 	    # We force the unresolved linking of symbols that are really in
+ 	    # the private libraries of Tcl and Tk.
+ 	    SHLIB_LD_LIBS="${SHLIB_LD_LIBS} \"`${CYGPATH} ${TCL_BIN_DIR}/${TCL_STUB_LIB_FILE}`\""
+ 	    if test x"${TK_BIN_DIR}" != x ; then
+ 		SHLIB_LD_LIBS="${SHLIB_LD_LIBS} \"`${CYGPATH} ${TK_BIN_DIR}/${TK_STUB_LIB_FILE}`\""
+ 	    fi
+ 	    eval eval "PKG_LIB_FILE=${PACKAGE_NAME}${SHARED_LIB_SUFFIX}"
+ 	else
+ 	    eval eval "PKG_LIB_FILE=${PACKAGE_NAME}${UNSHARED_LIB_SUFFIX}"
+ 	fi
+ 	# Some packages build their own stubs libraries
+ 	eval eval "PKG_STUB_LIB_FILE=${PACKAGE_NAME}stub${UNSHARED_LIB_SUFFIX}"
+ 	if test "$GCC" = "yes"; then
+ 	    PKG_STUB_LIB_FILE=lib${PKG_STUB_LIB_FILE}
+ 	fi
+ 	# These aren't needed on Windows (either MSVC or gcc)
+ 	RANLIB=:
+ 	RANLIB_STUB=:
+     else
+ 	RANLIB_STUB="${RANLIB}"
+ 	if test "${SHARED_BUILD}" = "1" ; then
+ 	    SHLIB_LD_LIBS="${SHLIB_LD_LIBS} ${TCL_STUB_LIB_SPEC}"
+ 	    if test x"${TK_BIN_DIR}" != x ; then
+ 		SHLIB_LD_LIBS="${SHLIB_LD_LIBS} ${TK_STUB_LIB_SPEC}"
+ 	    fi
+ 	    eval eval "PKG_LIB_FILE=lib${PACKAGE_NAME}${SHARED_LIB_SUFFIX}"
+ 	    RANLIB=:
+ 	else
+ 	    eval eval "PKG_LIB_FILE=lib${PACKAGE_NAME}${UNSHARED_LIB_SUFFIX}"
+ 	fi
+ 	# Some packages build their own stubs libraries
+ 	eval eval "PKG_STUB_LIB_FILE=lib${PACKAGE_NAME}stub${UNSHARED_LIB_SUFFIX}"
+     fi
+ 
+     # These are escaped so that only CFLAGS is picked up at configure time.
+     # The other values will be substituted at make time.
+     CFLAGS="${CFLAGS} \${CFLAGS_DEFAULT} \${CFLAGS_WARNING}"
+     if test "${SHARED_BUILD}" = "1" ; then
+ 	CFLAGS="${CFLAGS} \${SHLIB_CFLAGS}"
+     fi
+ 
+     AC_SUBST(MAKE_LIB)
+     AC_SUBST(MAKE_SHARED_LIB)
+     AC_SUBST(MAKE_STATIC_LIB)
+     AC_SUBST(MAKE_STUB_LIB)
+     AC_SUBST(RANLIB_STUB)
+ ])
+ 
+ #------------------------------------------------------------------------
+ # TEA_LIB_SPEC --
+ #
+ #	Compute the name of an existing object library located in libdir
+ #	from the given base name and produce the appropriate linker flags.
+ #
+ # Arguments:
+ #	basename	The base name of the library without version
+ #			numbers, extensions, or "lib" prefixes.
+ #	extra_dir	Extra directory in which to search for the
+ #			library.  This location is used first, then
+ #			$prefix/$exec-prefix, then some defaults.
+ #
+ # Requires:
+ #	TEA_INIT and TEA_PREFIX must be called first.
+ #
+ # Results:
+ #
+ #	Defines the following vars:
+ #		${basename}_LIB_NAME	The computed library name.
+ #		${basename}_LIB_SPEC	The computed linker flags.
+ #------------------------------------------------------------------------
+ 
+ AC_DEFUN([TEA_LIB_SPEC], [
+     AC_MSG_CHECKING([for $1 library])
+ 
+     # Look in exec-prefix for the library (defined by TEA_PREFIX).
+ 
+     tea_lib_name_dir="${exec_prefix}/lib"
+ 
+     # Or in a user-specified location.
+ 
+     if test x"$2" != x ; then
+ 	tea_extra_lib_dir=$2
+     else
+ 	tea_extra_lib_dir=NONE
+     fi
+ 
+     for i in \
+ 	    `ls -dr ${tea_extra_lib_dir}/$1[[0-9]]*.lib 2>/dev/null ` \
+ 	    `ls -dr ${tea_extra_lib_dir}/lib$1[[0-9]]* 2>/dev/null ` \
+ 	    `ls -dr ${tea_lib_name_dir}/$1[[0-9]]*.lib 2>/dev/null ` \
+ 	    `ls -dr ${tea_lib_name_dir}/lib$1[[0-9]]* 2>/dev/null ` \
+ 	    `ls -dr /usr/lib/$1[[0-9]]*.lib 2>/dev/null ` \
+ 	    `ls -dr /usr/lib/lib$1[[0-9]]* 2>/dev/null ` \
+ 	    `ls -dr /usr/local/lib/$1[[0-9]]*.lib 2>/dev/null ` \
+ 	    `ls -dr /usr/local/lib/lib$1[[0-9]]* 2>/dev/null ` ; do
+ 	if test -f "$i" ; then
+ 	    tea_lib_name_dir=`dirname $i`
+ 	    $1_LIB_NAME=`basename $i`
+ 	    $1_LIB_PATH_NAME=$i
+ 	    break
+ 	fi
+     done
+ 
+     if test "${TEA_PLATFORM}" = "windows"; then
+ 	$1_LIB_SPEC=\"`${CYGPATH} ${$1_LIB_PATH_NAME} 2>/dev/null`\"
+     else
+ 	# Strip off the leading "lib" and trailing ".a" or ".so"
+ 
+ 	tea_lib_name_lib=`echo ${$1_LIB_NAME}|sed -e 's/^lib//' -e 's/\.[[^.]]*$//' -e 's/\.so.*//'`
+ 	$1_LIB_SPEC="-L${tea_lib_name_dir} -l${tea_lib_name_lib}"
+     fi
+ 
+     if test "x${$1_LIB_NAME}" = x ; then
+ 	AC_MSG_ERROR([not found])
+     else
+ 	AC_MSG_RESULT([${$1_LIB_SPEC}])
+     fi
+ ])
+ 
+ #------------------------------------------------------------------------
+ # TEA_PRIVATE_TCL_HEADERS --
+ #
+ #	Locate the private Tcl include files
+ #
+ # Arguments:
+ #
+ #	Requires:
+ #		TCL_SRC_DIR	Assumes that TEA_LOAD_TCLCONFIG has
+ #				 already been called.
+ #
+ # Results:
+ #
+ #	Substs the following vars:
+ #		TCL_TOP_DIR_NATIVE
+ #		TCL_GENERIC_DIR_NATIVE
+ #		TCL_UNIX_DIR_NATIVE
+ #		TCL_WIN_DIR_NATIVE
+ #		TCL_BMAP_DIR_NATIVE
+ #		TCL_TOOL_DIR_NATIVE
+ #		TCL_PLATFORM_DIR_NATIVE
+ #		TCL_BIN_DIR_NATIVE
+ #		TCL_INCLUDES
+ #------------------------------------------------------------------------
+ 
+ AC_DEFUN([TEA_PRIVATE_TCL_HEADERS], [
+     AC_MSG_CHECKING([for Tcl private include files])
+ 
+     TCL_SRC_DIR_NATIVE=`${CYGPATH} ${TCL_SRC_DIR}`
+     TCL_TOP_DIR_NATIVE=\"${TCL_SRC_DIR_NATIVE}\"
+     TCL_GENERIC_DIR_NATIVE=\"${TCL_SRC_DIR_NATIVE}/generic\"
+     TCL_UNIX_DIR_NATIVE=\"${TCL_SRC_DIR_NATIVE}/unix\"
+     TCL_WIN_DIR_NATIVE=\"${TCL_SRC_DIR_NATIVE}/win\"
+     TCL_BMAP_DIR_NATIVE=\"${TCL_SRC_DIR_NATIVE}/bitmaps\"
+     TCL_TOOL_DIR_NATIVE=\"${TCL_SRC_DIR_NATIVE}/tools\"
+     TCL_COMPAT_DIR_NATIVE=\"${TCL_SRC_DIR_NATIVE}/compat\"
+ 
+     if test "${TEA_PLATFORM}" = "windows"; then
+ 	TCL_PLATFORM_DIR_NATIVE=${TCL_WIN_DIR_NATIVE}
+     else
+ 	TCL_PLATFORM_DIR_NATIVE=${TCL_UNIX_DIR_NATIVE}
+     fi
+     # We want to ensure these are substituted so as not to require
+     # any *_NATIVE vars be defined in the Makefile
+     TCL_INCLUDES="-I${TCL_GENERIC_DIR_NATIVE} -I${TCL_PLATFORM_DIR_NATIVE}"
+     if test "`uname -s`" = "Darwin"; then
+         # If Tcl was built as a framework, attempt to use
+         # the framework's Headers and PrivateHeaders directories
+         case ${TCL_DEFS} in
+ 	    *TCL_FRAMEWORK*)
+ 	        if test -d "${TCL_BIN_DIR}/Headers" -a -d "${TCL_BIN_DIR}/PrivateHeaders"; then
+ 	        TCL_INCLUDES="-I\"${TCL_BIN_DIR}/Headers\" -I\"${TCL_BIN_DIR}/PrivateHeaders\" ${TCL_INCLUDES}"; else
+ 	        TCL_INCLUDES="${TCL_INCLUDES} ${TCL_INCLUDE_SPEC} `echo "${TCL_INCLUDE_SPEC}" | sed -e 's/Headers/PrivateHeaders/'`"; fi
+ 	        ;;
+ 	esac
+     else
+ 	if test ! -f "${TCL_SRC_DIR}/generic/tclInt.h" ; then
+ 	    AC_MSG_ERROR([Cannot find private header tclInt.h in ${TCL_SRC_DIR}])
+ 	fi
+     fi
+ 
+ 
+     AC_SUBST(TCL_TOP_DIR_NATIVE)
+     AC_SUBST(TCL_GENERIC_DIR_NATIVE)
+     AC_SUBST(TCL_UNIX_DIR_NATIVE)
+     AC_SUBST(TCL_WIN_DIR_NATIVE)
+     AC_SUBST(TCL_BMAP_DIR_NATIVE)
+     AC_SUBST(TCL_TOOL_DIR_NATIVE)
+     AC_SUBST(TCL_PLATFORM_DIR_NATIVE)
+ 
+     AC_SUBST(TCL_INCLUDES)
+     AC_MSG_RESULT([Using srcdir found in tclConfig.sh: ${TCL_SRC_DIR}])
+ ])
+ 
+ #------------------------------------------------------------------------
+ # TEA_PUBLIC_TCL_HEADERS --
+ #
+ #	Locate the installed public Tcl header files
+ #
+ # Arguments:
+ #	None.
+ #
+ # Requires:
+ #	CYGPATH must be set
+ #
+ # Results:
+ #
+ #	Adds a --with-tclinclude switch to configure.
+ #	Result is cached.
+ #
+ #	Substs the following vars:
+ #		TCL_INCLUDES
+ #------------------------------------------------------------------------
+ 
+ AC_DEFUN([TEA_PUBLIC_TCL_HEADERS], [
+     AC_MSG_CHECKING([for Tcl public headers])
+ 
+     AC_ARG_WITH(tclinclude, [  --with-tclinclude       directory containing the public Tcl header files], with_tclinclude=${withval})
+ 
+     AC_CACHE_VAL(ac_cv_c_tclh, [
+ 	# Use the value from --with-tclinclude, if it was given
+ 
+ 	if test x"${with_tclinclude}" != x ; then
+ 	    if test -f "${with_tclinclude}/tcl.h" ; then
+ 		ac_cv_c_tclh=${with_tclinclude}
+ 	    else
+ 		AC_MSG_ERROR([${with_tclinclude} directory does not contain tcl.h])
+ 	    fi
+ 	else
+ 	    if test "`uname -s`" = "Darwin"; then
+ 		# If Tcl was built as a framework, attempt to use
+ 		# the framework's Headers directory
+ 		case ${TCL_DEFS} in
+ 		    *TCL_FRAMEWORK*)
+ 			list="`ls -d ${TCL_BIN_DIR}/Headers 2>/dev/null`"
+ 			;;
+ 		esac
+ 	    fi
+ 
+ 	    # Look in the source dir only if Tcl is not installed,
+ 	    # and in that situation, look there before installed locations.
+ 	    if test -f "${TCL_BIN_DIR}/Makefile" ; then
+ 		list="$list `ls -d ${TCL_SRC_DIR}/generic 2>/dev/null`"
+ 	    fi
+ 
+ 	    # Check order: pkg --prefix location, Tcl's --prefix location,
+ 	    # relative to directory of tclConfig.sh.
+ 
+ 	    eval "temp_includedir=${includedir}"
+ 	    list="$list \
+ 		`ls -d ${temp_includedir}        2>/dev/null` \
+ 		`ls -d ${TCL_PREFIX}/include     2>/dev/null` \
+ 		`ls -d ${TCL_BIN_DIR}/../include 2>/dev/null`"
+ 	    if test "${TEA_PLATFORM}" != "windows" -o "$GCC" = "yes"; then
+ 		list="$list /usr/local/include /usr/include"
+ 		if test x"${TCL_INCLUDE_SPEC}" != x ; then
+ 		    d=`echo "${TCL_INCLUDE_SPEC}" | sed -e 's/^-I//'`
+ 		    list="$list `ls -d ${d} 2>/dev/null`"
+ 		fi
+ 	    fi
+ 	    for i in $list ; do
+ 		if test -f "$i/tcl.h" ; then
+ 		    ac_cv_c_tclh=$i
+ 		    break
+ 		fi
+ 	    done
+ 	fi
+     ])
+ 
+     # Print a message based on how we determined the include path
+ 
+     if test x"${ac_cv_c_tclh}" = x ; then
+ 	AC_MSG_ERROR([tcl.h not found.  Please specify its location with --with-tclinclude])
+     else
+ 	AC_MSG_RESULT([${ac_cv_c_tclh}])
+     fi
+ 
+     # Convert to a native path and substitute into the output files.
+ 
+     INCLUDE_DIR_NATIVE=`${CYGPATH} ${ac_cv_c_tclh}`
+ 
+     TCL_INCLUDES=-I\"${INCLUDE_DIR_NATIVE}\"
+ 
+     AC_SUBST(TCL_INCLUDES)
+ ])
+ 
+ #------------------------------------------------------------------------
+ # TEA_PRIVATE_TK_HEADERS --
+ #
+ #	Locate the private Tk include files
+ #
+ # Arguments:
+ #
+ #	Requires:
+ #		TK_SRC_DIR	Assumes that TEA_LOAD_TKCONFIG has
+ #				 already been called.
+ #
+ # Results:
+ #
+ #	Substs the following vars:
+ #		TK_INCLUDES
+ #------------------------------------------------------------------------
+ 
+ AC_DEFUN([TEA_PRIVATE_TK_HEADERS], [
+     AC_MSG_CHECKING([for Tk private include files])
+ 
+     TK_SRC_DIR_NATIVE=`${CYGPATH} ${TK_SRC_DIR}`
+     TK_TOP_DIR_NATIVE=\"${TK_SRC_DIR_NATIVE}\"
+     TK_UNIX_DIR_NATIVE=\"${TK_SRC_DIR_NATIVE}/unix\"
+     TK_WIN_DIR_NATIVE=\"${TK_SRC_DIR_NATIVE}/win\"
+     TK_GENERIC_DIR_NATIVE=\"${TK_SRC_DIR_NATIVE}/generic\"
+     TK_XLIB_DIR_NATIVE=\"${TK_SRC_DIR_NATIVE}/xlib\"
+     if test "${TEA_PLATFORM}" = "windows"; then
+ 	TK_PLATFORM_DIR_NATIVE=${TK_WIN_DIR_NATIVE}
+     else
+ 	TK_PLATFORM_DIR_NATIVE=${TK_UNIX_DIR_NATIVE}
+     fi
+     # We want to ensure these are substituted so as not to require
+     # any *_NATIVE vars be defined in the Makefile
+     TK_INCLUDES="-I${TK_GENERIC_DIR_NATIVE} -I${TK_PLATFORM_DIR_NATIVE}"
+     # Detect and add ttk subdir
+     if test -d ${TK_SRC_DIR_NATIVE}/generic/ttk; then
+ 	TK_INCLUDES="${TK_INCLUDES} -I\"${TK_SRC_DIR_NATIVE}/generic/ttk\""
+     fi
+     if test "${TEA_WINDOWINGSYSTEM}" = "win32" \
+ 	-o "${TEA_WINDOWINGSYSTEM}" = "aqua"; then
+ 	TK_INCLUDES="${TK_INCLUDES} -I${TK_XLIB_DIR_NATIVE}"
+     fi
+     if test "${TEA_WINDOWINGSYSTEM}" = "aqua"; then
+ 	TK_INCLUDES="${TK_INCLUDES} -I${TK_SRC_DIR_NATIVE}/macosx"
+     fi
+     if test "`uname -s`" = "Darwin"; then
+         # If Tk was built as a framework, attempt to use
+         # the framework's Headers and PrivateHeaders directories
+         case ${TK_DEFS} in
+ 	    *TK_FRAMEWORK*)
+ 	        if test -d "${TK_BIN_DIR}/Headers" -a -d "${TK_BIN_DIR}/PrivateHeaders"; then
+ 	        TK_INCLUDES="-I\"${TK_BIN_DIR}/Headers\" -I\"${TK_BIN_DIR}/PrivateHeaders\" ${TK_INCLUDES}"; fi
+ 	        ;;
+ 	esac
+     else
+ 	if test ! -f "${TK_SRC_DIR}/generic/tkInt.h" ; then
+ 	    AC_MSG_ERROR([Cannot find private header tkInt.h in ${TK_SRC_DIR}])
+ 	fi
+     fi
+ 
+     AC_SUBST(TK_TOP_DIR_NATIVE)
+     AC_SUBST(TK_UNIX_DIR_NATIVE)
+     AC_SUBST(TK_WIN_DIR_NATIVE)
+     AC_SUBST(TK_GENERIC_DIR_NATIVE)
+     AC_SUBST(TK_XLIB_DIR_NATIVE)
+     AC_SUBST(TK_PLATFORM_DIR_NATIVE)
+ 
+     AC_SUBST(TK_INCLUDES)
+     AC_MSG_RESULT([Using srcdir found in tkConfig.sh: ${TK_SRC_DIR}])
+ ])
+ 
+ #------------------------------------------------------------------------
+ # TEA_PUBLIC_TK_HEADERS --
+ #
+ #	Locate the installed public Tk header files
+ #
+ # Arguments:
+ #	None.
+ #
+ # Requires:
+ #	CYGPATH must be set
+ #
+ # Results:
+ #
+ #	Adds a --with-tkinclude switch to configure.
+ #	Result is cached.
+ #
+ #	Substs the following vars:
+ #		TK_INCLUDES
+ #------------------------------------------------------------------------
+ 
+ AC_DEFUN([TEA_PUBLIC_TK_HEADERS], [
+     AC_MSG_CHECKING([for Tk public headers])
+ 
+     AC_ARG_WITH(tkinclude, [  --with-tkinclude        directory containing the public Tk header files], with_tkinclude=${withval})
+ 
+     AC_CACHE_VAL(ac_cv_c_tkh, [
+ 	# Use the value from --with-tkinclude, if it was given
+ 
+ 	if test x"${with_tkinclude}" != x ; then
+ 	    if test -f "${with_tkinclude}/tk.h" ; then
+ 		ac_cv_c_tkh=${with_tkinclude}
+ 	    else
+ 		AC_MSG_ERROR([${with_tkinclude} directory does not contain tk.h])
+ 	    fi
+ 	else
+ 	    if test "`uname -s`" = "Darwin"; then
+ 		# If Tk was built as a framework, attempt to use
+ 		# the framework's Headers directory.
+ 		case ${TK_DEFS} in
+ 		    *TK_FRAMEWORK*)
+ 			list="`ls -d ${TK_BIN_DIR}/Headers 2>/dev/null`"
+ 			;;
+ 		esac
+ 	    fi
+ 
+ 	    # Look in the source dir only if Tk is not installed,
+ 	    # and in that situation, look there before installed locations.
+ 	    if test -f "${TK_BIN_DIR}/Makefile" ; then
+ 		list="$list `ls -d ${TK_SRC_DIR}/generic 2>/dev/null`"
+ 	    fi
+ 
+ 	    # Check order: pkg --prefix location, Tk's --prefix location,
+ 	    # relative to directory of tkConfig.sh, Tcl's --prefix location, 
+ 	    # relative to directory of tclConfig.sh.
+ 
+ 	    eval "temp_includedir=${includedir}"
+ 	    list="$list \
+ 		`ls -d ${temp_includedir}        2>/dev/null` \
+ 		`ls -d ${TK_PREFIX}/include      2>/dev/null` \
+ 		`ls -d ${TK_BIN_DIR}/../include  2>/dev/null` \
+ 		`ls -d ${TCL_PREFIX}/include     2>/dev/null` \
+ 		`ls -d ${TCL_BIN_DIR}/../include 2>/dev/null`"
+ 	    if test "${TEA_PLATFORM}" != "windows" -o "$GCC" = "yes"; then
+ 		list="$list /usr/local/include /usr/include"
+ 	    fi
+ 	    for i in $list ; do
+ 		if test -f "$i/tk.h" ; then
+ 		    ac_cv_c_tkh=$i
+ 		    break
+ 		fi
+ 	    done
+ 	fi
+     ])
+ 
+     # Print a message based on how we determined the include path
+ 
+     if test x"${ac_cv_c_tkh}" = x ; then
+ 	AC_MSG_ERROR([tk.h not found.  Please specify its location with --with-tkinclude])
+     else
+ 	AC_MSG_RESULT([${ac_cv_c_tkh}])
+     fi
+ 
+     # Convert to a native path and substitute into the output files.
+ 
+     INCLUDE_DIR_NATIVE=`${CYGPATH} ${ac_cv_c_tkh}`
+ 
+     TK_INCLUDES=-I\"${INCLUDE_DIR_NATIVE}\"
+ 
+     AC_SUBST(TK_INCLUDES)
+ 
+     if test "${TEA_WINDOWINGSYSTEM}" = "win32" \
+ 	-o "${TEA_WINDOWINGSYSTEM}" = "aqua"; then
+ 	# On Windows and Aqua, we need the X compat headers
+ 	AC_MSG_CHECKING([for X11 header files])
+ 	if test ! -r "${INCLUDE_DIR_NATIVE}/X11/Xlib.h"; then
+ 	    INCLUDE_DIR_NATIVE="`${CYGPATH} ${TK_SRC_DIR}/xlib`"
+ 	    TK_XINCLUDES=-I\"${INCLUDE_DIR_NATIVE}\"
+ 	    AC_SUBST(TK_XINCLUDES)
+ 	fi
+ 	AC_MSG_RESULT([${INCLUDE_DIR_NATIVE}])
+     fi
+ ])
+ 
+ #------------------------------------------------------------------------
+ # TEA_PATH_CONFIG --
+ #
+ #	Locate the ${1}Config.sh file and perform a sanity check on
+ #	the ${1} compile flags.  These are used by packages like
+ #	[incr Tk] that load *Config.sh files from more than Tcl and Tk.
+ #
+ # Arguments:
+ #	none
+ #
+ # Results:
+ #
+ #	Adds the following arguments to configure:
+ #		--with-$1=...
+ #
+ #	Defines the following vars:
+ #		$1_BIN_DIR	Full path to the directory containing
+ #				the $1Config.sh file
+ #------------------------------------------------------------------------
+ 
+ AC_DEFUN([TEA_PATH_CONFIG], [
+     #
+     # Ok, lets find the $1 configuration
+     # First, look for one uninstalled.
+     # the alternative search directory is invoked by --with-$1
+     #
+ 
+     if test x"${no_$1}" = x ; then
+ 	# we reset no_$1 in case something fails here
+ 	no_$1=true
+ 	AC_ARG_WITH($1, [  --with-$1              directory containing $1 configuration ($1Config.sh)], with_$1config=${withval})
+ 	AC_MSG_CHECKING([for $1 configuration])
+ 	AC_CACHE_VAL(ac_cv_c_$1config,[
+ 
+ 	    # First check to see if --with-$1 was specified.
+ 	    if test x"${with_$1config}" != x ; then
+ 		case ${with_$1config} in
+ 		    */$1Config.sh )
+ 			if test -f ${with_$1config}; then
+ 			    AC_MSG_WARN([--with-$1 argument should refer to directory containing $1Config.sh, not to $1Config.sh itself])
+ 			    with_$1config=`echo ${with_$1config} | sed 's!/$1Config\.sh$!!'`
+ 			fi;;
+ 		esac
+ 		if test -f "${with_$1config}/$1Config.sh" ; then
+ 		    ac_cv_c_$1config=`(cd ${with_$1config}; pwd)`
+ 		else
+ 		    AC_MSG_ERROR([${with_$1config} directory doesn't contain $1Config.sh])
+ 		fi
+ 	    fi
+ 
+ 	    # then check for a private $1 installation
+ 	    if test x"${ac_cv_c_$1config}" = x ; then
+ 		for i in \
+ 			../$1 \
+ 			`ls -dr ../$1*[[0-9]].[[0-9]]*.[[0-9]]* 2>/dev/null` \
+ 			`ls -dr ../$1*[[0-9]].[[0-9]][[0-9]] 2>/dev/null` \
+ 			`ls -dr ../$1*[[0-9]].[[0-9]] 2>/dev/null` \
+ 			`ls -dr ../$1*[[0-9]].[[0-9]]* 2>/dev/null` \
+ 			../../$1 \
+ 			`ls -dr ../../$1*[[0-9]].[[0-9]]*.[[0-9]]* 2>/dev/null` \
+ 			`ls -dr ../../$1*[[0-9]].[[0-9]][[0-9]] 2>/dev/null` \
+ 			`ls -dr ../../$1*[[0-9]].[[0-9]] 2>/dev/null` \
+ 			`ls -dr ../../$1*[[0-9]].[[0-9]]* 2>/dev/null` \
+ 			../../../$1 \
+ 			`ls -dr ../../../$1*[[0-9]].[[0-9]]*.[[0-9]]* 2>/dev/null` \
+ 			`ls -dr ../../../$1*[[0-9]].[[0-9]][[0-9]] 2>/dev/null` \
+ 			`ls -dr ../../../$1*[[0-9]].[[0-9]] 2>/dev/null` \
+ 			`ls -dr ../../../$1*[[0-9]].[[0-9]]* 2>/dev/null` \
+ 			${srcdir}/../$1 \
+ 			`ls -dr ${srcdir}/../$1*[[0-9]].[[0-9]]*.[[0-9]]* 2>/dev/null` \
+ 			`ls -dr ${srcdir}/../$1*[[0-9]].[[0-9]][[0-9]] 2>/dev/null` \
+ 			`ls -dr ${srcdir}/../$1*[[0-9]].[[0-9]] 2>/dev/null` \
+ 			`ls -dr ${srcdir}/../$1*[[0-9]].[[0-9]]* 2>/dev/null` \
+ 			; do
+ 		    if test -f "$i/$1Config.sh" ; then
+ 			ac_cv_c_$1config=`(cd $i; pwd)`
+ 			break
+ 		    fi
+ 		    if test -f "$i/unix/$1Config.sh" ; then
+ 			ac_cv_c_$1config=`(cd $i/unix; pwd)`
+ 			break
+ 		    fi
+ 		done
+ 	    fi
+ 
+ 	    # check in a few common install locations
+ 	    if test x"${ac_cv_c_$1config}" = x ; then
+ 		for i in `ls -d ${libdir} 2>/dev/null` \
+ 			`ls -d ${exec_prefix}/lib 2>/dev/null` \
+ 			`ls -d ${prefix}/lib 2>/dev/null` \
+ 			`ls -d /usr/local/lib 2>/dev/null` \
+ 			`ls -d /usr/contrib/lib 2>/dev/null` \
+ 			`ls -d /usr/lib 2>/dev/null` \
+ 			; do
+ 		    if test -f "$i/$1Config.sh" ; then
+ 			ac_cv_c_$1config=`(cd $i; pwd)`
+ 			break
+ 		    fi
+ 		done
+ 	    fi
+ 	])
+ 
+ 	if test x"${ac_cv_c_$1config}" = x ; then
+ 	    $1_BIN_DIR="# no $1 configs found"
+ 	    AC_MSG_WARN([Cannot find $1 configuration definitions])
+ 	    exit 0
+ 	else
+ 	    no_$1=
+ 	    $1_BIN_DIR=${ac_cv_c_$1config}
+ 	    AC_MSG_RESULT([found $$1_BIN_DIR/$1Config.sh])
+ 	fi
+     fi
+ ])
+ 
+ #------------------------------------------------------------------------
+ # TEA_LOAD_CONFIG --
+ #
+ #	Load the $1Config.sh file
+ #
+ # Arguments:
+ #	
+ #	Requires the following vars to be set:
+ #		$1_BIN_DIR
+ #
+ # Results:
+ #
+ #	Subst the following vars:
+ #		$1_SRC_DIR
+ #		$1_LIB_FILE
+ #		$1_LIB_SPEC
+ #
+ #------------------------------------------------------------------------
+ 
+ AC_DEFUN([TEA_LOAD_CONFIG], [
+     AC_MSG_CHECKING([for existence of ${$1_BIN_DIR}/$1Config.sh])
+ 
+     if test -f "${$1_BIN_DIR}/$1Config.sh" ; then
+         AC_MSG_RESULT([loading])
+ 	. "${$1_BIN_DIR}/$1Config.sh"
+     else
+         AC_MSG_RESULT([file not found])
+     fi
+ 
+     #
+     # If the $1_BIN_DIR is the build directory (not the install directory),
+     # then set the common variable name to the value of the build variables.
+     # For example, the variable $1_LIB_SPEC will be set to the value
+     # of $1_BUILD_LIB_SPEC. An extension should make use of $1_LIB_SPEC
+     # instead of $1_BUILD_LIB_SPEC since it will work with both an
+     # installed and uninstalled version of Tcl.
+     #
+ 
+     if test -f "${$1_BIN_DIR}/Makefile" ; then
+ 	AC_MSG_WARN([Found Makefile - using build library specs for $1])
+         $1_LIB_SPEC=${$1_BUILD_LIB_SPEC}
+         $1_STUB_LIB_SPEC=${$1_BUILD_STUB_LIB_SPEC}
+         $1_STUB_LIB_PATH=${$1_BUILD_STUB_LIB_PATH}
+     fi
+ 
+     AC_SUBST($1_VERSION)
+     AC_SUBST($1_BIN_DIR)
+     AC_SUBST($1_SRC_DIR)
+ 
+     AC_SUBST($1_LIB_FILE)
+     AC_SUBST($1_LIB_SPEC)
+ 
+     AC_SUBST($1_STUB_LIB_FILE)
+     AC_SUBST($1_STUB_LIB_SPEC)
+     AC_SUBST($1_STUB_LIB_PATH)
+ ])
+ 
+ #------------------------------------------------------------------------
+ # TEA_PATH_CELIB --
+ #
+ #	Locate Keuchel's celib emulation layer for targeting Win/CE
+ #
+ # Arguments:
+ #	none
+ #
+ # Results:
+ #
+ #	Adds the following arguments to configure:
+ #		--with-celib=...
+ #
+ #	Defines the following vars:
+ #		CELIB_DIR	Full path to the directory containing
+ #				the include and platform lib files
+ #------------------------------------------------------------------------
+ 
+ AC_DEFUN([TEA_PATH_CELIB], [
+     # First, look for one uninstalled.
+     # the alternative search directory is invoked by --with-celib
+ 
+     if test x"${no_celib}" = x ; then
+ 	# we reset no_celib in case something fails here
+ 	no_celib=true
+ 	AC_ARG_WITH(celib,[  --with-celib=DIR        use Windows/CE support library from DIR], with_celibconfig=${withval})
+ 	AC_MSG_CHECKING([for Windows/CE celib directory])
+ 	AC_CACHE_VAL(ac_cv_c_celibconfig,[
+ 	    # First check to see if --with-celibconfig was specified.
+ 	    if test x"${with_celibconfig}" != x ; then
+ 		if test -d "${with_celibconfig}/inc" ; then
+ 		    ac_cv_c_celibconfig=`(cd ${with_celibconfig}; pwd)`
+ 		else
+ 		    AC_MSG_ERROR([${with_celibconfig} directory doesn't contain inc directory])
+ 		fi
+ 	    fi
+ 
+ 	    # then check for a celib library
+ 	    if test x"${ac_cv_c_celibconfig}" = x ; then
+ 		for i in \
+ 			../celib-palm-3.0 \
+ 			../celib \
+ 			../../celib-palm-3.0 \
+ 			../../celib \
+ 			`ls -dr ../celib-*3.[[0-9]]* 2>/dev/null` \
+ 			${srcdir}/../celib-palm-3.0 \
+ 			${srcdir}/../celib \
+ 			`ls -dr ${srcdir}/../celib-*3.[[0-9]]* 2>/dev/null` \
+ 			; do
+ 		    if test -d "$i/inc" ; then
+ 			ac_cv_c_celibconfig=`(cd $i; pwd)`
+ 			break
+ 		    fi
+ 		done
+ 	    fi
+ 	])
+ 	if test x"${ac_cv_c_celibconfig}" = x ; then
+ 	    AC_MSG_ERROR([Cannot find celib support library directory])
+ 	else
+ 	    no_celib=
+ 	    CELIB_DIR=${ac_cv_c_celibconfig}
+ 	    CELIB_DIR=`echo "$CELIB_DIR" | sed -e 's!\\\!/!g'`
+ 	    AC_MSG_RESULT([found $CELIB_DIR])
+ 	fi
+     fi
+ ])
+ 
+ 
+ # Local Variables:
+ # mode: autoconf
+ # End:
diff -rNc gdal-1.6.1/swig/GNUmakefile gdal-1.6.1-patched/swig/GNUmakefile
*** gdal-1.6.1/swig/GNUmakefile	2007-11-15 18:01:02.000000000 +0200
--- gdal-1.6.1-patched/swig/GNUmakefile	2009-06-30 15:38:24.000000000 +0300
***************
*** 6,12 ****
  
  # The ALL_BINDINGS variable defines all the possible bindings.  It's used
  # in the dist and clean definitions.
! ALL_BINDINGS = python php csharp ruby perl java
  
  default: generate
  
--- 6,12 ----
  
  # The ALL_BINDINGS variable defines all the possible bindings.  It's used
  # in the dist and clean definitions.
! ALL_BINDINGS = python php csharp ruby perl java tcl
  
  default: generate
  
diff -rNc gdal-1.6.1/swig/include/tcl/gdal_tcl.i gdal-1.6.1-patched/swig/include/tcl/gdal_tcl.i
*** gdal-1.6.1/swig/include/tcl/gdal_tcl.i	1970-01-01 02:00:00.000000000 +0200
--- gdal-1.6.1-patched/swig/include/tcl/gdal_tcl.i	2009-06-29 17:07:20.000000000 +0300
***************
*** 0 ****
--- 1,98 ----
+ /*
+  *
+  * tcl specific code for gdal bindings.
+  */
+ 
+ 
+ %init %{
+   /* gdal_tcl.i %init code */
+   if ( GDALGetDriverCount() == 0 ) {
+     GDALAllRegister();
+   }
+ 
+   /* Setup exception handling */
+   UseExceptions();
+ %}
+ 
+ %rename (DataTypeUnion) GDALDataTypeUnion;
+ GDALDataType GDALDataTypeUnion( GDALDataType, GDALDataType );
+ 
+ %include "cpl_exceptions.i";
+ 
+ %extend GDAL_GCP {
+ }
+ 
+ %extend GDALRasterBandShadow {
+ }
+ 
+ %extend GDALDatasetShadow {
+ }
+ 
+ %extend GDALMajorObjectShadow {
+ }
+ 
+ %extend GDALDriverShadow {
+ /*
+     const char *GetShortName() {
+         return GDALGetDriverShortName(self);
+     }
+ */
+ }
+ 
+ /* ==================================================================== */
+ /*	Support function for progress callbacks to tcl.                     */
+ /* ==================================================================== */
+ 
+ %{
+ 
+ typedef struct {
+     Tcl_Interp *interp;
+     Tcl_Obj *psTclCallback;
+     Tcl_Obj *psTclCallbackData;
+     int nLastReported;
+ } TclProgressData;
+ 
+ 
+ /************************************************************************/
+ /*                         TclProgressProxy()                           */
+ /************************************************************************/
+ 
+ int CPL_STDCALL
+ TclProgressProxy( double dfComplete, const char *pszMessage, void *pData )
+ {
+     TclProgressData *psInfo = (TclProgressData *) pData;
+ 
+     if( psInfo->nLastReported == (int) (100.0 * dfComplete) )
+         return TRUE;
+ 
+     if( psInfo->psTclCallback == NULL || !strcmp(Tcl_GetString(psInfo->psTclCallback), "") )
+         return TRUE;
+ 
+     psInfo->nLastReported = (int) (100.0 * dfComplete);
+ 
+     if( pszMessage == NULL )
+         pszMessage = "";
+ 
+     Tcl_Obj *objv[4];
+     objv[0] = psInfo->psTclCallback;
+     objv[1] = Tcl_NewDoubleObj(dfComplete);
+     objv[2] = Tcl_NewStringObj(pszMessage, -1);
+     objv[3] = psInfo->psTclCallbackData;
+ 
+     int psResult;
+     if( psInfo->psTclCallbackData == NULL )
+         psResult = Tcl_EvalObjv( psInfo->interp, 3, objv, TCL_EVAL_GLOBAL ); 
+     else
+         psResult = Tcl_EvalObjv( psInfo->interp, 4, objv, TCL_EVAL_GLOBAL ); 
+ 
+     Tcl_DecrRefCount(objv[1]);
+     Tcl_DecrRefCount(objv[2]);
+ 
+     if( psResult == TCL_BREAK )
+         return FALSE;
+ 
+     return TRUE;
+ }
+ %}
+ 
+ %import typemaps_tcl.i
diff -rNc gdal-1.6.1/swig/include/tcl/ogr_tcl.i gdal-1.6.1-patched/swig/include/tcl/ogr_tcl.i
*** gdal-1.6.1/swig/include/tcl/ogr_tcl.i	1970-01-01 02:00:00.000000000 +0200
--- gdal-1.6.1-patched/swig/include/tcl/ogr_tcl.i	2009-06-29 15:21:09.000000000 +0300
***************
*** 0 ****
--- 1,49 ----
+ /*
+  *
+  * tcl specific code for ogr bindings.
+  */
+ 
+ %include "cpl_exceptions.i";
+ 
+ %init %{
+   /* ogr_tcl.i %init code */
+   if ( OGRGetDriverCount() == 0 ) {
+     OGRRegisterAll();
+   }
+   
+   /* Setup exception handling */
+   UseExceptions();
+ %}
+ 
+ 
+ %rename (GetDriverCount) OGRGetDriverCount;
+ %rename (GetOpenDSCount) OGRGetOpenDSCount;
+ %rename (SetGenerate_DB2_V72_BYTE_ORDER) OGRSetGenerate_DB2_V72_BYTE_ORDER;
+ %rename (RegisterAll) OGRRegisterAll();
+ 
+ %extend OGRDataSourceShadow {
+ //SWIG_exception(SWIG_TypeError, "Value must be a string or integer.");
+ }
+ 
+ %extend OGRLayerShadow {
+ 
+ }
+ 
+ %extend OGRFeatureShadow {
+ 
+ }
+ 
+ %extend OGRGeometryShadow {
+ }
+ 
+ 
+ %extend OGRFieldDefnShadow {
+ }
+ 
+ %extend OGRFeatureDefnShadow {
+ }
+ 
+ %extend OGRFieldDefnShadow {
+ }
+ 
+ %import typemaps_tcl.i
diff -rNc gdal-1.6.1/swig/include/tcl/osr_tcl.i gdal-1.6.1-patched/swig/include/tcl/osr_tcl.i
*** gdal-1.6.1/swig/include/tcl/osr_tcl.i	1970-01-01 02:00:00.000000000 +0200
--- gdal-1.6.1-patched/swig/include/tcl/osr_tcl.i	2009-06-29 14:59:36.000000000 +0300
***************
*** 0 ****
--- 1,104 ----
+ /*
+  *
+  * tcl specific code for osr bindings.
+  */
+ 
+ 
+ %include "cpl_exceptions.i";
+ 
+ %{
+ static Tcl_Obj *
+ tcl_OPTGetProjectionMethods(Tcl_Obj *self, Tcl_Obj *args) {
+     Tcl_Obj *MList;
+     char     **papszMethods;
+     int      iMethod;
+ 
+     self = self;
+     args = args;
+ 
+     papszMethods = OPTGetProjectionMethods();
+     MList = Tcl_NewListObj(0, NULL);
+ 
+     for( iMethod = 0; papszMethods[iMethod] != NULL; iMethod++ ) {
+         char    *pszUserMethodName;
+         char    **papszParameters;
+         Tcl_Obj *PList;
+         Tcl_Obj *val;
+         int       iParam;
+ 
+         papszParameters = OPTGetParameterList( papszMethods[iMethod],
+                 &pszUserMethodName );
+         if( papszParameters == NULL )
+             return NULL;
+ 
+         PList = Tcl_NewListObj(0, NULL);
+         for( iParam = 0; papszParameters[iParam] != NULL; iParam++ ) {
+             char    *pszType;
+             char    *pszUserParamName;
+             double  dfDefault;
+ 
+             OPTGetParameterInfo( papszMethods[iMethod],
+                     papszParameters[iParam],
+                     &pszUserParamName,
+                     &pszType, &dfDefault );
+ 
+             val = Tcl_NewStringObj( papszParameters[iParam], -1 );
+             if (Tcl_ListObjAppendElement(NULL, PList, val) != TCL_OK) {
+                 Tcl_DecrRefCount(val);
+                 Tcl_DecrRefCount(PList);
+                 Tcl_DecrRefCount(MList);
+                 return NULL; /* signifies error */
+             }
+             val = Tcl_NewStringObj( pszUserParamName, -1 );
+             if (Tcl_ListObjAppendElement(NULL, PList, val) != TCL_OK) {
+                 Tcl_DecrRefCount(val);
+                 Tcl_DecrRefCount(PList);
+                 Tcl_DecrRefCount(MList);
+                 return NULL; /* signifies error */
+             }
+             val = Tcl_NewStringObj( pszType, -1 );
+             if (Tcl_ListObjAppendElement(NULL, PList, val) != TCL_OK) {
+                 Tcl_DecrRefCount(val);
+                 Tcl_DecrRefCount(PList);
+                 Tcl_DecrRefCount(MList);
+                 return NULL; /* signifies error */
+             }
+             val = Tcl_NewDoubleObj( dfDefault );
+             if (Tcl_ListObjAppendElement(NULL, PList, val) != TCL_OK) {
+                 Tcl_DecrRefCount(val);
+                 Tcl_DecrRefCount(PList);
+                 Tcl_DecrRefCount(MList);
+                 return NULL; /* signifies error */
+             }
+         }
+ 
+         CSLDestroy( papszParameters );
+ 
+         val = Tcl_NewStringObj( papszMethods[iMethod], -1 );
+         if (Tcl_ListObjAppendElement(NULL, MList, val) != TCL_OK) {
+             Tcl_DecrRefCount(val);
+             Tcl_DecrRefCount(PList);
+             Tcl_DecrRefCount(MList);
+             return NULL; /* signifies error */
+         }
+         val = Tcl_NewStringObj( pszUserMethodName, -1 );
+         if (Tcl_ListObjAppendElement(NULL, MList, val) != TCL_OK) {
+             Tcl_DecrRefCount(val);
+             Tcl_DecrRefCount(PList);
+             Tcl_DecrRefCount(MList);
+             return NULL; /* signifies error */
+         }
+         if (Tcl_ListObjAppendElement(NULL, MList, PList) != TCL_OK) {
+             Tcl_DecrRefCount(PList);
+             Tcl_DecrRefCount(MList);
+             return NULL; /* signifies error */
+         }
+     }
+ 
+     CSLDestroy( papszMethods );
+ 
+     return MList;
+ %}
+ %native(GetProjectionMethods) tcl_OPTGetProjectionMethods;
+ 
+ %include typemaps_tcl.i
diff -rNc gdal-1.6.1/swig/include/tcl/typemaps_tcl.i gdal-1.6.1-patched/swig/include/tcl/typemaps_tcl.i
*** gdal-1.6.1/swig/include/tcl/typemaps_tcl.i	1970-01-01 02:00:00.000000000 +0200
--- gdal-1.6.1-patched/swig/include/tcl/typemaps_tcl.i	2009-06-28 16:57:10.000000000 +0300
***************
*** 0 ****
--- 1,1437 ----
+ /******************************************************************************
+  *
+  * Name:     typemaps_tcl.i
+  * Project:  GDAL Tcl Interface
+  * Purpose:  GDAL Core SWIG Interface declarations.
+  * Author:   Alexandros Stergiakis, alsterg@gmail.com
+  *
+ */
+ // XXX find a better way for this:
+ //  if (!strcmp(Tcl_GetString($input), "")) 
+ 
+ /*
+  * Include the typemaps from swig library for returning of
+  * standard types through arguments.
+  */
+ %include "typemaps.i"
+ 
+ %apply (double *OUTPUT) { double *argout };
+ 
+ /*
+  * double *val, int*hasval, is a special contrived typemap used for
+  * the RasterBand GetNoDataValue, GetMinimum, GetMaximum, GetOffset, GetScale methods.
+  * In the tcl bindings, the variable hasval is tested.  If it is 0 (is, the value
+  * is not set in the raster band) then an empty list is returned.  If is is != 0, then
+  * the value is coerced into a long and returned.
+  */
+ %typemap(in,numinputs=0) (double *val, int*hasval) ( double tmpval, int tmphasval ) {
+   /* %typemap(tcl,in,numinputs=0) (double *val, int*hasval) */
+   $1 = &tmpval;
+   $2 = &tmphasval;
+ }
+ %typemap(argout) (double *val, int*hasval) {
+   /* %typemap(tcl,argout) (double *val, int*hasval) */
+   Tcl_Obj *r;
+   if ( !*$2 ) {
+     r = Tcl_NewObj(); /* NONE */
+   } else {
+     r = Tcl_NewDoubleObj( *$1 );
+   }
+   %append_output(r);
+ }
+ 
+ /*
+  *
+  * Define a simple return code typemap which checks if the return code from
+  * the wrapped method is non-zero. If zero, return None.  Otherwise,
+  * return any argout or None.
+  *
+  * Applied like this:
+  * %apply (IF_FALSE_RETURN_NONE) {int};
+  * int function_to_wrap( );
+  * %clear (int);
+  */
+ /*
+  * The out typemap prevents the default typemap for output integers from
+  * applying.
+  */
+ %typemap(out) IF_FALSE_RETURN_NONE "/*%typemap(out) IF_FALSE_RETURN_NONE */"
+ %typemap(ret) IF_FALSE_RETURN_NONE
+ {
+  /* %typemap(ret) IF_FALSE_RETURN_NONE */
+   if ($1 == 0 ) {
+     Tcl_ResetResult(interp); /* NONE = Empty string */
+   }
+ }
+ 
+ 
+ %typemap(out) IF_ERROR_RETURN_NONE
+ {
+   /* %typemap(out) IF_ERROR_RETURN_NONE */
+   /* (do not return the error code) */
+ }
+ 
+ 
+ /* --------  OGR Error Handling --------------- */
+ %import "ogr_error_map.i"
+ 
+ %typemap(out,fragment="OGRErrMessages") OGRErr
+ {
+   /* %typemap(out) OGRErr */
+   if (result != 0) {
+     Tcl_SetResult(interp, (char*) OGRErrMessages(result), TCL_STATIC);
+     SWIG_fail;
+   }
+ }
+ 
+ %typemap(ret) OGRErr
+ {
+   /* %typemap(ret) OGRErr */
+   if (!strcmp(Tcl_GetStringResult(interp), "{}") || !strcmp(Tcl_GetStringResult(interp), "")) {
+     Tcl_SetObjResult(interp, Tcl_NewLongObj( $1 ));
+   }
+ }
+ 
+ %fragment("CreateListFromDoubleArray","header") %{
+ static Tcl_Obj*
+ CreateListFromDoubleArray(Tcl_Interp *interp, double *first, unsigned int size ) {
+   Tcl_Obj *out = Tcl_NewListObj(0, NULL);
+   for( unsigned int i=0; i<size; i++ ) {
+     Tcl_Obj *val = Tcl_NewDoubleObj( *first );
+     ++first;
+     if (Tcl_ListObjAppendElement(interp, out, val) != TCL_OK) {
+         Tcl_DecrRefCount(val);
+         Tcl_DecrRefCount(out);
+         /* Error msg in interp result */
+         return NULL; /* signifies error */
+     }
+   }
+   return out;
+ }
+ %}
+ 
+ %typemap(in,numinputs=0) ( double argout[ANY]) (double argout[$dim0])
+ {
+   /* %typemap(in,numinputs=0) (double argout[ANY]) */
+   $1 = argout;
+ }
+ %typemap(argout,fragment="CreateListFromDoubleArray") ( double argout[ANY])
+ {
+   /* %typemap(argout) (double argout[ANY]) */
+   Tcl_Obj *out = CreateListFromDoubleArray( interp, $1, $dim0 );
+   if (out == NULL) SWIG_fail;
+   %append_output(out);
+ }
+ 
+ %typemap(in,numinputs=0) ( double *argout[ANY]) (double *argout)
+ {
+   /* %typemap(in,numinputs=0) (double *argout[ANY]) */
+   $1 = &argout;
+ }
+ %typemap(argout,fragment="CreateListFromDoubleArray") ( double *argout[ANY])
+ {
+   /* %typemap(argout) (double *argout[ANY]) */
+   Tcl_Obj *out = CreateListFromDoubleArray( interp, *$1, $dim0 );
+   if (out == NULL) SWIG_fail;
+   %append_output(out);
+ }
+ %typemap(freearg) (double *argout[ANY])
+ {
+   /* %typemap(freearg) (double *argout[ANY]) */
+   CPLFree(*$1);
+ }
+ %typemap(in) (double argin[ANY]) (double argin[$dim0])
+ {
+   /* %typemap(in) (double argin[ANY]) */
+   $1 = argin;
+   int lst_size;
+   /* The following also checks if input is a list */
+   if (Tcl_ListObjLength(interp, $input, &lst_size) != TCL_OK) {
+     /* Error msg in interp result */
+     SWIG_fail;
+   }
+   if ( lst_size != $dim0 ) {
+     Tcl_SetResult(interp, (char*) "List must have length ##size", TCL_STATIC);
+     SWIG_fail;
+   }
+   for (unsigned int i=0; i<$dim0; i++) {
+     Tcl_Obj **o = NULL;
+     if (Tcl_ListObjIndex(interp, $input, i, o) != TCL_OK) { /* ref count is not incremented */
+         /* Error msg in interp result */
+         SWIG_fail;
+     }
+ 
+     double val;
+     if (Tcl_GetDoubleFromObj(interp, *o, &val ) != TCL_OK) {
+         /* Error msg in interp result */
+         SWIG_fail;
+     }
+     $1[i] = val;
+   }
+ }
+ 
+ /*
+  *  Typemap for counted arrays of ints <- list
+  */
+ %typemap(in,numinputs=1) (int nList, int* pList)
+ {
+   /* %typemap(in,numinputs=1) (int nList, int* pList)*/
+   /* The following also checks if input is a list */
+   if (Tcl_ListObjLength(interp, $input, &$1) != TCL_OK) {
+     /* Error msg in interp result */
+     SWIG_fail;
+   }
+   if ( !$1 ) {
+       Tcl_SetResult(interp, (char*) "Input list mustn't be empty", TCL_STATIC);
+       SWIG_fail;
+   }
+ 
+   $2 = (int*) CPLMalloc($1*sizeof(int));
+ 
+   for( int i = 0; i<$1; i++ ) {
+     Tcl_Obj **o = NULL;
+     if (Tcl_ListObjIndex(interp, $input, i, o) != TCL_OK) { /* ref count is not incremented */
+         /* Error msg in interp result */
+         SWIG_fail;
+     }
+ 
+     int val;
+     if (Tcl_GetIntFromObj(interp, *o, &val ) != TCL_OK) {
+         /* Error msg in interp result */
+         SWIG_fail;
+     }
+     $2[i] = val;
+   }
+ }
+ 
+ %typemap(freearg) (int nList, int* pList)
+ {
+   /* %typemap(freearg) (int nList, int* pList) */
+   if ($2) {
+     CPLFree((void*) $2);
+   }
+ }
+ 
+ /*
+  *  Typemap for counted arrays of doubles <- list
+  */
+ %typemap(in,numinputs=1) (int nList, double* pList)
+ {
+   /* %typemap(in,numinputs=1) (int nList, double* pList)*/
+   /* The following also checks if input is a list */
+   if (Tcl_ListObjLength(interp, $input, &$1) != TCL_OK) {
+     /* Error msg in interp result */
+     SWIG_fail;
+   }
+   if ( !$1 ) {
+       Tcl_SetResult(interp, (char*) "Input list mustn't be empty", TCL_STATIC);
+       SWIG_fail;
+   }
+ 
+   $2 = (double*) CPLMalloc($1*sizeof(double));
+ 
+   for( int i = 0; i<$1; i++ ) {
+     Tcl_Obj **o = NULL;
+     if (Tcl_ListObjIndex(interp, $input, i, o) != TCL_OK) { /* ref count is not incremented */
+         /* Error msg in interp result */
+         SWIG_fail;
+     }
+ 
+     double val;
+     if (Tcl_GetDoubleFromObj(interp, *o, &val ) != TCL_OK) {
+         /* Error msg in interp result */
+         SWIG_fail;
+     }
+     $2[i] = val;
+   }
+ }
+ 
+ %typemap(freearg) (int nList, double* pList)
+ {
+   /* %typemap(freearg) (int nList, double* pList) */
+   if ($2) {
+     CPLFree((void*) $2);
+   }
+ }
+ 
+ /*
+  * Typemap for buffers with length <-> string
+  * Used in Band::ReadRaster() and Band::WriteRaster()
+  *
+  * This typemap has a typecheck also since the WriteRaster()
+  * methods are overloaded.
+  */
+ %typemap(in,numinputs=0) (int *nLen, char **pBuf ) ( int nLen = 0, char *pBuf = 0 )
+ {
+   /* %typemap(in,numinputs=0) (int *nLen, char **pBuf ) */
+   $1 = &nLen;
+   $2 = &pBuf;
+ }
+ %typemap(argout) (int *nLen, char **pBuf )
+ {
+   /* %typemap(argout) (int *nLen, char **pBuf ) */
+   Tcl_SetObjResult(interp, Tcl_NewStringObj( *$2, *$1 ));
+ }
+ %typemap(freearg) (int *nLen, char **pBuf )
+ {
+   /* %typemap(freearg) (int *nLen, char **pBuf ) */
+   if( *$1 ) {
+     CPLFree( *$2 );
+   }
+ }
+ %typemap(in,numinputs=1) (int nLen, char *pBuf )
+ {
+   /* %typemap(in,numinputs=1) (int nLen, char *pBuf ) */
+   /* Storage is handled by the respective Tcl_Obj. It should considered read-only. */
+   $2 = Tcl_GetStringFromObj($input, &$1);
+ }
+ %typemap(typecheck,precedence=SWIG_TYPECHECK_POINTER)
+         (int nLen, char *pBuf)
+ {
+   /* %typecheck(SWIG_TYPECHECK_POINTER) (int nLen, char *pBuf) */
+   $1 = 1; /* Everything in Tcl is a string */
+ }
+ 
+ /*
+  * Typemap argout used in Feature::GetFieldAsIntegerList()
+  */
+ %typemap(in,numinputs=0) (int *nLen, const int **pList) (int nLen, int *pList)
+ {
+   /* %typemap(in,numinputs=0) (int *nLen, const int **pList) (int nLen, int *pList) */
+   $1 = &nLen;
+   $2 = &pList;
+ }
+ 
+ %typemap(argout) (int *nLen, const int **pList )
+ {
+   /* %typemap(argout) (int *nLen, const int **pList ) */
+   Tcl_Obj *out = Tcl_NewListObj(0, NULL);
+   for( int i=0; i<*$1; i++ ) {
+     Tcl_Obj *val = Tcl_NewLongObj( (*$2)[i] );
+     if (Tcl_ListObjAppendElement(interp, out, val) != TCL_OK) {
+         Tcl_DecrRefCount(val);
+         Tcl_DecrRefCount(out);
+         /* Error msg in interp result */
+         SWIG_fail;
+     }
+   }
+   Tcl_SetObjResult(interp, out);
+ }
+ 
+ /*
+  * Typemap argout used in Feature::GetFieldAsDoubleList()
+  */
+ %typemap(in,numinputs=0) (int *nLen, const double **pList) (int nLen, double *pList)
+ {
+   /* %typemap(in,numinputs=0) (int *nLen, const double **pList) (int nLen, double *pList) */
+   $1 = &nLen;
+   $2 = &pList;
+ }
+ 
+ %typemap(argout) (int *nLen, const double **pList )
+ {
+   /* %typemap(argout) (int *nLen, const double **pList ) */
+   Tcl_Obj *out = Tcl_NewListObj(0, NULL);
+   for( int i=0; i<*$1; i++ ) {
+     Tcl_Obj *val = Tcl_NewDoubleObj( (*$2)[i] );
+     if (Tcl_ListObjAppendElement(interp, out, val) != TCL_OK) {
+         Tcl_DecrRefCount(val);
+         Tcl_DecrRefCount(out);
+         /* Error msg in interp result */
+         SWIG_fail;
+     }
+   }
+   Tcl_SetObjResult(interp, out);
+ }
+ /*
+  * Typemap argout of GDAL_GCP* used in Dataset::GetGCPs( )
+  */
+ %typemap(in,numinputs=0) (int *nGCPs, GDAL_GCP const **pGCPs ) (int nGCPs=0, GDAL_GCP *pGCPs=0 )
+ {
+   /* %typemap(in,numinputs=0) (int *nGCPs, GDAL_GCP const **pGCPs ) */
+   $1 = &nGCPs;
+   $2 = &pGCPs;
+ }
+ %typemap(argout) (int *nGCPs, GDAL_GCP const **pGCPs )
+ {
+   /* %typemap(argout) (int *nGCPs, GDAL_GCP const **pGCPs ) */
+   Tcl_Obj *out = Tcl_NewListObj(0, NULL);;
+   for( int i = 0; i < *$1; i++ ) {
+     /* We dublicate every GCP (seperate object in memory) */
+     GDAL_GCP *o = new_GDAL_GCP( (*$2)[i].dfGCPX,
+                                 (*$2)[i].dfGCPY,
+                                 (*$2)[i].dfGCPZ,
+                                 (*$2)[i].dfGCPPixel,
+                                 (*$2)[i].dfGCPLine,
+                                 (*$2)[i].pszInfo,
+                                 (*$2)[i].pszId );
+     if (Tcl_ListObjAppendElement(interp, out, SWIG_NewPointerObj((void*)o,SWIGTYPE_p_GDAL_GCP,1)) != TCL_OK) {
+         delete_GDAL_GCP(o);
+         /* Note: XXX I assume here that by freeing this list, the respective GDAL_GCP memory of each pointer is fred automatically */
+         Tcl_DecrRefCount(out);
+         /* Error msg in interp result */
+         SWIG_fail;
+     }
+   }
+   Tcl_SetObjResult(interp, out);
+ }
+ %typemap(in,numinputs=1) (int nGCPs, GDAL_GCP const *pGCPs ) ( GDAL_GCP *tmpGCPList )
+ {
+   /* %typemap(in,numinputs=1) (int nGCPs, GDAL_GCP const *pGCPs ) */
+   /* The following also checks if input is a list */
+   if (Tcl_ListObjLength(interp, $input, &$1) != TCL_OK) {
+     /* Error msg in interp result */
+     SWIG_fail;
+   }
+   if ( !$1 ) {
+       Tcl_SetResult(interp, (char*) "Input list mustn't be empty", TCL_STATIC);
+       SWIG_fail;
+   }
+ 
+   tmpGCPList = (GDAL_GCP*) CPLMalloc($1*sizeof(GDAL_GCP));
+   $2 = tmpGCPList;
+   for( int i = 0; i<$1; i++ ) {
+     Tcl_Obj **o = NULL;
+     /* The reference count for the list element is not incremented with the following */
+     if (Tcl_ListObjIndex(interp, $input, i, o) != TCL_OK) {
+         /* Error msg in interp result */
+         SWIG_fail;
+     }
+ 
+     GDAL_GCP *item = 0;
+     SWIG_ConvertPtr( *o, (void**)&item, SWIGTYPE_p_GDAL_GCP, SWIG_POINTER_EXCEPTION | 0 );
+     if ( ! item ) {
+       SWIG_fail;
+     }
+ 
+     memcpy( (void*) tmpGCPList, (void*) item, sizeof( GDAL_GCP ) );
+     ++tmpGCPList;
+   }
+ }
+ %typemap(freearg) (int nGCPs, GDAL_GCP const *pGCPs )
+ {
+   /* %typemap(freearg) (int nGCPs, GDAL_GCP const *pGCPs ) */
+   if ($2) {
+     CPLFree( (void*) $2 );
+   }
+ }
+ 
+ /*
+  * Typemap for GDALColorEntry* <-> tuple
+  */
+ %typemap(out) GDALColorEntry*
+ {
+     /* %typemap(out) GDALColorEntry* */
+     Tcl_Obj *out = Tcl_NewListObj(0, NULL);
+     Tcl_Obj *val;
+     val  = Tcl_NewIntObj((*$1).c1);
+     if (Tcl_ListObjAppendElement(interp, out, val) != TCL_OK) {
+         Tcl_DecrRefCount(val);
+         Tcl_DecrRefCount(out);
+         SWIG_fail;
+     }
+     val = Tcl_NewIntObj((*$1).c2);
+     if (Tcl_ListObjAppendElement(interp, out, val) != TCL_OK) {
+         Tcl_DecrRefCount(val);
+         Tcl_DecrRefCount(out);
+         SWIG_fail;
+     }
+     val = Tcl_NewIntObj((*$1).c3);
+     if (Tcl_ListObjAppendElement(interp, out, val) != TCL_OK) {
+         Tcl_DecrRefCount(val);
+         Tcl_DecrRefCount(out);
+         SWIG_fail;
+     }
+     val = Tcl_NewIntObj((*$1).c4);
+     if (Tcl_ListObjAppendElement(interp, out, val) != TCL_OK) {
+         Tcl_DecrRefCount(val);
+         Tcl_DecrRefCount(out);
+         SWIG_fail;
+     }
+     Tcl_SetObjResult(interp, out);
+ 
+     /* More compact: (If used, the next typemap must be modified as well)
+        Tcl_SetObjResult(interp, Tcl_ObjPrintf("%x%x%x%x", (*$1).c1, (*$1).c2, (*$1).c3, (*$1).c4));
+      */
+ }
+ 
+ %typemap(in) GDALColorEntry* (GDALColorEntry ce)
+ {
+     /* %typemap(in) GDALColorEntry* */
+     ce.c1 = 0;
+     ce.c2 = 0;
+     ce.c3 = 0;
+     ce.c4 = 255;
+     /* The following also checks if input is a list */
+     int size;
+     if (Tcl_ListObjLength(interp, $input, &size) != TCL_OK) {
+         /* Error msg in interp result */
+         SWIG_fail;
+     }
+     if ( size > 4 ) {
+         Tcl_SetResult(interp, (char*) "ColorEntry sequence too long", TCL_STATIC);
+         SWIG_fail;
+     }
+     if ( size < 3 ) {
+         Tcl_SetResult(interp, (char*) "ColorEntry sequence too short", TCL_STATIC);
+         SWIG_fail;
+     }
+     for( int i = 0; i<size; i++ ) {
+         Tcl_Obj **o = NULL;
+         int val;
+         /* The reference count for the list element is not incremented with the following */
+         if (Tcl_ListObjIndex(interp, $input, i, o) != TCL_OK) {
+             /* Error msg in interp result */
+             SWIG_fail;
+         }
+ 
+         if (Tcl_GetIntFromObj(interp, *o, &val) != TCL_OK) {
+             /* Error msg in interp result */
+             SWIG_fail;
+         }
+         switch (i) {
+             case 1: ce.c1 = (short) val; break;
+             case 2: ce.c2 = (short) val; break;
+             case 3: ce.c3 = (short) val; break;
+             case 4: ce.c4 = (short) val; break;
+         }
+     }
+     $1 = &ce;
+ }
+ 
+ /*
+  * Typemap char ** -> dict
+  */
+ %typemap(out) char **dict
+ {
+   /* %typemap(out) char **dict */
+     char **stringarray = $1;
+     Tcl_Obj *out = Tcl_NewDictObj();
+     if ( stringarray != NULL ) {
+         while (*stringarray != NULL ) {
+             char const *valptr;
+             char *keyptr;
+             valptr = CPLParseNameValue( *stringarray, &keyptr );
+             if ( valptr != 0 ) {
+                 Tcl_Obj *nm = Tcl_NewStringObj( keyptr, -1 );
+                 Tcl_Obj *val = Tcl_NewStringObj( valptr, -1 );
+                 if (Tcl_DictObjPut(interp, out, nm, val) != TCL_OK) {
+                     Tcl_DecrRefCount(nm);
+                     Tcl_DecrRefCount(val);
+                     Tcl_DecrRefCount(out);
+                     /* Error msg in interp result */
+                     SWIG_fail;
+                 }
+                 CPLFree( keyptr );
+             }
+             stringarray++;
+         }
+     }
+     Tcl_SetObjResult(interp, out);
+ }
+ 
+ /*
+  * Typemap char **<- dict. 
+  */
+ %typemap(typecheck,precedence=SWIG_TYPECHECK_POINTER) (char **dict)
+ {
+   /* %typecheck(SWIG_TYPECHECK_POINTER) (char **dict) */
+   int size;
+   $1 = (Tcl_DictObjSize(interp, $input, &size) == TCL_OK || Tcl_ListObjLength(interp, $input, &size) == TCL_OK) ? 1 : 0;
+ }
+ %typemap(in) char **dict
+ {
+   /* %typemap(in) char **dict */
+   $1 = NULL;
+   int size;
+   if (Tcl_DictObjSize(interp, $input, &size) != TCL_OK) {
+     if ( size > 0 ) {
+         Tcl_DictSearch search;
+         Tcl_Obj *key, *value;
+         int done;
+ 
+         if (Tcl_DictObjFirst(interp, $input, &search, &key, &value, &done) != TCL_OK) {
+             SWIG_fail;;
+         }
+         for (; !done ; Tcl_DictObjNext(&search, &key, &value, &done)) {
+             char *nm = Tcl_GetString(key);
+             char *val = Tcl_GetString(value);
+             $1 = CSLAddNameValue( $1, nm, val );
+         }
+         Tcl_DictObjDone(&search);
+     }
+   }
+   else {
+     Tcl_SetResult(interp, (char*) "Argument must be a dictionary", TCL_STATIC);
+     SWIG_fail;
+   }
+ }
+ %typemap(freearg) char **dict
+ {
+   /* %typemap(freearg) char **dict */
+   CSLDestroy( $1 );
+ }
+ 
+ /*
+  * Typemap maps char** arguments from Tcl List Object
+  */
+ %typemap(in) char **options
+ {
+     /* %typemap(in) char **options */
+     int size;
+     if (Tcl_ListObjLength(interp, $input, &size) != TCL_OK) {
+         /* Error msg in interp result */
+         SWIG_fail;
+     }
+     if ( !size ) {
+         Tcl_SetResult(interp, (char*) "Input list mustn't be empty", TCL_STATIC);
+         SWIG_fail;
+     }
+ 
+     for (int i = 0; i < size; i++) {
+         Tcl_Obj **o = NULL;
+         /* The reference count for the list element is not incremented with the following */
+         if (Tcl_ListObjIndex(interp, $input, i, o) != TCL_OK) {
+             /* Error msg in interp result */
+             SWIG_fail;
+         }
+         char *pszItem = Tcl_GetString(*o);
+         $1 = CSLAddString( $1, pszItem );
+     }
+ }
+ %typemap(freearg) char **options
+ {
+   /* %typemap(freearg) char **options */
+   CSLDestroy( $1 );
+ }
+ 
+ 
+ /*
+  * Typemap converts an array of strings into a list of strings
+  * with the assumption that the called object maintains ownership of the
+  * array of strings.
+  */
+ %typemap(out) char **options
+ {
+   /* %typemap(out) char **options -> ( string ) */
+   char **stringarray = $1;
+   if ( stringarray == NULL ) {
+     Tcl_ResetResult(interp); /* NONE = Empty string */
+   } else {
+       int len = CSLCount( stringarray );
+       Tcl_Obj *out = Tcl_NewListObj(0, NULL);
+       for ( int i = 0; i < len; ++i ) {
+           Tcl_Obj *o = Tcl_NewStringObj( stringarray[i], -1 );
+           if (Tcl_ListObjAppendElement(interp, out, o) != TCL_OK) {
+               Tcl_DecrRefCount(o);
+               Tcl_DecrRefCount(out);
+               /* Error msg in interp result */
+               SWIG_fail;
+           }
+       }
+       Tcl_SetObjResult(interp, out);
+   }
+ }
+ 
+ /*
+  * The return value is a list that is copied into a Tcl list and then CSLDestroyed
+  */
+ %typemap(out) (char **CSL)
+ {
+ /*XXX Test it*/
+     /* %typemap(out) char **CSL */
+     char **stringarray = $1;
+     if ( stringarray == NULL ) {
+         Tcl_ResetResult(interp); /* NONE = Empty string */
+     } else {
+         int len = CSLCount( stringarray );
+         Tcl_Obj *out = Tcl_NewListObj(0, NULL);
+         for ( int i = 0; i < len; ++i ) {
+             Tcl_Obj *o = Tcl_NewStringObj( stringarray[i], -1 );
+             if (Tcl_ListObjAppendElement(interp, out, o) != TCL_OK) {
+                 Tcl_DecrRefCount(o);
+                 Tcl_DecrRefCount(out);
+                 /* Error msg in interp result */
+                 SWIG_fail;
+             }
+         }
+         CSLDestroy($1);
+         Tcl_SetObjResult(interp, out);
+     }
+ }
+ 
+ /*
+  * Typemaps map mutable char ** arguments from string.  Does not
+  * return the modified argument
+  */
+ %typemap(in) (char **ignorechange) ( char *val )
+ {
+   /* %typemap(in) (char **ignorechange) */
+   val = Tcl_GetString($input);
+   $1 = &val;
+ }
+ 
+ /*
+  * Typemap for char **argout.
+  */
+ %typemap(in,numinputs=0) (char **argout) ( char *argout=0 )
+ {
+   /* %typemap(in,numinputs=0) (char **argout) */
+   $1 = &argout;
+ }
+ %typemap(argout) (char **argout)
+ {
+   /* %typemap(argout) (char **argout) */
+   Tcl_Obj *o;
+   if ( $1 ) {
+     o = Tcl_NewStringObj( *$1, -1 );
+   } else {
+     o = Tcl_NewObj();
+   }
+   %append_output(o);
+ }
+ %typemap(freearg) (char **argout)
+ {
+   /* %typemap(freearg) (char **argout) */
+   if ( *$1 )
+     CPLFree( *$1 );
+ }
+ 
+ %apply int* {int* optional_int};
+ 
+ /*
+  * Typedef const char * <- Any object.
+  *
+  * Formats the object using str and returns the string representation
+  */
+ 
+ 
+ %typemap(in) (tostring argin)
+ {
+   /* %typemap(in) (tostring argin) */
+   $1 = Tcl_GetString( $input ); 
+ }
+ %typemap(typecheck,precedence=SWIG_TYPECHECK_POINTER) (tostring argin)
+ {
+   /* %typemap(typecheck,precedence=SWIG_TYPECHECK_POINTER) (tostring argin) */
+   $1 = 1;
+ }
+ 
+ /* No "%typemap(ret) CPLErr" because we always raise an exception. */
+ 
+ /*
+  * Typemaps for minixml:  CPLXMLNode* input, CPLXMLNode *ret
+  */
+ 
+ %fragment("TclListToXMLTree","header") %{
+ /************************************************************************/
+ /*                          TclListToXMLTree()                           */
+ /************************************************************************/
+ static CPLXMLNode *TclListToXMLTree( Tcl_Interp *interp, Tcl_Obj *tclList )
+ {
+     int      nChildCount = 0, iChild, nType;
+     CPLXMLNode *psThisNode;
+     CPLXMLNode *psChild;
+     char       *pszText = NULL;
+ 
+     if (Tcl_ListObjLength(interp, tclList, &nChildCount) != TCL_OK) {
+         /* Error msg in interp result */
+         return NULL;
+     }
+     nChildCount = nChildCount - 2;
+     if( nChildCount < 0 )
+     {
+         Tcl_SetResult(interp, (char*) "Error in input XMLTree.", TCL_STATIC);
+         return NULL;
+     }
+ 
+     Tcl_Obj **o = NULL;
+     if (Tcl_ListObjIndex(interp, tclList, 0, o) != TCL_OK) { /* ref count is not incremented */
+         /* Error msg in interp result */
+         return NULL;
+     }
+     if (Tcl_GetIntFromObj(interp, *o, &nType) != TCL_OK) {
+         /* Error msg in interp result */
+         return NULL;
+     }
+     if (Tcl_ListObjIndex(interp, tclList, 1, o) != TCL_OK) { /* ref count is not incremented */
+         /* Error msg in interp result */
+         return NULL;
+     }
+     pszText = Tcl_GetStringFromObj(*o, NULL);
+     psThisNode = CPLCreateXMLNode( NULL, (CPLXMLNodeType) nType, pszText );
+ 
+     for( iChild = 0; iChild < nChildCount; iChild++ )
+     {
+         if (Tcl_ListObjIndex(interp, tclList, iChild+2, o) != TCL_OK) { /* ref count is not incremented */
+             /* Error msg in interp result */
+             return NULL;
+         }
+         psChild = TclListToXMLTree( interp, *o );
+         CPLAddXMLChild( psThisNode, psChild );
+     }
+ 
+     return psThisNode;
+ }
+ %}
+ 
+ %typemap(in,fragment="TclListToXMLTree") (CPLXMLNode* xmlnode )
+ {
+   /* %typemap(tcl,in) (CPLXMLNode* xmlnode ) */
+   $1 = TclListToXMLTree( interp, $input );
+   if ( !$1 ) SWIG_fail;
+ }
+ %typemap(freearg) (CPLXMLNode *xmlnode)
+ {
+   /* %typemap(freearg) (CPLXMLNode *xmlnode) */
+   if ( $1 ) CPLDestroyXMLNode( $1 );
+ }
+ 
+ %fragment("XMLTreeToTclList","header") %{
+ /************************************************************************/
+ /*                          XMLTreeToTclList()                           */
+ /************************************************************************/
+ static Tcl_Obj *XMLTreeToTclList( Tcl_Interp *interp, CPLXMLNode *psTree )
+ {
+     Tcl_Obj *tclList;
+     int      nChildCount = 0, iChild;
+     CPLXMLNode *psChild;
+ 
+     for( psChild = psTree->psChild; 
+          psChild != NULL; 
+          psChild = psChild->psNext )
+         nChildCount++;
+ 
+     tclList = Tcl_NewListObj(0, NULL);
+     if (Tcl_ListObjAppendElement(interp, tclList, Tcl_NewIntObj((int) psTree->eType)) != TCL_OK) {
+         Tcl_DecrRefCount(tclList);
+         /* Error msg in interp result */
+         return NULL; /* signifies error */
+     }
+     if (Tcl_ListObjAppendElement(interp, tclList, Tcl_NewStringObj(psTree->pszValue, -1)) != TCL_OK) {
+         Tcl_DecrRefCount(tclList);
+         /* Error msg in interp result */
+         return NULL; /* signifies error */
+     }
+ 
+     for( psChild = psTree->psChild, iChild = 2; 
+          psChild != NULL; 
+          psChild = psChild->psNext, iChild++ )
+     {
+         if (Tcl_ListObjAppendElement(interp, tclList, XMLTreeToTclList( interp, psChild )) != TCL_OK) {
+             Tcl_DecrRefCount(tclList);
+             /* Error msg in interp result */
+             return NULL; /* signifies error */
+         }
+     }
+ 
+     return tclList; 
+ }
+ %}
+ 
+ %typemap(out,fragment="XMLTreeToTclList") (CPLXMLNode*)
+ {
+   /* %typemap(out) (CPLXMLNode*) */
+ 
+   Tcl_Obj *out;
+   CPLXMLNode *psXMLTree = $1;
+   int         bFakeRoot = FALSE;
+ 
+   if( psXMLTree != NULL && psXMLTree->psNext != NULL )
+   {
+       CPLXMLNode *psFirst = psXMLTree;
+ 
+       /* create a "pseudo" root if we have multiple elements */
+       psXMLTree = CPLCreateXMLNode( NULL, CXT_Element, "" );
+       psXMLTree->psChild = psFirst;
+       bFakeRoot = TRUE;
+   }
+ 
+   out = XMLTreeToTclList( interp, psXMLTree );
+   if ( !out ) SWIG_fail;
+ 
+   if( bFakeRoot )
+   {
+         psXMLTree->psChild = NULL;
+         CPLDestroyXMLNode( psXMLTree );
+   }
+ 
+   Tcl_SetObjResult(interp, out);
+ }
+ %typemap(ret) (CPLXMLNode*)
+ {
+   /* %typemap(ret) (CPLXMLNode*) */
+   if ( $1 ) CPLDestroyXMLNode( $1 );
+ }
+ 
+ /* Check inputs to ensure they are not NULL but instead empty #1775 */
+ %define CHECK_NOT_UNDEF(type, param, msg)
+ %typemap(check) (const char *pszNewDesc)
+ {
+     /* %typemap(check) (type *param) */
+     if (!$1) {
+         Tcl_SetResult(interp, (char*) "Variable cannot be None", TCL_STATIC);
+         SWIG_fail;
+     }
+ }
+ %enddef
+ 
+ //CHECK_NOT_UNDEF(char, method, method)
+ //CHECK_NOT_UNDEF(const char, name, name)
+ //CHECK_NOT_UNDEF(const char, request, request)
+ //CHECK_NOT_UNDEF(const char, cap, capability)
+ //CHECK_NOT_UNDEF(const char, statement, statement)
+ CHECK_NOT_UNDEF(const char, pszNewDesc, description)
+ CHECK_NOT_UNDEF(OSRCoordinateTransformationShadow, , coordinate transformation)
+ CHECK_NOT_UNDEF(OGRGeometryShadow, other, other geometry)
+ CHECK_NOT_UNDEF(OGRGeometryShadow, other_disown, other geometry)
+ CHECK_NOT_UNDEF(OGRGeometryShadow, geom, geometry)
+ CHECK_NOT_UNDEF(OGRFieldDefnShadow, defn, field definition)
+ CHECK_NOT_UNDEF(OGRFieldDefnShadow, field_defn, field definition)
+ CHECK_NOT_UNDEF(OGRFeatureShadow, feature, feature)
+ 
+ 
+ /* ==================================================================== */
+ /*	Support function for progress callbacks to tcl.                     */
+ /* ==================================================================== */
+ 
+ /*                                                                      */
+ /*  A number of things happen as part of callbacks in GDAL.  First,     */
+ /*  there is a generic callback function internal to GDAL called        */
+ /*  GDALTermProgress, which just outputs generic progress counts to the */
+ /*  terminal as you would expect.  This callback function is a special  */
+ /*  case.  Alternatively, a user can pass in a Tcl procedure that       */
+ /*  can be used as a callback, and it will be eval'd by GDAL during     */
+ /*  its update loop.  The typemaps here handle taking in                */
+ /*  GDALTermProgress and the Tcl procedure.                             */
+ 
+ /*  This arginit does some magic because it must create a               */
+ /*  psProgressInfo that is global to the wrapper function.  The noblock */
+ /*  option here allows it to end up being global and not being          */
+ /*  instantiated within a {} block.  Both the callback_data and the     */
+ /*  callback typemaps will then use this struct to hold pointers to the */
+ /*  callback and callback_data Tcl_Obj*'s.                              */
+ 
+ %typemap(arginit, noblock=1) ( void* callback_data=NULL)
+ {
+     /* %typemap(arginit) ( const char* callback_data=NULL)  */
+         TclProgressData *psProgressInfo;
+         psProgressInfo = (TclProgressData *) CPLCalloc(1,sizeof(TclProgressData));
+         psProgressInfo->nLastReported = -1;
+         psProgressInfo->interp = interp;
+         psProgressInfo->psTclCallback = NULL;
+         psProgressInfo->psTclCallbackData = NULL;
+ 
+ }
+ 
+ /*  This is kind of silly, but this typemap takes the $input'ed         */
+ /*  Tcl_Obj * and hangs it on the struct's callback data *and* sets     */
+ /*  the argument to the tclProgressInfo void* that will eventually be   */
+ /*  passed into the function as its callback data.  Confusing.  Sorry.  */
+ %typemap(in) (void* callback_data=NULL) 
+ {
+     /* %typemap(in) ( void* callback_data=NULL)  */
+     psProgressInfo->psTclCallbackData = $input;
+     Tcl_IncrRefCount(psProgressInfo->psTclCallbackData);
+     $1 = psProgressInfo;
+ 
+ }
+ 
+ /*  Here is our actual callback function.  It could be a generic GDAL   */
+ /*  callback function like GDALTermProgress, or it might be a user-     */
+ /*  defined callback function that is actually a Tcl procedure.         */
+ /*  If we were the generic function, set our argument to that,          */
+ /*  otherwise, setup the tclProgressInfo's callback to be our Tcl_Obj*  */
+ /*  and set our callback function to be TclProgressProxy, which is      */
+ /*  defined in gdal_tcl.i                                               */
+ %typemap(in) (GDALProgressFunc callback = NULL) 
+ {
+     /* %typemap(in) (GDALProgressFunc callback = NULL) */
+     /* callback_func typemap */
+     if ($input && !strcmp(Tcl_GetString($input), "")) {
+         void* cbfunction = NULL;
+         SWIG_ConvertPtr( $input, 
+                          (void**)&cbfunction, 
+                          SWIGTYPE_p_f_double_p_q_const__char_p_void__int, 
+                          SWIG_POINTER_EXCEPTION | 0 );
+ 
+         if ( cbfunction == GDALTermProgress ) {
+             $1 = GDALTermProgress;
+         } else if ( cbfunction == GDALDummyProgress) {
+             $1 = GDALDummyProgress;
+         } else if ( cbfunction == GDALScaledProgress) {
+             $1 = GDALScaledProgress;
+         } else {
+             psProgressInfo->psTclCallback = $input;
+             Tcl_IncrRefCount(psProgressInfo->psTclCallback);
+             $1 = TclProgressProxy;
+         }
+     }
+ }
+ 
+ /*  clean up our global (to the wrapper function) psProgressInfo        */
+ /*  struct now that we're done with it.                                 */
+ %typemap(freearg) (void* callback_data=NULL) 
+ {
+     /* %typemap(freearg) ( void* callback_data=NULL)  */
+     Tcl_DecrRefCount(psProgressInfo->psTclCallback);
+     Tcl_DecrRefCount(psProgressInfo->psTclCallbackData);
+     CPLFree(psProgressInfo);
+ }
+ 
+ 
+ %typemap(arginit) ( GUInt32 ) 
+ {
+     /* %typemap(out) ( GUInt32 )  */
+     $1 = 0;
+ }
+ 
+ %typemap(out) ( GUInt32 ) 
+ {
+     /* %typemap(out) ( GUInt32 )  */
+     Tcl_SetObjResult(interp, Tcl_NewIntObj($1));
+ }
+ 
+ %typemap(in) ( GUInt32 ) 
+ {
+     /* %typemap(in) ( GUInt32 )  */
+     if (Tcl_GetLongFromObj(interp, $input, &$1) != TCL_OK) {
+         /* Error in interp result */
+         // SWIG_fail;
+     }
+ }
+ 
+ %define OBJECT_LIST_INPUT(type, pointertype)
+ %typemap(in, numinputs=1) (int object_list_count, type **poObjects)
+ {
+     /*  OBJECT_LIST_INPUT %typemap(in) (int itemcount, type *optional_##type)*/
+     if (Tcl_ListObjLength(interp, $input, &$1) != TCL_OK) {
+         /* Error msg in interp result */
+         SWIG_fail;
+     }
+     if ( !$1 ) {
+         Tcl_SetResult(interp, (char*) "Input list mustn't be empty", TCL_STATIC);
+         SWIG_fail;
+     }
+ 
+     $2 = (type**) CPLMalloc($1*sizeof(type*));
+ 
+     for( int i = 0; i<$1; i++ ) {
+         Tcl_Obj **o = NULL;
+         if (Tcl_ListObjIndex(interp, $input, i, o) != TCL_OK) { /* ref count is not incremented */
+             /* Error msg in interp result */
+             SWIG_fail;
+         }
+         /* No equivalent of SWIG_Python_GetSwigThis for Tcl in SWIG, but we can still use this */
+ //XXX
+         type* pointer = NULL;
+         SWIG_ConvertPtr( *o, (void**)&pointer, pointertype, SWIG_POINTER_EXCEPTION | 0 );
+         if (!pointer) {
+             SWIG_fail;
+         }
+         $2[i] = pointer;
+     }
+ }
+ 
+ %typemap(freearg)  (int object_list_count, type **poObjects)
+ {
+   /* OBJECT_LIST_INPUT %typemap(freearg) (int object_list_count, type **poObjects)*/
+   CPLFree( $2 );
+ }
+ %enddef
+ 
+ OBJECT_LIST_INPUT(GDALRasterBandShadow, SWIGTYPE_p_GDALRasterBandShadow);
+ 
+ /* ***************************************************************************
+  *                       GetHistogram()
+  * Tcl is somewhat special in that we don't want the caller
+  * to pass in the histogram array to populate.  Instead we allocate
+  * it internally, call the C level, and then turn the result into 
+  * a list object. 
+  */
+ 
+ %typemap(arginit) (int buckets, int* panHistogram)
+ {
+   /* %typemap(in) int buckets, int* panHistogram -> list */
+   $2 = (int *) CPLCalloc(sizeof(int),$1);
+ }
+ 
+ %typemap(in, numinputs=1) (int buckets, int* panHistogram)
+ {
+   /* %typemap(in) int buckets, int* panHistogram -> list */
+   int requested_buckets;
+   SWIG_AsVal_int(interp, $input, &requested_buckets);
+   if( requested_buckets != $1 )
+   { 
+     $1 = requested_buckets;
+     $2 = (int *) CPLRealloc($2,sizeof(int) * requested_buckets);
+   }
+ }
+ 
+ %typemap(freearg)  (int buckets, int* panHistogram)
+ {
+   /* %typemap(freearg) (int buckets, int* panHistogram)*/
+   if ( $2 ) {
+     CPLFree( $2 );
+   }
+ }
+ 
+ %typemap(argout) (int buckets, int* panHistogram)
+ {
+     /* %typemap(out) int buckets, int* panHistogram -> list */
+     int *integerarray = $2;
+     if ( integerarray == NULL ) {
+         Tcl_ResetResult(interp); /* NONE = Empty string */
+     } else {
+         Tcl_Obj *out = Tcl_NewListObj(0, NULL);
+         for( int i=0; i < $1; i++ ) {
+             Tcl_Obj *o = Tcl_NewLongObj( integerarray[i] );
+             if (Tcl_ListObjAppendElement(interp, out, o) != TCL_OK) {
+                 Tcl_DecrRefCount(o);
+                 Tcl_DecrRefCount(out);
+                 /* Error msg in interp result */
+                 SWIG_fail;
+             }
+         }
+         Tcl_SetObjResult(interp, out);
+     }
+ }
+ 
+ /* ***************************************************************************
+  *                       GetDefaultHistogram()
+  */
+ 
+ %typemap(arginit, noblock=1) (double *min_ret, double *max_ret, int *buckets_ret, int **ppanHistogram)
+ {
+    double min_val, max_val;
+    int buckets_val;
+    int *panHistogram;
+ 
+   /* frankwdebug */
+ 
+    $1 = &min_val;
+    $2 = &max_val;
+    $3 = &buckets_val;
+    $4 = &panHistogram;
+ }
+ 
+ %typemap(argout) (double *min_ret, double *max_ret, int *buckets_ret, int** ppanHistogram)
+ {
+   int i;
+   Tcl_Obj *o, *psList = NULL;
+ 
+   /* frankwdebug */
+ 
+   psList = Tcl_NewListObj(0, NULL);
+ 
+   o = Tcl_NewDoubleObj( min_val );
+   if (Tcl_ListObjAppendElement(interp, psList, o) != TCL_OK) {
+       Tcl_DecrRefCount(o);
+       Tcl_DecrRefCount(psList);
+       /* Error msg in interp result */
+       SWIG_fail;
+   }
+   o = Tcl_NewDoubleObj( max_val );
+   if (Tcl_ListObjAppendElement(interp, psList, o) != TCL_OK) {
+       Tcl_DecrRefCount(o);
+       Tcl_DecrRefCount(psList);
+       /* Error msg in interp result */
+       SWIG_fail;
+   }
+   o = Tcl_NewLongObj( buckets_val );
+   if (Tcl_ListObjAppendElement(interp, psList, o) != TCL_OK) {
+       Tcl_DecrRefCount(o);
+       Tcl_DecrRefCount(psList);
+       /* Error msg in interp result */
+       SWIG_fail;
+   }
+ 
+   for( i = 0; i < buckets_val; i++ ) {
+       o = Tcl_NewLongObj( panHistogram[i] );
+       if (Tcl_ListObjAppendElement(interp, psList, o) != TCL_OK) {
+           Tcl_DecrRefCount(o);
+           Tcl_DecrRefCount(psList);
+           /* Error msg in interp result */
+           SWIG_fail;
+       }
+   }
+ 
+   Tcl_SetObjResult(interp, psList);
+   CPLFree( panHistogram );
+ }
+ 
+ /***************************************************
+  * Typemaps for CoordinateTransformation.TransformPoints()
+  ***************************************************/
+ %typemap(in,numinputs=1) (int nCount, double *x, double *y, double *z)
+ {
+   /*  typemap(in,numinputs=1) (int nCount, double *x, double *y, double *z) */
+     if (Tcl_ListObjLength(interp, $input, &$1) != TCL_OK) {
+         /* Error msg in interp result */
+         SWIG_fail;
+     }
+     if ( !$1 ) {
+         Tcl_SetResult(interp, (char*) "Input list mustn't be empty", TCL_STATIC);
+         SWIG_fail;
+     }
+     $2 = (double*) CPLMalloc($1*sizeof(double));
+     $3 = (double*) CPLMalloc($1*sizeof(double));
+     $4 = (double*) CPLMalloc($1*sizeof(double));
+ 
+     for( int i = 0; i<$1; i++ ) {
+ 
+         Tcl_Obj **o = NULL;
+         if (Tcl_ListObjIndex(interp, $input, i, o) != TCL_OK) { /* ref count is not incremented */
+             /* Error msg in interp result */
+             SWIG_fail;
+         }
+ 
+         int size;
+         if (Tcl_ListObjLength(interp, *o, &size) != TCL_OK) {
+             /* Error msg in interp result */
+             SWIG_fail;
+         }
+         if ( size < 2 || size > 3 ) {
+             Tcl_SetResult(interp, (char*) "Not a list of 2 or 3 doubles", TCL_STATIC);
+             SWIG_fail;
+         }
+ 
+         double x, y, z = 0;
+         Tcl_Obj **o2 = NULL;
+         if (Tcl_ListObjIndex(interp, *o, 0, o2) != TCL_OK) { /* ref count is not incremented */
+             /* Error msg in interp result */
+             SWIG_fail;
+         }
+         if (Tcl_GetDoubleFromObj(interp, *o2, &x ) != TCL_OK) {
+             /* Error msg in interp result */
+             SWIG_fail;
+         }
+ 
+         if (Tcl_ListObjIndex(interp, *o, 1, o2) != TCL_OK) { /* ref count is not incremented */
+             /* Error msg in interp result */
+             SWIG_fail;
+         }
+         if (Tcl_GetDoubleFromObj(interp, *o2, &y ) != TCL_OK) {
+             /* Error msg in interp result */
+             SWIG_fail;
+         }
+ 
+         if (size == 3) {
+             if (Tcl_ListObjIndex(interp, *o, 2, o2) != TCL_OK) { /* ref count is not incremented */
+                 /* Error msg in interp result */
+                 SWIG_fail;
+             }
+             if (Tcl_GetDoubleFromObj(interp, *o2, &z ) != TCL_OK) {
+                 /* Error msg in interp result */
+                 SWIG_fail;
+             }
+         }
+ 
+         ($2)[i] = x;
+         ($3)[i] = y;
+         ($4)[i] = z;
+     }
+ }
+ 
+ %typemap(argout)  (int nCount, double *x, double *y, double *z)
+ {
+   /* %typemap(argout)  (int nCount, double *x, double *y, double *z) */
+   Tcl_Obj *out = Tcl_NewListObj(0, NULL);
+   for( int i=0; i< $1; i++ ) {
+       Tcl_Obj *tuple = Tcl_NewListObj(0, NULL);
+       Tcl_Obj *val = Tcl_NewDoubleObj(($2)[i] );
+       if (Tcl_ListObjAppendElement(interp, tuple, val) != TCL_OK) {
+           Tcl_DecrRefCount(val);
+           Tcl_DecrRefCount(tuple);
+           Tcl_DecrRefCount(out);
+           /* Error msg in interp result */
+           SWIG_fail;
+       }
+       val = Tcl_NewDoubleObj(($3)[i] );
+       if (Tcl_ListObjAppendElement(interp, tuple, val) != TCL_OK) {
+           Tcl_DecrRefCount(val);
+           Tcl_DecrRefCount(tuple);
+           Tcl_DecrRefCount(out);
+           /* Error msg in interp result */
+           SWIG_fail;
+       }
+       val = Tcl_NewDoubleObj(($4)[i] );
+       if (Tcl_ListObjAppendElement(interp, tuple, val) != TCL_OK) {
+           Tcl_DecrRefCount(val);
+           Tcl_DecrRefCount(tuple);
+           Tcl_DecrRefCount(out);
+           /* Error msg in interp result */
+           SWIG_fail;
+       }
+       if (Tcl_ListObjAppendElement(interp, out, tuple) != TCL_OK) {
+           Tcl_DecrRefCount(tuple);
+           Tcl_DecrRefCount(out);
+           /* Error msg in interp result */
+           SWIG_fail;
+       }
+   }
+   Tcl_SetObjResult(interp, out);
+ }
+ 
+ %typemap(freearg)  (int nCount, double *x, double *y, double *z)
+ {
+     /* %typemap(freearg)  (int nCount, double *x, double *y, double *z) */
+     CPLFree($2);
+     CPLFree($3);
+     CPLFree($4);
+ }
+ 
+ /***************************************************
+  * Typemaps for Transform.TransformPoints()
+  ***************************************************/
+ 
+ %typemap(in,numinputs=1) (int nCount, double *x, double *y, double *z, int* panSuccess)
+ {
+   /*  typemap(in,numinputs=1) (int nCount, double *x, double *y, double *z, int* panSuccess) */
+   /* The following also checks if input is a list */
+   if (Tcl_ListObjLength(interp, $input, &$1) != TCL_OK) {
+     /* Error msg in interp result */
+     SWIG_fail;
+   }
+   if ( !$1 ) {
+       Tcl_SetResult(interp, (char*) "Input list mustn't be empty", TCL_STATIC);
+       SWIG_fail;
+   }
+   $2 = (double*) CPLMalloc($1*sizeof(double));
+   $3 = (double*) CPLMalloc($1*sizeof(double));
+   $4 = (double*) CPLMalloc($1*sizeof(double));
+   $5 = (int*) CPLMalloc($1*sizeof(int));
+ 
+   for( int i = 0; i<$1; i++ ) {
+ 
+         Tcl_Obj **o = NULL;
+         if (Tcl_ListObjIndex(interp, $input, i, o) != TCL_OK) { /* ref count is not incremented */
+             /* Error msg in interp result */
+             SWIG_fail;
+         }
+ 
+         int size;
+         if (Tcl_ListObjLength(interp, *o, &size) != TCL_OK) {
+             /* Error msg in interp result */
+             SWIG_fail;
+         }
+         if ( size < 2 || size > 3 ) {
+             Tcl_SetResult(interp, (char*) "Not a list of 2 or 3 doubles", TCL_STATIC);
+             SWIG_fail;
+         }
+ 
+         double x, y, z = 0;
+         Tcl_Obj **o2 = NULL;
+         if (Tcl_ListObjIndex(interp, *o, 0, o2) != TCL_OK) { /* ref count is not incremented */
+             /* Error msg in interp result */
+             SWIG_fail;
+         }
+         if (Tcl_GetDoubleFromObj(interp, *o2, &x ) != TCL_OK) {
+             /* Error msg in interp result */
+             SWIG_fail;
+         }
+ 
+         if (Tcl_ListObjIndex(interp, *o, 1, o2) != TCL_OK) { /* ref count is not incremented */
+             /* Error msg in interp result */
+             SWIG_fail;
+         }
+         if (Tcl_GetDoubleFromObj(interp, *o2, &y ) != TCL_OK) {
+             /* Error msg in interp result */
+             SWIG_fail;
+         }
+ 
+         if (size == 3) {
+             if (Tcl_ListObjIndex(interp, *o, 2, o2) != TCL_OK) { /* ref count is not incremented */
+                 /* Error msg in interp result */
+                 SWIG_fail;
+             }
+             if (Tcl_GetDoubleFromObj(interp, *o2, &z ) != TCL_OK) {
+                 /* Error msg in interp result */
+                 SWIG_fail;
+             }
+         }
+ 
+         ($2)[i] = x;
+         ($3)[i] = y;
+         ($4)[i] = z;
+   }
+ }
+ 
+ %typemap(argout)  (int nCount, double *x, double *y, double *z, int* panSuccess)
+ {
+   /* %typemap(argout)  (int nCount, double *x, double *y, double *z, int* panSuccess) */
+   Tcl_Obj *xyz = Tcl_NewListObj(0, NULL);
+   Tcl_Obj *success = Tcl_NewListObj(0, NULL);
+   for( int i=0; i< $1; i++ ) {
+       Tcl_Obj *tuple = Tcl_NewListObj(0, NULL);
+       Tcl_Obj *val = Tcl_NewDoubleObj(($2)[i] );
+       if (Tcl_ListObjAppendElement(interp, tuple, val) != TCL_OK) {
+           Tcl_DecrRefCount(val);
+           Tcl_DecrRefCount(tuple);
+           Tcl_DecrRefCount(xyz);
+           Tcl_DecrRefCount(success);
+           /* Error msg in interp result */
+           SWIG_fail;
+       }
+       val = Tcl_NewDoubleObj(($3)[i] );
+       if (Tcl_ListObjAppendElement(interp, tuple, val) != TCL_OK) {
+           Tcl_DecrRefCount(val);
+           Tcl_DecrRefCount(tuple);
+           Tcl_DecrRefCount(xyz);
+           Tcl_DecrRefCount(success);
+           /* Error msg in interp result */
+           SWIG_fail;
+       }
+       val = Tcl_NewDoubleObj(($4)[i] );
+       if (Tcl_ListObjAppendElement(interp, tuple, val) != TCL_OK) {
+           Tcl_DecrRefCount(val);
+           Tcl_DecrRefCount(tuple);
+           Tcl_DecrRefCount(xyz);
+           Tcl_DecrRefCount(success);
+           /* Error msg in interp result */
+           SWIG_fail;
+       }
+ 
+       if (Tcl_ListObjAppendElement(interp, xyz, tuple) != TCL_OK) {
+           Tcl_DecrRefCount(tuple);
+           Tcl_DecrRefCount(xyz);
+           Tcl_DecrRefCount(success);
+           /* Error msg in interp result */
+           SWIG_fail;
+       }
+ 
+       val = Tcl_NewIntObj(($5)[i] );
+       if (Tcl_ListObjAppendElement(interp, success, val) != TCL_OK) {
+           Tcl_DecrRefCount(val);
+           Tcl_DecrRefCount(xyz);
+           Tcl_DecrRefCount(success);
+           /* Error msg in interp result */
+           SWIG_fail;
+       }
+   }
+ 
+   Tcl_Obj *out = Tcl_NewListObj(0, NULL);
+   if (Tcl_ListObjAppendElement(interp, out, xyz) != TCL_OK) {
+       Tcl_DecrRefCount(xyz);
+       Tcl_DecrRefCount(out);
+       Tcl_DecrRefCount(success);
+       /* Error msg in interp result */
+       SWIG_fail;
+   }
+   if (Tcl_ListObjAppendElement(interp, out, success) != TCL_OK) {
+       Tcl_DecrRefCount(success);
+       Tcl_DecrRefCount(out);
+       /* Error msg in interp result */
+       SWIG_fail;
+   }
+   Tcl_SetObjResult(interp, out);
+ }
+ 
+ %typemap(freearg)  (int nCount, double *x, double *y, double *z, int* panSuccess)
+ {
+     /* %typemap(freearg)  (int nCount, double *x, double *y, double *z, int* panSuccess) */
+     CPLFree($2);
+     CPLFree($3);
+     CPLFree($4);
+     CPLFree($5);
+ }
diff -rNc gdal-1.6.1/swig/tcl/gdalconst_wrap.c gdal-1.6.1-patched/swig/tcl/gdalconst_wrap.c
*** gdal-1.6.1/swig/tcl/gdalconst_wrap.c	1970-01-01 02:00:00.000000000 +0200
--- gdal-1.6.1-patched/swig/tcl/gdalconst_wrap.c	2009-06-30 15:40:02.000000000 +0300
***************
*** 0 ****
--- 1,2148 ----
+ /* ----------------------------------------------------------------------------
+  * This file was automatically generated by SWIG (http://www.swig.org).
+  * Version 1.3.36
+  * 
+  * This file is not intended to be easily readable and contains a number of 
+  * coding conventions designed to improve portability and efficiency. Do not make
+  * changes to this file unless you know what you are doing--modify the SWIG 
+  * interface file instead. 
+  * ----------------------------------------------------------------------------- */
+ 
+ /* -----------------------------------------------------------------------------
+  *  This section contains generic SWIG labels for method/variable
+  *  declarations/attributes, and other compiler dependent labels.
+  * ----------------------------------------------------------------------------- */
+ 
+ /* template workaround for compilers that cannot correctly implement the C++ standard */
+ #ifndef SWIGTEMPLATEDISAMBIGUATOR
+ # if defined(__SUNPRO_CC) && (__SUNPRO_CC <= 0x560)
+ #  define SWIGTEMPLATEDISAMBIGUATOR template
+ # elif defined(__HP_aCC)
+ /* Needed even with `aCC -AA' when `aCC -V' reports HP ANSI C++ B3910B A.03.55 */
+ /* If we find a maximum version that requires this, the test would be __HP_aCC <= 35500 for A.03.55 */
+ #  define SWIGTEMPLATEDISAMBIGUATOR template
+ # else
+ #  define SWIGTEMPLATEDISAMBIGUATOR
+ # endif
+ #endif
+ 
+ /* inline attribute */
+ #ifndef SWIGINLINE
+ # if defined(__cplusplus) || (defined(__GNUC__) && !defined(__STRICT_ANSI__))
+ #   define SWIGINLINE inline
+ # else
+ #   define SWIGINLINE
+ # endif
+ #endif
+ 
+ /* attribute recognised by some compilers to avoid 'unused' warnings */
+ #ifndef SWIGUNUSED
+ # if defined(__GNUC__)
+ #   if !(defined(__cplusplus)) || (__GNUC__ > 3 || (__GNUC__ == 3 && __GNUC_MINOR__ >= 4))
+ #     define SWIGUNUSED __attribute__ ((__unused__)) 
+ #   else
+ #     define SWIGUNUSED
+ #   endif
+ # elif defined(__ICC)
+ #   define SWIGUNUSED __attribute__ ((__unused__)) 
+ # else
+ #   define SWIGUNUSED 
+ # endif
+ #endif
+ 
+ #ifndef SWIG_MSC_UNSUPPRESS_4505
+ # if defined(_MSC_VER)
+ #   pragma warning(disable : 4505) /* unreferenced local function has been removed */
+ # endif 
+ #endif
+ 
+ #ifndef SWIGUNUSEDPARM
+ # ifdef __cplusplus
+ #   define SWIGUNUSEDPARM(p)
+ # else
+ #   define SWIGUNUSEDPARM(p) p SWIGUNUSED 
+ # endif
+ #endif
+ 
+ /* internal SWIG method */
+ #ifndef SWIGINTERN
+ # define SWIGINTERN static SWIGUNUSED
+ #endif
+ 
+ /* internal inline SWIG method */
+ #ifndef SWIGINTERNINLINE
+ # define SWIGINTERNINLINE SWIGINTERN SWIGINLINE
+ #endif
+ 
+ /* exporting methods */
+ #if (__GNUC__ >= 4) || (__GNUC__ == 3 && __GNUC_MINOR__ >= 4)
+ #  ifndef GCC_HASCLASSVISIBILITY
+ #    define GCC_HASCLASSVISIBILITY
+ #  endif
+ #endif
+ 
+ #ifndef SWIGEXPORT
+ # if defined(_WIN32) || defined(__WIN32__) || defined(__CYGWIN__)
+ #   if defined(STATIC_LINKED)
+ #     define SWIGEXPORT
+ #   else
+ #     define SWIGEXPORT __declspec(dllexport)
+ #   endif
+ # else
+ #   if defined(__GNUC__) && defined(GCC_HASCLASSVISIBILITY)
+ #     define SWIGEXPORT __attribute__ ((visibility("default")))
+ #   else
+ #     define SWIGEXPORT
+ #   endif
+ # endif
+ #endif
+ 
+ /* calling conventions for Windows */
+ #ifndef SWIGSTDCALL
+ # if defined(_WIN32) || defined(__WIN32__) || defined(__CYGWIN__)
+ #   define SWIGSTDCALL __stdcall
+ # else
+ #   define SWIGSTDCALL
+ # endif 
+ #endif
+ 
+ /* Deal with Microsoft's attempt at deprecating C standard runtime functions */
+ #if !defined(SWIG_NO_CRT_SECURE_NO_DEPRECATE) && defined(_MSC_VER) && !defined(_CRT_SECURE_NO_DEPRECATE)
+ # define _CRT_SECURE_NO_DEPRECATE
+ #endif
+ 
+ /* Deal with Microsoft's attempt at deprecating methods in the standard C++ library */
+ #if !defined(SWIG_NO_SCL_SECURE_NO_DEPRECATE) && defined(_MSC_VER) && !defined(_SCL_SECURE_NO_DEPRECATE)
+ # define _SCL_SECURE_NO_DEPRECATE
+ #endif
+ 
+ 
+ 
+ #include <stdio.h>
+ #include <tcl.h>
+ #include <errno.h>
+ #include <stdlib.h>
+ #include <stdarg.h>
+ #include <ctype.h>
+ 
+ /* -----------------------------------------------------------------------------
+  * swigrun.swg
+  *
+  * This file contains generic CAPI SWIG runtime support for pointer
+  * type checking.
+  * ----------------------------------------------------------------------------- */
+ 
+ /* This should only be incremented when either the layout of swig_type_info changes,
+    or for whatever reason, the runtime changes incompatibly */
+ #define SWIG_RUNTIME_VERSION "4"
+ 
+ /* define SWIG_TYPE_TABLE_NAME as "SWIG_TYPE_TABLE" */
+ #ifdef SWIG_TYPE_TABLE
+ # define SWIG_QUOTE_STRING(x) #x
+ # define SWIG_EXPAND_AND_QUOTE_STRING(x) SWIG_QUOTE_STRING(x)
+ # define SWIG_TYPE_TABLE_NAME SWIG_EXPAND_AND_QUOTE_STRING(SWIG_TYPE_TABLE)
+ #else
+ # define SWIG_TYPE_TABLE_NAME
+ #endif
+ 
+ /*
+   You can use the SWIGRUNTIME and SWIGRUNTIMEINLINE macros for
+   creating a static or dynamic library from the swig runtime code.
+   In 99.9% of the cases, swig just needs to declare them as 'static'.
+   
+   But only do this if is strictly necessary, ie, if you have problems
+   with your compiler or so.
+ */
+ 
+ #ifndef SWIGRUNTIME
+ # define SWIGRUNTIME SWIGINTERN
+ #endif
+ 
+ #ifndef SWIGRUNTIMEINLINE
+ # define SWIGRUNTIMEINLINE SWIGRUNTIME SWIGINLINE
+ #endif
+ 
+ /*  Generic buffer size */
+ #ifndef SWIG_BUFFER_SIZE
+ # define SWIG_BUFFER_SIZE 1024
+ #endif
+ 
+ /* Flags for pointer conversions */
+ #define SWIG_POINTER_DISOWN        0x1
+ #define SWIG_CAST_NEW_MEMORY       0x2
+ 
+ /* Flags for new pointer objects */
+ #define SWIG_POINTER_OWN           0x1
+ 
+ 
+ /* 
+    Flags/methods for returning states.
+    
+    The swig conversion methods, as ConvertPtr, return and integer 
+    that tells if the conversion was successful or not. And if not,
+    an error code can be returned (see swigerrors.swg for the codes).
+    
+    Use the following macros/flags to set or process the returning
+    states.
+    
+    In old swig versions, you usually write code as:
+ 
+      if (SWIG_ConvertPtr(obj,vptr,ty.flags) != -1) {
+        // success code
+      } else {
+        //fail code
+      }
+ 
+    Now you can be more explicit as:
+ 
+     int res = SWIG_ConvertPtr(obj,vptr,ty.flags);
+     if (SWIG_IsOK(res)) {
+       // success code
+     } else {
+       // fail code
+     }
+ 
+    that seems to be the same, but now you can also do
+ 
+     Type *ptr;
+     int res = SWIG_ConvertPtr(obj,(void **)(&ptr),ty.flags);
+     if (SWIG_IsOK(res)) {
+       // success code
+       if (SWIG_IsNewObj(res) {
+         ...
+ 	delete *ptr;
+       } else {
+         ...
+       }
+     } else {
+       // fail code
+     }
+     
+    I.e., now SWIG_ConvertPtr can return new objects and you can
+    identify the case and take care of the deallocation. Of course that
+    requires also to SWIG_ConvertPtr to return new result values, as
+ 
+       int SWIG_ConvertPtr(obj, ptr,...) {         
+         if (<obj is ok>) {			       
+           if (<need new object>) {		       
+             *ptr = <ptr to new allocated object>; 
+             return SWIG_NEWOBJ;		       
+           } else {				       
+             *ptr = <ptr to old object>;	       
+             return SWIG_OLDOBJ;		       
+           } 				       
+         } else {				       
+           return SWIG_BADOBJ;		       
+         }					       
+       }
+ 
+    Of course, returning the plain '0(success)/-1(fail)' still works, but you can be
+    more explicit by returning SWIG_BADOBJ, SWIG_ERROR or any of the
+    swig errors code.
+ 
+    Finally, if the SWIG_CASTRANK_MODE is enabled, the result code
+    allows to return the 'cast rank', for example, if you have this
+ 
+        int food(double)
+        int fooi(int);
+ 
+    and you call
+  
+       food(1)   // cast rank '1'  (1 -> 1.0)
+       fooi(1)   // cast rank '0'
+ 
+    just use the SWIG_AddCast()/SWIG_CheckState()
+ 
+ 
+  */
+ #define SWIG_OK                    (0) 
+ #define SWIG_ERROR                 (-1)
+ #define SWIG_IsOK(r)               (r >= 0)
+ #define SWIG_ArgError(r)           ((r != SWIG_ERROR) ? r : SWIG_TypeError)  
+ 
+ /* The CastRankLimit says how many bits are used for the cast rank */
+ #define SWIG_CASTRANKLIMIT         (1 << 8)
+ /* The NewMask denotes the object was created (using new/malloc) */
+ #define SWIG_NEWOBJMASK            (SWIG_CASTRANKLIMIT  << 1)
+ /* The TmpMask is for in/out typemaps that use temporal objects */
+ #define SWIG_TMPOBJMASK            (SWIG_NEWOBJMASK << 1)
+ /* Simple returning values */
+ #define SWIG_BADOBJ                (SWIG_ERROR)
+ #define SWIG_OLDOBJ                (SWIG_OK)
+ #define SWIG_NEWOBJ                (SWIG_OK | SWIG_NEWOBJMASK)
+ #define SWIG_TMPOBJ                (SWIG_OK | SWIG_TMPOBJMASK)
+ /* Check, add and del mask methods */
+ #define SWIG_AddNewMask(r)         (SWIG_IsOK(r) ? (r | SWIG_NEWOBJMASK) : r)
+ #define SWIG_DelNewMask(r)         (SWIG_IsOK(r) ? (r & ~SWIG_NEWOBJMASK) : r)
+ #define SWIG_IsNewObj(r)           (SWIG_IsOK(r) && (r & SWIG_NEWOBJMASK))
+ #define SWIG_AddTmpMask(r)         (SWIG_IsOK(r) ? (r | SWIG_TMPOBJMASK) : r)
+ #define SWIG_DelTmpMask(r)         (SWIG_IsOK(r) ? (r & ~SWIG_TMPOBJMASK) : r)
+ #define SWIG_IsTmpObj(r)           (SWIG_IsOK(r) && (r & SWIG_TMPOBJMASK))
+ 
+ 
+ /* Cast-Rank Mode */
+ #if defined(SWIG_CASTRANK_MODE)
+ #  ifndef SWIG_TypeRank
+ #    define SWIG_TypeRank             unsigned long
+ #  endif
+ #  ifndef SWIG_MAXCASTRANK            /* Default cast allowed */
+ #    define SWIG_MAXCASTRANK          (2)
+ #  endif
+ #  define SWIG_CASTRANKMASK          ((SWIG_CASTRANKLIMIT) -1)
+ #  define SWIG_CastRank(r)           (r & SWIG_CASTRANKMASK)
+ SWIGINTERNINLINE int SWIG_AddCast(int r) { 
+   return SWIG_IsOK(r) ? ((SWIG_CastRank(r) < SWIG_MAXCASTRANK) ? (r + 1) : SWIG_ERROR) : r;
+ }
+ SWIGINTERNINLINE int SWIG_CheckState(int r) { 
+   return SWIG_IsOK(r) ? SWIG_CastRank(r) + 1 : 0; 
+ }
+ #else /* no cast-rank mode */
+ #  define SWIG_AddCast
+ #  define SWIG_CheckState(r) (SWIG_IsOK(r) ? 1 : 0)
+ #endif
+ 
+ 
+ 
+ 
+ #include <string.h>
+ 
+ #ifdef __cplusplus
+ extern "C" {
+ #endif
+ 
+ typedef void *(*swig_converter_func)(void *, int *);
+ typedef struct swig_type_info *(*swig_dycast_func)(void **);
+ 
+ /* Structure to store information on one type */
+ typedef struct swig_type_info {
+   const char             *name;			/* mangled name of this type */
+   const char             *str;			/* human readable name of this type */
+   swig_dycast_func        dcast;		/* dynamic cast function down a hierarchy */
+   struct swig_cast_info  *cast;			/* linked list of types that can cast into this type */
+   void                   *clientdata;		/* language specific type data */
+   int                    owndata;		/* flag if the structure owns the clientdata */
+ } swig_type_info;
+ 
+ /* Structure to store a type and conversion function used for casting */
+ typedef struct swig_cast_info {
+   swig_type_info         *type;			/* pointer to type that is equivalent to this type */
+   swig_converter_func     converter;		/* function to cast the void pointers */
+   struct swig_cast_info  *next;			/* pointer to next cast in linked list */
+   struct swig_cast_info  *prev;			/* pointer to the previous cast */
+ } swig_cast_info;
+ 
+ /* Structure used to store module information
+  * Each module generates one structure like this, and the runtime collects
+  * all of these structures and stores them in a circularly linked list.*/
+ typedef struct swig_module_info {
+   swig_type_info         **types;		/* Array of pointers to swig_type_info structures that are in this module */
+   size_t                 size;		        /* Number of types in this module */
+   struct swig_module_info *next;		/* Pointer to next element in circularly linked list */
+   swig_type_info         **type_initial;	/* Array of initially generated type structures */
+   swig_cast_info         **cast_initial;	/* Array of initially generated casting structures */
+   void                    *clientdata;		/* Language specific module data */
+ } swig_module_info;
+ 
+ /* 
+   Compare two type names skipping the space characters, therefore
+   "char*" == "char *" and "Class<int>" == "Class<int >", etc.
+ 
+   Return 0 when the two name types are equivalent, as in
+   strncmp, but skipping ' '.
+ */
+ SWIGRUNTIME int
+ SWIG_TypeNameComp(const char *f1, const char *l1,
+ 		  const char *f2, const char *l2) {
+   for (;(f1 != l1) && (f2 != l2); ++f1, ++f2) {
+     while ((*f1 == ' ') && (f1 != l1)) ++f1;
+     while ((*f2 == ' ') && (f2 != l2)) ++f2;
+     if (*f1 != *f2) return (*f1 > *f2) ? 1 : -1;
+   }
+   return (int)((l1 - f1) - (l2 - f2));
+ }
+ 
+ /*
+   Check type equivalence in a name list like <name1>|<name2>|...
+   Return 0 if not equal, 1 if equal
+ */
+ SWIGRUNTIME int
+ SWIG_TypeEquiv(const char *nb, const char *tb) {
+   int equiv = 0;
+   const char* te = tb + strlen(tb);
+   const char* ne = nb;
+   while (!equiv && *ne) {
+     for (nb = ne; *ne; ++ne) {
+       if (*ne == '|') break;
+     }
+     equiv = (SWIG_TypeNameComp(nb, ne, tb, te) == 0) ? 1 : 0;
+     if (*ne) ++ne;
+   }
+   return equiv;
+ }
+ 
+ /*
+   Check type equivalence in a name list like <name1>|<name2>|...
+   Return 0 if equal, -1 if nb < tb, 1 if nb > tb
+ */
+ SWIGRUNTIME int
+ SWIG_TypeCompare(const char *nb, const char *tb) {
+   int equiv = 0;
+   const char* te = tb + strlen(tb);
+   const char* ne = nb;
+   while (!equiv && *ne) {
+     for (nb = ne; *ne; ++ne) {
+       if (*ne == '|') break;
+     }
+     equiv = (SWIG_TypeNameComp(nb, ne, tb, te) == 0) ? 1 : 0;
+     if (*ne) ++ne;
+   }
+   return equiv;
+ }
+ 
+ 
+ /* think of this as a c++ template<> or a scheme macro */
+ #define SWIG_TypeCheck_Template(comparison, ty)         \
+   if (ty) {                                             \
+     swig_cast_info *iter = ty->cast;                    \
+     while (iter) {                                      \
+       if (comparison) {                                 \
+         if (iter == ty->cast) return iter;              \
+         /* Move iter to the top of the linked list */   \
+         iter->prev->next = iter->next;                  \
+         if (iter->next)                                 \
+           iter->next->prev = iter->prev;                \
+         iter->next = ty->cast;                          \
+         iter->prev = 0;                                 \
+         if (ty->cast) ty->cast->prev = iter;            \
+         ty->cast = iter;                                \
+         return iter;                                    \
+       }                                                 \
+       iter = iter->next;                                \
+     }                                                   \
+   }                                                     \
+   return 0
+ 
+ /*
+   Check the typename
+ */
+ SWIGRUNTIME swig_cast_info *
+ SWIG_TypeCheck(const char *c, swig_type_info *ty) {
+   SWIG_TypeCheck_Template(strcmp(iter->type->name, c) == 0, ty);
+ }
+ 
+ /* Same as previous function, except strcmp is replaced with a pointer comparison */
+ SWIGRUNTIME swig_cast_info *
+ SWIG_TypeCheckStruct(swig_type_info *from, swig_type_info *into) {
+   SWIG_TypeCheck_Template(iter->type == from, into);
+ }
+ 
+ /*
+   Cast a pointer up an inheritance hierarchy
+ */
+ SWIGRUNTIMEINLINE void *
+ SWIG_TypeCast(swig_cast_info *ty, void *ptr, int *newmemory) {
+   return ((!ty) || (!ty->converter)) ? ptr : (*ty->converter)(ptr, newmemory);
+ }
+ 
+ /* 
+    Dynamic pointer casting. Down an inheritance hierarchy
+ */
+ SWIGRUNTIME swig_type_info *
+ SWIG_TypeDynamicCast(swig_type_info *ty, void **ptr) {
+   swig_type_info *lastty = ty;
+   if (!ty || !ty->dcast) return ty;
+   while (ty && (ty->dcast)) {
+     ty = (*ty->dcast)(ptr);
+     if (ty) lastty = ty;
+   }
+   return lastty;
+ }
+ 
+ /*
+   Return the name associated with this type
+ */
+ SWIGRUNTIMEINLINE const char *
+ SWIG_TypeName(const swig_type_info *ty) {
+   return ty->name;
+ }
+ 
+ /*
+   Return the pretty name associated with this type,
+   that is an unmangled type name in a form presentable to the user.
+ */
+ SWIGRUNTIME const char *
+ SWIG_TypePrettyName(const swig_type_info *type) {
+   /* The "str" field contains the equivalent pretty names of the
+      type, separated by vertical-bar characters.  We choose
+      to print the last name, as it is often (?) the most
+      specific. */
+   if (!type) return NULL;
+   if (type->str != NULL) {
+     const char *last_name = type->str;
+     const char *s;
+     for (s = type->str; *s; s++)
+       if (*s == '|') last_name = s+1;
+     return last_name;
+   }
+   else
+     return type->name;
+ }
+ 
+ /* 
+    Set the clientdata field for a type
+ */
+ SWIGRUNTIME void
+ SWIG_TypeClientData(swig_type_info *ti, void *clientdata) {
+   swig_cast_info *cast = ti->cast;
+   /* if (ti->clientdata == clientdata) return; */
+   ti->clientdata = clientdata;
+   
+   while (cast) {
+     if (!cast->converter) {
+       swig_type_info *tc = cast->type;
+       if (!tc->clientdata) {
+ 	SWIG_TypeClientData(tc, clientdata);
+       }
+     }    
+     cast = cast->next;
+   }
+ }
+ SWIGRUNTIME void
+ SWIG_TypeNewClientData(swig_type_info *ti, void *clientdata) {
+   SWIG_TypeClientData(ti, clientdata);
+   ti->owndata = 1;
+ }
+   
+ /*
+   Search for a swig_type_info structure only by mangled name
+   Search is a O(log #types)
+   
+   We start searching at module start, and finish searching when start == end.  
+   Note: if start == end at the beginning of the function, we go all the way around
+   the circular list.
+ */
+ SWIGRUNTIME swig_type_info *
+ SWIG_MangledTypeQueryModule(swig_module_info *start, 
+                             swig_module_info *end, 
+ 		            const char *name) {
+   swig_module_info *iter = start;
+   do {
+     if (iter->size) {
+       register size_t l = 0;
+       register size_t r = iter->size - 1;
+       do {
+ 	/* since l+r >= 0, we can (>> 1) instead (/ 2) */
+ 	register size_t i = (l + r) >> 1; 
+ 	const char *iname = iter->types[i]->name;
+ 	if (iname) {
+ 	  register int compare = strcmp(name, iname);
+ 	  if (compare == 0) {	    
+ 	    return iter->types[i];
+ 	  } else if (compare < 0) {
+ 	    if (i) {
+ 	      r = i - 1;
+ 	    } else {
+ 	      break;
+ 	    }
+ 	  } else if (compare > 0) {
+ 	    l = i + 1;
+ 	  }
+ 	} else {
+ 	  break; /* should never happen */
+ 	}
+       } while (l <= r);
+     }
+     iter = iter->next;
+   } while (iter != end);
+   return 0;
+ }
+ 
+ /*
+   Search for a swig_type_info structure for either a mangled name or a human readable name.
+   It first searches the mangled names of the types, which is a O(log #types)
+   If a type is not found it then searches the human readable names, which is O(#types).
+   
+   We start searching at module start, and finish searching when start == end.  
+   Note: if start == end at the beginning of the function, we go all the way around
+   the circular list.
+ */
+ SWIGRUNTIME swig_type_info *
+ SWIG_TypeQueryModule(swig_module_info *start, 
+                      swig_module_info *end, 
+ 		     const char *name) {
+   /* STEP 1: Search the name field using binary search */
+   swig_type_info *ret = SWIG_MangledTypeQueryModule(start, end, name);
+   if (ret) {
+     return ret;
+   } else {
+     /* STEP 2: If the type hasn't been found, do a complete search
+        of the str field (the human readable name) */
+     swig_module_info *iter = start;
+     do {
+       register size_t i = 0;
+       for (; i < iter->size; ++i) {
+ 	if (iter->types[i]->str && (SWIG_TypeEquiv(iter->types[i]->str, name)))
+ 	  return iter->types[i];
+       }
+       iter = iter->next;
+     } while (iter != end);
+   }
+   
+   /* neither found a match */
+   return 0;
+ }
+ 
+ /* 
+    Pack binary data into a string
+ */
+ SWIGRUNTIME char *
+ SWIG_PackData(char *c, void *ptr, size_t sz) {
+   static const char hex[17] = "0123456789abcdef";
+   register const unsigned char *u = (unsigned char *) ptr;
+   register const unsigned char *eu =  u + sz;
+   for (; u != eu; ++u) {
+     register unsigned char uu = *u;
+     *(c++) = hex[(uu & 0xf0) >> 4];
+     *(c++) = hex[uu & 0xf];
+   }
+   return c;
+ }
+ 
+ /* 
+    Unpack binary data from a string
+ */
+ SWIGRUNTIME const char *
+ SWIG_UnpackData(const char *c, void *ptr, size_t sz) {
+   register unsigned char *u = (unsigned char *) ptr;
+   register const unsigned char *eu = u + sz;
+   for (; u != eu; ++u) {
+     register char d = *(c++);
+     register unsigned char uu;
+     if ((d >= '0') && (d <= '9'))
+       uu = ((d - '0') << 4);
+     else if ((d >= 'a') && (d <= 'f'))
+       uu = ((d - ('a'-10)) << 4);
+     else 
+       return (char *) 0;
+     d = *(c++);
+     if ((d >= '0') && (d <= '9'))
+       uu |= (d - '0');
+     else if ((d >= 'a') && (d <= 'f'))
+       uu |= (d - ('a'-10));
+     else 
+       return (char *) 0;
+     *u = uu;
+   }
+   return c;
+ }
+ 
+ /* 
+    Pack 'void *' into a string buffer.
+ */
+ SWIGRUNTIME char *
+ SWIG_PackVoidPtr(char *buff, void *ptr, const char *name, size_t bsz) {
+   char *r = buff;
+   if ((2*sizeof(void *) + 2) > bsz) return 0;
+   *(r++) = '_';
+   r = SWIG_PackData(r,&ptr,sizeof(void *));
+   if (strlen(name) + 1 > (bsz - (r - buff))) return 0;
+   strcpy(r,name);
+   return buff;
+ }
+ 
+ SWIGRUNTIME const char *
+ SWIG_UnpackVoidPtr(const char *c, void **ptr, const char *name) {
+   if (*c != '_') {
+     if (strcmp(c,"NULL") == 0) {
+       *ptr = (void *) 0;
+       return name;
+     } else {
+       return 0;
+     }
+   }
+   return SWIG_UnpackData(++c,ptr,sizeof(void *));
+ }
+ 
+ SWIGRUNTIME char *
+ SWIG_PackDataName(char *buff, void *ptr, size_t sz, const char *name, size_t bsz) {
+   char *r = buff;
+   size_t lname = (name ? strlen(name) : 0);
+   if ((2*sz + 2 + lname) > bsz) return 0;
+   *(r++) = '_';
+   r = SWIG_PackData(r,ptr,sz);
+   if (lname) {
+     strncpy(r,name,lname+1);
+   } else {
+     *r = 0;
+   }
+   return buff;
+ }
+ 
+ SWIGRUNTIME const char *
+ SWIG_UnpackDataName(const char *c, void *ptr, size_t sz, const char *name) {
+   if (*c != '_') {
+     if (strcmp(c,"NULL") == 0) {
+       memset(ptr,0,sz);
+       return name;
+     } else {
+       return 0;
+     }
+   }
+   return SWIG_UnpackData(++c,ptr,sz);
+ }
+ 
+ #ifdef __cplusplus
+ }
+ #endif
+ 
+ /*  Errors in SWIG */
+ #define  SWIG_UnknownError    	   -1 
+ #define  SWIG_IOError        	   -2 
+ #define  SWIG_RuntimeError   	   -3 
+ #define  SWIG_IndexError     	   -4 
+ #define  SWIG_TypeError      	   -5 
+ #define  SWIG_DivisionByZero 	   -6 
+ #define  SWIG_OverflowError  	   -7 
+ #define  SWIG_SyntaxError    	   -8 
+ #define  SWIG_ValueError     	   -9 
+ #define  SWIG_SystemError    	   -10
+ #define  SWIG_AttributeError 	   -11
+ #define  SWIG_MemoryError    	   -12 
+ #define  SWIG_NullReferenceError   -13
+ 
+ 
+ 
+ /* -----------------------------------------------------------------------------
+  * error manipulation
+  * ----------------------------------------------------------------------------- */
+ 
+ SWIGINTERN const char*
+ SWIG_Tcl_ErrorType(int code) {
+   const char* type = 0;
+   switch(code) {
+   case SWIG_MemoryError:
+     type = "MemoryError";
+     break;
+   case SWIG_IOError:
+     type = "IOError";
+     break;
+   case SWIG_RuntimeError:
+     type = "RuntimeError";
+     break;
+   case SWIG_IndexError:
+     type = "IndexError";
+     break;
+   case SWIG_TypeError:
+     type = "TypeError";
+     break;
+   case SWIG_DivisionByZero:
+     type = "ZeroDivisionError";
+     break;
+   case SWIG_OverflowError:
+     type = "OverflowError";
+     break;
+   case SWIG_SyntaxError:
+     type = "SyntaxError";
+     break;
+   case SWIG_ValueError:
+     type = "ValueError";
+     break;
+   case SWIG_SystemError:
+     type = "SystemError";
+     break;
+   case SWIG_AttributeError:
+     type = "AttributeError";
+     break;
+   default:
+     type = "RuntimeError";
+   }
+   return type;
+ }
+ 
+ 
+ SWIGINTERN void
+ SWIG_Tcl_SetErrorObj(Tcl_Interp *interp, const char *ctype, Tcl_Obj *obj)
+ {
+   Tcl_ResetResult(interp);
+   Tcl_SetObjResult(interp, obj);
+   Tcl_SetErrorCode(interp, "SWIG", ctype, NULL);
+ }
+ 
+ SWIGINTERN void
+ SWIG_Tcl_SetErrorMsg(Tcl_Interp *interp, const char *ctype, const char *mesg)
+ {
+   Tcl_ResetResult(interp);
+   Tcl_SetErrorCode(interp, "SWIG", ctype, NULL);
+   Tcl_AppendResult(interp, ctype, " ", mesg, NULL);
+   /*
+   Tcl_AddErrorInfo(interp, ctype);
+   Tcl_AddErrorInfo(interp, " ");
+   Tcl_AddErrorInfo(interp, mesg);
+   */
+ }
+ 
+ SWIGINTERNINLINE void
+ SWIG_Tcl_AddErrorMsg(Tcl_Interp *interp, const char* mesg)
+ {
+   Tcl_AddErrorInfo(interp, mesg);
+ }
+ 
+ 
+ 
+ /* -----------------------------------------------------------------------------
+  * SWIG API. Portion that goes into the runtime
+  * ----------------------------------------------------------------------------- */
+ #ifdef __cplusplus
+ extern "C" {
+ #endif
+ 
+ /* -----------------------------------------------------------------------------
+  * Constant declarations
+  * ----------------------------------------------------------------------------- */
+ 
+ /* Constant Types */
+ #define SWIG_TCL_POINTER 4
+ #define SWIG_TCL_BINARY  5
+ 
+ /* Constant information structure */
+ typedef struct swig_const_info {
+     int type;
+     char *name;
+     long lvalue;
+     double dvalue;
+     void   *pvalue;
+     swig_type_info **ptype;
+ } swig_const_info;
+ 
+ typedef int   (*swig_wrapper)(ClientData, Tcl_Interp *, int, Tcl_Obj *CONST []);
+ typedef int   (*swig_wrapper_func)(ClientData, Tcl_Interp *, int, Tcl_Obj *CONST []);
+ typedef char *(*swig_variable_func)(ClientData, Tcl_Interp *, char *, char *, int);
+ typedef void  (*swig_delete_func)(ClientData);
+ 
+ typedef struct swig_method {
+   const char     *name;
+   swig_wrapper   method;
+ } swig_method;
+ 
+ typedef struct swig_attribute {
+   const char     *name;
+   swig_wrapper   getmethod;
+   swig_wrapper   setmethod;
+ } swig_attribute;
+ 
+ typedef struct swig_class {
+   const char         *name;
+   swig_type_info   **type;
+   swig_wrapper       constructor;
+   void              (*destructor)(void *);
+   swig_method        *methods;
+   swig_attribute     *attributes;
+   struct swig_class **bases;
+   const char              **base_names;
+   swig_module_info   *module;
+ } swig_class;
+ 
+ typedef struct swig_instance {
+   Tcl_Obj       *thisptr;
+   void          *thisvalue;
+   swig_class   *classptr;
+   int            destroy;
+   Tcl_Command    cmdtok;
+ } swig_instance;
+ 
+ /* Structure for command table */
+ typedef struct {
+   const char *name;
+   int       (*wrapper)(ClientData, Tcl_Interp *, int, Tcl_Obj *CONST []);
+   ClientData  clientdata;
+ } swig_command_info;
+ 
+ /* Structure for variable linking table */
+ typedef struct {
+   const char *name;
+   void *addr;
+   char * (*get)(ClientData, Tcl_Interp *, char *, char *, int);
+   char * (*set)(ClientData, Tcl_Interp *, char *, char *, int);
+ } swig_var_info;
+ 
+ 
+ /* -----------------------------------------------------------------------------*
+  *  Install a constant object 
+  * -----------------------------------------------------------------------------*/
+ 
+ static Tcl_HashTable   swigconstTable;
+ static int             swigconstTableinit = 0;
+ 
+ SWIGINTERN void
+ SWIG_Tcl_SetConstantObj(Tcl_Interp *interp, const char* name, Tcl_Obj *obj) {
+   int newobj;
+   Tcl_ObjSetVar2(interp,Tcl_NewStringObj(name,-1), NULL, obj, TCL_GLOBAL_ONLY);
+   Tcl_SetHashValue(Tcl_CreateHashEntry(&swigconstTable, name, &newobj), (ClientData) obj);
+ }
+ 
+ SWIGINTERN Tcl_Obj *
+ SWIG_Tcl_GetConstantObj(const char *key) {
+   Tcl_HashEntry *entryPtr;
+   if (!swigconstTableinit) return 0;
+   entryPtr = Tcl_FindHashEntry(&swigconstTable, key);
+   if (entryPtr) {
+     return (Tcl_Obj *) Tcl_GetHashValue(entryPtr);
+   }
+   return 0;
+ }
+ 
+ #ifdef __cplusplus
+ }
+ #endif
+ 
+ 
+ 
+ /* -----------------------------------------------------------------------------
+  * See the LICENSE file for information on copyright, usage and redistribution
+  * of SWIG, and the README file for authors - http://www.swig.org/release.html.
+  *
+  * tclrun.swg
+  *
+  * This file contains the runtime support for Tcl modules and includes
+  * code for managing global variables and pointer type checking.
+  * ----------------------------------------------------------------------------- */
+ 
+ /* Common SWIG API */
+ 
+ /* for raw pointers */
+ #define SWIG_ConvertPtr(oc, ptr, ty, flags)             SWIG_Tcl_ConvertPtr(interp, oc, ptr, ty, flags)
+ #define SWIG_NewPointerObj(ptr, type, flags)            SWIG_Tcl_NewPointerObj(ptr, type, flags)
+ 
+ /* for raw packed data */
+ #define SWIG_ConvertPacked(obj, ptr, sz, ty)            SWIG_Tcl_ConvertPacked(interp, obj, ptr, sz, ty)
+ #define SWIG_NewPackedObj(ptr, sz, type)                SWIG_Tcl_NewPackedObj(ptr, sz, type)
+ 
+ /* for class or struct pointers */
+ #define SWIG_ConvertInstance(obj, pptr, type, flags)    SWIG_Tcl_ConvertPtr(interp, obj, pptr, type, flags)
+ #define SWIG_NewInstanceObj(thisvalue, type, flags)     SWIG_Tcl_NewInstanceObj(interp, thisvalue, type, flags)
+ 
+ /* for C or C++ function pointers */
+ #define SWIG_ConvertFunctionPtr(obj, pptr, type)        SWIG_Tcl_ConvertPtr(interp, obj, pptr, type, 0)
+ #define SWIG_NewFunctionPtrObj(ptr, type)               SWIG_Tcl_NewPointerObj(ptr, type, 0)
+ 
+ /* for C++ member pointers, ie, member methods */
+ #define SWIG_ConvertMember(obj, ptr, sz, ty)            SWIG_Tcl_ConvertPacked(interp,obj, ptr, sz, ty)
+ #define SWIG_NewMemberObj(ptr, sz, type)                SWIG_Tcl_NewPackedObj(ptr, sz, type)
+ 
+ 
+ /* Runtime API */
+ 
+ #define SWIG_GetModule(clientdata)                      SWIG_Tcl_GetModule((Tcl_Interp *) (clientdata))	     
+ #define SWIG_SetModule(clientdata, pointer)          	SWIG_Tcl_SetModule((Tcl_Interp *) (clientdata), pointer)
+ 
+ 
+ /* Error manipulation */
+ 
+ #define SWIG_ErrorType(code)                            SWIG_Tcl_ErrorType(code)                                      
+ #define SWIG_Error(code, msg)            		SWIG_Tcl_SetErrorMsg(interp, SWIG_Tcl_ErrorType(code), msg)
+ #define SWIG_fail                        		goto fail						    
+ 
+ 
+ /* Tcl-specific SWIG API */
+ 
+ #define SWIG_Acquire(ptr)                               SWIG_Tcl_Acquire(ptr)                                     
+ #define SWIG_MethodCommand                           	SWIG_Tcl_MethodCommand				       
+ #define SWIG_Disown(ptr)                             	SWIG_Tcl_Disown(ptr)				       
+ #define SWIG_ConvertPtrFromString(c, ptr, ty, flags) 	SWIG_Tcl_ConvertPtrFromString(interp, c, ptr, ty, flags)  
+ #define SWIG_MakePtr(c, ptr, ty, flags)              	SWIG_Tcl_MakePtr(c, ptr, ty, flags)		       
+ #define SWIG_PointerTypeFromString(c)                	SWIG_Tcl_PointerTypeFromString(c)			       
+ #define SWIG_GetArgs                                 	SWIG_Tcl_GetArgs					       
+ #define SWIG_GetConstantObj(key)                     	SWIG_Tcl_GetConstantObj(key)			       
+ #define SWIG_ObjectConstructor                       	SWIG_Tcl_ObjectConstructor				       
+ #define SWIG_Thisown(ptr)                            	SWIG_Tcl_Thisown(ptr)				       
+ #define SWIG_ObjectDelete                            	SWIG_Tcl_ObjectDelete				       
+ 
+ 
+ #define SWIG_TCL_DECL_ARGS_2(arg1, arg2)                (Tcl_Interp *interp SWIGUNUSED, arg1, arg2)
+ #define SWIG_TCL_CALL_ARGS_2(arg1, arg2)                (interp, arg1, arg2)
+ /* -----------------------------------------------------------------------------
+  * pointers/data manipulation
+  * ----------------------------------------------------------------------------- */
+ 
+ /* For backward compatibility only */
+ #define SWIG_POINTER_EXCEPTION  0
+ #define SWIG_GetConstant        SWIG_GetConstantObj
+ #define SWIG_Tcl_GetConstant    SWIG_Tcl_GetConstantObj
+ 
+ #include "assert.h"
+ 
+ #ifdef __cplusplus
+ extern "C" {
+ #if 0
+ } /* cc-mode */
+ #endif
+ #endif
+ 
+ /* Object support */
+ 
+ SWIGRUNTIME Tcl_HashTable*
+ SWIG_Tcl_ObjectTable(void) {
+   static Tcl_HashTable  swigobjectTable;
+   static int            swigobjectTableinit = 0;
+   if (!swigobjectTableinit) {
+     Tcl_InitHashTable(&swigobjectTable, TCL_ONE_WORD_KEYS);
+     swigobjectTableinit = 1;
+   }
+   return &swigobjectTable;
+ }
+ 
+ /* Acquire ownership of a pointer */
+ SWIGRUNTIME void
+ SWIG_Tcl_Acquire(void *ptr) {
+   int newobj;
+   Tcl_CreateHashEntry(SWIG_Tcl_ObjectTable(), (char *) ptr, &newobj);
+ }
+ 
+ SWIGRUNTIME int
+ SWIG_Tcl_Thisown(void *ptr) {
+   if (Tcl_FindHashEntry(SWIG_Tcl_ObjectTable(), (char *) ptr)) {
+     return 1;
+   }
+   return 0;
+ }
+ 
+ /* Disown a pointer.  Returns 1 if we owned it to begin with */
+ SWIGRUNTIME int
+ SWIG_Tcl_Disown(void *ptr) {
+   Tcl_HashEntry *entryPtr = Tcl_FindHashEntry(SWIG_Tcl_ObjectTable(), (char *) ptr);
+   if (entryPtr) {
+     Tcl_DeleteHashEntry(entryPtr);
+     return 1;
+   }
+   return 0;
+ }
+ 
+ /* Convert a pointer value */
+ SWIGRUNTIME int
+ SWIG_Tcl_ConvertPtrFromString(Tcl_Interp *interp, const char *c, void **ptr, swig_type_info *ty, int flags) {
+   swig_cast_info *tc;
+   /* Pointer values must start with leading underscore */
+   while (*c != '_') {
+     *ptr = (void *) 0;
+     if (strcmp(c,"NULL") == 0) return SWIG_OK;
+ 
+     /* Empty string: not a pointer */
+     if (*c == 0) return SWIG_ERROR; 
+ 
+     /* Hmmm. It could be an object name. */
+ 
+     /* Check if this is a command at all. Prevents <c> cget -this         */
+     /* from being called when c is not a command, firing the unknown proc */
+     if (Tcl_VarEval(interp,"info commands ", c, (char *) NULL) == TCL_OK) {
+       Tcl_Obj *result = Tcl_GetObjResult(interp);
+       if (*(Tcl_GetStringFromObj(result, NULL)) == 0) {
+         /* It's not a command, so it can't be a pointer */
+         Tcl_ResetResult(interp);
+         return SWIG_ERROR;
+       }
+     } else {
+       /* This will only fail if the argument is multiple words. */
+       /* Multiple words are also not commands.                  */
+       Tcl_ResetResult(interp);
+       return SWIG_ERROR;
+     }
+ 
+     /* Check if this is really a SWIG pointer */
+     if (Tcl_VarEval(interp,c," cget -this", (char *) NULL) != TCL_OK) {
+       Tcl_ResetResult(interp);
+       return SWIG_ERROR;
+     }
+ 
+     c = Tcl_GetStringFromObj(Tcl_GetObjResult(interp), NULL);
+   }
+ 
+   c++;
+   c = SWIG_UnpackData(c,ptr,sizeof(void *));
+   if (ty) {
+     tc = c ? SWIG_TypeCheck(c,ty) : 0;
+     if (!tc) {
+       return SWIG_ERROR;
+     }
+     if (flags & SWIG_POINTER_DISOWN) {
+       SWIG_Disown((void *) *ptr);
+     }
+     {
+       int newmemory = 0;
+       *ptr = SWIG_TypeCast(tc,(void *) *ptr,&newmemory);
+       assert(!newmemory); /* newmemory handling not yet implemented */
+     }
+   }
+   return SWIG_OK;
+ }
+ 
+ /* Convert a pointer value */
+ SWIGRUNTIMEINLINE int
+ SWIG_Tcl_ConvertPtr(Tcl_Interp *interp, Tcl_Obj *oc, void **ptr, swig_type_info *ty, int flags) {
+   return SWIG_Tcl_ConvertPtrFromString(interp, Tcl_GetStringFromObj(oc,NULL), ptr, ty, flags);
+ }
+ 
+ /* Convert a pointer value */
+ SWIGRUNTIME char *
+ SWIG_Tcl_PointerTypeFromString(char *c) {
+   char d;
+   /* Pointer values must start with leading underscore. NULL has no type */
+   if (*c != '_') {
+     return 0;
+   }
+   c++;
+   /* Extract hex value from pointer */
+   while ((d = *c)) {
+     if (!(((d >= '0') && (d <= '9')) || ((d >= 'a') && (d <= 'f')))) break;
+     c++;
+   }
+   return c;
+ }
+ 
+ /* Convert a packed value value */
+ SWIGRUNTIME int
+ SWIG_Tcl_ConvertPacked(Tcl_Interp *SWIGUNUSEDPARM(interp) , Tcl_Obj *obj, void *ptr, int sz, swig_type_info *ty) {
+   swig_cast_info *tc;
+   const char  *c;
+ 
+   if (!obj) goto type_error;
+   c = Tcl_GetStringFromObj(obj,NULL);
+   /* Pointer values must start with leading underscore */
+   if (*c != '_') goto type_error;
+   c++;
+   c = SWIG_UnpackData(c,ptr,sz);
+   if (ty) {
+     tc = SWIG_TypeCheck(c,ty);
+     if (!tc) goto type_error;
+   }
+   return SWIG_OK;
+ 
+  type_error:
+ 
+   return SWIG_ERROR;
+ }
+ 
+ 
+ /* Take a pointer and convert it to a string */
+ SWIGRUNTIME void
+ SWIG_Tcl_MakePtr(char *c, void *ptr, swig_type_info *ty, int flags) {
+   if (ptr) {
+     *(c++) = '_';
+     c = SWIG_PackData(c,&ptr,sizeof(void *));
+     strcpy(c,ty->name);
+   } else {
+     strcpy(c,(char *)"NULL");
+   }
+   flags = 0;
+ }
+ 
+ /* Create a new pointer object */
+ SWIGRUNTIMEINLINE Tcl_Obj *
+ SWIG_Tcl_NewPointerObj(void *ptr, swig_type_info *type, int flags) {
+   Tcl_Obj *robj;
+   char result[SWIG_BUFFER_SIZE];
+   SWIG_MakePtr(result,ptr,type,flags);
+   robj = Tcl_NewStringObj(result,-1);
+   return robj;
+ }
+ 
+ SWIGRUNTIME Tcl_Obj *
+ SWIG_Tcl_NewPackedObj(void *ptr, int sz, swig_type_info *type) {
+   char result[1024];
+   char *r = result;
+   if ((2*sz + 1 + strlen(type->name)) > 1000) return 0;
+   *(r++) = '_';
+   r = SWIG_PackData(r,ptr,sz);
+   strcpy(r,type->name);
+   return Tcl_NewStringObj(result,-1);
+ }
+ 
+ /* -----------------------------------------------------------------------------*
+  *  Get type list 
+  * -----------------------------------------------------------------------------*/
+ 
+ SWIGRUNTIME swig_module_info * 
+ SWIG_Tcl_GetModule(Tcl_Interp *interp) {
+   const char *data;
+   swig_module_info *ret = 0;
+   
+   /* first check if pointer already created */
+   data = Tcl_GetVar(interp, (char *)"swig_runtime_data_type_pointer" SWIG_RUNTIME_VERSION SWIG_TYPE_TABLE_NAME, TCL_GLOBAL_ONLY);
+   if (data) {
+     SWIG_UnpackData(data, &ret, sizeof(swig_type_info **));
+   }
+ 
+   return ret;
+ }
+ 
+ SWIGRUNTIME void
+ SWIG_Tcl_SetModule(Tcl_Interp *interp, swig_module_info *module) {
+   char buf[SWIG_BUFFER_SIZE];
+   char *data;
+ 
+   /* create a new pointer */
+   data = SWIG_PackData(buf, &module, sizeof(swig_type_info **));
+   *data = 0;
+   Tcl_SetVar(interp, (char *)"swig_runtime_data_type_pointer" SWIG_RUNTIME_VERSION SWIG_TYPE_TABLE_NAME, buf, 0);
+ }
+ 
+ /* -----------------------------------------------------------------------------*
+  *  Object auxiliars
+  * -----------------------------------------------------------------------------*/
+ 
+ 
+ SWIGRUNTIME void
+ SWIG_Tcl_ObjectDelete(ClientData clientData) {
+   swig_instance *si = (swig_instance *) clientData;
+   if ((si) && (si->destroy) && (SWIG_Disown(si->thisvalue))) {
+     if (si->classptr->destructor) {
+       (si->classptr->destructor)(si->thisvalue);
+     }
+   }
+   Tcl_DecrRefCount(si->thisptr);
+   free(si);
+ }
+ 
+ /* Function to invoke object methods given an instance */
+ SWIGRUNTIME int
+ SWIG_Tcl_MethodCommand(ClientData clientData, Tcl_Interp *interp, int objc, Tcl_Obj *CONST _objv[]) {
+   char *method,   *attrname;
+   swig_instance   *inst = (swig_instance *) clientData;
+   swig_method     *meth;
+   swig_attribute  *attr;
+   Tcl_Obj         *oldarg;
+   Tcl_Obj         **objv;
+   int              rcode;
+   swig_class      *cls;
+   swig_class      *cls_stack[64];
+   int              cls_stack_bi[64];
+   int              cls_stack_top = 0;
+   int              numconf = 2;
+   int              bi;
+ 
+   objv = (Tcl_Obj **) _objv;
+   if (objc < 2) {
+     Tcl_SetResult(interp, (char *) "wrong # args.", TCL_STATIC);
+     return TCL_ERROR;
+   }
+   method = Tcl_GetStringFromObj(objv[1],NULL);
+   if (strcmp(method,"-acquire") == 0) {
+     inst->destroy = 1;
+     SWIG_Acquire(inst->thisvalue);
+     return TCL_OK;
+   }
+   if (strcmp(method,"-disown") == 0) {
+     if (inst->destroy) {
+       SWIG_Disown(inst->thisvalue);
+     }
+     inst->destroy = 0;
+     return TCL_OK;
+   }
+   if (strcmp(method,"-delete") == 0) {
+     Tcl_DeleteCommandFromToken(interp,inst->cmdtok);
+     return TCL_OK;
+   }
+   cls_stack[cls_stack_top] = inst->classptr;
+   cls_stack_bi[cls_stack_top] = -1;
+   cls = inst->classptr;
+   while (1) {
+     bi = cls_stack_bi[cls_stack_top];
+     cls = cls_stack[cls_stack_top];
+     if (bi != -1) {
+       if (!cls->bases[bi] && cls->base_names[bi]) {
+         /* lookup and cache the base class */
+ 	swig_type_info *info = SWIG_TypeQueryModule(cls->module, cls->module, cls->base_names[bi]);
+ 	if (info) cls->bases[bi] = (swig_class *) info->clientdata;
+       }
+       cls = cls->bases[bi];
+       if (cls) {
+         cls_stack_bi[cls_stack_top]++;
+         cls_stack_top++;
+         cls_stack[cls_stack_top] = cls;
+         cls_stack_bi[cls_stack_top] = -1;
+         continue;
+       }
+     }
+     if (!cls) {
+       cls_stack_top--;
+       if (cls_stack_top < 0) break;
+       else continue;
+     }
+     cls_stack_bi[cls_stack_top]++;
+ 
+     meth = cls->methods;
+     /* Check for methods */
+     while (meth && meth->name) {
+       if (strcmp(meth->name,method) == 0) {
+         oldarg = objv[1];
+         objv[1] = inst->thisptr;
+         Tcl_IncrRefCount(inst->thisptr);
+         rcode = (*meth->method)(clientData,interp,objc,objv);
+         objv[1] = oldarg;
+         Tcl_DecrRefCount(inst->thisptr);
+         return rcode;
+       }
+       meth++;
+     }
+     /* Check class methods for a match */
+     if (strcmp(method,"cget") == 0) {
+       if (objc < 3) {
+         Tcl_SetResult(interp, (char *) "wrong # args.", TCL_STATIC);
+         return TCL_ERROR;
+       }
+       attrname = Tcl_GetStringFromObj(objv[2],NULL);
+       attr = cls->attributes;
+       while (attr && attr->name) {
+         if ((strcmp(attr->name, attrname) == 0) && (attr->getmethod)) {
+           oldarg = objv[1];
+           objv[1] = inst->thisptr;
+           Tcl_IncrRefCount(inst->thisptr);
+           rcode = (*attr->getmethod)(clientData,interp,2, objv);
+           objv[1] = oldarg;
+           Tcl_DecrRefCount(inst->thisptr);
+           return rcode;
+         }
+         attr++;
+       }
+       if (strcmp(attrname, "-this") == 0) {
+         Tcl_SetObjResult(interp, Tcl_DuplicateObj(inst->thisptr));
+         return TCL_OK;
+       }
+       if (strcmp(attrname, "-thisown") == 0) {
+         if (SWIG_Thisown(inst->thisvalue)) {
+           Tcl_SetResult(interp,(char*)"1",TCL_STATIC);
+         } else {
+           Tcl_SetResult(interp,(char*)"0",TCL_STATIC);
+         }
+         return TCL_OK;
+       }
+     } else if (strcmp(method, "configure") == 0) {
+       int i;
+       if (objc < 4) {
+         Tcl_SetResult(interp, (char *) "wrong # args.", TCL_STATIC);
+         return TCL_ERROR;
+       }
+       i = 2;
+       while (i < objc) {
+         attrname = Tcl_GetStringFromObj(objv[i],NULL);
+         attr = cls->attributes;
+         while (attr && attr->name) {
+           if ((strcmp(attr->name, attrname) == 0) && (attr->setmethod)) {
+             oldarg = objv[i];
+             objv[i] = inst->thisptr;
+             Tcl_IncrRefCount(inst->thisptr);
+             rcode = (*attr->setmethod)(clientData,interp,3, &objv[i-1]);
+             objv[i] = oldarg;
+             Tcl_DecrRefCount(inst->thisptr);
+             if (rcode != TCL_OK) return rcode;
+             numconf += 2;
+           }
+           attr++;
+         }
+         i+=2;
+       }
+     }
+   }
+   if (strcmp(method,"configure") == 0) {
+     if (numconf >= objc) {
+       return TCL_OK;
+     } else {
+       Tcl_SetResult(interp,(char *) "Invalid attribute name.", TCL_STATIC);
+       return TCL_ERROR;
+     }
+   }
+   if (strcmp(method,"cget") == 0) {
+     Tcl_SetResult(interp,(char *) "Invalid attribute name.", TCL_STATIC);
+     return TCL_ERROR;
+   }
+   Tcl_SetResult(interp, (char *) "Invalid method. Must be one of: configure cget -acquire -disown -delete", TCL_STATIC);
+   cls = inst->classptr;
+   bi = 0;
+   while (cls) {
+     meth = cls->methods;
+     while (meth && meth->name) {
+       char *cr = (char *) Tcl_GetStringResult(interp);
+       size_t meth_len = strlen(meth->name);
+       char* where = strchr(cr,':');
+       while(where) {
+         where = strstr(where, meth->name);
+         if(where) {
+           if(where[-1] == ' ' && (where[meth_len] == ' ' || where[meth_len]==0)) {
+             break;
+           } else {
+             where++;
+           }
+         }
+       }
+ 
+       if (!where)
+         Tcl_AppendElement(interp, (char *) meth->name);
+       meth++;
+     }
+     cls = inst->classptr->bases[bi++];
+   }
+   return TCL_ERROR;
+ }
+ 
+ /* This function takes the current result and turns it into an object command */
+ SWIGRUNTIME Tcl_Obj *
+ SWIG_Tcl_NewInstanceObj(Tcl_Interp *interp, void *thisvalue, swig_type_info *type, int flags) {
+   Tcl_Obj *robj = SWIG_NewPointerObj(thisvalue, type,0);
+   /* Check to see if this pointer belongs to a class or not */
+   if ((type->clientdata) && (interp)) {
+     Tcl_CmdInfo    ci;
+     char          *name;
+     name = Tcl_GetStringFromObj(robj,NULL);
+     if (!Tcl_GetCommandInfo(interp,name, &ci) || (flags)) {
+       swig_instance *newinst = (swig_instance *) malloc(sizeof(swig_instance));
+       newinst->thisptr = Tcl_DuplicateObj(robj);
+       Tcl_IncrRefCount(newinst->thisptr);
+       newinst->thisvalue = thisvalue;
+       newinst->classptr = (swig_class *) type->clientdata;
+       newinst->destroy = flags;
+       newinst->cmdtok = Tcl_CreateObjCommand(interp, Tcl_GetStringFromObj(robj,NULL), (swig_wrapper_func) SWIG_MethodCommand, (ClientData) newinst, (swig_delete_func) SWIG_ObjectDelete);
+       if (flags) {
+         SWIG_Acquire(thisvalue);
+       }
+     }
+   }
+   return robj;
+ }
+ 
+ /* Function to create objects */
+ SWIGRUNTIME int
+ SWIG_Tcl_ObjectConstructor(ClientData clientData, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
+   Tcl_Obj          *newObj = 0;
+   void             *thisvalue = 0;
+   swig_instance   *newinst = 0;
+   swig_class      *classptr = (swig_class *) clientData;
+   swig_wrapper     cons = 0;
+   char             *name = 0;
+   int               firstarg = 0;
+   int               thisarg = 0;
+   int               destroy = 1;
+ 
+   if (!classptr) {
+     Tcl_SetResult(interp, (char *) "swig: internal runtime error. No class object defined.", TCL_STATIC);
+     return TCL_ERROR;
+   }
+   cons = classptr->constructor;
+   if (objc > 1) {
+     char *s = Tcl_GetStringFromObj(objv[1],NULL);
+     if (strcmp(s,"-this") == 0) {
+       thisarg = 2;
+       cons = 0;
+     } else if (strcmp(s,"-args") == 0) {
+       firstarg = 1;
+     } else if (objc == 2) {
+       firstarg = 1;
+       name = s;
+     } else if (objc >= 3) {
+       char *s1;
+       name = s;
+       s1 = Tcl_GetStringFromObj(objv[2],NULL);
+       if (strcmp(s1,"-this") == 0) {
+ 	thisarg = 3;
+ 	cons = 0;
+       } else {
+ 	firstarg = 1;
+       }
+     }
+   }
+   if (cons) {
+     int result;
+     result = (*cons)(0, interp, objc-firstarg, &objv[firstarg]);
+     if (result != TCL_OK) {
+       return result;
+     }
+     newObj = Tcl_DuplicateObj(Tcl_GetObjResult(interp));
+     if (!name) name = Tcl_GetStringFromObj(newObj,NULL);
+   } else if (thisarg > 0) {
+     if (thisarg < objc) {
+       destroy = 0;
+       newObj = Tcl_DuplicateObj(objv[thisarg]);
+       if (!name) name = Tcl_GetStringFromObj(newObj,NULL);
+     } else {
+       Tcl_SetResult(interp, (char *) "wrong # args.", TCL_STATIC);
+       return TCL_ERROR;
+     }
+   } else {
+     Tcl_SetResult(interp, (char *) "No constructor available.", TCL_STATIC);
+     return TCL_ERROR;
+   }
+   if (SWIG_Tcl_ConvertPtr(interp,newObj, (void **) &thisvalue, *(classptr->type), 0) != SWIG_OK) {
+     Tcl_DecrRefCount(newObj);
+     return TCL_ERROR;
+   }
+   newinst = (swig_instance *) malloc(sizeof(swig_instance));
+   newinst->thisptr = newObj;
+   Tcl_IncrRefCount(newObj);
+   newinst->thisvalue = thisvalue;
+   newinst->classptr = classptr;
+   newinst->destroy = destroy;
+   if (destroy) {
+     SWIG_Acquire(thisvalue);
+   }
+   newinst->cmdtok = Tcl_CreateObjCommand(interp,name, (swig_wrapper) SWIG_MethodCommand, (ClientData) newinst, (swig_delete_func) SWIG_ObjectDelete);
+   return TCL_OK;
+ }
+ 
+ /* -----------------------------------------------------------------------------*
+  *   Get arguments 
+  * -----------------------------------------------------------------------------*/
+ SWIGRUNTIME int
+ SWIG_Tcl_GetArgs(Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[], const char *fmt, ...) {
+   int        argno = 0, opt = 0;
+   long       tempi;
+   double     tempd;
+   const char *c;
+   va_list    ap;
+   void      *vptr;
+   Tcl_Obj   *obj = 0;
+   swig_type_info *ty;
+ 
+   va_start(ap,fmt);
+   for (c = fmt; (*c && (*c != ':') && (*c != ';')); c++,argno++) {
+     if (*c == '|') {
+       opt = 1;
+       c++;
+     }
+     if (argno >= (objc-1)) {
+       if (!opt) {
+         Tcl_SetResult(interp, (char *) "Wrong number of arguments ", TCL_STATIC);
+         goto argerror;
+       } else {
+         va_end(ap);
+         return TCL_OK;
+       }
+     }
+ 
+     vptr = va_arg(ap,void *);
+     if (vptr) {
+       if (isupper(*c)) {
+         obj = SWIG_Tcl_GetConstantObj(Tcl_GetStringFromObj(objv[argno+1],0));
+         if (!obj) obj = objv[argno+1];
+       } else {
+         obj = objv[argno+1];
+       }
+       switch(*c) {
+       case 'i': case 'I':
+       case 'l': case 'L':
+       case 'h': case 'H':
+       case 'b': case 'B':
+         if (Tcl_GetLongFromObj(interp,obj,&tempi) != TCL_OK) goto argerror;
+         if ((*c == 'i') || (*c == 'I')) *((int *)vptr) = (int)tempi;
+         else if ((*c == 'l') || (*c == 'L')) *((long *)vptr) = (long)tempi;
+         else if ((*c == 'h') || (*c == 'H')) *((short*)vptr) = (short)tempi;
+         else if ((*c == 'b') || (*c == 'B')) *((unsigned char *)vptr) = (unsigned char)tempi;
+         break;
+       case 'f': case 'F':
+       case 'd': case 'D':
+         if (Tcl_GetDoubleFromObj(interp,obj,&tempd) != TCL_OK) goto argerror;
+         if ((*c == 'f') || (*c == 'F')) *((float *) vptr) = (float)tempd;
+         else if ((*c == 'd') || (*c == 'D')) *((double*) vptr) = tempd;
+         break;
+       case 's': case 'S':
+         if (*(c+1) == '#') {
+           int *vlptr = (int *) va_arg(ap, void *);
+           *((char **) vptr) = Tcl_GetStringFromObj(obj, vlptr);
+           c++;
+         } else {
+           *((char **)vptr) = Tcl_GetStringFromObj(obj,NULL);
+         }
+         break;
+       case 'c': case 'C':
+         *((char *)vptr) = *(Tcl_GetStringFromObj(obj,NULL));
+         break;
+       case 'p': case 'P':
+         ty = (swig_type_info *) va_arg(ap, void *);
+         if (SWIG_Tcl_ConvertPtr(interp, obj, (void **) vptr, ty, 0) != SWIG_OK) goto argerror;
+         break;
+       case 'o': case 'O':
+         *((Tcl_Obj **)vptr) = objv[argno+1];
+         break;
+       default:
+         break;
+       }
+     }
+   }
+ 
+   if ((*c != ';') && ((objc-1) > argno)) {
+     Tcl_SetResult(interp, (char *) "Wrong # args.", TCL_STATIC);
+     goto argerror;
+   }
+   va_end(ap);
+   return TCL_OK;
+ 
+  argerror:
+   {
+     char temp[32];
+     sprintf(temp,"%d", argno+1);
+     c = strchr(fmt,':');
+     if (!c) c = strchr(fmt,';');
+     if (!c) c = (char *)"";
+     Tcl_AppendResult(interp,c," argument ", temp, NULL);
+     va_end(ap);
+     return TCL_ERROR;
+   }
+ }
+ 
+ #ifdef __cplusplus
+ #if 0
+ { /* cc-mode */
+ #endif
+ }
+ #endif
+ 
+ 
+ 
+ #define SWIG_exception_fail(code, msg) do { SWIG_Error(code, msg); SWIG_fail; } while(0) 
+ 
+ #define SWIG_contract_assert(expr, msg) if (!(expr)) { SWIG_Error(SWIG_RuntimeError, msg); SWIG_fail; } else 
+ 
+ 
+ 
+ /* -------- TYPES TABLE (BEGIN) -------- */
+ 
+ #define SWIGTYPE_p_char swig_types[0]
+ static swig_type_info *swig_types[2];
+ static swig_module_info swig_module = {swig_types, 1, 0, 0, 0, 0};
+ #define SWIG_TypeQuery(name) SWIG_TypeQueryModule(&swig_module, &swig_module, name)
+ #define SWIG_MangledTypeQuery(name) SWIG_MangledTypeQueryModule(&swig_module, &swig_module, name)
+ 
+ /* -------- TYPES TABLE (END) -------- */
+ 
+ #define SWIG_init    Gdalconst_Init
+ #define SWIG_name    "gdalconst"
+ #define SWIG_prefix  "osgeo::"
+ #define SWIG_namespace "osgeo"
+ 
+ #define SWIG_version "1.0"
+ 
+ #define SWIGVERSION 0x010336 
+ #define SWIG_VERSION SWIGVERSION
+ 
+ 
+ #define SWIG_as_voidptr(a) (void *)((const void *)(a)) 
+ #define SWIG_as_voidptrptr(a) ((void)SWIG_as_voidptr(*a),(void**)(a)) 
+ 
+ 
+ 
+ #ifdef __cplusplus
+ extern "C" {
+ #endif
+ #ifdef MAC_TCL
+ #pragma export on
+ #endif
+ SWIGEXPORT int SWIG_init(Tcl_Interp *);
+ #ifdef MAC_TCL
+ #pragma export off
+ #endif
+ #ifdef __cplusplus
+ }
+ #endif
+ 
+ 
+ 
+ #include "gdal.h"
+ #include "gdalwarper.h"
+ #include "cpl_string.h"
+ #include "cpl_minixml.h"
+ 
+ 
+ #include <limits.h>
+ #if !defined(SWIG_NO_LLONG_MAX)
+ # if !defined(LLONG_MAX) && defined(__GNUC__) && defined (__LONG_LONG_MAX__)
+ #   define LLONG_MAX __LONG_LONG_MAX__
+ #   define LLONG_MIN (-LLONG_MAX - 1LL)
+ #   define ULLONG_MAX (LLONG_MAX * 2ULL + 1ULL)
+ # endif
+ #endif
+ 
+ 
+ SWIGINTERNINLINE Tcl_Obj* 
+ SWIG_From_long  (long value)
+ {
+   if (((long) INT_MIN <= value) && (value <= (long) INT_MAX)) {
+     return Tcl_NewIntObj((int)(value));
+   } else {
+     return Tcl_NewLongObj(value);
+   }
+ }
+ 
+ 
+ SWIGINTERNINLINE Tcl_Obj *
+ SWIG_From_int  (int value)
+ {    
+   return SWIG_From_long  (value);
+ }
+ 
+ 
+ SWIGINTERNINLINE Tcl_Obj *
+ SWIG_FromCharPtrAndSize(const char* carray, size_t size)
+ {
+   return (size < INT_MAX) ? Tcl_NewStringObj(carray, (int)(size)) : NULL;
+ }
+ 
+ 
+ SWIGINTERNINLINE Tcl_Obj * 
+ SWIG_FromCharPtr(const char *cptr)
+ { 
+   return SWIG_FromCharPtrAndSize(cptr, (cptr ? strlen(cptr) : 0));
+ }
+ 
+ #ifdef __cplusplus
+ extern "C" {
+ #endif
+ 
+ static swig_command_info swig_commands[] = {
+     {0, 0, 0}
+ };
+ 
+ static swig_var_info swig_variables[] = {
+     {0,0,0,0}
+ };
+ 
+ static swig_const_info swig_constants[] = {
+     {0,0,0,0,0,0}
+ };
+ 
+ /* -------- TYPE CONVERSION AND EQUIVALENCE RULES (BEGIN) -------- */
+ 
+ static swig_type_info _swigt__p_char = {"_p_char", "char *", 0, 0, (void*)0, 0};
+ 
+ static swig_type_info *swig_type_initial[] = {
+   &_swigt__p_char,
+ };
+ 
+ static swig_cast_info _swigc__p_char[] = {  {&_swigt__p_char, 0, 0, 0},{0, 0, 0, 0}};
+ 
+ static swig_cast_info *swig_cast_initial[] = {
+   _swigc__p_char,
+ };
+ 
+ 
+ /* -------- TYPE CONVERSION AND EQUIVALENCE RULES (END) -------- */
+ 
+ #ifdef __cplusplus
+ }
+ #endif
+ /* -----------------------------------------------------------------------------
+  * Type initialization:
+  * This problem is tough by the requirement that no dynamic 
+  * memory is used. Also, since swig_type_info structures store pointers to 
+  * swig_cast_info structures and swig_cast_info structures store pointers back
+  * to swig_type_info structures, we need some lookup code at initialization. 
+  * The idea is that swig generates all the structures that are needed. 
+  * The runtime then collects these partially filled structures. 
+  * The SWIG_InitializeModule function takes these initial arrays out of 
+  * swig_module, and does all the lookup, filling in the swig_module.types
+  * array with the correct data and linking the correct swig_cast_info
+  * structures together.
+  *
+  * The generated swig_type_info structures are assigned staticly to an initial 
+  * array. We just loop through that array, and handle each type individually.
+  * First we lookup if this type has been already loaded, and if so, use the
+  * loaded structure instead of the generated one. Then we have to fill in the
+  * cast linked list. The cast data is initially stored in something like a
+  * two-dimensional array. Each row corresponds to a type (there are the same
+  * number of rows as there are in the swig_type_initial array). Each entry in
+  * a column is one of the swig_cast_info structures for that type.
+  * The cast_initial array is actually an array of arrays, because each row has
+  * a variable number of columns. So to actually build the cast linked list,
+  * we find the array of casts associated with the type, and loop through it 
+  * adding the casts to the list. The one last trick we need to do is making
+  * sure the type pointer in the swig_cast_info struct is correct.
+  *
+  * First off, we lookup the cast->type name to see if it is already loaded. 
+  * There are three cases to handle:
+  *  1) If the cast->type has already been loaded AND the type we are adding
+  *     casting info to has not been loaded (it is in this module), THEN we
+  *     replace the cast->type pointer with the type pointer that has already
+  *     been loaded.
+  *  2) If BOTH types (the one we are adding casting info to, and the 
+  *     cast->type) are loaded, THEN the cast info has already been loaded by
+  *     the previous module so we just ignore it.
+  *  3) Finally, if cast->type has not already been loaded, then we add that
+  *     swig_cast_info to the linked list (because the cast->type) pointer will
+  *     be correct.
+  * ----------------------------------------------------------------------------- */
+ 
+ #ifdef __cplusplus
+ extern "C" {
+ #if 0
+ } /* c-mode */
+ #endif
+ #endif
+ 
+ #if 0
+ #define SWIGRUNTIME_DEBUG
+ #endif
+ 
+ 
+ SWIGRUNTIME void
+ SWIG_InitializeModule(void *clientdata) {
+   size_t i;
+   swig_module_info *module_head, *iter;
+   int found, init;
+   
+   clientdata = clientdata;
+   
+   /* check to see if the circular list has been setup, if not, set it up */
+   if (swig_module.next==0) {
+     /* Initialize the swig_module */
+     swig_module.type_initial = swig_type_initial;
+     swig_module.cast_initial = swig_cast_initial;
+     swig_module.next = &swig_module;
+     init = 1;
+   } else {
+     init = 0;
+   }
+   
+   /* Try and load any already created modules */
+   module_head = SWIG_GetModule(clientdata);
+   if (!module_head) {
+     /* This is the first module loaded for this interpreter */
+     /* so set the swig module into the interpreter */
+     SWIG_SetModule(clientdata, &swig_module);
+     module_head = &swig_module;
+   } else {
+     /* the interpreter has loaded a SWIG module, but has it loaded this one? */
+     found=0;
+     iter=module_head;
+     do {
+       if (iter==&swig_module) {
+         found=1;
+         break;
+       }
+       iter=iter->next;
+     } while (iter!= module_head);
+     
+     /* if the is found in the list, then all is done and we may leave */
+     if (found) return;
+     /* otherwise we must add out module into the list */
+     swig_module.next = module_head->next;
+     module_head->next = &swig_module;
+   }
+   
+   /* When multiple interpeters are used, a module could have already been initialized in
+        a different interpreter, but not yet have a pointer in this interpreter.
+        In this case, we do not want to continue adding types... everything should be
+        set up already */
+   if (init == 0) return;
+   
+   /* Now work on filling in swig_module.types */
+ #ifdef SWIGRUNTIME_DEBUG
+   printf("SWIG_InitializeModule: size %d\n", swig_module.size);
+ #endif
+   for (i = 0; i < swig_module.size; ++i) {
+     swig_type_info *type = 0;
+     swig_type_info *ret;
+     swig_cast_info *cast;
+     
+ #ifdef SWIGRUNTIME_DEBUG
+     printf("SWIG_InitializeModule: type %d %s\n", i, swig_module.type_initial[i]->name);
+ #endif
+     
+     /* if there is another module already loaded */
+     if (swig_module.next != &swig_module) {
+       type = SWIG_MangledTypeQueryModule(swig_module.next, &swig_module, swig_module.type_initial[i]->name);
+     }
+     if (type) {
+       /* Overwrite clientdata field */
+ #ifdef SWIGRUNTIME_DEBUG
+       printf("SWIG_InitializeModule: found type %s\n", type->name);
+ #endif
+       if (swig_module.type_initial[i]->clientdata) {
+         type->clientdata = swig_module.type_initial[i]->clientdata;
+ #ifdef SWIGRUNTIME_DEBUG
+         printf("SWIG_InitializeModule: found and overwrite type %s \n", type->name);
+ #endif
+       }
+     } else {
+       type = swig_module.type_initial[i];
+     }
+     
+     /* Insert casting types */
+     cast = swig_module.cast_initial[i];
+     while (cast->type) {
+       /* Don't need to add information already in the list */
+       ret = 0;
+ #ifdef SWIGRUNTIME_DEBUG
+       printf("SWIG_InitializeModule: look cast %s\n", cast->type->name);
+ #endif
+       if (swig_module.next != &swig_module) {
+         ret = SWIG_MangledTypeQueryModule(swig_module.next, &swig_module, cast->type->name);
+ #ifdef SWIGRUNTIME_DEBUG
+         if (ret) printf("SWIG_InitializeModule: found cast %s\n", ret->name);
+ #endif
+       }
+       if (ret) {
+         if (type == swig_module.type_initial[i]) {
+ #ifdef SWIGRUNTIME_DEBUG
+           printf("SWIG_InitializeModule: skip old type %s\n", ret->name);
+ #endif
+           cast->type = ret;
+           ret = 0;
+         } else {
+           /* Check for casting already in the list */
+           swig_cast_info *ocast = SWIG_TypeCheck(ret->name, type);
+ #ifdef SWIGRUNTIME_DEBUG
+           if (ocast) printf("SWIG_InitializeModule: skip old cast %s\n", ret->name);
+ #endif
+           if (!ocast) ret = 0;
+         }
+       }
+       
+       if (!ret) {
+ #ifdef SWIGRUNTIME_DEBUG
+         printf("SWIG_InitializeModule: adding cast %s\n", cast->type->name);
+ #endif
+         if (type->cast) {
+           type->cast->prev = cast;
+           cast->next = type->cast;
+         }
+         type->cast = cast;
+       }
+       cast++;
+     }
+     /* Set entry in modules->types array equal to the type */
+     swig_module.types[i] = type;
+   }
+   swig_module.types[i] = 0;
+   
+ #ifdef SWIGRUNTIME_DEBUG
+   printf("**** SWIG_InitializeModule: Cast List ******\n");
+   for (i = 0; i < swig_module.size; ++i) {
+     int j = 0;
+     swig_cast_info *cast = swig_module.cast_initial[i];
+     printf("SWIG_InitializeModule: type %d %s\n", i, swig_module.type_initial[i]->name);
+     while (cast->type) {
+       printf("SWIG_InitializeModule: cast type %s\n", cast->type->name);
+       cast++;
+       ++j;
+     }
+     printf("---- Total casts: %d\n",j);
+   }
+   printf("**** SWIG_InitializeModule: Cast List ******\n");
+ #endif
+ }
+ 
+ /* This function will propagate the clientdata field of type to
+ * any new swig_type_info structures that have been added into the list
+ * of equivalent types.  It is like calling
+ * SWIG_TypeClientData(type, clientdata) a second time.
+ */
+ SWIGRUNTIME void
+ SWIG_PropagateClientData(void) {
+   size_t i;
+   swig_cast_info *equiv;
+   static int init_run = 0;
+   
+   if (init_run) return;
+   init_run = 1;
+   
+   for (i = 0; i < swig_module.size; i++) {
+     if (swig_module.types[i]->clientdata) {
+       equiv = swig_module.types[i]->cast;
+       while (equiv) {
+         if (!equiv->converter) {
+           if (equiv->type && !equiv->type->clientdata)
+           SWIG_TypeClientData(equiv->type, swig_module.types[i]->clientdata);
+         }
+         equiv = equiv->next;
+       }
+     }
+   }
+ }
+ 
+ #ifdef __cplusplus
+ #if 0
+ {
+   /* c-mode */
+ #endif
+ }
+ #endif
+ 
+ 
+ #ifdef __cplusplus
+ extern "C" {
+ #endif
+   
+   /* -----------------------------------------------------------------------------
+    * constants/methods manipulation
+    * ----------------------------------------------------------------------------- */
+   
+   /* Install Constants */
+   
+   SWIGINTERN void
+   SWIG_Tcl_InstallConstants(Tcl_Interp *interp, swig_const_info constants[]) {
+     int i;
+     Tcl_Obj *obj;
+     
+     if (!swigconstTableinit) {
+       Tcl_InitHashTable(&swigconstTable, TCL_STRING_KEYS);
+       swigconstTableinit = 1;
+     }
+     for (i = 0; constants[i].type; i++) {
+       switch(constants[i].type) {
+       case SWIG_TCL_POINTER:
+         obj = SWIG_NewPointerObj(constants[i].pvalue, *(constants[i]).ptype,0);
+         break;
+       case SWIG_TCL_BINARY:
+         obj = SWIG_NewPackedObj(constants[i].pvalue, constants[i].lvalue, *(constants[i].ptype));
+         break;
+       default:
+         obj = 0;
+         break;
+       }
+       if (obj) {
+         SWIG_Tcl_SetConstantObj(interp, constants[i].name, obj);
+       }
+     }
+   }
+   
+ #ifdef __cplusplus
+ }
+ #endif
+ 
+ /* -----------------------------------------------------------------------------*
+  *  Partial Init method
+  * -----------------------------------------------------------------------------*/
+ 
+ SWIGEXPORT int SWIG_init(Tcl_Interp *interp) {
+   int i;
+   if (interp == 0) return TCL_ERROR;
+ #ifdef USE_TCL_STUBS
+   if (Tcl_InitStubs(interp, (char*)"8.1", 0) == NULL) {
+     return TCL_ERROR;
+   }
+ #endif  
+   Tcl_PkgProvide(interp, (char*)SWIG_name, (char*)SWIG_version);
+   
+ #ifdef SWIG_namespace
+   Tcl_Eval(interp, "namespace eval " SWIG_namespace " { }");
+ #endif
+   
+   SWIG_InitializeModule((void *) interp);
+   SWIG_PropagateClientData();
+   
+   for (i = 0; swig_commands[i].name; i++) {
+     Tcl_CreateObjCommand(interp, (char *) swig_commands[i].name, (swig_wrapper_func) swig_commands[i].wrapper,
+       swig_commands[i].clientdata, NULL);
+   }
+   for (i = 0; swig_variables[i].name; i++) {
+     Tcl_SetVar(interp, (char *) swig_variables[i].name, (char *) "", TCL_GLOBAL_ONLY);
+     Tcl_TraceVar(interp, (char *) swig_variables[i].name, TCL_TRACE_READS | TCL_GLOBAL_ONLY, 
+       (Tcl_VarTraceProc *) swig_variables[i].get, (ClientData) swig_variables[i].addr);
+     Tcl_TraceVar(interp, (char *) swig_variables[i].name, TCL_TRACE_WRITES | TCL_GLOBAL_ONLY, 
+       (Tcl_VarTraceProc *) swig_variables[i].set, (ClientData) swig_variables[i].addr);
+   }
+   
+   SWIG_Tcl_InstallConstants(interp, swig_constants);
+   
+   
+   SWIG_Tcl_SetConstantObj(interp, "osgeo::GDT_Unknown", SWIG_From_int((int)(GDT_Unknown)));
+   SWIG_Tcl_SetConstantObj(interp, "osgeo::GDT_Byte", SWIG_From_int((int)(GDT_Byte)));
+   SWIG_Tcl_SetConstantObj(interp, "osgeo::GDT_UInt16", SWIG_From_int((int)(GDT_UInt16)));
+   SWIG_Tcl_SetConstantObj(interp, "osgeo::GDT_Int16", SWIG_From_int((int)(GDT_Int16)));
+   SWIG_Tcl_SetConstantObj(interp, "osgeo::GDT_UInt32", SWIG_From_int((int)(GDT_UInt32)));
+   SWIG_Tcl_SetConstantObj(interp, "osgeo::GDT_Int32", SWIG_From_int((int)(GDT_Int32)));
+   SWIG_Tcl_SetConstantObj(interp, "osgeo::GDT_Float32", SWIG_From_int((int)(GDT_Float32)));
+   SWIG_Tcl_SetConstantObj(interp, "osgeo::GDT_Float64", SWIG_From_int((int)(GDT_Float64)));
+   SWIG_Tcl_SetConstantObj(interp, "osgeo::GDT_CInt16", SWIG_From_int((int)(GDT_CInt16)));
+   SWIG_Tcl_SetConstantObj(interp, "osgeo::GDT_CInt32", SWIG_From_int((int)(GDT_CInt32)));
+   SWIG_Tcl_SetConstantObj(interp, "osgeo::GDT_CFloat32", SWIG_From_int((int)(GDT_CFloat32)));
+   SWIG_Tcl_SetConstantObj(interp, "osgeo::GDT_CFloat64", SWIG_From_int((int)(GDT_CFloat64)));
+   SWIG_Tcl_SetConstantObj(interp, "osgeo::GDT_TypeCount", SWIG_From_int((int)(GDT_TypeCount)));
+   SWIG_Tcl_SetConstantObj(interp, "osgeo::GA_ReadOnly", SWIG_From_int((int)(GA_ReadOnly)));
+   SWIG_Tcl_SetConstantObj(interp, "osgeo::GA_Update", SWIG_From_int((int)(GA_Update)));
+   SWIG_Tcl_SetConstantObj(interp, "osgeo::GF_Read", SWIG_From_int((int)(GF_Read)));
+   SWIG_Tcl_SetConstantObj(interp, "osgeo::GF_Write", SWIG_From_int((int)(GF_Write)));
+   SWIG_Tcl_SetConstantObj(interp, "osgeo::GCI_Undefined", SWIG_From_int((int)(GCI_Undefined)));
+   SWIG_Tcl_SetConstantObj(interp, "osgeo::GCI_GrayIndex", SWIG_From_int((int)(GCI_GrayIndex)));
+   SWIG_Tcl_SetConstantObj(interp, "osgeo::GCI_PaletteIndex", SWIG_From_int((int)(GCI_PaletteIndex)));
+   SWIG_Tcl_SetConstantObj(interp, "osgeo::GCI_RedBand", SWIG_From_int((int)(GCI_RedBand)));
+   SWIG_Tcl_SetConstantObj(interp, "osgeo::GCI_GreenBand", SWIG_From_int((int)(GCI_GreenBand)));
+   SWIG_Tcl_SetConstantObj(interp, "osgeo::GCI_BlueBand", SWIG_From_int((int)(GCI_BlueBand)));
+   SWIG_Tcl_SetConstantObj(interp, "osgeo::GCI_AlphaBand", SWIG_From_int((int)(GCI_AlphaBand)));
+   SWIG_Tcl_SetConstantObj(interp, "osgeo::GCI_HueBand", SWIG_From_int((int)(GCI_HueBand)));
+   SWIG_Tcl_SetConstantObj(interp, "osgeo::GCI_SaturationBand", SWIG_From_int((int)(GCI_SaturationBand)));
+   SWIG_Tcl_SetConstantObj(interp, "osgeo::GCI_LightnessBand", SWIG_From_int((int)(GCI_LightnessBand)));
+   SWIG_Tcl_SetConstantObj(interp, "osgeo::GCI_CyanBand", SWIG_From_int((int)(GCI_CyanBand)));
+   SWIG_Tcl_SetConstantObj(interp, "osgeo::GCI_MagentaBand", SWIG_From_int((int)(GCI_MagentaBand)));
+   SWIG_Tcl_SetConstantObj(interp, "osgeo::GCI_YellowBand", SWIG_From_int((int)(GCI_YellowBand)));
+   SWIG_Tcl_SetConstantObj(interp, "osgeo::GCI_BlackBand", SWIG_From_int((int)(GCI_BlackBand)));
+   SWIG_Tcl_SetConstantObj(interp, "osgeo::GRA_NearestNeighbour", SWIG_From_int((int)(GRA_NearestNeighbour)));
+   SWIG_Tcl_SetConstantObj(interp, "osgeo::GRA_Bilinear", SWIG_From_int((int)(GRA_Bilinear)));
+   SWIG_Tcl_SetConstantObj(interp, "osgeo::GRA_Cubic", SWIG_From_int((int)(GRA_Cubic)));
+   SWIG_Tcl_SetConstantObj(interp, "osgeo::GRA_CubicSpline", SWIG_From_int((int)(GRA_CubicSpline)));
+   SWIG_Tcl_SetConstantObj(interp, "osgeo::GRA_Lanczos", SWIG_From_int((int)(GRA_Lanczos)));
+   SWIG_Tcl_SetConstantObj(interp, "osgeo::GPI_Gray", SWIG_From_int((int)(GPI_Gray)));
+   SWIG_Tcl_SetConstantObj(interp, "osgeo::GPI_RGB", SWIG_From_int((int)(GPI_RGB)));
+   SWIG_Tcl_SetConstantObj(interp, "osgeo::GPI_CMYK", SWIG_From_int((int)(GPI_CMYK)));
+   SWIG_Tcl_SetConstantObj(interp, "osgeo::GPI_HLS", SWIG_From_int((int)(GPI_HLS)));
+   SWIG_Tcl_SetConstantObj(interp, "osgeo::CXT_Element", SWIG_From_int((int)(CXT_Element)));
+   SWIG_Tcl_SetConstantObj(interp, "osgeo::CXT_Text", SWIG_From_int((int)(CXT_Text)));
+   SWIG_Tcl_SetConstantObj(interp, "osgeo::CXT_Attribute", SWIG_From_int((int)(CXT_Attribute)));
+   SWIG_Tcl_SetConstantObj(interp, "osgeo::CXT_Comment", SWIG_From_int((int)(CXT_Comment)));
+   SWIG_Tcl_SetConstantObj(interp, "osgeo::CXT_Literal", SWIG_From_int((int)(CXT_Literal)));
+   SWIG_Tcl_SetConstantObj(interp, "osgeo::CE_None", SWIG_From_int((int)(CE_None)));
+   SWIG_Tcl_SetConstantObj(interp, "osgeo::CE_Debug", SWIG_From_int((int)(CE_Debug)));
+   SWIG_Tcl_SetConstantObj(interp, "osgeo::CE_Warning", SWIG_From_int((int)(CE_Warning)));
+   SWIG_Tcl_SetConstantObj(interp, "osgeo::CE_Failure", SWIG_From_int((int)(CE_Failure)));
+   SWIG_Tcl_SetConstantObj(interp, "osgeo::CE_Fatal", SWIG_From_int((int)(CE_Fatal)));
+   SWIG_Tcl_SetConstantObj(interp, "osgeo::CPLE_None", SWIG_From_int((int)(CPLE_None)));
+   SWIG_Tcl_SetConstantObj(interp, "osgeo::CPLE_AppDefined", SWIG_From_int((int)(CPLE_AppDefined)));
+   SWIG_Tcl_SetConstantObj(interp, "osgeo::CPLE_OutOfMemory", SWIG_From_int((int)(CPLE_OutOfMemory)));
+   SWIG_Tcl_SetConstantObj(interp, "osgeo::CPLE_FileIO", SWIG_From_int((int)(CPLE_FileIO)));
+   SWIG_Tcl_SetConstantObj(interp, "osgeo::CPLE_OpenFailed", SWIG_From_int((int)(CPLE_OpenFailed)));
+   SWIG_Tcl_SetConstantObj(interp, "osgeo::CPLE_IllegalArg", SWIG_From_int((int)(CPLE_IllegalArg)));
+   SWIG_Tcl_SetConstantObj(interp, "osgeo::CPLE_NotSupported", SWIG_From_int((int)(CPLE_NotSupported)));
+   SWIG_Tcl_SetConstantObj(interp, "osgeo::CPLE_AssertionFailed", SWIG_From_int((int)(CPLE_AssertionFailed)));
+   SWIG_Tcl_SetConstantObj(interp, "osgeo::CPLE_NoWriteAccess", SWIG_From_int((int)(CPLE_NoWriteAccess)));
+   SWIG_Tcl_SetConstantObj(interp, "osgeo::CPLE_UserInterrupt", SWIG_From_int((int)(CPLE_UserInterrupt)));
+   SWIG_Tcl_SetConstantObj(interp, "osgeo::DMD_LONGNAME", SWIG_FromCharPtr(GDAL_DMD_LONGNAME));
+   SWIG_Tcl_SetConstantObj(interp, "osgeo::DMD_HELPTOPIC", SWIG_FromCharPtr(GDAL_DMD_HELPTOPIC));
+   SWIG_Tcl_SetConstantObj(interp, "osgeo::DMD_MIMETYPE", SWIG_FromCharPtr(GDAL_DMD_MIMETYPE));
+   SWIG_Tcl_SetConstantObj(interp, "osgeo::DMD_EXTENSION", SWIG_FromCharPtr(GDAL_DMD_EXTENSION));
+   SWIG_Tcl_SetConstantObj(interp, "osgeo::DMD_CREATIONOPTIONLIST", SWIG_FromCharPtr(GDAL_DMD_CREATIONOPTIONLIST));
+   SWIG_Tcl_SetConstantObj(interp, "osgeo::DMD_CREATIONDATATYPES", SWIG_FromCharPtr(GDAL_DMD_CREATIONDATATYPES));
+   SWIG_Tcl_SetConstantObj(interp, "osgeo::DCAP_CREATE", SWIG_FromCharPtr(GDAL_DCAP_CREATE));
+   SWIG_Tcl_SetConstantObj(interp, "osgeo::DCAP_CREATECOPY", SWIG_FromCharPtr(GDAL_DCAP_CREATECOPY));
+   SWIG_Tcl_SetConstantObj(interp, "osgeo::CPLES_BackslashQuotable", SWIG_From_int((int)(CPLES_BackslashQuotable)));
+   SWIG_Tcl_SetConstantObj(interp, "osgeo::CPLES_XML", SWIG_From_int((int)(CPLES_XML)));
+   SWIG_Tcl_SetConstantObj(interp, "osgeo::CPLES_URL", SWIG_From_int((int)(CPLES_URL)));
+   SWIG_Tcl_SetConstantObj(interp, "osgeo::CPLES_SQL", SWIG_From_int((int)(CPLES_SQL)));
+   SWIG_Tcl_SetConstantObj(interp, "osgeo::CPLES_CSV", SWIG_From_int((int)(CPLES_CSV)));
+   SWIG_Tcl_SetConstantObj(interp, "osgeo::GFT_Integer", SWIG_From_int((int)(GFT_Integer)));
+   SWIG_Tcl_SetConstantObj(interp, "osgeo::GFT_Real", SWIG_From_int((int)(GFT_Real)));
+   SWIG_Tcl_SetConstantObj(interp, "osgeo::GFT_String", SWIG_From_int((int)(GFT_String)));
+   SWIG_Tcl_SetConstantObj(interp, "osgeo::GFU_Generic", SWIG_From_int((int)(GFU_Generic)));
+   SWIG_Tcl_SetConstantObj(interp, "osgeo::GFU_PixelCount", SWIG_From_int((int)(GFU_PixelCount)));
+   SWIG_Tcl_SetConstantObj(interp, "osgeo::GFU_Name", SWIG_From_int((int)(GFU_Name)));
+   SWIG_Tcl_SetConstantObj(interp, "osgeo::GFU_Min", SWIG_From_int((int)(GFU_Min)));
+   SWIG_Tcl_SetConstantObj(interp, "osgeo::GFU_Max", SWIG_From_int((int)(GFU_Max)));
+   SWIG_Tcl_SetConstantObj(interp, "osgeo::GFU_MinMax", SWIG_From_int((int)(GFU_MinMax)));
+   SWIG_Tcl_SetConstantObj(interp, "osgeo::GFU_Red", SWIG_From_int((int)(GFU_Red)));
+   SWIG_Tcl_SetConstantObj(interp, "osgeo::GFU_Green", SWIG_From_int((int)(GFU_Green)));
+   SWIG_Tcl_SetConstantObj(interp, "osgeo::GFU_Blue", SWIG_From_int((int)(GFU_Blue)));
+   SWIG_Tcl_SetConstantObj(interp, "osgeo::GFU_Alpha", SWIG_From_int((int)(GFU_Alpha)));
+   SWIG_Tcl_SetConstantObj(interp, "osgeo::GFU_RedMin", SWIG_From_int((int)(GFU_RedMin)));
+   SWIG_Tcl_SetConstantObj(interp, "osgeo::GFU_GreenMin", SWIG_From_int((int)(GFU_GreenMin)));
+   SWIG_Tcl_SetConstantObj(interp, "osgeo::GFU_BlueMin", SWIG_From_int((int)(GFU_BlueMin)));
+   SWIG_Tcl_SetConstantObj(interp, "osgeo::GFU_AlphaMin", SWIG_From_int((int)(GFU_AlphaMin)));
+   SWIG_Tcl_SetConstantObj(interp, "osgeo::GFU_RedMax", SWIG_From_int((int)(GFU_RedMax)));
+   SWIG_Tcl_SetConstantObj(interp, "osgeo::GFU_GreenMax", SWIG_From_int((int)(GFU_GreenMax)));
+   SWIG_Tcl_SetConstantObj(interp, "osgeo::GFU_BlueMax", SWIG_From_int((int)(GFU_BlueMax)));
+   SWIG_Tcl_SetConstantObj(interp, "osgeo::GFU_AlphaMax", SWIG_From_int((int)(GFU_AlphaMax)));
+   SWIG_Tcl_SetConstantObj(interp, "osgeo::GFU_MaxCount", SWIG_From_int((int)(GFU_MaxCount)));
+   SWIG_Tcl_SetConstantObj(interp, "osgeo::GMF_ALL_VALID", SWIG_From_int((int)(0x01)));
+   SWIG_Tcl_SetConstantObj(interp, "osgeo::GMF_PER_DATASET", SWIG_From_int((int)(0x02)));
+   SWIG_Tcl_SetConstantObj(interp, "osgeo::GMF_ALPHA", SWIG_From_int((int)(0x04)));
+   SWIG_Tcl_SetConstantObj(interp, "osgeo::GMF_NODATA", SWIG_From_int((int)(0x08)));
+   return TCL_OK;
+ }
+ SWIGEXPORT int Gdalconst_SafeInit(Tcl_Interp *interp) {
+   return SWIG_init(interp);
+ }
+ 
diff -rNc gdal-1.6.1/swig/tcl/gdal_wrap.cpp gdal-1.6.1-patched/swig/tcl/gdal_wrap.cpp
*** gdal-1.6.1/swig/tcl/gdal_wrap.cpp	1970-01-01 02:00:00.000000000 +0200
--- gdal-1.6.1-patched/swig/tcl/gdal_wrap.cpp	2009-06-30 15:40:02.000000000 +0300
***************
*** 0 ****
--- 1,17230 ----
+ /* ----------------------------------------------------------------------------
+  * This file was automatically generated by SWIG (http://www.swig.org).
+  * Version 1.3.36
+  * 
+  * This file is not intended to be easily readable and contains a number of 
+  * coding conventions designed to improve portability and efficiency. Do not make
+  * changes to this file unless you know what you are doing--modify the SWIG 
+  * interface file instead. 
+  * ----------------------------------------------------------------------------- */
+ 
+ 
+ #ifdef __cplusplus
+ template<typename T> class SwigValueWrapper {
+     T *tt;
+ public:
+     SwigValueWrapper() : tt(0) { }
+     SwigValueWrapper(const SwigValueWrapper<T>& rhs) : tt(new T(*rhs.tt)) { }
+     SwigValueWrapper(const T& t) : tt(new T(t)) { }
+     ~SwigValueWrapper() { delete tt; } 
+     SwigValueWrapper& operator=(const T& t) { delete tt; tt = new T(t); return *this; }
+     operator T&() const { return *tt; }
+     T *operator&() { return tt; }
+ private:
+     SwigValueWrapper& operator=(const SwigValueWrapper<T>& rhs);
+ };
+ 
+ template <typename T> T SwigValueInit() {
+   return T();
+ }
+ #endif
+ 
+ /* -----------------------------------------------------------------------------
+  *  This section contains generic SWIG labels for method/variable
+  *  declarations/attributes, and other compiler dependent labels.
+  * ----------------------------------------------------------------------------- */
+ 
+ /* template workaround for compilers that cannot correctly implement the C++ standard */
+ #ifndef SWIGTEMPLATEDISAMBIGUATOR
+ # if defined(__SUNPRO_CC) && (__SUNPRO_CC <= 0x560)
+ #  define SWIGTEMPLATEDISAMBIGUATOR template
+ # elif defined(__HP_aCC)
+ /* Needed even with `aCC -AA' when `aCC -V' reports HP ANSI C++ B3910B A.03.55 */
+ /* If we find a maximum version that requires this, the test would be __HP_aCC <= 35500 for A.03.55 */
+ #  define SWIGTEMPLATEDISAMBIGUATOR template
+ # else
+ #  define SWIGTEMPLATEDISAMBIGUATOR
+ # endif
+ #endif
+ 
+ /* inline attribute */
+ #ifndef SWIGINLINE
+ # if defined(__cplusplus) || (defined(__GNUC__) && !defined(__STRICT_ANSI__))
+ #   define SWIGINLINE inline
+ # else
+ #   define SWIGINLINE
+ # endif
+ #endif
+ 
+ /* attribute recognised by some compilers to avoid 'unused' warnings */
+ #ifndef SWIGUNUSED
+ # if defined(__GNUC__)
+ #   if !(defined(__cplusplus)) || (__GNUC__ > 3 || (__GNUC__ == 3 && __GNUC_MINOR__ >= 4))
+ #     define SWIGUNUSED __attribute__ ((__unused__)) 
+ #   else
+ #     define SWIGUNUSED
+ #   endif
+ # elif defined(__ICC)
+ #   define SWIGUNUSED __attribute__ ((__unused__)) 
+ # else
+ #   define SWIGUNUSED 
+ # endif
+ #endif
+ 
+ #ifndef SWIG_MSC_UNSUPPRESS_4505
+ # if defined(_MSC_VER)
+ #   pragma warning(disable : 4505) /* unreferenced local function has been removed */
+ # endif 
+ #endif
+ 
+ #ifndef SWIGUNUSEDPARM
+ # ifdef __cplusplus
+ #   define SWIGUNUSEDPARM(p)
+ # else
+ #   define SWIGUNUSEDPARM(p) p SWIGUNUSED 
+ # endif
+ #endif
+ 
+ /* internal SWIG method */
+ #ifndef SWIGINTERN
+ # define SWIGINTERN static SWIGUNUSED
+ #endif
+ 
+ /* internal inline SWIG method */
+ #ifndef SWIGINTERNINLINE
+ # define SWIGINTERNINLINE SWIGINTERN SWIGINLINE
+ #endif
+ 
+ /* exporting methods */
+ #if (__GNUC__ >= 4) || (__GNUC__ == 3 && __GNUC_MINOR__ >= 4)
+ #  ifndef GCC_HASCLASSVISIBILITY
+ #    define GCC_HASCLASSVISIBILITY
+ #  endif
+ #endif
+ 
+ #ifndef SWIGEXPORT
+ # if defined(_WIN32) || defined(__WIN32__) || defined(__CYGWIN__)
+ #   if defined(STATIC_LINKED)
+ #     define SWIGEXPORT
+ #   else
+ #     define SWIGEXPORT __declspec(dllexport)
+ #   endif
+ # else
+ #   if defined(__GNUC__) && defined(GCC_HASCLASSVISIBILITY)
+ #     define SWIGEXPORT __attribute__ ((visibility("default")))
+ #   else
+ #     define SWIGEXPORT
+ #   endif
+ # endif
+ #endif
+ 
+ /* calling conventions for Windows */
+ #ifndef SWIGSTDCALL
+ # if defined(_WIN32) || defined(__WIN32__) || defined(__CYGWIN__)
+ #   define SWIGSTDCALL __stdcall
+ # else
+ #   define SWIGSTDCALL
+ # endif 
+ #endif
+ 
+ /* Deal with Microsoft's attempt at deprecating C standard runtime functions */
+ #if !defined(SWIG_NO_CRT_SECURE_NO_DEPRECATE) && defined(_MSC_VER) && !defined(_CRT_SECURE_NO_DEPRECATE)
+ # define _CRT_SECURE_NO_DEPRECATE
+ #endif
+ 
+ /* Deal with Microsoft's attempt at deprecating methods in the standard C++ library */
+ #if !defined(SWIG_NO_SCL_SECURE_NO_DEPRECATE) && defined(_MSC_VER) && !defined(_SCL_SECURE_NO_DEPRECATE)
+ # define _SCL_SECURE_NO_DEPRECATE
+ #endif
+ 
+ 
+ 
+ #include <stdio.h>
+ #include <tcl.h>
+ #include <errno.h>
+ #include <stdlib.h>
+ #include <stdarg.h>
+ #include <ctype.h>
+ 
+ /* -----------------------------------------------------------------------------
+  * swigrun.swg
+  *
+  * This file contains generic CAPI SWIG runtime support for pointer
+  * type checking.
+  * ----------------------------------------------------------------------------- */
+ 
+ /* This should only be incremented when either the layout of swig_type_info changes,
+    or for whatever reason, the runtime changes incompatibly */
+ #define SWIG_RUNTIME_VERSION "4"
+ 
+ /* define SWIG_TYPE_TABLE_NAME as "SWIG_TYPE_TABLE" */
+ #ifdef SWIG_TYPE_TABLE
+ # define SWIG_QUOTE_STRING(x) #x
+ # define SWIG_EXPAND_AND_QUOTE_STRING(x) SWIG_QUOTE_STRING(x)
+ # define SWIG_TYPE_TABLE_NAME SWIG_EXPAND_AND_QUOTE_STRING(SWIG_TYPE_TABLE)
+ #else
+ # define SWIG_TYPE_TABLE_NAME
+ #endif
+ 
+ /*
+   You can use the SWIGRUNTIME and SWIGRUNTIMEINLINE macros for
+   creating a static or dynamic library from the swig runtime code.
+   In 99.9% of the cases, swig just needs to declare them as 'static'.
+   
+   But only do this if is strictly necessary, ie, if you have problems
+   with your compiler or so.
+ */
+ 
+ #ifndef SWIGRUNTIME
+ # define SWIGRUNTIME SWIGINTERN
+ #endif
+ 
+ #ifndef SWIGRUNTIMEINLINE
+ # define SWIGRUNTIMEINLINE SWIGRUNTIME SWIGINLINE
+ #endif
+ 
+ /*  Generic buffer size */
+ #ifndef SWIG_BUFFER_SIZE
+ # define SWIG_BUFFER_SIZE 1024
+ #endif
+ 
+ /* Flags for pointer conversions */
+ #define SWIG_POINTER_DISOWN        0x1
+ #define SWIG_CAST_NEW_MEMORY       0x2
+ 
+ /* Flags for new pointer objects */
+ #define SWIG_POINTER_OWN           0x1
+ 
+ 
+ /* 
+    Flags/methods for returning states.
+    
+    The swig conversion methods, as ConvertPtr, return and integer 
+    that tells if the conversion was successful or not. And if not,
+    an error code can be returned (see swigerrors.swg for the codes).
+    
+    Use the following macros/flags to set or process the returning
+    states.
+    
+    In old swig versions, you usually write code as:
+ 
+      if (SWIG_ConvertPtr(obj,vptr,ty.flags) != -1) {
+        // success code
+      } else {
+        //fail code
+      }
+ 
+    Now you can be more explicit as:
+ 
+     int res = SWIG_ConvertPtr(obj,vptr,ty.flags);
+     if (SWIG_IsOK(res)) {
+       // success code
+     } else {
+       // fail code
+     }
+ 
+    that seems to be the same, but now you can also do
+ 
+     Type *ptr;
+     int res = SWIG_ConvertPtr(obj,(void **)(&ptr),ty.flags);
+     if (SWIG_IsOK(res)) {
+       // success code
+       if (SWIG_IsNewObj(res) {
+         ...
+ 	delete *ptr;
+       } else {
+         ...
+       }
+     } else {
+       // fail code
+     }
+     
+    I.e., now SWIG_ConvertPtr can return new objects and you can
+    identify the case and take care of the deallocation. Of course that
+    requires also to SWIG_ConvertPtr to return new result values, as
+ 
+       int SWIG_ConvertPtr(obj, ptr,...) {         
+         if (<obj is ok>) {			       
+           if (<need new object>) {		       
+             *ptr = <ptr to new allocated object>; 
+             return SWIG_NEWOBJ;		       
+           } else {				       
+             *ptr = <ptr to old object>;	       
+             return SWIG_OLDOBJ;		       
+           } 				       
+         } else {				       
+           return SWIG_BADOBJ;		       
+         }					       
+       }
+ 
+    Of course, returning the plain '0(success)/-1(fail)' still works, but you can be
+    more explicit by returning SWIG_BADOBJ, SWIG_ERROR or any of the
+    swig errors code.
+ 
+    Finally, if the SWIG_CASTRANK_MODE is enabled, the result code
+    allows to return the 'cast rank', for example, if you have this
+ 
+        int food(double)
+        int fooi(int);
+ 
+    and you call
+  
+       food(1)   // cast rank '1'  (1 -> 1.0)
+       fooi(1)   // cast rank '0'
+ 
+    just use the SWIG_AddCast()/SWIG_CheckState()
+ 
+ 
+  */
+ #define SWIG_OK                    (0) 
+ #define SWIG_ERROR                 (-1)
+ #define SWIG_IsOK(r)               (r >= 0)
+ #define SWIG_ArgError(r)           ((r != SWIG_ERROR) ? r : SWIG_TypeError)  
+ 
+ /* The CastRankLimit says how many bits are used for the cast rank */
+ #define SWIG_CASTRANKLIMIT         (1 << 8)
+ /* The NewMask denotes the object was created (using new/malloc) */
+ #define SWIG_NEWOBJMASK            (SWIG_CASTRANKLIMIT  << 1)
+ /* The TmpMask is for in/out typemaps that use temporal objects */
+ #define SWIG_TMPOBJMASK            (SWIG_NEWOBJMASK << 1)
+ /* Simple returning values */
+ #define SWIG_BADOBJ                (SWIG_ERROR)
+ #define SWIG_OLDOBJ                (SWIG_OK)
+ #define SWIG_NEWOBJ                (SWIG_OK | SWIG_NEWOBJMASK)
+ #define SWIG_TMPOBJ                (SWIG_OK | SWIG_TMPOBJMASK)
+ /* Check, add and del mask methods */
+ #define SWIG_AddNewMask(r)         (SWIG_IsOK(r) ? (r | SWIG_NEWOBJMASK) : r)
+ #define SWIG_DelNewMask(r)         (SWIG_IsOK(r) ? (r & ~SWIG_NEWOBJMASK) : r)
+ #define SWIG_IsNewObj(r)           (SWIG_IsOK(r) && (r & SWIG_NEWOBJMASK))
+ #define SWIG_AddTmpMask(r)         (SWIG_IsOK(r) ? (r | SWIG_TMPOBJMASK) : r)
+ #define SWIG_DelTmpMask(r)         (SWIG_IsOK(r) ? (r & ~SWIG_TMPOBJMASK) : r)
+ #define SWIG_IsTmpObj(r)           (SWIG_IsOK(r) && (r & SWIG_TMPOBJMASK))
+ 
+ 
+ /* Cast-Rank Mode */
+ #if defined(SWIG_CASTRANK_MODE)
+ #  ifndef SWIG_TypeRank
+ #    define SWIG_TypeRank             unsigned long
+ #  endif
+ #  ifndef SWIG_MAXCASTRANK            /* Default cast allowed */
+ #    define SWIG_MAXCASTRANK          (2)
+ #  endif
+ #  define SWIG_CASTRANKMASK          ((SWIG_CASTRANKLIMIT) -1)
+ #  define SWIG_CastRank(r)           (r & SWIG_CASTRANKMASK)
+ SWIGINTERNINLINE int SWIG_AddCast(int r) { 
+   return SWIG_IsOK(r) ? ((SWIG_CastRank(r) < SWIG_MAXCASTRANK) ? (r + 1) : SWIG_ERROR) : r;
+ }
+ SWIGINTERNINLINE int SWIG_CheckState(int r) { 
+   return SWIG_IsOK(r) ? SWIG_CastRank(r) + 1 : 0; 
+ }
+ #else /* no cast-rank mode */
+ #  define SWIG_AddCast
+ #  define SWIG_CheckState(r) (SWIG_IsOK(r) ? 1 : 0)
+ #endif
+ 
+ 
+ 
+ 
+ #include <string.h>
+ 
+ #ifdef __cplusplus
+ extern "C" {
+ #endif
+ 
+ typedef void *(*swig_converter_func)(void *, int *);
+ typedef struct swig_type_info *(*swig_dycast_func)(void **);
+ 
+ /* Structure to store information on one type */
+ typedef struct swig_type_info {
+   const char             *name;			/* mangled name of this type */
+   const char             *str;			/* human readable name of this type */
+   swig_dycast_func        dcast;		/* dynamic cast function down a hierarchy */
+   struct swig_cast_info  *cast;			/* linked list of types that can cast into this type */
+   void                   *clientdata;		/* language specific type data */
+   int                    owndata;		/* flag if the structure owns the clientdata */
+ } swig_type_info;
+ 
+ /* Structure to store a type and conversion function used for casting */
+ typedef struct swig_cast_info {
+   swig_type_info         *type;			/* pointer to type that is equivalent to this type */
+   swig_converter_func     converter;		/* function to cast the void pointers */
+   struct swig_cast_info  *next;			/* pointer to next cast in linked list */
+   struct swig_cast_info  *prev;			/* pointer to the previous cast */
+ } swig_cast_info;
+ 
+ /* Structure used to store module information
+  * Each module generates one structure like this, and the runtime collects
+  * all of these structures and stores them in a circularly linked list.*/
+ typedef struct swig_module_info {
+   swig_type_info         **types;		/* Array of pointers to swig_type_info structures that are in this module */
+   size_t                 size;		        /* Number of types in this module */
+   struct swig_module_info *next;		/* Pointer to next element in circularly linked list */
+   swig_type_info         **type_initial;	/* Array of initially generated type structures */
+   swig_cast_info         **cast_initial;	/* Array of initially generated casting structures */
+   void                    *clientdata;		/* Language specific module data */
+ } swig_module_info;
+ 
+ /* 
+   Compare two type names skipping the space characters, therefore
+   "char*" == "char *" and "Class<int>" == "Class<int >", etc.
+ 
+   Return 0 when the two name types are equivalent, as in
+   strncmp, but skipping ' '.
+ */
+ SWIGRUNTIME int
+ SWIG_TypeNameComp(const char *f1, const char *l1,
+ 		  const char *f2, const char *l2) {
+   for (;(f1 != l1) && (f2 != l2); ++f1, ++f2) {
+     while ((*f1 == ' ') && (f1 != l1)) ++f1;
+     while ((*f2 == ' ') && (f2 != l2)) ++f2;
+     if (*f1 != *f2) return (*f1 > *f2) ? 1 : -1;
+   }
+   return (int)((l1 - f1) - (l2 - f2));
+ }
+ 
+ /*
+   Check type equivalence in a name list like <name1>|<name2>|...
+   Return 0 if not equal, 1 if equal
+ */
+ SWIGRUNTIME int
+ SWIG_TypeEquiv(const char *nb, const char *tb) {
+   int equiv = 0;
+   const char* te = tb + strlen(tb);
+   const char* ne = nb;
+   while (!equiv && *ne) {
+     for (nb = ne; *ne; ++ne) {
+       if (*ne == '|') break;
+     }
+     equiv = (SWIG_TypeNameComp(nb, ne, tb, te) == 0) ? 1 : 0;
+     if (*ne) ++ne;
+   }
+   return equiv;
+ }
+ 
+ /*
+   Check type equivalence in a name list like <name1>|<name2>|...
+   Return 0 if equal, -1 if nb < tb, 1 if nb > tb
+ */
+ SWIGRUNTIME int
+ SWIG_TypeCompare(const char *nb, const char *tb) {
+   int equiv = 0;
+   const char* te = tb + strlen(tb);
+   const char* ne = nb;
+   while (!equiv && *ne) {
+     for (nb = ne; *ne; ++ne) {
+       if (*ne == '|') break;
+     }
+     equiv = (SWIG_TypeNameComp(nb, ne, tb, te) == 0) ? 1 : 0;
+     if (*ne) ++ne;
+   }
+   return equiv;
+ }
+ 
+ 
+ /* think of this as a c++ template<> or a scheme macro */
+ #define SWIG_TypeCheck_Template(comparison, ty)         \
+   if (ty) {                                             \
+     swig_cast_info *iter = ty->cast;                    \
+     while (iter) {                                      \
+       if (comparison) {                                 \
+         if (iter == ty->cast) return iter;              \
+         /* Move iter to the top of the linked list */   \
+         iter->prev->next = iter->next;                  \
+         if (iter->next)                                 \
+           iter->next->prev = iter->prev;                \
+         iter->next = ty->cast;                          \
+         iter->prev = 0;                                 \
+         if (ty->cast) ty->cast->prev = iter;            \
+         ty->cast = iter;                                \
+         return iter;                                    \
+       }                                                 \
+       iter = iter->next;                                \
+     }                                                   \
+   }                                                     \
+   return 0
+ 
+ /*
+   Check the typename
+ */
+ SWIGRUNTIME swig_cast_info *
+ SWIG_TypeCheck(const char *c, swig_type_info *ty) {
+   SWIG_TypeCheck_Template(strcmp(iter->type->name, c) == 0, ty);
+ }
+ 
+ /* Same as previous function, except strcmp is replaced with a pointer comparison */
+ SWIGRUNTIME swig_cast_info *
+ SWIG_TypeCheckStruct(swig_type_info *from, swig_type_info *into) {
+   SWIG_TypeCheck_Template(iter->type == from, into);
+ }
+ 
+ /*
+   Cast a pointer up an inheritance hierarchy
+ */
+ SWIGRUNTIMEINLINE void *
+ SWIG_TypeCast(swig_cast_info *ty, void *ptr, int *newmemory) {
+   return ((!ty) || (!ty->converter)) ? ptr : (*ty->converter)(ptr, newmemory);
+ }
+ 
+ /* 
+    Dynamic pointer casting. Down an inheritance hierarchy
+ */
+ SWIGRUNTIME swig_type_info *
+ SWIG_TypeDynamicCast(swig_type_info *ty, void **ptr) {
+   swig_type_info *lastty = ty;
+   if (!ty || !ty->dcast) return ty;
+   while (ty && (ty->dcast)) {
+     ty = (*ty->dcast)(ptr);
+     if (ty) lastty = ty;
+   }
+   return lastty;
+ }
+ 
+ /*
+   Return the name associated with this type
+ */
+ SWIGRUNTIMEINLINE const char *
+ SWIG_TypeName(const swig_type_info *ty) {
+   return ty->name;
+ }
+ 
+ /*
+   Return the pretty name associated with this type,
+   that is an unmangled type name in a form presentable to the user.
+ */
+ SWIGRUNTIME const char *
+ SWIG_TypePrettyName(const swig_type_info *type) {
+   /* The "str" field contains the equivalent pretty names of the
+      type, separated by vertical-bar characters.  We choose
+      to print the last name, as it is often (?) the most
+      specific. */
+   if (!type) return NULL;
+   if (type->str != NULL) {
+     const char *last_name = type->str;
+     const char *s;
+     for (s = type->str; *s; s++)
+       if (*s == '|') last_name = s+1;
+     return last_name;
+   }
+   else
+     return type->name;
+ }
+ 
+ /* 
+    Set the clientdata field for a type
+ */
+ SWIGRUNTIME void
+ SWIG_TypeClientData(swig_type_info *ti, void *clientdata) {
+   swig_cast_info *cast = ti->cast;
+   /* if (ti->clientdata == clientdata) return; */
+   ti->clientdata = clientdata;
+   
+   while (cast) {
+     if (!cast->converter) {
+       swig_type_info *tc = cast->type;
+       if (!tc->clientdata) {
+ 	SWIG_TypeClientData(tc, clientdata);
+       }
+     }    
+     cast = cast->next;
+   }
+ }
+ SWIGRUNTIME void
+ SWIG_TypeNewClientData(swig_type_info *ti, void *clientdata) {
+   SWIG_TypeClientData(ti, clientdata);
+   ti->owndata = 1;
+ }
+   
+ /*
+   Search for a swig_type_info structure only by mangled name
+   Search is a O(log #types)
+   
+   We start searching at module start, and finish searching when start == end.  
+   Note: if start == end at the beginning of the function, we go all the way around
+   the circular list.
+ */
+ SWIGRUNTIME swig_type_info *
+ SWIG_MangledTypeQueryModule(swig_module_info *start, 
+                             swig_module_info *end, 
+ 		            const char *name) {
+   swig_module_info *iter = start;
+   do {
+     if (iter->size) {
+       register size_t l = 0;
+       register size_t r = iter->size - 1;
+       do {
+ 	/* since l+r >= 0, we can (>> 1) instead (/ 2) */
+ 	register size_t i = (l + r) >> 1; 
+ 	const char *iname = iter->types[i]->name;
+ 	if (iname) {
+ 	  register int compare = strcmp(name, iname);
+ 	  if (compare == 0) {	    
+ 	    return iter->types[i];
+ 	  } else if (compare < 0) {
+ 	    if (i) {
+ 	      r = i - 1;
+ 	    } else {
+ 	      break;
+ 	    }
+ 	  } else if (compare > 0) {
+ 	    l = i + 1;
+ 	  }
+ 	} else {
+ 	  break; /* should never happen */
+ 	}
+       } while (l <= r);
+     }
+     iter = iter->next;
+   } while (iter != end);
+   return 0;
+ }
+ 
+ /*
+   Search for a swig_type_info structure for either a mangled name or a human readable name.
+   It first searches the mangled names of the types, which is a O(log #types)
+   If a type is not found it then searches the human readable names, which is O(#types).
+   
+   We start searching at module start, and finish searching when start == end.  
+   Note: if start == end at the beginning of the function, we go all the way around
+   the circular list.
+ */
+ SWIGRUNTIME swig_type_info *
+ SWIG_TypeQueryModule(swig_module_info *start, 
+                      swig_module_info *end, 
+ 		     const char *name) {
+   /* STEP 1: Search the name field using binary search */
+   swig_type_info *ret = SWIG_MangledTypeQueryModule(start, end, name);
+   if (ret) {
+     return ret;
+   } else {
+     /* STEP 2: If the type hasn't been found, do a complete search
+        of the str field (the human readable name) */
+     swig_module_info *iter = start;
+     do {
+       register size_t i = 0;
+       for (; i < iter->size; ++i) {
+ 	if (iter->types[i]->str && (SWIG_TypeEquiv(iter->types[i]->str, name)))
+ 	  return iter->types[i];
+       }
+       iter = iter->next;
+     } while (iter != end);
+   }
+   
+   /* neither found a match */
+   return 0;
+ }
+ 
+ /* 
+    Pack binary data into a string
+ */
+ SWIGRUNTIME char *
+ SWIG_PackData(char *c, void *ptr, size_t sz) {
+   static const char hex[17] = "0123456789abcdef";
+   register const unsigned char *u = (unsigned char *) ptr;
+   register const unsigned char *eu =  u + sz;
+   for (; u != eu; ++u) {
+     register unsigned char uu = *u;
+     *(c++) = hex[(uu & 0xf0) >> 4];
+     *(c++) = hex[uu & 0xf];
+   }
+   return c;
+ }
+ 
+ /* 
+    Unpack binary data from a string
+ */
+ SWIGRUNTIME const char *
+ SWIG_UnpackData(const char *c, void *ptr, size_t sz) {
+   register unsigned char *u = (unsigned char *) ptr;
+   register const unsigned char *eu = u + sz;
+   for (; u != eu; ++u) {
+     register char d = *(c++);
+     register unsigned char uu;
+     if ((d >= '0') && (d <= '9'))
+       uu = ((d - '0') << 4);
+     else if ((d >= 'a') && (d <= 'f'))
+       uu = ((d - ('a'-10)) << 4);
+     else 
+       return (char *) 0;
+     d = *(c++);
+     if ((d >= '0') && (d <= '9'))
+       uu |= (d - '0');
+     else if ((d >= 'a') && (d <= 'f'))
+       uu |= (d - ('a'-10));
+     else 
+       return (char *) 0;
+     *u = uu;
+   }
+   return c;
+ }
+ 
+ /* 
+    Pack 'void *' into a string buffer.
+ */
+ SWIGRUNTIME char *
+ SWIG_PackVoidPtr(char *buff, void *ptr, const char *name, size_t bsz) {
+   char *r = buff;
+   if ((2*sizeof(void *) + 2) > bsz) return 0;
+   *(r++) = '_';
+   r = SWIG_PackData(r,&ptr,sizeof(void *));
+   if (strlen(name) + 1 > (bsz - (r - buff))) return 0;
+   strcpy(r,name);
+   return buff;
+ }
+ 
+ SWIGRUNTIME const char *
+ SWIG_UnpackVoidPtr(const char *c, void **ptr, const char *name) {
+   if (*c != '_') {
+     if (strcmp(c,"NULL") == 0) {
+       *ptr = (void *) 0;
+       return name;
+     } else {
+       return 0;
+     }
+   }
+   return SWIG_UnpackData(++c,ptr,sizeof(void *));
+ }
+ 
+ SWIGRUNTIME char *
+ SWIG_PackDataName(char *buff, void *ptr, size_t sz, const char *name, size_t bsz) {
+   char *r = buff;
+   size_t lname = (name ? strlen(name) : 0);
+   if ((2*sz + 2 + lname) > bsz) return 0;
+   *(r++) = '_';
+   r = SWIG_PackData(r,ptr,sz);
+   if (lname) {
+     strncpy(r,name,lname+1);
+   } else {
+     *r = 0;
+   }
+   return buff;
+ }
+ 
+ SWIGRUNTIME const char *
+ SWIG_UnpackDataName(const char *c, void *ptr, size_t sz, const char *name) {
+   if (*c != '_') {
+     if (strcmp(c,"NULL") == 0) {
+       memset(ptr,0,sz);
+       return name;
+     } else {
+       return 0;
+     }
+   }
+   return SWIG_UnpackData(++c,ptr,sz);
+ }
+ 
+ #ifdef __cplusplus
+ }
+ #endif
+ 
+ /*  Errors in SWIG */
+ #define  SWIG_UnknownError    	   -1 
+ #define  SWIG_IOError        	   -2 
+ #define  SWIG_RuntimeError   	   -3 
+ #define  SWIG_IndexError     	   -4 
+ #define  SWIG_TypeError      	   -5 
+ #define  SWIG_DivisionByZero 	   -6 
+ #define  SWIG_OverflowError  	   -7 
+ #define  SWIG_SyntaxError    	   -8 
+ #define  SWIG_ValueError     	   -9 
+ #define  SWIG_SystemError    	   -10
+ #define  SWIG_AttributeError 	   -11
+ #define  SWIG_MemoryError    	   -12 
+ #define  SWIG_NullReferenceError   -13
+ 
+ 
+ 
+ /* -----------------------------------------------------------------------------
+  * error manipulation
+  * ----------------------------------------------------------------------------- */
+ 
+ SWIGINTERN const char*
+ SWIG_Tcl_ErrorType(int code) {
+   const char* type = 0;
+   switch(code) {
+   case SWIG_MemoryError:
+     type = "MemoryError";
+     break;
+   case SWIG_IOError:
+     type = "IOError";
+     break;
+   case SWIG_RuntimeError:
+     type = "RuntimeError";
+     break;
+   case SWIG_IndexError:
+     type = "IndexError";
+     break;
+   case SWIG_TypeError:
+     type = "TypeError";
+     break;
+   case SWIG_DivisionByZero:
+     type = "ZeroDivisionError";
+     break;
+   case SWIG_OverflowError:
+     type = "OverflowError";
+     break;
+   case SWIG_SyntaxError:
+     type = "SyntaxError";
+     break;
+   case SWIG_ValueError:
+     type = "ValueError";
+     break;
+   case SWIG_SystemError:
+     type = "SystemError";
+     break;
+   case SWIG_AttributeError:
+     type = "AttributeError";
+     break;
+   default:
+     type = "RuntimeError";
+   }
+   return type;
+ }
+ 
+ 
+ SWIGINTERN void
+ SWIG_Tcl_SetErrorObj(Tcl_Interp *interp, const char *ctype, Tcl_Obj *obj)
+ {
+   Tcl_ResetResult(interp);
+   Tcl_SetObjResult(interp, obj);
+   Tcl_SetErrorCode(interp, "SWIG", ctype, NULL);
+ }
+ 
+ SWIGINTERN void
+ SWIG_Tcl_SetErrorMsg(Tcl_Interp *interp, const char *ctype, const char *mesg)
+ {
+   Tcl_ResetResult(interp);
+   Tcl_SetErrorCode(interp, "SWIG", ctype, NULL);
+   Tcl_AppendResult(interp, ctype, " ", mesg, NULL);
+   /*
+   Tcl_AddErrorInfo(interp, ctype);
+   Tcl_AddErrorInfo(interp, " ");
+   Tcl_AddErrorInfo(interp, mesg);
+   */
+ }
+ 
+ SWIGINTERNINLINE void
+ SWIG_Tcl_AddErrorMsg(Tcl_Interp *interp, const char* mesg)
+ {
+   Tcl_AddErrorInfo(interp, mesg);
+ }
+ 
+ 
+ 
+ /* -----------------------------------------------------------------------------
+  * SWIG API. Portion that goes into the runtime
+  * ----------------------------------------------------------------------------- */
+ #ifdef __cplusplus
+ extern "C" {
+ #endif
+ 
+ /* -----------------------------------------------------------------------------
+  * Constant declarations
+  * ----------------------------------------------------------------------------- */
+ 
+ /* Constant Types */
+ #define SWIG_TCL_POINTER 4
+ #define SWIG_TCL_BINARY  5
+ 
+ /* Constant information structure */
+ typedef struct swig_const_info {
+     int type;
+     char *name;
+     long lvalue;
+     double dvalue;
+     void   *pvalue;
+     swig_type_info **ptype;
+ } swig_const_info;
+ 
+ typedef int   (*swig_wrapper)(ClientData, Tcl_Interp *, int, Tcl_Obj *CONST []);
+ typedef int   (*swig_wrapper_func)(ClientData, Tcl_Interp *, int, Tcl_Obj *CONST []);
+ typedef char *(*swig_variable_func)(ClientData, Tcl_Interp *, char *, char *, int);
+ typedef void  (*swig_delete_func)(ClientData);
+ 
+ typedef struct swig_method {
+   const char     *name;
+   swig_wrapper   method;
+ } swig_method;
+ 
+ typedef struct swig_attribute {
+   const char     *name;
+   swig_wrapper   getmethod;
+   swig_wrapper   setmethod;
+ } swig_attribute;
+ 
+ typedef struct swig_class {
+   const char         *name;
+   swig_type_info   **type;
+   swig_wrapper       constructor;
+   void              (*destructor)(void *);
+   swig_method        *methods;
+   swig_attribute     *attributes;
+   struct swig_class **bases;
+   const char              **base_names;
+   swig_module_info   *module;
+ } swig_class;
+ 
+ typedef struct swig_instance {
+   Tcl_Obj       *thisptr;
+   void          *thisvalue;
+   swig_class   *classptr;
+   int            destroy;
+   Tcl_Command    cmdtok;
+ } swig_instance;
+ 
+ /* Structure for command table */
+ typedef struct {
+   const char *name;
+   int       (*wrapper)(ClientData, Tcl_Interp *, int, Tcl_Obj *CONST []);
+   ClientData  clientdata;
+ } swig_command_info;
+ 
+ /* Structure for variable linking table */
+ typedef struct {
+   const char *name;
+   void *addr;
+   char * (*get)(ClientData, Tcl_Interp *, char *, char *, int);
+   char * (*set)(ClientData, Tcl_Interp *, char *, char *, int);
+ } swig_var_info;
+ 
+ 
+ /* -----------------------------------------------------------------------------*
+  *  Install a constant object 
+  * -----------------------------------------------------------------------------*/
+ 
+ static Tcl_HashTable   swigconstTable;
+ static int             swigconstTableinit = 0;
+ 
+ SWIGINTERN void
+ SWIG_Tcl_SetConstantObj(Tcl_Interp *interp, const char* name, Tcl_Obj *obj) {
+   int newobj;
+   Tcl_ObjSetVar2(interp,Tcl_NewStringObj(name,-1), NULL, obj, TCL_GLOBAL_ONLY);
+   Tcl_SetHashValue(Tcl_CreateHashEntry(&swigconstTable, name, &newobj), (ClientData) obj);
+ }
+ 
+ SWIGINTERN Tcl_Obj *
+ SWIG_Tcl_GetConstantObj(const char *key) {
+   Tcl_HashEntry *entryPtr;
+   if (!swigconstTableinit) return 0;
+   entryPtr = Tcl_FindHashEntry(&swigconstTable, key);
+   if (entryPtr) {
+     return (Tcl_Obj *) Tcl_GetHashValue(entryPtr);
+   }
+   return 0;
+ }
+ 
+ #ifdef __cplusplus
+ }
+ #endif
+ 
+ 
+ 
+ /* -----------------------------------------------------------------------------
+  * See the LICENSE file for information on copyright, usage and redistribution
+  * of SWIG, and the README file for authors - http://www.swig.org/release.html.
+  *
+  * tclrun.swg
+  *
+  * This file contains the runtime support for Tcl modules and includes
+  * code for managing global variables and pointer type checking.
+  * ----------------------------------------------------------------------------- */
+ 
+ /* Common SWIG API */
+ 
+ /* for raw pointers */
+ #define SWIG_ConvertPtr(oc, ptr, ty, flags)             SWIG_Tcl_ConvertPtr(interp, oc, ptr, ty, flags)
+ #define SWIG_NewPointerObj(ptr, type, flags)            SWIG_Tcl_NewPointerObj(ptr, type, flags)
+ 
+ /* for raw packed data */
+ #define SWIG_ConvertPacked(obj, ptr, sz, ty)            SWIG_Tcl_ConvertPacked(interp, obj, ptr, sz, ty)
+ #define SWIG_NewPackedObj(ptr, sz, type)                SWIG_Tcl_NewPackedObj(ptr, sz, type)
+ 
+ /* for class or struct pointers */
+ #define SWIG_ConvertInstance(obj, pptr, type, flags)    SWIG_Tcl_ConvertPtr(interp, obj, pptr, type, flags)
+ #define SWIG_NewInstanceObj(thisvalue, type, flags)     SWIG_Tcl_NewInstanceObj(interp, thisvalue, type, flags)
+ 
+ /* for C or C++ function pointers */
+ #define SWIG_ConvertFunctionPtr(obj, pptr, type)        SWIG_Tcl_ConvertPtr(interp, obj, pptr, type, 0)
+ #define SWIG_NewFunctionPtrObj(ptr, type)               SWIG_Tcl_NewPointerObj(ptr, type, 0)
+ 
+ /* for C++ member pointers, ie, member methods */
+ #define SWIG_ConvertMember(obj, ptr, sz, ty)            SWIG_Tcl_ConvertPacked(interp,obj, ptr, sz, ty)
+ #define SWIG_NewMemberObj(ptr, sz, type)                SWIG_Tcl_NewPackedObj(ptr, sz, type)
+ 
+ 
+ /* Runtime API */
+ 
+ #define SWIG_GetModule(clientdata)                      SWIG_Tcl_GetModule((Tcl_Interp *) (clientdata))	     
+ #define SWIG_SetModule(clientdata, pointer)          	SWIG_Tcl_SetModule((Tcl_Interp *) (clientdata), pointer)
+ 
+ 
+ /* Error manipulation */
+ 
+ #define SWIG_ErrorType(code)                            SWIG_Tcl_ErrorType(code)                                      
+ #define SWIG_Error(code, msg)            		SWIG_Tcl_SetErrorMsg(interp, SWIG_Tcl_ErrorType(code), msg)
+ #define SWIG_fail                        		goto fail						    
+ 
+ 
+ /* Tcl-specific SWIG API */
+ 
+ #define SWIG_Acquire(ptr)                               SWIG_Tcl_Acquire(ptr)                                     
+ #define SWIG_MethodCommand                           	SWIG_Tcl_MethodCommand				       
+ #define SWIG_Disown(ptr)                             	SWIG_Tcl_Disown(ptr)				       
+ #define SWIG_ConvertPtrFromString(c, ptr, ty, flags) 	SWIG_Tcl_ConvertPtrFromString(interp, c, ptr, ty, flags)  
+ #define SWIG_MakePtr(c, ptr, ty, flags)              	SWIG_Tcl_MakePtr(c, ptr, ty, flags)		       
+ #define SWIG_PointerTypeFromString(c)                	SWIG_Tcl_PointerTypeFromString(c)			       
+ #define SWIG_GetArgs                                 	SWIG_Tcl_GetArgs					       
+ #define SWIG_GetConstantObj(key)                     	SWIG_Tcl_GetConstantObj(key)			       
+ #define SWIG_ObjectConstructor                       	SWIG_Tcl_ObjectConstructor				       
+ #define SWIG_Thisown(ptr)                            	SWIG_Tcl_Thisown(ptr)				       
+ #define SWIG_ObjectDelete                            	SWIG_Tcl_ObjectDelete				       
+ 
+ 
+ #define SWIG_TCL_DECL_ARGS_2(arg1, arg2)                (Tcl_Interp *interp SWIGUNUSED, arg1, arg2)
+ #define SWIG_TCL_CALL_ARGS_2(arg1, arg2)                (interp, arg1, arg2)
+ /* -----------------------------------------------------------------------------
+  * pointers/data manipulation
+  * ----------------------------------------------------------------------------- */
+ 
+ /* For backward compatibility only */
+ #define SWIG_POINTER_EXCEPTION  0
+ #define SWIG_GetConstant        SWIG_GetConstantObj
+ #define SWIG_Tcl_GetConstant    SWIG_Tcl_GetConstantObj
+ 
+ #include "assert.h"
+ 
+ #ifdef __cplusplus
+ extern "C" {
+ #if 0
+ } /* cc-mode */
+ #endif
+ #endif
+ 
+ /* Object support */
+ 
+ SWIGRUNTIME Tcl_HashTable*
+ SWIG_Tcl_ObjectTable(void) {
+   static Tcl_HashTable  swigobjectTable;
+   static int            swigobjectTableinit = 0;
+   if (!swigobjectTableinit) {
+     Tcl_InitHashTable(&swigobjectTable, TCL_ONE_WORD_KEYS);
+     swigobjectTableinit = 1;
+   }
+   return &swigobjectTable;
+ }
+ 
+ /* Acquire ownership of a pointer */
+ SWIGRUNTIME void
+ SWIG_Tcl_Acquire(void *ptr) {
+   int newobj;
+   Tcl_CreateHashEntry(SWIG_Tcl_ObjectTable(), (char *) ptr, &newobj);
+ }
+ 
+ SWIGRUNTIME int
+ SWIG_Tcl_Thisown(void *ptr) {
+   if (Tcl_FindHashEntry(SWIG_Tcl_ObjectTable(), (char *) ptr)) {
+     return 1;
+   }
+   return 0;
+ }
+ 
+ /* Disown a pointer.  Returns 1 if we owned it to begin with */
+ SWIGRUNTIME int
+ SWIG_Tcl_Disown(void *ptr) {
+   Tcl_HashEntry *entryPtr = Tcl_FindHashEntry(SWIG_Tcl_ObjectTable(), (char *) ptr);
+   if (entryPtr) {
+     Tcl_DeleteHashEntry(entryPtr);
+     return 1;
+   }
+   return 0;
+ }
+ 
+ /* Convert a pointer value */
+ SWIGRUNTIME int
+ SWIG_Tcl_ConvertPtrFromString(Tcl_Interp *interp, const char *c, void **ptr, swig_type_info *ty, int flags) {
+   swig_cast_info *tc;
+   /* Pointer values must start with leading underscore */
+   while (*c != '_') {
+     *ptr = (void *) 0;
+     if (strcmp(c,"NULL") == 0) return SWIG_OK;
+ 
+     /* Empty string: not a pointer */
+     if (*c == 0) return SWIG_ERROR; 
+ 
+     /* Hmmm. It could be an object name. */
+ 
+     /* Check if this is a command at all. Prevents <c> cget -this         */
+     /* from being called when c is not a command, firing the unknown proc */
+     if (Tcl_VarEval(interp,"info commands ", c, (char *) NULL) == TCL_OK) {
+       Tcl_Obj *result = Tcl_GetObjResult(interp);
+       if (*(Tcl_GetStringFromObj(result, NULL)) == 0) {
+         /* It's not a command, so it can't be a pointer */
+         Tcl_ResetResult(interp);
+         return SWIG_ERROR;
+       }
+     } else {
+       /* This will only fail if the argument is multiple words. */
+       /* Multiple words are also not commands.                  */
+       Tcl_ResetResult(interp);
+       return SWIG_ERROR;
+     }
+ 
+     /* Check if this is really a SWIG pointer */
+     if (Tcl_VarEval(interp,c," cget -this", (char *) NULL) != TCL_OK) {
+       Tcl_ResetResult(interp);
+       return SWIG_ERROR;
+     }
+ 
+     c = Tcl_GetStringFromObj(Tcl_GetObjResult(interp), NULL);
+   }
+ 
+   c++;
+   c = SWIG_UnpackData(c,ptr,sizeof(void *));
+   if (ty) {
+     tc = c ? SWIG_TypeCheck(c,ty) : 0;
+     if (!tc) {
+       return SWIG_ERROR;
+     }
+     if (flags & SWIG_POINTER_DISOWN) {
+       SWIG_Disown((void *) *ptr);
+     }
+     {
+       int newmemory = 0;
+       *ptr = SWIG_TypeCast(tc,(void *) *ptr,&newmemory);
+       assert(!newmemory); /* newmemory handling not yet implemented */
+     }
+   }
+   return SWIG_OK;
+ }
+ 
+ /* Convert a pointer value */
+ SWIGRUNTIMEINLINE int
+ SWIG_Tcl_ConvertPtr(Tcl_Interp *interp, Tcl_Obj *oc, void **ptr, swig_type_info *ty, int flags) {
+   return SWIG_Tcl_ConvertPtrFromString(interp, Tcl_GetStringFromObj(oc,NULL), ptr, ty, flags);
+ }
+ 
+ /* Convert a pointer value */
+ SWIGRUNTIME char *
+ SWIG_Tcl_PointerTypeFromString(char *c) {
+   char d;
+   /* Pointer values must start with leading underscore. NULL has no type */
+   if (*c != '_') {
+     return 0;
+   }
+   c++;
+   /* Extract hex value from pointer */
+   while ((d = *c)) {
+     if (!(((d >= '0') && (d <= '9')) || ((d >= 'a') && (d <= 'f')))) break;
+     c++;
+   }
+   return c;
+ }
+ 
+ /* Convert a packed value value */
+ SWIGRUNTIME int
+ SWIG_Tcl_ConvertPacked(Tcl_Interp *SWIGUNUSEDPARM(interp) , Tcl_Obj *obj, void *ptr, int sz, swig_type_info *ty) {
+   swig_cast_info *tc;
+   const char  *c;
+ 
+   if (!obj) goto type_error;
+   c = Tcl_GetStringFromObj(obj,NULL);
+   /* Pointer values must start with leading underscore */
+   if (*c != '_') goto type_error;
+   c++;
+   c = SWIG_UnpackData(c,ptr,sz);
+   if (ty) {
+     tc = SWIG_TypeCheck(c,ty);
+     if (!tc) goto type_error;
+   }
+   return SWIG_OK;
+ 
+  type_error:
+ 
+   return SWIG_ERROR;
+ }
+ 
+ 
+ /* Take a pointer and convert it to a string */
+ SWIGRUNTIME void
+ SWIG_Tcl_MakePtr(char *c, void *ptr, swig_type_info *ty, int flags) {
+   if (ptr) {
+     *(c++) = '_';
+     c = SWIG_PackData(c,&ptr,sizeof(void *));
+     strcpy(c,ty->name);
+   } else {
+     strcpy(c,(char *)"NULL");
+   }
+   flags = 0;
+ }
+ 
+ /* Create a new pointer object */
+ SWIGRUNTIMEINLINE Tcl_Obj *
+ SWIG_Tcl_NewPointerObj(void *ptr, swig_type_info *type, int flags) {
+   Tcl_Obj *robj;
+   char result[SWIG_BUFFER_SIZE];
+   SWIG_MakePtr(result,ptr,type,flags);
+   robj = Tcl_NewStringObj(result,-1);
+   return robj;
+ }
+ 
+ SWIGRUNTIME Tcl_Obj *
+ SWIG_Tcl_NewPackedObj(void *ptr, int sz, swig_type_info *type) {
+   char result[1024];
+   char *r = result;
+   if ((2*sz + 1 + strlen(type->name)) > 1000) return 0;
+   *(r++) = '_';
+   r = SWIG_PackData(r,ptr,sz);
+   strcpy(r,type->name);
+   return Tcl_NewStringObj(result,-1);
+ }
+ 
+ /* -----------------------------------------------------------------------------*
+  *  Get type list 
+  * -----------------------------------------------------------------------------*/
+ 
+ SWIGRUNTIME swig_module_info * 
+ SWIG_Tcl_GetModule(Tcl_Interp *interp) {
+   const char *data;
+   swig_module_info *ret = 0;
+   
+   /* first check if pointer already created */
+   data = Tcl_GetVar(interp, (char *)"swig_runtime_data_type_pointer" SWIG_RUNTIME_VERSION SWIG_TYPE_TABLE_NAME, TCL_GLOBAL_ONLY);
+   if (data) {
+     SWIG_UnpackData(data, &ret, sizeof(swig_type_info **));
+   }
+ 
+   return ret;
+ }
+ 
+ SWIGRUNTIME void
+ SWIG_Tcl_SetModule(Tcl_Interp *interp, swig_module_info *module) {
+   char buf[SWIG_BUFFER_SIZE];
+   char *data;
+ 
+   /* create a new pointer */
+   data = SWIG_PackData(buf, &module, sizeof(swig_type_info **));
+   *data = 0;
+   Tcl_SetVar(interp, (char *)"swig_runtime_data_type_pointer" SWIG_RUNTIME_VERSION SWIG_TYPE_TABLE_NAME, buf, 0);
+ }
+ 
+ /* -----------------------------------------------------------------------------*
+  *  Object auxiliars
+  * -----------------------------------------------------------------------------*/
+ 
+ 
+ SWIGRUNTIME void
+ SWIG_Tcl_ObjectDelete(ClientData clientData) {
+   swig_instance *si = (swig_instance *) clientData;
+   if ((si) && (si->destroy) && (SWIG_Disown(si->thisvalue))) {
+     if (si->classptr->destructor) {
+       (si->classptr->destructor)(si->thisvalue);
+     }
+   }
+   Tcl_DecrRefCount(si->thisptr);
+   free(si);
+ }
+ 
+ /* Function to invoke object methods given an instance */
+ SWIGRUNTIME int
+ SWIG_Tcl_MethodCommand(ClientData clientData, Tcl_Interp *interp, int objc, Tcl_Obj *CONST _objv[]) {
+   char *method,   *attrname;
+   swig_instance   *inst = (swig_instance *) clientData;
+   swig_method     *meth;
+   swig_attribute  *attr;
+   Tcl_Obj         *oldarg;
+   Tcl_Obj         **objv;
+   int              rcode;
+   swig_class      *cls;
+   swig_class      *cls_stack[64];
+   int              cls_stack_bi[64];
+   int              cls_stack_top = 0;
+   int              numconf = 2;
+   int              bi;
+ 
+   objv = (Tcl_Obj **) _objv;
+   if (objc < 2) {
+     Tcl_SetResult(interp, (char *) "wrong # args.", TCL_STATIC);
+     return TCL_ERROR;
+   }
+   method = Tcl_GetStringFromObj(objv[1],NULL);
+   if (strcmp(method,"-acquire") == 0) {
+     inst->destroy = 1;
+     SWIG_Acquire(inst->thisvalue);
+     return TCL_OK;
+   }
+   if (strcmp(method,"-disown") == 0) {
+     if (inst->destroy) {
+       SWIG_Disown(inst->thisvalue);
+     }
+     inst->destroy = 0;
+     return TCL_OK;
+   }
+   if (strcmp(method,"-delete") == 0) {
+     Tcl_DeleteCommandFromToken(interp,inst->cmdtok);
+     return TCL_OK;
+   }
+   cls_stack[cls_stack_top] = inst->classptr;
+   cls_stack_bi[cls_stack_top] = -1;
+   cls = inst->classptr;
+   while (1) {
+     bi = cls_stack_bi[cls_stack_top];
+     cls = cls_stack[cls_stack_top];
+     if (bi != -1) {
+       if (!cls->bases[bi] && cls->base_names[bi]) {
+         /* lookup and cache the base class */
+ 	swig_type_info *info = SWIG_TypeQueryModule(cls->module, cls->module, cls->base_names[bi]);
+ 	if (info) cls->bases[bi] = (swig_class *) info->clientdata;
+       }
+       cls = cls->bases[bi];
+       if (cls) {
+         cls_stack_bi[cls_stack_top]++;
+         cls_stack_top++;
+         cls_stack[cls_stack_top] = cls;
+         cls_stack_bi[cls_stack_top] = -1;
+         continue;
+       }
+     }
+     if (!cls) {
+       cls_stack_top--;
+       if (cls_stack_top < 0) break;
+       else continue;
+     }
+     cls_stack_bi[cls_stack_top]++;
+ 
+     meth = cls->methods;
+     /* Check for methods */
+     while (meth && meth->name) {
+       if (strcmp(meth->name,method) == 0) {
+         oldarg = objv[1];
+         objv[1] = inst->thisptr;
+         Tcl_IncrRefCount(inst->thisptr);
+         rcode = (*meth->method)(clientData,interp,objc,objv);
+         objv[1] = oldarg;
+         Tcl_DecrRefCount(inst->thisptr);
+         return rcode;
+       }
+       meth++;
+     }
+     /* Check class methods for a match */
+     if (strcmp(method,"cget") == 0) {
+       if (objc < 3) {
+         Tcl_SetResult(interp, (char *) "wrong # args.", TCL_STATIC);
+         return TCL_ERROR;
+       }
+       attrname = Tcl_GetStringFromObj(objv[2],NULL);
+       attr = cls->attributes;
+       while (attr && attr->name) {
+         if ((strcmp(attr->name, attrname) == 0) && (attr->getmethod)) {
+           oldarg = objv[1];
+           objv[1] = inst->thisptr;
+           Tcl_IncrRefCount(inst->thisptr);
+           rcode = (*attr->getmethod)(clientData,interp,2, objv);
+           objv[1] = oldarg;
+           Tcl_DecrRefCount(inst->thisptr);
+           return rcode;
+         }
+         attr++;
+       }
+       if (strcmp(attrname, "-this") == 0) {
+         Tcl_SetObjResult(interp, Tcl_DuplicateObj(inst->thisptr));
+         return TCL_OK;
+       }
+       if (strcmp(attrname, "-thisown") == 0) {
+         if (SWIG_Thisown(inst->thisvalue)) {
+           Tcl_SetResult(interp,(char*)"1",TCL_STATIC);
+         } else {
+           Tcl_SetResult(interp,(char*)"0",TCL_STATIC);
+         }
+         return TCL_OK;
+       }
+     } else if (strcmp(method, "configure") == 0) {
+       int i;
+       if (objc < 4) {
+         Tcl_SetResult(interp, (char *) "wrong # args.", TCL_STATIC);
+         return TCL_ERROR;
+       }
+       i = 2;
+       while (i < objc) {
+         attrname = Tcl_GetStringFromObj(objv[i],NULL);
+         attr = cls->attributes;
+         while (attr && attr->name) {
+           if ((strcmp(attr->name, attrname) == 0) && (attr->setmethod)) {
+             oldarg = objv[i];
+             objv[i] = inst->thisptr;
+             Tcl_IncrRefCount(inst->thisptr);
+             rcode = (*attr->setmethod)(clientData,interp,3, &objv[i-1]);
+             objv[i] = oldarg;
+             Tcl_DecrRefCount(inst->thisptr);
+             if (rcode != TCL_OK) return rcode;
+             numconf += 2;
+           }
+           attr++;
+         }
+         i+=2;
+       }
+     }
+   }
+   if (strcmp(method,"configure") == 0) {
+     if (numconf >= objc) {
+       return TCL_OK;
+     } else {
+       Tcl_SetResult(interp,(char *) "Invalid attribute name.", TCL_STATIC);
+       return TCL_ERROR;
+     }
+   }
+   if (strcmp(method,"cget") == 0) {
+     Tcl_SetResult(interp,(char *) "Invalid attribute name.", TCL_STATIC);
+     return TCL_ERROR;
+   }
+   Tcl_SetResult(interp, (char *) "Invalid method. Must be one of: configure cget -acquire -disown -delete", TCL_STATIC);
+   cls = inst->classptr;
+   bi = 0;
+   while (cls) {
+     meth = cls->methods;
+     while (meth && meth->name) {
+       char *cr = (char *) Tcl_GetStringResult(interp);
+       size_t meth_len = strlen(meth->name);
+       char* where = strchr(cr,':');
+       while(where) {
+         where = strstr(where, meth->name);
+         if(where) {
+           if(where[-1] == ' ' && (where[meth_len] == ' ' || where[meth_len]==0)) {
+             break;
+           } else {
+             where++;
+           }
+         }
+       }
+ 
+       if (!where)
+         Tcl_AppendElement(interp, (char *) meth->name);
+       meth++;
+     }
+     cls = inst->classptr->bases[bi++];
+   }
+   return TCL_ERROR;
+ }
+ 
+ /* This function takes the current result and turns it into an object command */
+ SWIGRUNTIME Tcl_Obj *
+ SWIG_Tcl_NewInstanceObj(Tcl_Interp *interp, void *thisvalue, swig_type_info *type, int flags) {
+   Tcl_Obj *robj = SWIG_NewPointerObj(thisvalue, type,0);
+   /* Check to see if this pointer belongs to a class or not */
+   if ((type->clientdata) && (interp)) {
+     Tcl_CmdInfo    ci;
+     char          *name;
+     name = Tcl_GetStringFromObj(robj,NULL);
+     if (!Tcl_GetCommandInfo(interp,name, &ci) || (flags)) {
+       swig_instance *newinst = (swig_instance *) malloc(sizeof(swig_instance));
+       newinst->thisptr = Tcl_DuplicateObj(robj);
+       Tcl_IncrRefCount(newinst->thisptr);
+       newinst->thisvalue = thisvalue;
+       newinst->classptr = (swig_class *) type->clientdata;
+       newinst->destroy = flags;
+       newinst->cmdtok = Tcl_CreateObjCommand(interp, Tcl_GetStringFromObj(robj,NULL), (swig_wrapper_func) SWIG_MethodCommand, (ClientData) newinst, (swig_delete_func) SWIG_ObjectDelete);
+       if (flags) {
+         SWIG_Acquire(thisvalue);
+       }
+     }
+   }
+   return robj;
+ }
+ 
+ /* Function to create objects */
+ SWIGRUNTIME int
+ SWIG_Tcl_ObjectConstructor(ClientData clientData, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
+   Tcl_Obj          *newObj = 0;
+   void             *thisvalue = 0;
+   swig_instance   *newinst = 0;
+   swig_class      *classptr = (swig_class *) clientData;
+   swig_wrapper     cons = 0;
+   char             *name = 0;
+   int               firstarg = 0;
+   int               thisarg = 0;
+   int               destroy = 1;
+ 
+   if (!classptr) {
+     Tcl_SetResult(interp, (char *) "swig: internal runtime error. No class object defined.", TCL_STATIC);
+     return TCL_ERROR;
+   }
+   cons = classptr->constructor;
+   if (objc > 1) {
+     char *s = Tcl_GetStringFromObj(objv[1],NULL);
+     if (strcmp(s,"-this") == 0) {
+       thisarg = 2;
+       cons = 0;
+     } else if (strcmp(s,"-args") == 0) {
+       firstarg = 1;
+     } else if (objc == 2) {
+       firstarg = 1;
+       name = s;
+     } else if (objc >= 3) {
+       char *s1;
+       name = s;
+       s1 = Tcl_GetStringFromObj(objv[2],NULL);
+       if (strcmp(s1,"-this") == 0) {
+ 	thisarg = 3;
+ 	cons = 0;
+       } else {
+ 	firstarg = 1;
+       }
+     }
+   }
+   if (cons) {
+     int result;
+     result = (*cons)(0, interp, objc-firstarg, &objv[firstarg]);
+     if (result != TCL_OK) {
+       return result;
+     }
+     newObj = Tcl_DuplicateObj(Tcl_GetObjResult(interp));
+     if (!name) name = Tcl_GetStringFromObj(newObj,NULL);
+   } else if (thisarg > 0) {
+     if (thisarg < objc) {
+       destroy = 0;
+       newObj = Tcl_DuplicateObj(objv[thisarg]);
+       if (!name) name = Tcl_GetStringFromObj(newObj,NULL);
+     } else {
+       Tcl_SetResult(interp, (char *) "wrong # args.", TCL_STATIC);
+       return TCL_ERROR;
+     }
+   } else {
+     Tcl_SetResult(interp, (char *) "No constructor available.", TCL_STATIC);
+     return TCL_ERROR;
+   }
+   if (SWIG_Tcl_ConvertPtr(interp,newObj, (void **) &thisvalue, *(classptr->type), 0) != SWIG_OK) {
+     Tcl_DecrRefCount(newObj);
+     return TCL_ERROR;
+   }
+   newinst = (swig_instance *) malloc(sizeof(swig_instance));
+   newinst->thisptr = newObj;
+   Tcl_IncrRefCount(newObj);
+   newinst->thisvalue = thisvalue;
+   newinst->classptr = classptr;
+   newinst->destroy = destroy;
+   if (destroy) {
+     SWIG_Acquire(thisvalue);
+   }
+   newinst->cmdtok = Tcl_CreateObjCommand(interp,name, (swig_wrapper) SWIG_MethodCommand, (ClientData) newinst, (swig_delete_func) SWIG_ObjectDelete);
+   return TCL_OK;
+ }
+ 
+ /* -----------------------------------------------------------------------------*
+  *   Get arguments 
+  * -----------------------------------------------------------------------------*/
+ SWIGRUNTIME int
+ SWIG_Tcl_GetArgs(Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[], const char *fmt, ...) {
+   int        argno = 0, opt = 0;
+   long       tempi;
+   double     tempd;
+   const char *c;
+   va_list    ap;
+   void      *vptr;
+   Tcl_Obj   *obj = 0;
+   swig_type_info *ty;
+ 
+   va_start(ap,fmt);
+   for (c = fmt; (*c && (*c != ':') && (*c != ';')); c++,argno++) {
+     if (*c == '|') {
+       opt = 1;
+       c++;
+     }
+     if (argno >= (objc-1)) {
+       if (!opt) {
+         Tcl_SetResult(interp, (char *) "Wrong number of arguments ", TCL_STATIC);
+         goto argerror;
+       } else {
+         va_end(ap);
+         return TCL_OK;
+       }
+     }
+ 
+     vptr = va_arg(ap,void *);
+     if (vptr) {
+       if (isupper(*c)) {
+         obj = SWIG_Tcl_GetConstantObj(Tcl_GetStringFromObj(objv[argno+1],0));
+         if (!obj) obj = objv[argno+1];
+       } else {
+         obj = objv[argno+1];
+       }
+       switch(*c) {
+       case 'i': case 'I':
+       case 'l': case 'L':
+       case 'h': case 'H':
+       case 'b': case 'B':
+         if (Tcl_GetLongFromObj(interp,obj,&tempi) != TCL_OK) goto argerror;
+         if ((*c == 'i') || (*c == 'I')) *((int *)vptr) = (int)tempi;
+         else if ((*c == 'l') || (*c == 'L')) *((long *)vptr) = (long)tempi;
+         else if ((*c == 'h') || (*c == 'H')) *((short*)vptr) = (short)tempi;
+         else if ((*c == 'b') || (*c == 'B')) *((unsigned char *)vptr) = (unsigned char)tempi;
+         break;
+       case 'f': case 'F':
+       case 'd': case 'D':
+         if (Tcl_GetDoubleFromObj(interp,obj,&tempd) != TCL_OK) goto argerror;
+         if ((*c == 'f') || (*c == 'F')) *((float *) vptr) = (float)tempd;
+         else if ((*c == 'd') || (*c == 'D')) *((double*) vptr) = tempd;
+         break;
+       case 's': case 'S':
+         if (*(c+1) == '#') {
+           int *vlptr = (int *) va_arg(ap, void *);
+           *((char **) vptr) = Tcl_GetStringFromObj(obj, vlptr);
+           c++;
+         } else {
+           *((char **)vptr) = Tcl_GetStringFromObj(obj,NULL);
+         }
+         break;
+       case 'c': case 'C':
+         *((char *)vptr) = *(Tcl_GetStringFromObj(obj,NULL));
+         break;
+       case 'p': case 'P':
+         ty = (swig_type_info *) va_arg(ap, void *);
+         if (SWIG_Tcl_ConvertPtr(interp, obj, (void **) vptr, ty, 0) != SWIG_OK) goto argerror;
+         break;
+       case 'o': case 'O':
+         *((Tcl_Obj **)vptr) = objv[argno+1];
+         break;
+       default:
+         break;
+       }
+     }
+   }
+ 
+   if ((*c != ';') && ((objc-1) > argno)) {
+     Tcl_SetResult(interp, (char *) "Wrong # args.", TCL_STATIC);
+     goto argerror;
+   }
+   va_end(ap);
+   return TCL_OK;
+ 
+  argerror:
+   {
+     char temp[32];
+     sprintf(temp,"%d", argno+1);
+     c = strchr(fmt,':');
+     if (!c) c = strchr(fmt,';');
+     if (!c) c = (char *)"";
+     Tcl_AppendResult(interp,c," argument ", temp, NULL);
+     va_end(ap);
+     return TCL_ERROR;
+   }
+ }
+ 
+ #ifdef __cplusplus
+ #if 0
+ { /* cc-mode */
+ #endif
+ }
+ #endif
+ 
+ 
+ 
+ #define SWIG_exception_fail(code, msg) do { SWIG_Error(code, msg); SWIG_fail; } while(0) 
+ 
+ #define SWIG_contract_assert(expr, msg) if (!(expr)) { SWIG_Error(SWIG_RuntimeError, msg); SWIG_fail; } else 
+ 
+ 
+ 
+   #define SWIG_exception(code, msg) do { SWIG_Error(code, msg); return TCL_ERROR;; } while(0) 
+ 
+ 
+ /* -------- TYPES TABLE (BEGIN) -------- */
+ 
+ #define SWIGTYPE_p_CPLErrorHandler swig_types[0]
+ #define SWIGTYPE_p_CPLXMLNode swig_types[1]
+ #define SWIGTYPE_p_GByte swig_types[2]
+ #define SWIGTYPE_p_GDALColorEntry swig_types[3]
+ #define SWIGTYPE_p_GDALColorTableShadow swig_types[4]
+ #define SWIGTYPE_p_GDALDatasetShadow swig_types[5]
+ #define SWIGTYPE_p_GDALDriverShadow swig_types[6]
+ #define SWIGTYPE_p_GDALMajorObjectShadow swig_types[7]
+ #define SWIGTYPE_p_GDALProgressFunc swig_types[8]
+ #define SWIGTYPE_p_GDALRasterAttributeTableShadow swig_types[9]
+ #define SWIGTYPE_p_GDALRasterBandShadow swig_types[10]
+ #define SWIGTYPE_p_GDALTransformerInfoShadow swig_types[11]
+ #define SWIGTYPE_p_GDAL_GCP swig_types[12]
+ #define SWIGTYPE_p_OGRLayerShadow swig_types[13]
+ #define SWIGTYPE_p_char swig_types[14]
+ #define SWIGTYPE_p_double swig_types[15]
+ #define SWIGTYPE_p_f_double_p_q_const__char_p_void__int swig_types[16]
+ #define SWIGTYPE_p_int swig_types[17]
+ #define SWIGTYPE_p_p_GDALRasterBandShadow swig_types[18]
+ #define SWIGTYPE_p_p_GDAL_GCP swig_types[19]
+ #define SWIGTYPE_p_p_char swig_types[20]
+ #define SWIGTYPE_p_p_int swig_types[21]
+ static swig_type_info *swig_types[23];
+ static swig_module_info swig_module = {swig_types, 22, 0, 0, 0, 0};
+ #define SWIG_TypeQuery(name) SWIG_TypeQueryModule(&swig_module, &swig_module, name)
+ #define SWIG_MangledTypeQuery(name) SWIG_MangledTypeQueryModule(&swig_module, &swig_module, name)
+ 
+ /* -------- TYPES TABLE (END) -------- */
+ 
+ #define SWIG_init    Gdal_Init
+ #define SWIG_name    "gdal"
+ #define SWIG_prefix  "osgeo::"
+ #define SWIG_namespace "osgeo"
+ 
+ #define SWIG_version "1.0"
+ 
+ #define SWIGVERSION 0x010336 
+ #define SWIG_VERSION SWIGVERSION
+ 
+ 
+ #define SWIG_as_voidptr(a) const_cast< void * >(static_cast< const void * >(a)) 
+ #define SWIG_as_voidptrptr(a) ((void)SWIG_as_voidptr(*a),reinterpret_cast< void** >(a)) 
+ 
+ 
+ #include <stdexcept>
+ 
+ 
+ 
+ #ifdef __cplusplus
+ extern "C" {
+ #endif
+ #ifdef MAC_TCL
+ #pragma export on
+ #endif
+ SWIGEXPORT int SWIG_init(Tcl_Interp *);
+ #ifdef MAC_TCL
+ #pragma export off
+ #endif
+ #ifdef __cplusplus
+ }
+ #endif
+ 
+ 
+ 
+ #include <iostream>
+ using namespace std;
+ 
+ #include "cpl_port.h"
+ #include "cpl_string.h"
+ 
+ #include "gdal.h"
+ #include "gdal_priv.h"
+ #include "gdal_alg.h"
+ #include "gdalwarper.h"
+ 
+ typedef void GDALMajorObjectShadow;
+ typedef void GDALDriverShadow;
+ typedef void GDALDatasetShadow;
+ typedef void GDALRasterBandShadow;
+ typedef void GDALColorTableShadow;
+ typedef void GDALRasterAttributeTableShadow;
+ typedef void GDALTransformerInfoShadow;
+ 
+ typedef int FALSE_IS_ERR;
+ 
+ 
+ 
+ #include <limits.h>
+ #if !defined(SWIG_NO_LLONG_MAX)
+ # if !defined(LLONG_MAX) && defined(__GNUC__) && defined (__LONG_LONG_MAX__)
+ #   define LLONG_MAX __LONG_LONG_MAX__
+ #   define LLONG_MIN (-LLONG_MAX - 1LL)
+ #   define ULLONG_MAX (LLONG_MAX * 2ULL + 1ULL)
+ # endif
+ #endif
+ 
+ 
+ SWIGINTERN int
+ SWIG_AsVal_long SWIG_TCL_DECL_ARGS_2(Tcl_Obj *obj, long* val)
+ {
+   long v;
+   if (Tcl_GetLongFromObj(0,obj, &v) == TCL_OK) {
+     if (val) *val = (long) v;
+     return SWIG_OK;
+   }
+   return SWIG_TypeError;
+ }
+ 
+ 
+ SWIGINTERN int
+ SWIG_AsVal_int SWIG_TCL_DECL_ARGS_2(Tcl_Obj * obj, int *val)
+ {
+   long v;
+   int res = SWIG_AsVal_long SWIG_TCL_CALL_ARGS_2(obj, &v);
+   if (SWIG_IsOK(res)) {
+     if ((v < INT_MIN || v > INT_MAX)) {
+       return SWIG_OverflowError;
+     } else {
+       if (val) *val = static_cast< int >(v);
+     }
+   }  
+   return res;
+ }
+ 
+ 
+ SWIGINTERNINLINE Tcl_Obj* 
+ SWIG_From_long  (long value)
+ {
+   if (((long) INT_MIN <= value) && (value <= (long) INT_MAX)) {
+     return Tcl_NewIntObj(static_cast< int >(value));
+   } else {
+     return Tcl_NewLongObj(value);
+   }
+ }
+ 
+ 
+ SWIGINTERNINLINE Tcl_Obj *
+ SWIG_From_int  (int value)
+ {    
+   return SWIG_From_long  (value);
+ }
+ 
+ 
+ void VeryQuiteErrorHandler(CPLErr eclass, int code, const char *msg ) {
+   /* If the error class is CE_Fatal, we want to have a message issued
+      because the CPL support code does an abort() before any exception
+      can be generated */
+   if (eclass == CE_Fatal ) {
+     CPLDefaultErrorHandler(eclass, code, msg );
+   }
+ }
+ 
+ 
+ void UseExceptions() {
+   CPLSetErrorHandler( (CPLErrorHandler) VeryQuiteErrorHandler );
+ }
+ 
+ void DontUseExceptions() {
+   CPLSetErrorHandler( CPLDefaultErrorHandler );
+ }
+ 
+ 
+ 
+ typedef struct {
+     Tcl_Interp *interp;
+     Tcl_Obj *psTclCallback;
+     Tcl_Obj *psTclCallbackData;
+     int nLastReported;
+ } TclProgressData;
+ 
+ 
+ /************************************************************************/
+ /*                         TclProgressProxy()                           */
+ /************************************************************************/
+ 
+ int CPL_STDCALL
+ TclProgressProxy( double dfComplete, const char *pszMessage, void *pData )
+ {
+     TclProgressData *psInfo = (TclProgressData *) pData;
+ 
+     if( psInfo->nLastReported == (int) (100.0 * dfComplete) )
+         return TRUE;
+ 
+     if( psInfo->psTclCallback == NULL || !strcmp(Tcl_GetString(psInfo->psTclCallback), "") )
+         return TRUE;
+ 
+     psInfo->nLastReported = (int) (100.0 * dfComplete);
+ 
+     if( pszMessage == NULL )
+         pszMessage = "";
+ 
+     Tcl_Obj *objv[4];
+     objv[0] = psInfo->psTclCallback;
+     objv[1] = Tcl_NewDoubleObj(dfComplete);
+     objv[2] = Tcl_NewStringObj(pszMessage, -1);
+     objv[3] = psInfo->psTclCallbackData;
+ 
+     int psResult;
+     if( psInfo->psTclCallbackData == NULL )
+         psResult = Tcl_EvalObjv( psInfo->interp, 3, objv, TCL_EVAL_GLOBAL ); 
+     else
+         psResult = Tcl_EvalObjv( psInfo->interp, 4, objv, TCL_EVAL_GLOBAL ); 
+ 
+     Tcl_DecrRefCount(objv[1]);
+     Tcl_DecrRefCount(objv[2]);
+ 
+     if( psResult == TCL_BREAK )
+         return FALSE;
+ 
+     return TRUE;
+ }
+ 
+ 
+   void Debug( const char *msg_class, const char *message ) {
+     CPLDebug( msg_class, "%s", message );
+   }
+   void Error( CPLErr msg_class = CE_Failure, int err_code = 0, const char* msg = "error" ) {
+     CPLError( msg_class, err_code, "%s", msg );
+   }
+ 
+   CPLErr PushErrorHandler( char const * pszCallbackName = "CPLQuietErrorHandler" ) {
+     CPLErrorHandler pfnHandler = NULL;
+     if( EQUAL(pszCallbackName,"CPLQuietErrorHandler") )
+       pfnHandler = CPLQuietErrorHandler;
+     else if( EQUAL(pszCallbackName,"CPLDefaultErrorHandler") )
+       pfnHandler = CPLDefaultErrorHandler;
+     else if( EQUAL(pszCallbackName,"CPLLoggingErrorHandler") )
+       pfnHandler = CPLLoggingErrorHandler;
+ 
+     if ( pfnHandler == NULL )
+       return CE_Fatal;
+ 
+     CPLPushErrorHandler( pfnHandler );
+ 
+     return CE_None;
+   }
+ 
+ 
+ 
+ SWIGINTERN int
+ SWIG_AsCharPtrAndSize(Tcl_Obj *obj, char** cptr, size_t* psize, int *alloc)
+ { 
+   int len = 0;
+   char *cstr = Tcl_GetStringFromObj(obj, &len);
+   if (cstr) {
+     if (cptr)  *cptr = cstr;
+     if (psize) *psize = len + 1;
+     if (alloc) *alloc = SWIG_OLDOBJ;
+     return SWIG_OK;
+   }
+   return SWIG_TypeError;
+ }
+ 
+ 
+ 
+ 
+ 
+ char* EscapeString(int len, char *bin_string , int scheme=CPLES_SQL) {
+     return CPLEscapeString(bin_string, len, scheme);
+ } 
+ 
+ 
+ SWIGINTERNINLINE Tcl_Obj *
+ SWIG_FromCharPtrAndSize(const char* carray, size_t size)
+ {
+   return (size < INT_MAX) ? Tcl_NewStringObj(carray, static_cast< int >(size)) : NULL;
+ }
+ 
+ 
+ SWIGINTERNINLINE Tcl_Obj * 
+ SWIG_FromCharPtr(const char *cptr)
+ { 
+   return SWIG_FromCharPtrAndSize(cptr, (cptr ? strlen(cptr) : 0));
+ }
+ 
+ SWIGINTERN char const *GDALMajorObjectShadow_GetDescription(GDALMajorObjectShadow *self){
+     return GDALGetDescription( self );
+   }
+ SWIGINTERN void GDALMajorObjectShadow_SetDescription(GDALMajorObjectShadow *self,char const *pszNewDesc){
+     GDALSetDescription( self, pszNewDesc );
+   }
+ SWIGINTERN char **GDALMajorObjectShadow_GetMetadata_Dict(GDALMajorObjectShadow *self,char const *pszDomain=""){
+     return GDALGetMetadata( self, pszDomain );
+   }
+ SWIGINTERN char **GDALMajorObjectShadow_GetMetadata_List(GDALMajorObjectShadow *self,char const *pszDomain=""){
+     return GDALGetMetadata( self, pszDomain );
+   }
+ SWIGINTERN CPLErr GDALMajorObjectShadow_SetMetadata__SWIG_0(GDALMajorObjectShadow *self,char **papszMetadata,char const *pszDomain=""){
+     return GDALSetMetadata( self, papszMetadata, pszDomain );
+   }
+ SWIGINTERN CPLErr GDALMajorObjectShadow_SetMetadata__SWIG_1(GDALMajorObjectShadow *self,char *pszMetadataString,char const *pszDomain=""){
+     char *tmpList[2];
+     tmpList[0] = pszMetadataString;
+     tmpList[1] = 0;
+     return GDALSetMetadata( self, tmpList, pszDomain );
+   }
+ SWIGINTERN char const *GDALMajorObjectShadow_GetMetadataItem(GDALMajorObjectShadow *self,char const *pszName,char const *pszDomain=""){
+     return GDALGetMetadataItem( self, pszName, pszDomain);
+   }
+ SWIGINTERN CPLErr GDALMajorObjectShadow_SetMetadataItem(GDALMajorObjectShadow *self,char const *pszName,char const *pszValue,char const *pszDomain=""){
+     return GDALSetMetadataItem( self, pszName, pszValue, pszDomain);
+   }
+ SWIGINTERN GDALDatasetShadow *GDALDriverShadow_Create(GDALDriverShadow *self,char const *name,int xsize,int ysize,int bands=1,GDALDataType eType=GDT_Byte,char **options=0){
+ 
+     GDALDatasetShadow* ds = (GDALDatasetShadow*) GDALCreate(    self, 
+                                                                 name, 
+                                                                 xsize, 
+                                                                 ysize, 
+                                                                 bands, 
+                                                                 eType, 
+                                                                 options );
+     return ds;
+   }
+ SWIGINTERN GDALDatasetShadow *GDALDriverShadow_CreateCopy(GDALDriverShadow *self,char const *name,GDALDatasetShadow *src,int strict=1,char **options=0,GDALProgressFunc callback=NULL,void *callback_data=NULL){
+ 
+     GDALDatasetShadow *ds = (GDALDatasetShadow*) GDALCreateCopy(    self, 
+                                                                     name, 
+                                                                     src, 
+                                                                     strict, 
+                                                                     options, 
+                                                                     callback, 
+                                                                     callback_data );
+     return ds;
+   }
+ SWIGINTERN int GDALDriverShadow_Delete(GDALDriverShadow *self,char const *name){
+     return GDALDeleteDataset( self, name );
+   }
+ SWIGINTERN int GDALDriverShadow_Rename(GDALDriverShadow *self,char const *newName,char const *oldName){
+     return GDALRenameDataset( self, newName, oldName );
+   }
+ SWIGINTERN int GDALDriverShadow_Register(GDALDriverShadow *self){
+     return GDALRegisterDriver( self );
+   }
+ SWIGINTERN void GDALDriverShadow_Deregister(GDALDriverShadow *self){
+     GDALDeregisterDriver( self );
+   }
+ 
+ char const *GDALDriverShadow_ShortName_get( GDALDriverShadow *h ) {
+   return GDALGetDriverShortName( h );
+ }
+ char const *GDALDriverShadow_LongName_get( GDALDriverShadow *h ) {
+   return GDALGetDriverLongName( h );
+ }
+ char const *GDALDriverShadow_HelpTopic_get( GDALDriverShadow *h ) {
+   return GDALGetDriverHelpTopic( h );
+ }
+ 
+ 
+ SWIGINTERN int
+ SWIG_AsVal_short SWIG_TCL_DECL_ARGS_2(Tcl_Obj * obj, short *val)
+ {
+   long v;
+   int res = SWIG_AsVal_long SWIG_TCL_CALL_ARGS_2(obj, &v);
+   if (SWIG_IsOK(res)) {
+     if ((v < SHRT_MIN || v > SHRT_MAX)) {
+       return SWIG_OverflowError;
+     } else {
+       if (val) *val = static_cast< short >(v);
+     }
+   }  
+   return res;
+ }
+ 
+ 
+ SWIGINTERNINLINE Tcl_Obj *
+ SWIG_From_short  (short value)
+ {    
+   return SWIG_From_long  (value);
+ }
+ 
+ 
+ SWIGINTERN int
+ SWIG_AsVal_double SWIG_TCL_DECL_ARGS_2(Tcl_Obj *obj, double *val)
+ {
+   double v;
+   if (Tcl_GetDoubleFromObj(0, obj, &v) == TCL_OK) {
+     if (val) *val = v;
+     return SWIG_OK;
+   }
+   return SWIG_TypeError;
+ }
+ 
+ 
+   #define SWIG_From_double   Tcl_NewDoubleObj 
+ 
+ SWIGINTERN GDAL_GCP *new_GDAL_GCP(double x=0.0,double y=0.0,double z=0.0,double pixel=0.0,double line=0.0,char const *info="",char const *id=""){
+     GDAL_GCP *self = (GDAL_GCP*) CPLMalloc( sizeof( GDAL_GCP ) );
+     self->dfGCPX = x;
+     self->dfGCPY = y;
+     self->dfGCPZ = z;
+     self->dfGCPPixel = pixel;
+     self->dfGCPLine = line;
+     self->pszInfo =  CPLStrdup( (info == 0) ? "" : info );
+     self->pszId = CPLStrdup( (id==0)? "" : id );
+     return self;
+   }
+ SWIGINTERN void delete_GDAL_GCP(GDAL_GCP *self){
+     if ( self->pszInfo )
+       CPLFree( self->pszInfo );
+     if ( self->pszId )
+       CPLFree( self->pszId );
+     CPLFree( self );
+   }
+ 
+ 
+ double GDAL_GCP_GCPX_get( GDAL_GCP *h ) {
+   return h->dfGCPX;
+ }
+ void GDAL_GCP_GCPX_set( GDAL_GCP *h, double val ) {
+   h->dfGCPX = val;
+ }
+ double GDAL_GCP_GCPY_get( GDAL_GCP *h ) {
+   return h->dfGCPY;
+ }
+ void GDAL_GCP_GCPY_set( GDAL_GCP *h, double val ) {
+   h->dfGCPY = val;
+ }
+ double GDAL_GCP_GCPZ_get( GDAL_GCP *h ) {
+   return h->dfGCPZ;
+ }
+ void GDAL_GCP_GCPZ_set( GDAL_GCP *h, double val ) {
+   h->dfGCPZ = val;
+ }
+ double GDAL_GCP_GCPPixel_get( GDAL_GCP *h ) {
+   return h->dfGCPPixel;
+ }
+ void GDAL_GCP_GCPPixel_set( GDAL_GCP *h, double val ) {
+   h->dfGCPPixel = val;
+ }
+ double GDAL_GCP_GCPLine_get( GDAL_GCP *h ) {
+   return h->dfGCPLine;
+ }
+ void GDAL_GCP_GCPLine_set( GDAL_GCP *h, double val ) {
+   h->dfGCPLine = val;
+ }
+ const char * GDAL_GCP_Info_get( GDAL_GCP *h ) {
+   return h->pszInfo;
+ }
+ void GDAL_GCP_Info_set( GDAL_GCP *h, const char * val ) {
+   if ( h->pszInfo ) 
+     CPLFree( h->pszInfo );
+   h->pszInfo = CPLStrdup(val);
+ }
+ const char * GDAL_GCP_Id_get( GDAL_GCP *h ) {
+   return h->pszId;
+ }
+ void GDAL_GCP_Id_set( GDAL_GCP *h, const char * val ) {
+   if ( h->pszId ) 
+     CPLFree( h->pszId );
+   h->pszId = CPLStrdup(val);
+ }
+ 
+ 
+ 
+ /* Duplicate, but transposed names for C# because 
+ *  the C# module outputs backwards names
+ */
+ double GDAL_GCP_get_GCPX( GDAL_GCP *h ) {
+   return h->dfGCPX;
+ }
+ void GDAL_GCP_set_GCPX( GDAL_GCP *h, double val ) {
+   h->dfGCPX = val;
+ }
+ double GDAL_GCP_get_GCPY( GDAL_GCP *h ) {
+   return h->dfGCPY;
+ }
+ void GDAL_GCP_set_GCPY( GDAL_GCP *h, double val ) {
+   h->dfGCPY = val;
+ }
+ double GDAL_GCP_get_GCPZ( GDAL_GCP *h ) {
+   return h->dfGCPZ;
+ }
+ void GDAL_GCP_set_GCPZ( GDAL_GCP *h, double val ) {
+   h->dfGCPZ = val;
+ }
+ double GDAL_GCP_get_GCPPixel( GDAL_GCP *h ) {
+   return h->dfGCPPixel;
+ }
+ void GDAL_GCP_set_GCPPixel( GDAL_GCP *h, double val ) {
+   h->dfGCPPixel = val;
+ }
+ double GDAL_GCP_get_GCPLine( GDAL_GCP *h ) {
+   return h->dfGCPLine;
+ }
+ void GDAL_GCP_set_GCPLine( GDAL_GCP *h, double val ) {
+   h->dfGCPLine = val;
+ }
+ const char * GDAL_GCP_get_Info( GDAL_GCP *h ) {
+   return h->pszInfo;
+ }
+ void GDAL_GCP_set_Info( GDAL_GCP *h, const char * val ) {
+   if ( h->pszInfo ) 
+     CPLFree( h->pszInfo );
+   h->pszInfo = CPLStrdup(val);
+ }
+ const char * GDAL_GCP_get_Id( GDAL_GCP *h ) {
+   return h->pszId;
+ }
+ void GDAL_GCP_set_Id( GDAL_GCP *h, const char * val ) {
+   if ( h->pszId ) 
+     CPLFree( h->pszId );
+   h->pszId = CPLStrdup(val);
+ }
+ 
+ 
+ 
+ static Tcl_Obj*
+ CreateListFromDoubleArray(Tcl_Interp *interp, double *first, unsigned int size ) {
+   Tcl_Obj *out = Tcl_NewListObj(0, NULL);
+   for( unsigned int i=0; i<size; i++ ) {
+     Tcl_Obj *val = Tcl_NewDoubleObj( *first );
+     ++first;
+     if (Tcl_ListObjAppendElement(interp, out, val) != TCL_OK) {
+         Tcl_DecrRefCount(val);
+         Tcl_DecrRefCount(out);
+         /* Error msg in interp result */
+         return NULL; /* signifies error */
+     }
+   }
+   return out;
+ }
+ 
+ 
+ 
+ 
+ static
+ CPLErr DSReadRaster_internal( GDALDatasetShadow *obj, 
+                             int xoff, int yoff, int xsize, int ysize,
+                             int buf_xsize, int buf_ysize,
+                             GDALDataType buf_type,
+                             int *buf_size, char **buf,
+                             int band_list, int *pband_list )
+ {
+   CPLErr result;
+   *buf_size = (size_t)buf_xsize * buf_ysize * (GDALGetDataTypeSize( buf_type ) / 8) * band_list;
+   *buf = (char*) VSIMalloc3( buf_xsize, buf_ysize, (GDALGetDataTypeSize( buf_type ) / 8) * band_list );
+   if (*buf)
+   {
+     result = GDALDatasetRasterIO(obj, GF_Read, xoff, yoff, xsize, ysize,
+                                     (void*) *buf, buf_xsize, buf_ysize, buf_type,
+                                     band_list, pband_list, 0, 0, 0 );
+     if ( result != CE_None ) {
+         free( *buf );
+         *buf = 0;
+         *buf_size = 0;
+     }
+   }
+   else
+   {
+     result = CE_Failure;
+     *buf = 0;
+     *buf_size = 0;
+   }
+   return result;
+ }
+ 
+ SWIGINTERN void delete_GDALDatasetShadow(GDALDatasetShadow *self){
+     if ( GDALDereferenceDataset( self ) <= 0 ) {
+       GDALClose(self);
+     }
+   }
+ SWIGINTERN GDALDriverShadow *GDALDatasetShadow_GetDriver(GDALDatasetShadow *self){
+     return (GDALDriverShadow*) GDALGetDatasetDriver( self );
+   }
+ SWIGINTERN GDALRasterBandShadow *GDALDatasetShadow_GetRasterBand(GDALDatasetShadow *self,int nBand){
+     return (GDALRasterBandShadow*) GDALGetRasterBand( self, nBand );
+   }
+ SWIGINTERN char const *GDALDatasetShadow_GetProjection(GDALDatasetShadow *self){
+     return GDALGetProjectionRef( self );
+   }
+ SWIGINTERN char const *GDALDatasetShadow_GetProjectionRef(GDALDatasetShadow *self){
+     return GDALGetProjectionRef( self );
+   }
+ SWIGINTERN CPLErr GDALDatasetShadow_SetProjection(GDALDatasetShadow *self,char const *prj){
+     return GDALSetProjection( self, prj );
+   }
+ SWIGINTERN void GDALDatasetShadow_GetGeoTransform(GDALDatasetShadow *self,double argout[6]){
+     if ( GDALGetGeoTransform( self, argout ) != 0 ) {
+       argout[0] = 0.0;
+       argout[1] = 1.0;
+       argout[2] = 0.0;
+       argout[3] = 0.0;
+       argout[4] = 0.0;
+       argout[5] = 1.0;
+     }
+   }
+ SWIGINTERN CPLErr GDALDatasetShadow_SetGeoTransform(GDALDatasetShadow *self,double argin[6]){
+     return GDALSetGeoTransform( self, argin );
+   }
+ SWIGINTERN int GDALDatasetShadow_BuildOverviews(GDALDatasetShadow *self,char const *resampling="NEAREST",int overviewlist=0,int *pOverviews=0,GDALProgressFunc callback=NULL,void *callback_data=NULL){
+                       
+     return GDALBuildOverviews(  self, 
+                                 resampling, 
+                                 overviewlist, 
+                                 pOverviews, 
+                                 0, 
+                                 0, 
+                                 callback, 
+                                 callback_data);
+   }
+ SWIGINTERN int GDALDatasetShadow_GetGCPCount(GDALDatasetShadow *self){
+     return GDALGetGCPCount( self );
+   }
+ SWIGINTERN char const *GDALDatasetShadow_GetGCPProjection(GDALDatasetShadow *self){
+     return GDALGetGCPProjection( self );
+   }
+ SWIGINTERN void GDALDatasetShadow_GetGCPs(GDALDatasetShadow *self,int *nGCPs,GDAL_GCP const **pGCPs){
+     *nGCPs = GDALGetGCPCount( self );
+     *pGCPs = GDALGetGCPs( self );
+   }
+ SWIGINTERN CPLErr GDALDatasetShadow_SetGCPs(GDALDatasetShadow *self,int nGCPs,GDAL_GCP const *pGCPs,char const *pszGCPProjection){
+     return GDALSetGCPs( self, nGCPs, pGCPs, pszGCPProjection );
+   }
+ SWIGINTERN void GDALDatasetShadow_FlushCache(GDALDatasetShadow *self){
+     GDALFlushCache( self );
+   }
+ SWIGINTERN CPLErr GDALDatasetShadow_AddBand(GDALDatasetShadow *self,GDALDataType datatype=GDT_Byte,char **options=0){
+     return GDALAddBand( self, datatype, options );
+   }
+ SWIGINTERN CPLErr GDALDatasetShadow_CreateMaskBand(GDALDatasetShadow *self,int nFlags){
+       return GDALCreateDatasetMaskBand( self, nFlags );
+   }
+ SWIGINTERN char **GDALDatasetShadow_GetFileList(GDALDatasetShadow *self){
+     return GDALGetFileList( self );
+   }
+ SWIGINTERN CPLErr GDALDatasetShadow_WriteRaster(GDALDatasetShadow *self,int xoff,int yoff,int xsize,int ysize,int buf_len,char *buf_string,int *buf_xsize=0,int *buf_ysize=0,GDALDataType *buf_type=0,int band_list=0,int *pband_list=0){
+     int nxsize = (buf_xsize==0) ? xsize : *buf_xsize;
+     int nysize = (buf_ysize==0) ? ysize : *buf_ysize;
+     GDALDataType ntype;
+     if ( buf_type != 0 ) {
+       ntype = (GDALDataType) *buf_type;
+     } else {
+       int lastband = GDALGetRasterCount( self ) - 1;
+       ntype = GDALGetRasterDataType( GDALGetRasterBand( self, lastband ) );
+     }
+     bool myBandList = false;
+     int nBandCount;
+     int *pBandList;
+     if ( band_list != 0 ) {
+       myBandList = false;
+       nBandCount = band_list;
+       pBandList = pband_list;
+     }
+     else {
+       myBandList = true;
+       nBandCount = GDALGetRasterCount( self );
+       pBandList = (int*) CPLMalloc( sizeof(int) * nBandCount );
+       for( int i = 0; i< nBandCount; ++i ) {
+         pBandList[i] = i;
+       }
+     }
+     return GDALDatasetRasterIO( self, GF_Write, xoff, yoff, xsize, ysize,
+                                 (void*) buf_string, nxsize, nysize, ntype,
+                                 band_list, pband_list, 0, 0, 0 );
+     if ( myBandList ) {
+        CPLFree( pBandList );
+     }
+   }
+ SWIGINTERN CPLErr GDALDatasetShadow_ReadRaster(GDALDatasetShadow *self,int xoff,int yoff,int xsize,int ysize,int *buf_len,char **buf,int *buf_xsize=0,int *buf_ysize=0,GDALDataType *buf_type=0,int band_list=0,int *pband_list=0){
+ 
+     int nxsize = (buf_xsize==0) ? xsize : *buf_xsize;
+     int nysize = (buf_ysize==0) ? ysize : *buf_ysize;
+     GDALDataType ntype;
+     if ( buf_type != 0 ) {
+       ntype = (GDALDataType) *buf_type;
+     } else {
+       int lastband = GDALGetRasterCount( self ) - 1;
+       ntype = GDALGetRasterDataType( GDALGetRasterBand( self, lastband ) );
+     }
+     bool myBandList = false;
+     int nBandCount;
+     int *pBandList;
+     if ( band_list != 0 ) {
+       myBandList = false;
+       nBandCount = band_list;
+       pBandList = pband_list;
+     }
+     else {
+       myBandList = true;
+       nBandCount = GDALGetRasterCount( self );
+       pBandList = (int*) CPLMalloc( sizeof(int) * nBandCount );
+       for( int i = 0; i< nBandCount; ++i ) {
+         pBandList[i] = i;
+       }
+     }
+                             
+     return DSReadRaster_internal( self, xoff, yoff, xsize, ysize,
+                                 nxsize, nysize, ntype,
+                                 buf_len, buf, 
+                                 nBandCount, pBandList);
+     if ( myBandList ) {
+        CPLFree( pBandList );
+     }
+ 
+ }
+ 
+ int GDALDatasetShadow_RasterXSize_get( GDALDatasetShadow *h ) {
+   return GDALGetRasterXSize( h );
+ }
+ int GDALDatasetShadow_RasterYSize_get( GDALDatasetShadow *h ) {
+   return GDALGetRasterYSize( h );
+ }
+ int GDALDatasetShadow_RasterCount_get( GDALDatasetShadow *h ) {
+   return GDALGetRasterCount( h );
+ }
+ 
+ 
+ static
+ CPLErr ReadRaster_internal( GDALRasterBandShadow *obj, 
+                             int xoff, int yoff, int xsize, int ysize,
+                             int buf_xsize, int buf_ysize,
+                             GDALDataType buf_type,
+                             int *buf_size, char **buf )
+ {
+   CPLErr result;
+   *buf_size = (size_t)buf_xsize * buf_ysize * (GDALGetDataTypeSize( buf_type ) / 8);
+   *buf = (char*) VSIMalloc3( buf_xsize, buf_ysize, GDALGetDataTypeSize( buf_type ) / 8 );
+   if (*buf)
+   {
+     result =  GDALRasterIO( obj, GF_Read, xoff, yoff, xsize, ysize,
+                                     (void *) *buf, buf_xsize, buf_ysize,
+                                     buf_type, 0, 0 );
+     if ( result != CE_None ) {
+         free( *buf );
+         *buf = 0;
+         *buf_size = 0;
+     }
+   }
+   else
+   {
+     result = CE_Failure;
+     *buf = 0;
+     *buf_size = 0;
+   }
+   return result;
+ }
+ 
+ static
+ CPLErr WriteRaster_internal( GDALRasterBandShadow *obj,
+                              int xoff, int yoff, int xsize, int ysize,
+                              int buf_xsize, int buf_ysize,
+                              GDALDataType buf_type,
+                              int buf_size, char *buffer )
+ {
+     if ( buf_size < buf_xsize * buf_ysize * GDALGetDataTypeSize( buf_type) /8 ) {
+       return CE_Failure;
+     }
+ 
+     return GDALRasterIO( obj, GF_Write, xoff, yoff, xsize, ysize, 
+ 		        (void *) buffer, buf_xsize, buf_ysize, buf_type, 0, 0 );
+ }
+ 
+ SWIGINTERN void GDALRasterBandShadow_GetBlockSize(GDALRasterBandShadow *self,int *pnBlockXSize,int *pnBlockYSize){
+       GDALGetBlockSize(self, pnBlockXSize, pnBlockYSize);
+   }
+ SWIGINTERN GDALColorInterp GDALRasterBandShadow_GetRasterColorInterpretation(GDALRasterBandShadow *self){
+     return GDALGetRasterColorInterpretation( self );
+   }
+ SWIGINTERN CPLErr GDALRasterBandShadow_SetRasterColorInterpretation(GDALRasterBandShadow *self,GDALColorInterp val){
+     return GDALSetRasterColorInterpretation( self, val );
+   }
+ SWIGINTERN void GDALRasterBandShadow_GetNoDataValue(GDALRasterBandShadow *self,double *val,int *hasval){
+     *val = GDALGetRasterNoDataValue( self, hasval );
+   }
+ SWIGINTERN CPLErr GDALRasterBandShadow_SetNoDataValue(GDALRasterBandShadow *self,double d){
+     return GDALSetRasterNoDataValue( self, d );
+   }
+ SWIGINTERN char **GDALRasterBandShadow_GetRasterCategoryNames(GDALRasterBandShadow *self){
+     return GDALGetRasterCategoryNames( self );
+   }
+ SWIGINTERN CPLErr GDALRasterBandShadow_SetRasterCategoryNames(GDALRasterBandShadow *self,char **names){
+     return GDALSetRasterCategoryNames( self, names );
+   }
+ SWIGINTERN void GDALRasterBandShadow_GetMinimum(GDALRasterBandShadow *self,double *val,int *hasval){
+     *val = GDALGetRasterMinimum( self, hasval );
+   }
+ SWIGINTERN void GDALRasterBandShadow_GetMaximum(GDALRasterBandShadow *self,double *val,int *hasval){
+     *val = GDALGetRasterMaximum( self, hasval );
+   }
+ SWIGINTERN void GDALRasterBandShadow_GetOffset(GDALRasterBandShadow *self,double *val,int *hasval){
+     *val = GDALGetRasterOffset( self, hasval );
+   }
+ SWIGINTERN void GDALRasterBandShadow_GetScale(GDALRasterBandShadow *self,double *val,int *hasval){
+     *val = GDALGetRasterScale( self, hasval );
+   }
+ SWIGINTERN CPLErr GDALRasterBandShadow_GetStatistics(GDALRasterBandShadow *self,int approx_ok,int force,double *min,double *max,double *mean,double *stddev){
+     return GDALGetRasterStatistics( self, approx_ok, force, 
+ 				    min, max, mean, stddev );
+   }
+ SWIGINTERN CPLErr GDALRasterBandShadow_SetStatistics(GDALRasterBandShadow *self,double min,double max,double mean,double stddev){
+     return GDALSetRasterStatistics( self, min, max, mean, stddev );
+   }
+ SWIGINTERN int GDALRasterBandShadow_GetOverviewCount(GDALRasterBandShadow *self){
+     return GDALGetOverviewCount( self );
+   }
+ SWIGINTERN GDALRasterBandShadow *GDALRasterBandShadow_GetOverview(GDALRasterBandShadow *self,int i){
+     return (GDALRasterBandShadow*) GDALGetOverview( self, i );
+   }
+ SWIGINTERN int GDALRasterBandShadow_Checksum(GDALRasterBandShadow *self,int xoff=0,int yoff=0,int *xsize=0,int *ysize=0){
+     int nxsize = (xsize!=0) ? *xsize : GDALGetRasterBandXSize( self );
+     int nysize = (ysize!=0) ? *ysize : GDALGetRasterBandYSize( self );
+     return GDALChecksumImage( self, xoff, yoff, nxsize, nysize );
+   }
+ SWIGINTERN void GDALRasterBandShadow_ComputeRasterMinMax(GDALRasterBandShadow *self,double argout[2],int approx_ok=0){
+     GDALComputeRasterMinMax( self, approx_ok, argout );
+   }
+ SWIGINTERN void GDALRasterBandShadow_ComputeBandStats(GDALRasterBandShadow *self,double argout[2],int samplestep=1){
+     GDALComputeBandStats( self, samplestep, argout+0, argout+1, 
+                           NULL, NULL );
+   }
+ SWIGINTERN CPLErr GDALRasterBandShadow_Fill(GDALRasterBandShadow *self,double real_fill,double imag_fill=0.0){
+     return GDALFillRaster( self, real_fill, imag_fill );
+   }
+ SWIGINTERN CPLErr GDALRasterBandShadow_ReadRaster(GDALRasterBandShadow *self,int xoff,int yoff,int xsize,int ysize,int *buf_len,char **buf,int *buf_xsize=0,int *buf_ysize=0,int *buf_type=0){
+     int nxsize = (buf_xsize==0) ? xsize : *buf_xsize;
+     int nysize = (buf_ysize==0) ? ysize : *buf_ysize;
+     GDALDataType ntype  = (buf_type==0) ? GDALGetRasterDataType(self)
+                                         : (GDALDataType)*buf_type;
+     return ReadRaster_internal( self, xoff, yoff, xsize, ysize,
+                                 nxsize, nysize, ntype, buf_len, buf );
+   }
+ SWIGINTERN CPLErr GDALRasterBandShadow_WriteRaster(GDALRasterBandShadow *self,int xoff,int yoff,int xsize,int ysize,int buf_len,char *buf_string,int *buf_xsize=0,int *buf_ysize=0,int *buf_type=0){
+     int nxsize = (buf_xsize==0) ? xsize : *buf_xsize;
+     int nysize = (buf_ysize==0) ? ysize : *buf_ysize;
+     GDALDataType ntype  = (buf_type==0) ? GDALGetRasterDataType(self)
+                                         : (GDALDataType)*buf_type;
+     return WriteRaster_internal( self, xoff, yoff, xsize, ysize,
+                                  nxsize, nysize, ntype, buf_len, buf_string );
+   }
+ SWIGINTERN void GDALRasterBandShadow_FlushCache(GDALRasterBandShadow *self){
+     GDALFlushRasterCache( self );
+   }
+ SWIGINTERN GDALColorTableShadow *GDALRasterBandShadow_GetRasterColorTable(GDALRasterBandShadow *self){
+     return (GDALColorTableShadow*) GDALGetRasterColorTable( self );
+   }
+ SWIGINTERN GDALColorTableShadow *GDALRasterBandShadow_GetColorTable(GDALRasterBandShadow *self){
+     return (GDALColorTableShadow*) GDALGetRasterColorTable( self );
+   }
+ SWIGINTERN int GDALRasterBandShadow_SetRasterColorTable(GDALRasterBandShadow *self,GDALColorTableShadow *arg){
+     return GDALSetRasterColorTable( self, arg );
+   }
+ SWIGINTERN int GDALRasterBandShadow_SetColorTable(GDALRasterBandShadow *self,GDALColorTableShadow *arg){
+     return GDALSetRasterColorTable( self, arg );
+   }
+ SWIGINTERN GDALRasterAttributeTableShadow *GDALRasterBandShadow_GetDefaultRAT(GDALRasterBandShadow *self){ 
+       return (GDALRasterAttributeTableShadow*) GDALGetDefaultRAT(self);
+   }
+ SWIGINTERN int GDALRasterBandShadow_SetDefaultRAT(GDALRasterBandShadow *self,GDALRasterAttributeTableShadow *table){
+       return GDALSetDefaultRAT(self, table);
+   }
+ SWIGINTERN GDALRasterBandShadow *GDALRasterBandShadow_GetMaskBand(GDALRasterBandShadow *self){
+       return (GDALRasterBandShadow *) GDALGetMaskBand( self );
+   }
+ SWIGINTERN int GDALRasterBandShadow_GetMaskFlags(GDALRasterBandShadow *self){
+       return GDALGetMaskFlags( self );
+   }
+ SWIGINTERN CPLErr GDALRasterBandShadow_CreateMaskBand(GDALRasterBandShadow *self,int nFlags){
+       return GDALCreateMaskBand( self, nFlags );
+   }
+ SWIGINTERN CPLErr GDALRasterBandShadow_GetHistogram(GDALRasterBandShadow *self,double min=-0.5,double max=255.5,int buckets=256,int *panHistogram=NULL,int include_out_of_range=0,int approx_ok=1,GDALProgressFunc callback=NULL,void *callback_data=NULL){
+     CPLErrorReset(); 
+     CPLErr err = GDALGetRasterHistogram( self, min, max, buckets, panHistogram,
+                                          include_out_of_range, approx_ok,
+                                          callback, callback_data );
+     return err;
+   }
+ SWIGINTERN CPLErr GDALRasterBandShadow_GetDefaultHistogram(GDALRasterBandShadow *self,double *min_ret=NULL,double *max_ret=NULL,int *buckets_ret=NULL,int **ppanHistogram=NULL,int force=1,GDALProgressFunc callback=NULL,void *callback_data=NULL){
+     return GDALGetDefaultHistogram( self, min_ret, max_ret, buckets_ret,
+                                     ppanHistogram, force, 
+                                     callback, callback_data );
+ }
+ SWIGINTERN CPLErr GDALRasterBandShadow_SetDefaultHistogram(GDALRasterBandShadow *self,double min,double max,int buckets_in,int *panHistogram_in){
+     return GDALSetDefaultHistogram( self, min, max, 
+     	   			    buckets_in, panHistogram_in );
+ }
+ 
+ GDALDataType GDALRasterBandShadow_DataType_get( GDALRasterBandShadow *h ) {
+   return GDALGetRasterDataType( h );
+ }
+ int GDALRasterBandShadow_XSize_get( GDALRasterBandShadow *h ) {
+   return GDALGetRasterBandXSize( h );
+ }
+ int GDALRasterBandShadow_YSize_get( GDALRasterBandShadow *h ) {
+   return GDALGetRasterBandYSize( h );
+ }
+ 
+ SWIGINTERN GDALColorTableShadow *new_GDALColorTableShadow(GDALPaletteInterp palette=GPI_RGB){
+         return (GDALColorTableShadow*) GDALCreateColorTable(palette);
+     }
+ SWIGINTERN void delete_GDALColorTableShadow(GDALColorTableShadow *self){
+         GDALDestroyColorTable(self);
+     }
+ SWIGINTERN GDALColorTableShadow *GDALColorTableShadow_Clone(GDALColorTableShadow *self){
+         return (GDALColorTableShadow*) GDALCloneColorTable (self);
+     }
+ SWIGINTERN GDALPaletteInterp GDALColorTableShadow_GetPaletteInterpretation(GDALColorTableShadow *self){
+         return GDALGetPaletteInterpretation(self);
+     }
+ SWIGINTERN int GDALColorTableShadow_GetColorEntryCount(GDALColorTableShadow *self){
+         return GDALGetColorEntryCount(self);
+     }
+ SWIGINTERN GDALColorEntry *GDALColorTableShadow_GetColorEntry(GDALColorTableShadow *self,int entry){
+         return (GDALColorEntry*) GDALGetColorEntry(self, entry);
+     }
+ SWIGINTERN int GDALColorTableShadow_GetColorEntryAsRGB(GDALColorTableShadow *self,int entry,GDALColorEntry *centry){
+         return GDALGetColorEntryAsRGB(self, entry, centry);
+     }
+ SWIGINTERN void GDALColorTableShadow_SetColorEntry(GDALColorTableShadow *self,int entry,GDALColorEntry const *centry){
+         GDALSetColorEntry(self, entry, centry);
+     }
+ SWIGINTERN void GDALColorTableShadow_CreateColorRamp(GDALColorTableShadow *self,int nStartIndex,GDALColorEntry const *startcolor,int nEndIndex,GDALColorEntry const *endcolor){
+         GDALCreateColorRamp(self, nStartIndex, startcolor, nEndIndex, endcolor);
+     }
+ SWIGINTERN GDALRasterAttributeTableShadow *new_GDALRasterAttributeTableShadow(){
+         return (GDALRasterAttributeTableShadow*) 
+ 		GDALCreateRasterAttributeTable();
+     }
+ SWIGINTERN void delete_GDALRasterAttributeTableShadow(GDALRasterAttributeTableShadow *self){
+         GDALDestroyRasterAttributeTable(self);
+     }
+ SWIGINTERN GDALRasterAttributeTableShadow *GDALRasterAttributeTableShadow_Clone(GDALRasterAttributeTableShadow *self){
+         return (GDALRasterAttributeTableShadow*) GDALRATClone(self);
+     }
+ SWIGINTERN int GDALRasterAttributeTableShadow_GetColumnCount(GDALRasterAttributeTableShadow *self){ 
+         return GDALRATGetColumnCount( self );
+     }
+ SWIGINTERN char const *GDALRasterAttributeTableShadow_GetNameOfCol(GDALRasterAttributeTableShadow *self,int iCol){ 
+         return GDALRATGetNameOfCol( self, iCol );
+     }
+ SWIGINTERN GDALRATFieldUsage GDALRasterAttributeTableShadow_GetUsageOfCol(GDALRasterAttributeTableShadow *self,int iCol){
+         return GDALRATGetUsageOfCol( self, iCol );
+     }
+ SWIGINTERN GDALRATFieldType GDALRasterAttributeTableShadow_GetTypeOfCol(GDALRasterAttributeTableShadow *self,int iCol){
+         return GDALRATGetTypeOfCol( self, iCol );
+     }
+ SWIGINTERN int GDALRasterAttributeTableShadow_GetColOfUsage(GDALRasterAttributeTableShadow *self,GDALRATFieldUsage eUsage){
+         return GDALRATGetColOfUsage( self, eUsage );
+     }
+ SWIGINTERN int GDALRasterAttributeTableShadow_GetRowCount(GDALRasterAttributeTableShadow *self){ 
+         return GDALRATGetRowCount( self );
+     }
+ SWIGINTERN char const *GDALRasterAttributeTableShadow_GetValueAsString(GDALRasterAttributeTableShadow *self,int iRow,int iCol){ 
+         return GDALRATGetValueAsString( self, iRow, iCol );
+     }
+ SWIGINTERN int GDALRasterAttributeTableShadow_GetValueAsInt(GDALRasterAttributeTableShadow *self,int iRow,int iCol){ 
+         return GDALRATGetValueAsInt( self, iRow, iCol );
+     }
+ SWIGINTERN double GDALRasterAttributeTableShadow_GetValueAsDouble(GDALRasterAttributeTableShadow *self,int iRow,int iCol){ 
+         return GDALRATGetValueAsDouble( self, iRow, iCol );
+     }
+ SWIGINTERN void GDALRasterAttributeTableShadow_SetValueAsString(GDALRasterAttributeTableShadow *self,int iRow,int iCol,char const *pszValue){ 
+         GDALRATSetValueAsString( self, iRow, iCol, pszValue );
+     }
+ SWIGINTERN void GDALRasterAttributeTableShadow_SetValueAsInt(GDALRasterAttributeTableShadow *self,int iRow,int iCol,int nValue){ 
+         GDALRATSetValueAsInt( self, iRow, iCol, nValue );
+     }
+ SWIGINTERN void GDALRasterAttributeTableShadow_SetValueAsDouble(GDALRasterAttributeTableShadow *self,int iRow,int iCol,double dfValue){ 
+         GDALRATSetValueAsDouble( self, iRow, iCol, dfValue );
+     }
+ SWIGINTERN void GDALRasterAttributeTableShadow_SetRowCount(GDALRasterAttributeTableShadow *self,int nCount){
+         GDALRATSetRowCount( self, nCount );
+     }
+ SWIGINTERN int GDALRasterAttributeTableShadow_CreateColumn(GDALRasterAttributeTableShadow *self,char const *pszName,GDALRATFieldType eType,GDALRATFieldUsage eUsage){
+         return GDALRATCreateColumn( self, pszName, eType, eUsage );
+     }
+ SWIGINTERN int GDALRasterAttributeTableShadow_GetRowOfValue(GDALRasterAttributeTableShadow *self,double dfValue){
+         return GDALRATGetRowOfValue( self, dfValue );
+     }
+ 
+ #ifdef DEBUG 
+ typedef struct OGRLayerHS OGRLayerShadow;
+ typedef struct OGRGeometryHS OGRGeometryShadow;
+ #else
+ typedef void OGRLayerShadow;
+ typedef void OGRGeometryShadow;
+ #endif
+ 
+ 
+ int GDALTermProgress_nocb( double dfProgress, const char * pszMessage=NULL, void *pData=NULL ) {
+   return GDALTermProgress( dfProgress, pszMessage, pData);
+ }
+ 
+ 
+ int  ComputeMedianCutPCT ( GDALRasterBandShadow *red,
+                               GDALRasterBandShadow *green,
+                               GDALRasterBandShadow *blue,
+                               int num_colors,
+                               GDALColorTableShadow* colors,
+                               GDALProgressFunc callback = NULL,
+                               void* callback_data=NULL) {
+ 
+     CPLErrorReset();
+ 
+     int err = GDALComputeMedianCutPCT( red,
+                                           green,
+                                           blue,
+                                           NULL,
+                                           num_colors,
+                                           colors,
+                                           callback,
+                                           callback_data);
+     
+     return err;
+ }
+ 
+ 
+ int  DitherRGB2PCT ( GDALRasterBandShadow *red,
+                      GDALRasterBandShadow *green,
+                      GDALRasterBandShadow *blue,
+                      GDALRasterBandShadow *target,
+                      GDALColorTableShadow *colors,
+                      GDALProgressFunc callback = NULL,
+                      void* callback_data=NULL) {
+ 
+     CPLErrorReset();
+     int err;
+     err = GDALDitherRGB2PCT(  red,
+                                   green,
+                                   blue,
+                                   target,
+                                   colors,
+                                   callback,
+                                   callback_data);
+     
+     return err;
+ }
+ 
+ 
+ CPLErr  ReprojectImage ( GDALDatasetShadow *src_ds,
+                          GDALDatasetShadow *dst_ds,
+                          const char *src_wkt=NULL,
+                          const char *dst_wkt=NULL,
+                          GDALResampleAlg eResampleAlg=GRA_NearestNeighbour,
+                          double WarpMemoryLimit=0.0,
+                          double maxerror = 0.0,
+ 			 GDALProgressFunc callback = NULL,
+                      	 void* callback_data=NULL) {
+ 
+     CPLErrorReset();
+ 
+     CPLErr err = GDALReprojectImage( src_ds,
+                                      src_wkt,
+                                      dst_ds,
+                                      dst_wkt,
+                                      eResampleAlg,
+                                      WarpMemoryLimit,
+                                      maxerror,
+                                      callback,
+                                      callback_data,
+                                      NULL);
+     
+     return err;
+ }
+ 
+ 
+ int  ComputeProximity( GDALRasterBandShadow *srcBand,
+                        GDALRasterBandShadow *proximityBand,
+                        char **options = NULL,
+                        GDALProgressFunc callback=NULL,
+                        void* callback_data=NULL) {
+ 
+     CPLErrorReset();
+ 
+     return GDALComputeProximity( srcBand, proximityBand, options,
+                                  callback, callback_data );
+ }
+ 
+ 
+ int  RasterizeLayer( GDALDatasetShadow *dataset,
+                  int bands, int *band_list,
+                  OGRLayerShadow *layer,
+                  void *pfnTransformer = NULL,
+                  void *pTransformArg = NULL, 
+ 		 int burn_values = 0, double *burn_values_list = NULL, 
+                  char **options = NULL,
+                  GDALProgressFunc callback=NULL,
+                  void* callback_data=NULL) {
+ 
+     CPLErr eErr;
+ 
+     CPLErrorReset();
+ 
+     if( burn_values == 0 )
+     {
+         burn_values_list = (double *) CPLMalloc(sizeof(double)*bands);
+         for( int i = 0; i < bands; i++ )
+             burn_values_list[i] = 255.0;
+     }
+     else if( burn_values != bands )
+     {
+         CPLError( CE_Failure, CPLE_AppDefined, 
+                   "Did not get the expected number of burn values in RasterizeLayer()" );
+         return CE_Failure;
+     }
+ 
+     eErr = GDALRasterizeLayers( dataset, bands, band_list,
+                                 1, &layer, 
+                                 (GDALTransformerFunc) pfnTransformer, 
+                                 pTransformArg,
+                                 burn_values_list, options, 
+                                 callback, callback_data );
+ 
+     if( burn_values == 0 )
+         CPLFree( burn_values_list );
+ 
+     return eErr;
+ }
+ 
+ 
+ int  Polygonize( GDALRasterBandShadow *srcBand,
+      		 GDALRasterBandShadow *maskBand,
+   	         OGRLayerShadow *outLayer, 
+                  int iPixValField,
+                  char **options = NULL,
+                  GDALProgressFunc callback=NULL,
+                  void* callback_data=NULL) {
+ 
+     CPLErrorReset();
+ 
+     return GDALPolygonize( srcBand, maskBand, outLayer, iPixValField,
+                            options, callback, callback_data );
+ }
+ 
+ 
+ int  SieveFilter( GDALRasterBandShadow *srcBand,
+      		  GDALRasterBandShadow *maskBand,
+   	          GDALRasterBandShadow *dstBand,
+                   int threshold, int connectedness=4,
+                   char **options = NULL,
+                   GDALProgressFunc callback=NULL,
+                   void* callback_data=NULL) {
+ 
+     CPLErrorReset();
+ 
+     return GDALSieveFilter( srcBand, maskBand, dstBand, 
+                             threshold, connectedness,
+                             options, callback, callback_data );
+ }
+ 
+ 
+ int  RegenerateOverviews( GDALRasterBandShadow *srcBand,
+      			  int overviewBandCount,
+                           GDALRasterBandShadow **overviewBands,
+                           char *resampling = "average",
+                           GDALProgressFunc callback=NULL,
+                           void* callback_data=NULL) {
+ 
+     CPLErrorReset();
+ 
+     return GDALRegenerateOverviews( srcBand, overviewBandCount, overviewBands,
+     	   			    resampling, callback, callback_data );
+ }
+ 
+ 
+ int  RegenerateOverview( GDALRasterBandShadow *srcBand,
+                           GDALRasterBandShadow *overviewBand,
+                           char *resampling,
+                           GDALProgressFunc callback=NULL,
+                           void* callback_data=NULL) {
+ 
+     CPLErrorReset();
+ 
+     return GDALRegenerateOverviews( srcBand, 1, &overviewBand,
+     	   			    resampling, callback, callback_data );
+ }
+ 
+ 
+ GDALDatasetShadow *AutoCreateWarpedVRT( GDALDatasetShadow *src_ds,
+                                         const char *src_wkt = 0,
+                                         const char *dst_wkt = 0,
+                                         GDALResampleAlg eResampleAlg = GRA_NearestNeighbour,
+                                         double maxerror = 0.0 ) {
+   GDALDatasetShadow *ds = GDALAutoCreateWarpedVRT( src_ds, src_wkt,
+                                                    dst_wkt,
+                                                    eResampleAlg,
+                                                    maxerror,
+                                                    0 );
+   if (ds == 0) {
+     /*throw CPLGetLastErrorMsg(); causes a SWIG_exception later*/
+   }
+   return ds;
+   
+ }
+ 
+ SWIGINTERN GDALTransformerInfoShadow *new_GDALTransformerInfoShadow(GDALDatasetShadow *src,GDALDatasetShadow *dst,char **options){
+     GDALTransformerInfoShadow *obj = (GDALTransformerInfoShadow*) 
+        GDALCreateGenImgProjTransformer2( (GDALDatasetH)src, (GDALDatasetH)dst, 
+                                          options );
+     return obj;
+   }
+ SWIGINTERN void delete_GDALTransformerInfoShadow(GDALTransformerInfoShadow *self){
+     GDALDestroyTransformer( self );
+   }
+ SWIGINTERN int GDALTransformerInfoShadow_TransformPoint__SWIG_0(GDALTransformerInfoShadow *self,int bDstToSrc,double inout[3]){
+     int nRet, nSuccess = TRUE;
+ 
+     nRet = GDALUseTransformer( self, bDstToSrc, 
+                                1, &inout[0], &inout[1], &inout[2], 
+                                &nSuccess );
+ 
+     return nRet && nSuccess;
+   }
+ SWIGINTERN int GDALTransformerInfoShadow_TransformPoint__SWIG_1(GDALTransformerInfoShadow *self,double argout[3],int bDstToSrc,double x,double y,double z=0.0){
+     int nRet, nSuccess = TRUE;
+     
+     argout[0] = x;
+     argout[1] = y;
+     argout[2] = z;
+     nRet = GDALUseTransformer( self, bDstToSrc, 
+                                1, &argout[0], &argout[1], &argout[2], 
+                                &nSuccess );
+ 
+     return nRet && nSuccess;
+   }
+ SWIGINTERN int GDALTransformerInfoShadow_TransformPoints(GDALTransformerInfoShadow *self,int bDstToSrc,int nCount,double *x,double *y,double *z,int *panSuccess){
+     int nRet;
+ 
+     nRet = GDALUseTransformer( self, bDstToSrc, nCount, x, y, z, panSuccess );
+ 
+     return nRet;
+   }
+ 
+ /************************************************************************/
+ /*                          XMLTreeToTclList()                           */
+ /************************************************************************/
+ static Tcl_Obj *XMLTreeToTclList( Tcl_Interp *interp, CPLXMLNode *psTree )
+ {
+     Tcl_Obj *tclList;
+     int      nChildCount = 0, iChild;
+     CPLXMLNode *psChild;
+ 
+     for( psChild = psTree->psChild; 
+          psChild != NULL; 
+          psChild = psChild->psNext )
+         nChildCount++;
+ 
+     tclList = Tcl_NewListObj(0, NULL);
+     if (Tcl_ListObjAppendElement(interp, tclList, Tcl_NewIntObj((int) psTree->eType)) != TCL_OK) {
+         Tcl_DecrRefCount(tclList);
+         /* Error msg in interp result */
+         return NULL; /* signifies error */
+     }
+     if (Tcl_ListObjAppendElement(interp, tclList, Tcl_NewStringObj(psTree->pszValue, -1)) != TCL_OK) {
+         Tcl_DecrRefCount(tclList);
+         /* Error msg in interp result */
+         return NULL; /* signifies error */
+     }
+ 
+     for( psChild = psTree->psChild, iChild = 2; 
+          psChild != NULL; 
+          psChild = psChild->psNext, iChild++ )
+     {
+         if (Tcl_ListObjAppendElement(interp, tclList, XMLTreeToTclList( interp, psChild )) != TCL_OK) {
+             Tcl_DecrRefCount(tclList);
+             /* Error msg in interp result */
+             return NULL; /* signifies error */
+         }
+     }
+ 
+     return tclList; 
+ }
+ 
+ 
+ /************************************************************************/
+ /*                          TclListToXMLTree()                           */
+ /************************************************************************/
+ static CPLXMLNode *TclListToXMLTree( Tcl_Interp *interp, Tcl_Obj *tclList )
+ {
+     int      nChildCount = 0, iChild, nType;
+     CPLXMLNode *psThisNode;
+     CPLXMLNode *psChild;
+     char       *pszText = NULL;
+ 
+     if (Tcl_ListObjLength(interp, tclList, &nChildCount) != TCL_OK) {
+         /* Error msg in interp result */
+         return NULL;
+     }
+     nChildCount = nChildCount - 2;
+     if( nChildCount < 0 )
+     {
+         Tcl_SetResult(interp, (char*) "Error in input XMLTree.", TCL_STATIC);
+         return NULL;
+     }
+ 
+     Tcl_Obj **o = NULL;
+     if (Tcl_ListObjIndex(interp, tclList, 0, o) != TCL_OK) { /* ref count is not incremented */
+         /* Error msg in interp result */
+         return NULL;
+     }
+     if (Tcl_GetIntFromObj(interp, *o, &nType) != TCL_OK) {
+         /* Error msg in interp result */
+         return NULL;
+     }
+     if (Tcl_ListObjIndex(interp, tclList, 1, o) != TCL_OK) { /* ref count is not incremented */
+         /* Error msg in interp result */
+         return NULL;
+     }
+     pszText = Tcl_GetStringFromObj(*o, NULL);
+     psThisNode = CPLCreateXMLNode( NULL, (CPLXMLNodeType) nType, pszText );
+ 
+     for( iChild = 0; iChild < nChildCount; iChild++ )
+     {
+         if (Tcl_ListObjIndex(interp, tclList, iChild+2, o) != TCL_OK) { /* ref count is not incremented */
+             /* Error msg in interp result */
+             return NULL;
+         }
+         psChild = TclListToXMLTree( interp, *o );
+         CPLAddXMLChild( psThisNode, psChild );
+     }
+ 
+     return psThisNode;
+ }
+ 
+ 
+ int GetDriverCount() {
+   return GDALGetDriverCount();
+ }
+ 
+ 
+ GDALDriverShadow* GetDriverByName( char const *name ) {
+   return (GDALDriverShadow*) GDALGetDriverByName( name );
+ }
+ 
+ 
+ GDALDriverShadow* GetDriver( int i ) {
+   return (GDALDriverShadow*) GDALGetDriver( i );
+ }
+ 
+ 
+ GDALDatasetShadow* Open( char const* name, GDALAccess eAccess = GA_ReadOnly ) {
+   CPLErrorReset();
+   GDALDatasetShadow *ds = GDALOpen( name, eAccess );
+   if( ds != NULL && CPLGetLastErrorType() == CE_Failure )
+   {
+       if ( GDALDereferenceDataset( ds ) <= 0 )
+           GDALClose(ds);
+       ds = NULL;
+   }
+   return (GDALDatasetShadow*) ds;
+ }
+ 
+ 
+ GDALDatasetShadow* OpenShared( char const* name, GDALAccess eAccess = GA_ReadOnly ) {
+   CPLErrorReset();
+   GDALDatasetShadow *ds = GDALOpenShared( name, eAccess );
+   if( ds != NULL && CPLGetLastErrorType() == CE_Failure )
+   {
+       if ( GDALDereferenceDataset( ds ) <= 0 )
+           GDALClose(ds);
+       ds = NULL;
+   }
+   return (GDALDatasetShadow*) ds;
+ }
+ 
+ 
+ GDALDriverShadow *IdentifyDriver( const char *pszDatasource, 
+ 				  char **papszSiblings = NULL ) {
+     return (GDALDriverShadow *) GDALIdentifyDriver( pszDatasource, 
+ 	                                            papszSiblings );
+ }
+ 
+ 
+   char **GeneralCmdLineProcessor( char **papszArgv, int nOptions = 0 ) {
+     int nResArgCount;
+ 
+     nResArgCount = 
+       GDALGeneralCmdLineProcessor( CSLCount(papszArgv), &papszArgv, nOptions ); 
+ 
+     if( nResArgCount <= 0 )
+         return NULL;
+     else
+         return papszArgv;
+   }
+ 
+ #ifdef __cplusplus
+ extern "C" {
+ #endif
+ SWIGINTERN int
+ _wrap_DataTypeUnion(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
+   GDALDataType arg1 ;
+   GDALDataType arg2 ;
+   int val1 ;
+   int ecode1 = 0 ;
+   int val2 ;
+   int ecode2 = 0 ;
+   GDALDataType result;
+   
+   if (SWIG_GetArgs(interp, objc, objv,"oo:osgeo::DataTypeUnion GDALDataType GDALDataType ",(void *)0,(void *)0) == TCL_ERROR) SWIG_fail;
+   ecode1 = SWIG_AsVal_int SWIG_TCL_CALL_ARGS_2(objv[1], &val1);
+   if (!SWIG_IsOK(ecode1)) {
+     SWIG_exception_fail(SWIG_ArgError(ecode1), "in method '" "DataTypeUnion" "', argument " "1"" of type '" "GDALDataType""'");
+   } 
+   arg1 = static_cast< GDALDataType >(val1);
+   ecode2 = SWIG_AsVal_int SWIG_TCL_CALL_ARGS_2(objv[2], &val2);
+   if (!SWIG_IsOK(ecode2)) {
+     SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "DataTypeUnion" "', argument " "2"" of type '" "GDALDataType""'");
+   } 
+   arg2 = static_cast< GDALDataType >(val2);
+   result = (GDALDataType)GDALDataTypeUnion(arg1,arg2);
+   Tcl_SetObjResult(interp,SWIG_From_int(static_cast< int >(result)));
+   return TCL_OK;
+ fail:
+   return TCL_ERROR;
+ }
+ 
+ 
+ SWIGINTERN int
+ _wrap_UseExceptions(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
+   if (SWIG_GetArgs(interp, objc, objv,":osgeo::UseExceptions ") == TCL_ERROR) SWIG_fail;
+   UseExceptions();
+   
+   return TCL_OK;
+ fail:
+   return TCL_ERROR;
+ }
+ 
+ 
+ SWIGINTERN int
+ _wrap_DontUseExceptions(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
+   if (SWIG_GetArgs(interp, objc, objv,":osgeo::DontUseExceptions ") == TCL_ERROR) SWIG_fail;
+   DontUseExceptions();
+   
+   return TCL_OK;
+ fail:
+   return TCL_ERROR;
+ }
+ 
+ 
+ SWIGINTERN int
+ _wrap_Debug(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
+   char *arg1 = (char *) 0 ;
+   char *arg2 = (char *) 0 ;
+   int res1 ;
+   char *buf1 = 0 ;
+   int alloc1 = 0 ;
+   int res2 ;
+   char *buf2 = 0 ;
+   int alloc2 = 0 ;
+   
+   if (SWIG_GetArgs(interp, objc, objv,"oo:osgeo::Debug msg_class message ",(void *)0,(void *)0) == TCL_ERROR) SWIG_fail;
+   res1 = SWIG_AsCharPtrAndSize(objv[1], &buf1, NULL, &alloc1);
+   if (!SWIG_IsOK(res1)) {
+     SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Debug" "', argument " "1"" of type '" "char const *""'");
+   }
+   arg1 = reinterpret_cast< char * >(buf1);
+   res2 = SWIG_AsCharPtrAndSize(objv[2], &buf2, NULL, &alloc2);
+   if (!SWIG_IsOK(res2)) {
+     SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "Debug" "', argument " "2"" of type '" "char const *""'");
+   }
+   arg2 = reinterpret_cast< char * >(buf2);
+   {
+     CPLErrorReset();
+     Debug((char const *)arg1,(char const *)arg2);
+     CPLErr eclass = CPLGetLastErrorType();
+     if ( eclass == CE_Failure || eclass == CE_Fatal ) {
+       SWIG_exception( SWIG_RuntimeError, CPLGetLastErrorMsg() );
+       
+     }
+     
+     
+     
+     
+     
+     
+     
+     
+     
+     
+     
+   }
+   
+   if (alloc1 == SWIG_NEWOBJ) delete[] buf1;
+   if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
+   return TCL_OK;
+ fail:
+   if (alloc1 == SWIG_NEWOBJ) delete[] buf1;
+   if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
+   return TCL_ERROR;
+ }
+ 
+ 
+ SWIGINTERN int
+ _wrap_Error(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
+   CPLErr arg1 = (CPLErr) CE_Failure ;
+   int arg2 = (int) 0 ;
+   char *arg3 = (char *) "error" ;
+   int val1 ;
+   int ecode1 = 0 ;
+   int val2 ;
+   int ecode2 = 0 ;
+   int res3 ;
+   char *buf3 = 0 ;
+   int alloc3 = 0 ;
+   
+   if (SWIG_GetArgs(interp, objc, objv,"|ooo:osgeo::Error ?msg_class? ?err_code? ?msg? ",(void *)0,(void *)0,(void *)0) == TCL_ERROR) SWIG_fail;
+   if (objc > 1) {
+     ecode1 = SWIG_AsVal_int SWIG_TCL_CALL_ARGS_2(objv[1], &val1);
+     if (!SWIG_IsOK(ecode1)) {
+       SWIG_exception_fail(SWIG_ArgError(ecode1), "in method '" "Error" "', argument " "1"" of type '" "CPLErr""'");
+     } 
+     arg1 = static_cast< CPLErr >(val1);
+   }
+   if (objc > 2) {
+     ecode2 = SWIG_AsVal_int SWIG_TCL_CALL_ARGS_2(objv[2], &val2);
+     if (!SWIG_IsOK(ecode2)) {
+       SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "Error" "', argument " "2"" of type '" "int""'");
+     } 
+     arg2 = static_cast< int >(val2);
+   }
+   if (objc > 3) {
+     res3 = SWIG_AsCharPtrAndSize(objv[3], &buf3, NULL, &alloc3);
+     if (!SWIG_IsOK(res3)) {
+       SWIG_exception_fail(SWIG_ArgError(res3), "in method '" "Error" "', argument " "3"" of type '" "char const *""'");
+     }
+     arg3 = reinterpret_cast< char * >(buf3);
+   }
+   {
+     CPLErrorReset();
+     Error(arg1,arg2,(char const *)arg3);
+     CPLErr eclass = CPLGetLastErrorType();
+     if ( eclass == CE_Failure || eclass == CE_Fatal ) {
+       SWIG_exception( SWIG_RuntimeError, CPLGetLastErrorMsg() );
+       
+     }
+     
+     
+     
+     
+     
+     
+     
+     
+     
+     
+     
+   }
+   
+   if (alloc3 == SWIG_NEWOBJ) delete[] buf3;
+   return TCL_OK;
+ fail:
+   if (alloc3 == SWIG_NEWOBJ) delete[] buf3;
+   return TCL_ERROR;
+ }
+ 
+ 
+ SWIGINTERN int
+ _wrap_PushErrorHandler__SWIG_0(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
+   char *arg1 = (char *) "CPLQuietErrorHandler" ;
+   int res1 ;
+   char *buf1 = 0 ;
+   int alloc1 = 0 ;
+   CPLErr result;
+   
+   if (SWIG_GetArgs(interp, objc, objv,"|o:osgeo::PushErrorHandler ?pszCallbackName? ",(void *)0) == TCL_ERROR) SWIG_fail;
+   if (objc > 1) {
+     res1 = SWIG_AsCharPtrAndSize(objv[1], &buf1, NULL, &alloc1);
+     if (!SWIG_IsOK(res1)) {
+       SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "PushErrorHandler" "', argument " "1"" of type '" "char const *""'");
+     }
+     arg1 = reinterpret_cast< char * >(buf1);
+   }
+   {
+     CPLErrorReset();
+     result = (CPLErr)PushErrorHandler((char const *)arg1);
+     CPLErr eclass = CPLGetLastErrorType();
+     if ( eclass == CE_Failure || eclass == CE_Fatal ) {
+       SWIG_exception( SWIG_RuntimeError, CPLGetLastErrorMsg() );
+       
+     }
+     
+     
+     
+     
+     
+     
+     
+     
+     
+     
+     
+   }
+   Tcl_SetObjResult(interp,SWIG_From_int(static_cast< int >(result)));
+   if (alloc1 == SWIG_NEWOBJ) delete[] buf1;
+   return TCL_OK;
+ fail:
+   if (alloc1 == SWIG_NEWOBJ) delete[] buf1;
+   return TCL_ERROR;
+ }
+ 
+ 
+ SWIGINTERN int
+ _wrap_PushErrorHandler__SWIG_1(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
+   CPLErrorHandler arg1 ;
+   void *argp1 ;
+   int res1 = 0 ;
+   
+   if (SWIG_GetArgs(interp, objc, objv,"o:osgeo::PushErrorHandler CPLErrorHandler ",(void *)0) == TCL_ERROR) SWIG_fail;
+   {
+     res1 = SWIG_ConvertPtr(objv[1], &argp1, SWIGTYPE_p_CPLErrorHandler,  0 );
+     if (!SWIG_IsOK(res1)) {
+       SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "PushErrorHandler" "', argument " "1"" of type '" "CPLErrorHandler""'"); 
+     }  
+     if (!argp1) {
+       SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "PushErrorHandler" "', argument " "1"" of type '" "CPLErrorHandler""'");
+     } else {
+       arg1 = *(reinterpret_cast< CPLErrorHandler * >(argp1));
+     }
+   }
+   {
+     CPLErrorReset();
+     CPLPushErrorHandler(arg1);
+     CPLErr eclass = CPLGetLastErrorType();
+     if ( eclass == CE_Failure || eclass == CE_Fatal ) {
+       SWIG_exception( SWIG_RuntimeError, CPLGetLastErrorMsg() );
+       
+     }
+     
+     
+     
+     
+     
+     
+     
+     
+     
+     
+     
+   }
+   
+   return TCL_OK;
+ fail:
+   return TCL_ERROR;
+ }
+ 
+ 
+ SWIGINTERN int
+ _wrap_PushErrorHandler(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
+   Tcl_Obj *CONST *argv = objv+1;
+   int argc = objc-1;
+   if ((argc >= 0) && (argc <= 1)) {
+     int _v;
+     if (argc <= 0) {
+       return _wrap_PushErrorHandler__SWIG_0(clientData, interp, objc, argv - 1);
+     }
+     int res = SWIG_AsCharPtrAndSize(argv[0], 0, NULL, 0);
+     _v = SWIG_CheckState(res);
+     if (_v) {
+       return _wrap_PushErrorHandler__SWIG_0(clientData, interp, objc, argv - 1);
+     }
+   }
+   if (argc == 1) {
+     int _v;
+     void *vptr = 0;
+     int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_CPLErrorHandler, 0);
+     _v = SWIG_CheckState(res);
+     if (_v) {
+       return _wrap_PushErrorHandler__SWIG_1(clientData, interp, objc, argv - 1);
+     }
+   }
+   
+   Tcl_SetResult(interp,(char *) "No matching function for overloaded 'PushErrorHandler'", TCL_STATIC);
+   return TCL_ERROR;
+ }
+ 
+ 
+ SWIGINTERN int
+ _wrap_PopErrorHandler(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
+   if (SWIG_GetArgs(interp, objc, objv,":osgeo::PopErrorHandler ") == TCL_ERROR) SWIG_fail;
+   {
+     CPLErrorReset();
+     CPLPopErrorHandler();
+     CPLErr eclass = CPLGetLastErrorType();
+     if ( eclass == CE_Failure || eclass == CE_Fatal ) {
+       SWIG_exception( SWIG_RuntimeError, CPLGetLastErrorMsg() );
+       
+     }
+     
+     
+     
+     
+     
+     
+     
+     
+     
+     
+     
+   }
+   
+   return TCL_OK;
+ fail:
+   return TCL_ERROR;
+ }
+ 
+ 
+ SWIGINTERN int
+ _wrap_ErrorReset(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
+   if (SWIG_GetArgs(interp, objc, objv,":osgeo::ErrorReset ") == TCL_ERROR) SWIG_fail;
+   {
+     CPLErrorReset();
+     CPLErrorReset();
+     CPLErr eclass = CPLGetLastErrorType();
+     if ( eclass == CE_Failure || eclass == CE_Fatal ) {
+       SWIG_exception( SWIG_RuntimeError, CPLGetLastErrorMsg() );
+       
+     }
+     
+     
+     
+     
+     
+     
+     
+     
+     
+     
+     
+   }
+   
+   return TCL_OK;
+ fail:
+   return TCL_ERROR;
+ }
+ 
+ 
+ SWIGINTERN int
+ _wrap_EscapeString(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
+   int arg1 ;
+   char *arg2 = (char *) 0 ;
+   int arg3 = (int) CPLES_SQL ;
+   int val3 ;
+   int ecode3 = 0 ;
+   char *result = 0 ;
+   
+   if (SWIG_GetArgs(interp, objc, objv,"o|o:osgeo::EscapeString len ?bin_string? ?scheme? ",(void *)0,(void *)0) == TCL_ERROR) SWIG_fail;
+   {
+     /* %typemap(in,numinputs=1) (int nLen, char *pBuf ) */
+     /* Storage is handled by the respective Tcl_Obj. It should considered read-only. */
+     arg2 = Tcl_GetStringFromObj(objv[1], &arg1);
+   }
+   if (objc > 2) {
+     ecode3 = SWIG_AsVal_int SWIG_TCL_CALL_ARGS_2(objv[2], &val3);
+     if (!SWIG_IsOK(ecode3)) {
+       SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "EscapeString" "', argument " "3"" of type '" "int""'");
+     } 
+     arg3 = static_cast< int >(val3);
+   }
+   {
+     CPLErrorReset();
+     result = (char *)EscapeString(arg1,arg2,arg3);
+     CPLErr eclass = CPLGetLastErrorType();
+     if ( eclass == CE_Failure || eclass == CE_Fatal ) {
+       SWIG_exception( SWIG_RuntimeError, CPLGetLastErrorMsg() );
+       
+     }
+     
+     
+     
+     
+     
+     
+     
+     
+     
+     
+     
+   }
+   Tcl_SetObjResult(interp,SWIG_FromCharPtr((const char *)result));
+   return TCL_OK;
+ fail:
+   return TCL_ERROR;
+ }
+ 
+ 
+ SWIGINTERN int
+ _wrap_GetLastErrorNo(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
+   int result;
+   
+   if (SWIG_GetArgs(interp, objc, objv,":osgeo::GetLastErrorNo ") == TCL_ERROR) SWIG_fail;
+   {
+     CPLErrorReset();
+     result = (int)CPLGetLastErrorNo();
+     CPLErr eclass = CPLGetLastErrorType();
+     if ( eclass == CE_Failure || eclass == CE_Fatal ) {
+       SWIG_exception( SWIG_RuntimeError, CPLGetLastErrorMsg() );
+       
+     }
+     
+     
+     
+     
+     
+     
+     
+     
+     
+     
+     
+   }
+   Tcl_SetObjResult(interp,SWIG_From_int(static_cast< int >(result)));
+   return TCL_OK;
+ fail:
+   return TCL_ERROR;
+ }
+ 
+ 
+ SWIGINTERN int
+ _wrap_GetLastErrorType(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
+   CPLErr result;
+   
+   if (SWIG_GetArgs(interp, objc, objv,":osgeo::GetLastErrorType ") == TCL_ERROR) SWIG_fail;
+   {
+     CPLErrorReset();
+     result = (CPLErr)CPLGetLastErrorType();
+     CPLErr eclass = CPLGetLastErrorType();
+     if ( eclass == CE_Failure || eclass == CE_Fatal ) {
+       SWIG_exception( SWIG_RuntimeError, CPLGetLastErrorMsg() );
+       
+     }
+     
+     
+     
+     
+     
+     
+     
+     
+     
+     
+     
+   }
+   Tcl_SetObjResult(interp,SWIG_From_int(static_cast< int >(result)));
+   return TCL_OK;
+ fail:
+   return TCL_ERROR;
+ }
+ 
+ 
+ SWIGINTERN int
+ _wrap_GetLastErrorMsg(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
+   char *result = 0 ;
+   
+   if (SWIG_GetArgs(interp, objc, objv,":osgeo::GetLastErrorMsg ") == TCL_ERROR) SWIG_fail;
+   {
+     CPLErrorReset();
+     result = (char *)CPLGetLastErrorMsg();
+     CPLErr eclass = CPLGetLastErrorType();
+     if ( eclass == CE_Failure || eclass == CE_Fatal ) {
+       SWIG_exception( SWIG_RuntimeError, CPLGetLastErrorMsg() );
+       
+     }
+     
+     
+     
+     
+     
+     
+     
+     
+     
+     
+     
+   }
+   Tcl_SetObjResult(interp,SWIG_FromCharPtr((const char *)result));
+   return TCL_OK;
+ fail:
+   return TCL_ERROR;
+ }
+ 
+ 
+ SWIGINTERN int
+ _wrap_PushFinderLocation(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
+   char *arg1 = (char *) 0 ;
+   int res1 ;
+   char *buf1 = 0 ;
+   int alloc1 = 0 ;
+   
+   if (SWIG_GetArgs(interp, objc, objv,"o:osgeo::PushFinderLocation char const * ",(void *)0) == TCL_ERROR) SWIG_fail;
+   res1 = SWIG_AsCharPtrAndSize(objv[1], &buf1, NULL, &alloc1);
+   if (!SWIG_IsOK(res1)) {
+     SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "PushFinderLocation" "', argument " "1"" of type '" "char const *""'");
+   }
+   arg1 = reinterpret_cast< char * >(buf1);
+   {
+     CPLErrorReset();
+     CPLPushFinderLocation((char const *)arg1);
+     CPLErr eclass = CPLGetLastErrorType();
+     if ( eclass == CE_Failure || eclass == CE_Fatal ) {
+       SWIG_exception( SWIG_RuntimeError, CPLGetLastErrorMsg() );
+       
+     }
+     
+     
+     
+     
+     
+     
+     
+     
+     
+     
+     
+   }
+   
+   if (alloc1 == SWIG_NEWOBJ) delete[] buf1;
+   return TCL_OK;
+ fail:
+   if (alloc1 == SWIG_NEWOBJ) delete[] buf1;
+   return TCL_ERROR;
+ }
+ 
+ 
+ SWIGINTERN int
+ _wrap_PopFinderLocation(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
+   if (SWIG_GetArgs(interp, objc, objv,":osgeo::PopFinderLocation ") == TCL_ERROR) SWIG_fail;
+   {
+     CPLErrorReset();
+     CPLPopFinderLocation();
+     CPLErr eclass = CPLGetLastErrorType();
+     if ( eclass == CE_Failure || eclass == CE_Fatal ) {
+       SWIG_exception( SWIG_RuntimeError, CPLGetLastErrorMsg() );
+       
+     }
+     
+     
+     
+     
+     
+     
+     
+     
+     
+     
+     
+   }
+   
+   return TCL_OK;
+ fail:
+   return TCL_ERROR;
+ }
+ 
+ 
+ SWIGINTERN int
+ _wrap_FinderClean(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
+   if (SWIG_GetArgs(interp, objc, objv,":osgeo::FinderClean ") == TCL_ERROR) SWIG_fail;
+   {
+     CPLErrorReset();
+     CPLFinderClean();
+     CPLErr eclass = CPLGetLastErrorType();
+     if ( eclass == CE_Failure || eclass == CE_Fatal ) {
+       SWIG_exception( SWIG_RuntimeError, CPLGetLastErrorMsg() );
+       
+     }
+     
+     
+     
+     
+     
+     
+     
+     
+     
+     
+     
+   }
+   
+   return TCL_OK;
+ fail:
+   return TCL_ERROR;
+ }
+ 
+ 
+ SWIGINTERN int
+ _wrap_FindFile(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
+   char *arg1 = (char *) 0 ;
+   char *arg2 = (char *) 0 ;
+   int res1 ;
+   char *buf1 = 0 ;
+   int alloc1 = 0 ;
+   int res2 ;
+   char *buf2 = 0 ;
+   int alloc2 = 0 ;
+   char *result = 0 ;
+   
+   if (SWIG_GetArgs(interp, objc, objv,"oo:osgeo::FindFile char const * char const * ",(void *)0,(void *)0) == TCL_ERROR) SWIG_fail;
+   res1 = SWIG_AsCharPtrAndSize(objv[1], &buf1, NULL, &alloc1);
+   if (!SWIG_IsOK(res1)) {
+     SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "FindFile" "', argument " "1"" of type '" "char const *""'");
+   }
+   arg1 = reinterpret_cast< char * >(buf1);
+   res2 = SWIG_AsCharPtrAndSize(objv[2], &buf2, NULL, &alloc2);
+   if (!SWIG_IsOK(res2)) {
+     SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "FindFile" "', argument " "2"" of type '" "char const *""'");
+   }
+   arg2 = reinterpret_cast< char * >(buf2);
+   {
+     CPLErrorReset();
+     result = (char *)CPLFindFile((char const *)arg1,(char const *)arg2);
+     CPLErr eclass = CPLGetLastErrorType();
+     if ( eclass == CE_Failure || eclass == CE_Fatal ) {
+       SWIG_exception( SWIG_RuntimeError, CPLGetLastErrorMsg() );
+       
+     }
+     
+     
+     
+     
+     
+     
+     
+     
+     
+     
+     
+   }
+   Tcl_SetObjResult(interp,SWIG_FromCharPtr((const char *)result));
+   if (alloc1 == SWIG_NEWOBJ) delete[] buf1;
+   if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
+   return TCL_OK;
+ fail:
+   if (alloc1 == SWIG_NEWOBJ) delete[] buf1;
+   if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
+   return TCL_ERROR;
+ }
+ 
+ 
+ SWIGINTERN int
+ _wrap_ReadDir(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
+   char *arg1 = (char *) 0 ;
+   int res1 ;
+   char *buf1 = 0 ;
+   int alloc1 = 0 ;
+   char **result = 0 ;
+   
+   if (SWIG_GetArgs(interp, objc, objv,"o:osgeo::ReadDir char const * ",(void *)0) == TCL_ERROR) SWIG_fail;
+   res1 = SWIG_AsCharPtrAndSize(objv[1], &buf1, NULL, &alloc1);
+   if (!SWIG_IsOK(res1)) {
+     SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "ReadDir" "', argument " "1"" of type '" "char const *""'");
+   }
+   arg1 = reinterpret_cast< char * >(buf1);
+   {
+     CPLErrorReset();
+     result = (char **)VSIReadDir((char const *)arg1);
+     CPLErr eclass = CPLGetLastErrorType();
+     if ( eclass == CE_Failure || eclass == CE_Fatal ) {
+       SWIG_exception( SWIG_RuntimeError, CPLGetLastErrorMsg() );
+       
+     }
+     
+     
+     
+     
+     
+     
+     
+     
+     
+     
+     
+   }
+   {
+     /* %typemap(out) char **options -> ( string ) */
+     char **stringarray = result;
+     if ( stringarray == NULL ) {
+       Tcl_ResetResult(interp); /* NONE = Empty string */
+     } else {
+       int len = CSLCount( stringarray );
+       Tcl_Obj *out = Tcl_NewListObj(0, NULL);
+       for ( int i = 0; i < len; ++i ) {
+         Tcl_Obj *o = Tcl_NewStringObj( stringarray[i], -1 );
+         if (Tcl_ListObjAppendElement(interp, out, o) != TCL_OK) {
+           Tcl_DecrRefCount(o);
+           Tcl_DecrRefCount(out);
+           /* Error msg in interp result */
+           SWIG_fail;
+         }
+       }
+       Tcl_SetObjResult(interp, out);
+     }
+   }
+   if (alloc1 == SWIG_NEWOBJ) delete[] buf1;
+   return TCL_OK;
+ fail:
+   if (alloc1 == SWIG_NEWOBJ) delete[] buf1;
+   return TCL_ERROR;
+ }
+ 
+ 
+ SWIGINTERN int
+ _wrap_SetConfigOption(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
+   char *arg1 = (char *) 0 ;
+   char *arg2 = (char *) 0 ;
+   int res1 ;
+   char *buf1 = 0 ;
+   int alloc1 = 0 ;
+   int res2 ;
+   char *buf2 = 0 ;
+   int alloc2 = 0 ;
+   
+   if (SWIG_GetArgs(interp, objc, objv,"oo:osgeo::SetConfigOption char const * char const * ",(void *)0,(void *)0) == TCL_ERROR) SWIG_fail;
+   res1 = SWIG_AsCharPtrAndSize(objv[1], &buf1, NULL, &alloc1);
+   if (!SWIG_IsOK(res1)) {
+     SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SetConfigOption" "', argument " "1"" of type '" "char const *""'");
+   }
+   arg1 = reinterpret_cast< char * >(buf1);
+   res2 = SWIG_AsCharPtrAndSize(objv[2], &buf2, NULL, &alloc2);
+   if (!SWIG_IsOK(res2)) {
+     SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "SetConfigOption" "', argument " "2"" of type '" "char const *""'");
+   }
+   arg2 = reinterpret_cast< char * >(buf2);
+   {
+     CPLErrorReset();
+     CPLSetConfigOption((char const *)arg1,(char const *)arg2);
+     CPLErr eclass = CPLGetLastErrorType();
+     if ( eclass == CE_Failure || eclass == CE_Fatal ) {
+       SWIG_exception( SWIG_RuntimeError, CPLGetLastErrorMsg() );
+       
+     }
+     
+     
+     
+     
+     
+     
+     
+     
+     
+     
+     
+   }
+   
+   if (alloc1 == SWIG_NEWOBJ) delete[] buf1;
+   if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
+   return TCL_OK;
+ fail:
+   if (alloc1 == SWIG_NEWOBJ) delete[] buf1;
+   if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
+   return TCL_ERROR;
+ }
+ 
+ 
+ SWIGINTERN int
+ _wrap_GetConfigOption(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
+   char *arg1 = (char *) 0 ;
+   char *arg2 = (char *) 0 ;
+   int res1 ;
+   char *buf1 = 0 ;
+   int alloc1 = 0 ;
+   int res2 ;
+   char *buf2 = 0 ;
+   int alloc2 = 0 ;
+   char *result = 0 ;
+   
+   if (SWIG_GetArgs(interp, objc, objv,"oo:osgeo::GetConfigOption char const * char const * ",(void *)0,(void *)0) == TCL_ERROR) SWIG_fail;
+   res1 = SWIG_AsCharPtrAndSize(objv[1], &buf1, NULL, &alloc1);
+   if (!SWIG_IsOK(res1)) {
+     SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "GetConfigOption" "', argument " "1"" of type '" "char const *""'");
+   }
+   arg1 = reinterpret_cast< char * >(buf1);
+   res2 = SWIG_AsCharPtrAndSize(objv[2], &buf2, NULL, &alloc2);
+   if (!SWIG_IsOK(res2)) {
+     SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "GetConfigOption" "', argument " "2"" of type '" "char const *""'");
+   }
+   arg2 = reinterpret_cast< char * >(buf2);
+   {
+     CPLErrorReset();
+     result = (char *)CPLGetConfigOption((char const *)arg1,(char const *)arg2);
+     CPLErr eclass = CPLGetLastErrorType();
+     if ( eclass == CE_Failure || eclass == CE_Fatal ) {
+       SWIG_exception( SWIG_RuntimeError, CPLGetLastErrorMsg() );
+       
+     }
+     
+     
+     
+     
+     
+     
+     
+     
+     
+     
+     
+   }
+   Tcl_SetObjResult(interp,SWIG_FromCharPtr((const char *)result));
+   if (alloc1 == SWIG_NEWOBJ) delete[] buf1;
+   if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
+   return TCL_OK;
+ fail:
+   if (alloc1 == SWIG_NEWOBJ) delete[] buf1;
+   if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
+   return TCL_ERROR;
+ }
+ 
+ 
+ SWIGINTERN int
+ _wrap_CPLBinaryToHex(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
+   int arg1 ;
+   GByte *arg2 = (GByte *) 0 ;
+   int val1 ;
+   int ecode1 = 0 ;
+   void *argp2 = 0 ;
+   int res2 = 0 ;
+   char *result = 0 ;
+   
+   if (SWIG_GetArgs(interp, objc, objv,"oo:osgeo::CPLBinaryToHex nBytes pabyData ",(void *)0,(void *)0) == TCL_ERROR) SWIG_fail;
+   ecode1 = SWIG_AsVal_int SWIG_TCL_CALL_ARGS_2(objv[1], &val1);
+   if (!SWIG_IsOK(ecode1)) {
+     SWIG_exception_fail(SWIG_ArgError(ecode1), "in method '" "CPLBinaryToHex" "', argument " "1"" of type '" "int""'");
+   } 
+   arg1 = static_cast< int >(val1);
+   res2 = SWIG_ConvertPtr(objv[2], &argp2,SWIGTYPE_p_GByte, 0 |  0 );
+   if (!SWIG_IsOK(res2)) {
+     SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "CPLBinaryToHex" "', argument " "2"" of type '" "GByte const *""'"); 
+   }
+   arg2 = reinterpret_cast< GByte * >(argp2);
+   {
+     CPLErrorReset();
+     result = (char *)CPLBinaryToHex(arg1,(GByte const *)arg2);
+     CPLErr eclass = CPLGetLastErrorType();
+     if ( eclass == CE_Failure || eclass == CE_Fatal ) {
+       SWIG_exception( SWIG_RuntimeError, CPLGetLastErrorMsg() );
+       
+     }
+     
+     
+     
+     
+     
+     
+     
+     
+     
+     
+     
+   }
+   Tcl_SetObjResult(interp,SWIG_FromCharPtr((const char *)result));
+   return TCL_OK;
+ fail:
+   return TCL_ERROR;
+ }
+ 
+ 
+ SWIGINTERN int
+ _wrap_CPLHexToBinary(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
+   char *arg1 = (char *) 0 ;
+   int *arg2 = (int *) 0 ;
+   int res1 ;
+   char *buf1 = 0 ;
+   int alloc1 = 0 ;
+   void *argp2 = 0 ;
+   int res2 = 0 ;
+   GByte *result = 0 ;
+   
+   if (SWIG_GetArgs(interp, objc, objv,"oo:osgeo::CPLHexToBinary pszHex pnBytes ",(void *)0,(void *)0) == TCL_ERROR) SWIG_fail;
+   res1 = SWIG_AsCharPtrAndSize(objv[1], &buf1, NULL, &alloc1);
+   if (!SWIG_IsOK(res1)) {
+     SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CPLHexToBinary" "', argument " "1"" of type '" "char const *""'");
+   }
+   arg1 = reinterpret_cast< char * >(buf1);
+   res2 = SWIG_ConvertPtr(objv[2], &argp2,SWIGTYPE_p_int, 0 |  0 );
+   if (!SWIG_IsOK(res2)) {
+     SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "CPLHexToBinary" "', argument " "2"" of type '" "int *""'"); 
+   }
+   arg2 = reinterpret_cast< int * >(argp2);
+   {
+     CPLErrorReset();
+     result = (GByte *)CPLHexToBinary((char const *)arg1,arg2);
+     CPLErr eclass = CPLGetLastErrorType();
+     if ( eclass == CE_Failure || eclass == CE_Fatal ) {
+       SWIG_exception( SWIG_RuntimeError, CPLGetLastErrorMsg() );
+       
+     }
+     
+     
+     
+     
+     
+     
+     
+     
+     
+     
+     
+   }
+   Tcl_SetObjResult(interp, SWIG_NewInstanceObj( SWIG_as_voidptr(result), SWIGTYPE_p_GByte,0));
+   if (alloc1 == SWIG_NEWOBJ) delete[] buf1;
+   return TCL_OK;
+ fail:
+   if (alloc1 == SWIG_NEWOBJ) delete[] buf1;
+   return TCL_ERROR;
+ }
+ 
+ 
+ SWIGINTERN int
+ _wrap_MajorObject_GetDescription(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
+   GDALMajorObjectShadow *arg1 = (GDALMajorObjectShadow *) 0 ;
+   void *argp1 = 0 ;
+   int res1 = 0 ;
+   char *result = 0 ;
+   
+   if (SWIG_GetArgs(interp, objc, objv,"o:osgeo::MajorObject_GetDescription self ",(void *)0) == TCL_ERROR) SWIG_fail;
+   res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_GDALMajorObjectShadow, 0 |  0 );
+   if (!SWIG_IsOK(res1)) {
+     SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "MajorObject_GetDescription" "', argument " "1"" of type '" "GDALMajorObjectShadow *""'"); 
+   }
+   arg1 = reinterpret_cast< GDALMajorObjectShadow * >(argp1);
+   {
+     CPLErrorReset();
+     result = (char *)GDALMajorObjectShadow_GetDescription(arg1);
+     CPLErr eclass = CPLGetLastErrorType();
+     if ( eclass == CE_Failure || eclass == CE_Fatal ) {
+       SWIG_exception( SWIG_RuntimeError, CPLGetLastErrorMsg() );
+       
+     }
+     
+     
+     
+     
+     
+     
+     
+     
+     
+     
+     
+   }
+   Tcl_SetObjResult(interp,SWIG_FromCharPtr((const char *)result));
+   return TCL_OK;
+ fail:
+   return TCL_ERROR;
+ }
+ 
+ 
+ SWIGINTERN int
+ _wrap_MajorObject_SetDescription(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
+   GDALMajorObjectShadow *arg1 = (GDALMajorObjectShadow *) 0 ;
+   char *arg2 = (char *) 0 ;
+   void *argp1 = 0 ;
+   int res1 = 0 ;
+   int res2 ;
+   char *buf2 = 0 ;
+   int alloc2 = 0 ;
+   
+   if (SWIG_GetArgs(interp, objc, objv,"oo:osgeo::MajorObject_SetDescription self pszNewDesc ",(void *)0,(void *)0) == TCL_ERROR) SWIG_fail;
+   res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_GDALMajorObjectShadow, 0 |  0 );
+   if (!SWIG_IsOK(res1)) {
+     SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "MajorObject_SetDescription" "', argument " "1"" of type '" "GDALMajorObjectShadow *""'"); 
+   }
+   arg1 = reinterpret_cast< GDALMajorObjectShadow * >(argp1);
+   res2 = SWIG_AsCharPtrAndSize(objv[2], &buf2, NULL, &alloc2);
+   if (!SWIG_IsOK(res2)) {
+     SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "MajorObject_SetDescription" "', argument " "2"" of type '" "char const *""'");
+   }
+   arg2 = reinterpret_cast< char * >(buf2);
+   {
+     /* %typemap(check) (OGRFeatureShadow *feature) */
+     if (!arg2) {
+       Tcl_SetResult(interp, (char*) "Variable cannot be None", TCL_STATIC);
+       SWIG_fail;
+     }
+   }
+   {
+     CPLErrorReset();
+     GDALMajorObjectShadow_SetDescription(arg1,(char const *)arg2);
+     CPLErr eclass = CPLGetLastErrorType();
+     if ( eclass == CE_Failure || eclass == CE_Fatal ) {
+       SWIG_exception( SWIG_RuntimeError, CPLGetLastErrorMsg() );
+       
+     }
+     
+     
+     
+     
+     
+     
+     
+     
+     
+     
+     
+   }
+   
+   if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
+   return TCL_OK;
+ fail:
+   if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
+   return TCL_ERROR;
+ }
+ 
+ 
+ SWIGINTERN int
+ _wrap_MajorObject_GetMetadata_Dict(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
+   GDALMajorObjectShadow *arg1 = (GDALMajorObjectShadow *) 0 ;
+   char *arg2 = (char *) "" ;
+   void *argp1 = 0 ;
+   int res1 = 0 ;
+   int res2 ;
+   char *buf2 = 0 ;
+   int alloc2 = 0 ;
+   char **result = 0 ;
+   
+   if (SWIG_GetArgs(interp, objc, objv,"o|o:osgeo::MajorObject_GetMetadata_Dict self ?pszDomain? ",(void *)0,(void *)0) == TCL_ERROR) SWIG_fail;
+   res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_GDALMajorObjectShadow, 0 |  0 );
+   if (!SWIG_IsOK(res1)) {
+     SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "MajorObject_GetMetadata_Dict" "', argument " "1"" of type '" "GDALMajorObjectShadow *""'"); 
+   }
+   arg1 = reinterpret_cast< GDALMajorObjectShadow * >(argp1);
+   if (objc > 2) {
+     res2 = SWIG_AsCharPtrAndSize(objv[2], &buf2, NULL, &alloc2);
+     if (!SWIG_IsOK(res2)) {
+       SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "MajorObject_GetMetadata_Dict" "', argument " "2"" of type '" "char const *""'");
+     }
+     arg2 = reinterpret_cast< char * >(buf2);
+   }
+   {
+     CPLErrorReset();
+     result = (char **)GDALMajorObjectShadow_GetMetadata_Dict(arg1,(char const *)arg2);
+     CPLErr eclass = CPLGetLastErrorType();
+     if ( eclass == CE_Failure || eclass == CE_Fatal ) {
+       SWIG_exception( SWIG_RuntimeError, CPLGetLastErrorMsg() );
+       
+     }
+     
+     
+     
+     
+     
+     
+     
+     
+     
+     
+     
+   }
+   {
+     /* %typemap(out) char **dict */
+     char **stringarray = result;
+     Tcl_Obj *out = Tcl_NewDictObj();
+     if ( stringarray != NULL ) {
+       while (*stringarray != NULL ) {
+         char const *valptr;
+         char *keyptr;
+         valptr = CPLParseNameValue( *stringarray, &keyptr );
+         if ( valptr != 0 ) {
+           Tcl_Obj *nm = Tcl_NewStringObj( keyptr, -1 );
+           Tcl_Obj *val = Tcl_NewStringObj( valptr, -1 );
+           if (Tcl_DictObjPut(interp, out, nm, val) != TCL_OK) {
+             Tcl_DecrRefCount(nm);
+             Tcl_DecrRefCount(val);
+             Tcl_DecrRefCount(out);
+             /* Error msg in interp result */
+             SWIG_fail;
+           }
+           CPLFree( keyptr );
+         }
+         stringarray++;
+       }
+     }
+     Tcl_SetObjResult(interp, out);
+   }
+   if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
+   return TCL_OK;
+ fail:
+   if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
+   return TCL_ERROR;
+ }
+ 
+ 
+ SWIGINTERN int
+ _wrap_MajorObject_GetMetadata_List(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
+   GDALMajorObjectShadow *arg1 = (GDALMajorObjectShadow *) 0 ;
+   char *arg2 = (char *) "" ;
+   void *argp1 = 0 ;
+   int res1 = 0 ;
+   int res2 ;
+   char *buf2 = 0 ;
+   int alloc2 = 0 ;
+   char **result = 0 ;
+   
+   if (SWIG_GetArgs(interp, objc, objv,"o|o:osgeo::MajorObject_GetMetadata_List self ?pszDomain? ",(void *)0,(void *)0) == TCL_ERROR) SWIG_fail;
+   res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_GDALMajorObjectShadow, 0 |  0 );
+   if (!SWIG_IsOK(res1)) {
+     SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "MajorObject_GetMetadata_List" "', argument " "1"" of type '" "GDALMajorObjectShadow *""'"); 
+   }
+   arg1 = reinterpret_cast< GDALMajorObjectShadow * >(argp1);
+   if (objc > 2) {
+     res2 = SWIG_AsCharPtrAndSize(objv[2], &buf2, NULL, &alloc2);
+     if (!SWIG_IsOK(res2)) {
+       SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "MajorObject_GetMetadata_List" "', argument " "2"" of type '" "char const *""'");
+     }
+     arg2 = reinterpret_cast< char * >(buf2);
+   }
+   {
+     CPLErrorReset();
+     result = (char **)GDALMajorObjectShadow_GetMetadata_List(arg1,(char const *)arg2);
+     CPLErr eclass = CPLGetLastErrorType();
+     if ( eclass == CE_Failure || eclass == CE_Fatal ) {
+       SWIG_exception( SWIG_RuntimeError, CPLGetLastErrorMsg() );
+       
+     }
+     
+     
+     
+     
+     
+     
+     
+     
+     
+     
+     
+   }
+   {
+     /* %typemap(out) char **options -> ( string ) */
+     char **stringarray = result;
+     if ( stringarray == NULL ) {
+       Tcl_ResetResult(interp); /* NONE = Empty string */
+     } else {
+       int len = CSLCount( stringarray );
+       Tcl_Obj *out = Tcl_NewListObj(0, NULL);
+       for ( int i = 0; i < len; ++i ) {
+         Tcl_Obj *o = Tcl_NewStringObj( stringarray[i], -1 );
+         if (Tcl_ListObjAppendElement(interp, out, o) != TCL_OK) {
+           Tcl_DecrRefCount(o);
+           Tcl_DecrRefCount(out);
+           /* Error msg in interp result */
+           SWIG_fail;
+         }
+       }
+       Tcl_SetObjResult(interp, out);
+     }
+   }
+   if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
+   return TCL_OK;
+ fail:
+   if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
+   return TCL_ERROR;
+ }
+ 
+ 
+ SWIGINTERN int
+ _wrap_MajorObject_SetMetadata__SWIG_0(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
+   GDALMajorObjectShadow *arg1 = (GDALMajorObjectShadow *) 0 ;
+   char **arg2 = (char **) 0 ;
+   char *arg3 = (char *) "" ;
+   void *argp1 = 0 ;
+   int res1 = 0 ;
+   int res3 ;
+   char *buf3 = 0 ;
+   int alloc3 = 0 ;
+   CPLErr result;
+   
+   if (SWIG_GetArgs(interp, objc, objv,"oo|o:osgeo::MajorObject_SetMetadata self papszMetadata ?pszDomain? ",(void *)0,(void *)0,(void *)0) == TCL_ERROR) SWIG_fail;
+   res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_GDALMajorObjectShadow, 0 |  0 );
+   if (!SWIG_IsOK(res1)) {
+     SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "MajorObject_SetMetadata" "', argument " "1"" of type '" "GDALMajorObjectShadow *""'"); 
+   }
+   arg1 = reinterpret_cast< GDALMajorObjectShadow * >(argp1);
+   {
+     /* %typemap(in) char **dict */
+     arg2 = NULL;
+     int size;
+     if (Tcl_DictObjSize(interp, objv[2], &size) != TCL_OK) {
+       if ( size > 0 ) {
+         Tcl_DictSearch search;
+         Tcl_Obj *key, *value;
+         int done;
+         
+         if (Tcl_DictObjFirst(interp, objv[2], &search, &key, &value, &done) != TCL_OK) {
+           SWIG_fail;;
+         }
+         for (; !done ; Tcl_DictObjNext(&search, &key, &value, &done)) {
+           char *nm = Tcl_GetString(key);
+           char *val = Tcl_GetString(value);
+           arg2 = CSLAddNameValue( arg2, nm, val );
+         }
+         Tcl_DictObjDone(&search);
+       }
+     }
+     else {
+       Tcl_SetResult(interp, (char*) "Argument must be a dictionary", TCL_STATIC);
+       SWIG_fail;
+     }
+   }
+   if (objc > 3) {
+     res3 = SWIG_AsCharPtrAndSize(objv[3], &buf3, NULL, &alloc3);
+     if (!SWIG_IsOK(res3)) {
+       SWIG_exception_fail(SWIG_ArgError(res3), "in method '" "MajorObject_SetMetadata" "', argument " "3"" of type '" "char const *""'");
+     }
+     arg3 = reinterpret_cast< char * >(buf3);
+   }
+   {
+     CPLErrorReset();
+     result = (CPLErr)GDALMajorObjectShadow_SetMetadata__SWIG_0(arg1,arg2,(char const *)arg3);
+     CPLErr eclass = CPLGetLastErrorType();
+     if ( eclass == CE_Failure || eclass == CE_Fatal ) {
+       SWIG_exception( SWIG_RuntimeError, CPLGetLastErrorMsg() );
+       
+     }
+     
+     
+     
+     
+     
+     
+     
+     
+     
+     
+     
+   }
+   Tcl_SetObjResult(interp,SWIG_From_int(static_cast< int >(result)));
+   {
+     /* %typemap(freearg) char **dict */
+     CSLDestroy( arg2 );
+   }
+   if (alloc3 == SWIG_NEWOBJ) delete[] buf3;
+   return TCL_OK;
+ fail:
+   {
+     /* %typemap(freearg) char **dict */
+     CSLDestroy( arg2 );
+   }
+   if (alloc3 == SWIG_NEWOBJ) delete[] buf3;
+   return TCL_ERROR;
+ }
+ 
+ 
+ SWIGINTERN int
+ _wrap_MajorObject_SetMetadata__SWIG_1(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
+   GDALMajorObjectShadow *arg1 = (GDALMajorObjectShadow *) 0 ;
+   char *arg2 = (char *) 0 ;
+   char *arg3 = (char *) "" ;
+   void *argp1 = 0 ;
+   int res1 = 0 ;
+   int res2 ;
+   char *buf2 = 0 ;
+   int alloc2 = 0 ;
+   int res3 ;
+   char *buf3 = 0 ;
+   int alloc3 = 0 ;
+   CPLErr result;
+   
+   if (SWIG_GetArgs(interp, objc, objv,"oo|o:osgeo::MajorObject_SetMetadata self pszMetadataString ?pszDomain? ",(void *)0,(void *)0,(void *)0) == TCL_ERROR) SWIG_fail;
+   res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_GDALMajorObjectShadow, 0 |  0 );
+   if (!SWIG_IsOK(res1)) {
+     SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "MajorObject_SetMetadata" "', argument " "1"" of type '" "GDALMajorObjectShadow *""'"); 
+   }
+   arg1 = reinterpret_cast< GDALMajorObjectShadow * >(argp1);
+   res2 = SWIG_AsCharPtrAndSize(objv[2], &buf2, NULL, &alloc2);
+   if (!SWIG_IsOK(res2)) {
+     SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "MajorObject_SetMetadata" "', argument " "2"" of type '" "char *""'");
+   }
+   arg2 = reinterpret_cast< char * >(buf2);
+   if (objc > 3) {
+     res3 = SWIG_AsCharPtrAndSize(objv[3], &buf3, NULL, &alloc3);
+     if (!SWIG_IsOK(res3)) {
+       SWIG_exception_fail(SWIG_ArgError(res3), "in method '" "MajorObject_SetMetadata" "', argument " "3"" of type '" "char const *""'");
+     }
+     arg3 = reinterpret_cast< char * >(buf3);
+   }
+   {
+     CPLErrorReset();
+     result = (CPLErr)GDALMajorObjectShadow_SetMetadata__SWIG_1(arg1,arg2,(char const *)arg3);
+     CPLErr eclass = CPLGetLastErrorType();
+     if ( eclass == CE_Failure || eclass == CE_Fatal ) {
+       SWIG_exception( SWIG_RuntimeError, CPLGetLastErrorMsg() );
+       
+     }
+     
+     
+     
+     
+     
+     
+     
+     
+     
+     
+     
+   }
+   Tcl_SetObjResult(interp,SWIG_From_int(static_cast< int >(result)));
+   if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
+   if (alloc3 == SWIG_NEWOBJ) delete[] buf3;
+   return TCL_OK;
+ fail:
+   if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
+   if (alloc3 == SWIG_NEWOBJ) delete[] buf3;
+   return TCL_ERROR;
+ }
+ 
+ 
+ SWIGINTERN int
+ _wrap_MajorObject_SetMetadata(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
+   Tcl_Obj *CONST *argv = objv+1;
+   int argc = objc-1;
+   if ((argc >= 2) && (argc <= 3)) {
+     int _v;
+     void *vptr = 0;
+     int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_GDALMajorObjectShadow, 0);
+     _v = SWIG_CheckState(res);
+     if (_v) {
+       {
+         /* %typecheck(SWIG_TYPECHECK_POINTER) (char **dict) */
+         int size;
+         _v = (Tcl_DictObjSize(interp, argv[1], &size) == TCL_OK || Tcl_ListObjLength(interp, argv[1], &size) == TCL_OK) ? 1 : 0;
+       }
+       if (_v) {
+         if (argc <= 2) {
+           return _wrap_MajorObject_SetMetadata__SWIG_0(clientData, interp, objc, argv - 1);
+         }
+         int res = SWIG_AsCharPtrAndSize(argv[2], 0, NULL, 0);
+         _v = SWIG_CheckState(res);
+         if (_v) {
+           return _wrap_MajorObject_SetMetadata__SWIG_0(clientData, interp, objc, argv - 1);
+         }
+       }
+     }
+   }
+   if ((argc >= 2) && (argc <= 3)) {
+     int _v;
+     void *vptr = 0;
+     int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_GDALMajorObjectShadow, 0);
+     _v = SWIG_CheckState(res);
+     if (_v) {
+       int res = SWIG_AsCharPtrAndSize(argv[1], 0, NULL, 0);
+       _v = SWIG_CheckState(res);
+       if (_v) {
+         if (argc <= 2) {
+           return _wrap_MajorObject_SetMetadata__SWIG_1(clientData, interp, objc, argv - 1);
+         }
+         int res = SWIG_AsCharPtrAndSize(argv[2], 0, NULL, 0);
+         _v = SWIG_CheckState(res);
+         if (_v) {
+           return _wrap_MajorObject_SetMetadata__SWIG_1(clientData, interp, objc, argv - 1);
+         }
+       }
+     }
+   }
+   
+   Tcl_SetResult(interp,(char *) "No matching function for overloaded 'MajorObject_SetMetadata'", TCL_STATIC);
+   return TCL_ERROR;
+ }
+ 
+ 
+ SWIGINTERN int
+ _wrap_MajorObject_GetMetadataItem(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
+   GDALMajorObjectShadow *arg1 = (GDALMajorObjectShadow *) 0 ;
+   char *arg2 = (char *) 0 ;
+   char *arg3 = (char *) "" ;
+   void *argp1 = 0 ;
+   int res1 = 0 ;
+   int res2 ;
+   char *buf2 = 0 ;
+   int alloc2 = 0 ;
+   int res3 ;
+   char *buf3 = 0 ;
+   int alloc3 = 0 ;
+   char *result = 0 ;
+   
+   if (SWIG_GetArgs(interp, objc, objv,"oo|o:osgeo::MajorObject_GetMetadataItem self pszName ?pszDomain? ",(void *)0,(void *)0,(void *)0) == TCL_ERROR) SWIG_fail;
+   res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_GDALMajorObjectShadow, 0 |  0 );
+   if (!SWIG_IsOK(res1)) {
+     SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "MajorObject_GetMetadataItem" "', argument " "1"" of type '" "GDALMajorObjectShadow *""'"); 
+   }
+   arg1 = reinterpret_cast< GDALMajorObjectShadow * >(argp1);
+   res2 = SWIG_AsCharPtrAndSize(objv[2], &buf2, NULL, &alloc2);
+   if (!SWIG_IsOK(res2)) {
+     SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "MajorObject_GetMetadataItem" "', argument " "2"" of type '" "char const *""'");
+   }
+   arg2 = reinterpret_cast< char * >(buf2);
+   if (objc > 3) {
+     res3 = SWIG_AsCharPtrAndSize(objv[3], &buf3, NULL, &alloc3);
+     if (!SWIG_IsOK(res3)) {
+       SWIG_exception_fail(SWIG_ArgError(res3), "in method '" "MajorObject_GetMetadataItem" "', argument " "3"" of type '" "char const *""'");
+     }
+     arg3 = reinterpret_cast< char * >(buf3);
+   }
+   {
+     CPLErrorReset();
+     result = (char *)GDALMajorObjectShadow_GetMetadataItem(arg1,(char const *)arg2,(char const *)arg3);
+     CPLErr eclass = CPLGetLastErrorType();
+     if ( eclass == CE_Failure || eclass == CE_Fatal ) {
+       SWIG_exception( SWIG_RuntimeError, CPLGetLastErrorMsg() );
+       
+     }
+     
+     
+     
+     
+     
+     
+     
+     
+     
+     
+     
+   }
+   Tcl_SetObjResult(interp,SWIG_FromCharPtr((const char *)result));
+   if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
+   if (alloc3 == SWIG_NEWOBJ) delete[] buf3;
+   return TCL_OK;
+ fail:
+   if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
+   if (alloc3 == SWIG_NEWOBJ) delete[] buf3;
+   return TCL_ERROR;
+ }
+ 
+ 
+ SWIGINTERN int
+ _wrap_MajorObject_SetMetadataItem(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
+   GDALMajorObjectShadow *arg1 = (GDALMajorObjectShadow *) 0 ;
+   char *arg2 = (char *) 0 ;
+   char *arg3 = (char *) 0 ;
+   char *arg4 = (char *) "" ;
+   void *argp1 = 0 ;
+   int res1 = 0 ;
+   int res2 ;
+   char *buf2 = 0 ;
+   int alloc2 = 0 ;
+   int res3 ;
+   char *buf3 = 0 ;
+   int alloc3 = 0 ;
+   int res4 ;
+   char *buf4 = 0 ;
+   int alloc4 = 0 ;
+   CPLErr result;
+   
+   if (SWIG_GetArgs(interp, objc, objv,"ooo|o:osgeo::MajorObject_SetMetadataItem self pszName pszValue ?pszDomain? ",(void *)0,(void *)0,(void *)0,(void *)0) == TCL_ERROR) SWIG_fail;
+   res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_GDALMajorObjectShadow, 0 |  0 );
+   if (!SWIG_IsOK(res1)) {
+     SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "MajorObject_SetMetadataItem" "', argument " "1"" of type '" "GDALMajorObjectShadow *""'"); 
+   }
+   arg1 = reinterpret_cast< GDALMajorObjectShadow * >(argp1);
+   res2 = SWIG_AsCharPtrAndSize(objv[2], &buf2, NULL, &alloc2);
+   if (!SWIG_IsOK(res2)) {
+     SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "MajorObject_SetMetadataItem" "', argument " "2"" of type '" "char const *""'");
+   }
+   arg2 = reinterpret_cast< char * >(buf2);
+   res3 = SWIG_AsCharPtrAndSize(objv[3], &buf3, NULL, &alloc3);
+   if (!SWIG_IsOK(res3)) {
+     SWIG_exception_fail(SWIG_ArgError(res3), "in method '" "MajorObject_SetMetadataItem" "', argument " "3"" of type '" "char const *""'");
+   }
+   arg3 = reinterpret_cast< char * >(buf3);
+   if (objc > 4) {
+     res4 = SWIG_AsCharPtrAndSize(objv[4], &buf4, NULL, &alloc4);
+     if (!SWIG_IsOK(res4)) {
+       SWIG_exception_fail(SWIG_ArgError(res4), "in method '" "MajorObject_SetMetadataItem" "', argument " "4"" of type '" "char const *""'");
+     }
+     arg4 = reinterpret_cast< char * >(buf4);
+   }
+   {
+     CPLErrorReset();
+     result = (CPLErr)GDALMajorObjectShadow_SetMetadataItem(arg1,(char const *)arg2,(char const *)arg3,(char const *)arg4);
+     CPLErr eclass = CPLGetLastErrorType();
+     if ( eclass == CE_Failure || eclass == CE_Fatal ) {
+       SWIG_exception( SWIG_RuntimeError, CPLGetLastErrorMsg() );
+       
+     }
+     
+     
+     
+     
+     
+     
+     
+     
+     
+     
+     
+   }
+   Tcl_SetObjResult(interp,SWIG_From_int(static_cast< int >(result)));
+   if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
+   if (alloc3 == SWIG_NEWOBJ) delete[] buf3;
+   if (alloc4 == SWIG_NEWOBJ) delete[] buf4;
+   return TCL_OK;
+ fail:
+   if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
+   if (alloc3 == SWIG_NEWOBJ) delete[] buf3;
+   if (alloc4 == SWIG_NEWOBJ) delete[] buf4;
+   return TCL_ERROR;
+ }
+ 
+ 
+ static swig_method swig_GDALMajorObjectShadow_methods[] = {
+     {"GetDescription", _wrap_MajorObject_GetDescription}, 
+     {"SetDescription", _wrap_MajorObject_SetDescription}, 
+     {"GetMetadata_Dict", _wrap_MajorObject_GetMetadata_Dict}, 
+     {"GetMetadata_List", _wrap_MajorObject_GetMetadata_List}, 
+     {"SetMetadata", _wrap_MajorObject_SetMetadata}, 
+     {"GetMetadataItem", _wrap_MajorObject_GetMetadataItem}, 
+     {"SetMetadataItem", _wrap_MajorObject_SetMetadataItem}, 
+     {0,0}
+ };
+ static swig_attribute swig_GDALMajorObjectShadow_attributes[] = {
+     {0,0,0}
+ };
+ static swig_class *swig_GDALMajorObjectShadow_bases[] = {0};
+ static const char * swig_GDALMajorObjectShadow_base_names[] = {0};
+ static swig_class _wrap_class_GDALMajorObjectShadow = { "MajorObject", &SWIGTYPE_p_GDALMajorObjectShadow,0,0, swig_GDALMajorObjectShadow_methods, swig_GDALMajorObjectShadow_attributes, swig_GDALMajorObjectShadow_bases,swig_GDALMajorObjectShadow_base_names, &swig_module };
+ SWIGINTERN int
+ _wrap_Driver_ShortName_get(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
+   GDALDriverShadow *arg1 = (GDALDriverShadow *) 0 ;
+   void *argp1 = 0 ;
+   int res1 = 0 ;
+   char *result = 0 ;
+   
+   if (SWIG_GetArgs(interp, objc, objv,"o:osgeo::Driver_ShortName_get self ",(void *)0) == TCL_ERROR) SWIG_fail;
+   res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_GDALDriverShadow, 0 |  0 );
+   if (!SWIG_IsOK(res1)) {
+     SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Driver_ShortName_get" "', argument " "1"" of type '" "GDALDriverShadow *""'"); 
+   }
+   arg1 = reinterpret_cast< GDALDriverShadow * >(argp1);
+   {
+     CPLErrorReset();
+     result = (char *)GDALDriverShadow_ShortName_get(arg1);
+     CPLErr eclass = CPLGetLastErrorType();
+     if ( eclass == CE_Failure || eclass == CE_Fatal ) {
+       SWIG_exception( SWIG_RuntimeError, CPLGetLastErrorMsg() );
+       
+     }
+     
+     
+     
+     
+     
+     
+     
+     
+     
+     
+     
+   }
+   Tcl_SetObjResult(interp,SWIG_FromCharPtr((const char *)result));
+   return TCL_OK;
+ fail:
+   return TCL_ERROR;
+ }
+ 
+ 
+ SWIGINTERN int
+ _wrap_Driver_LongName_get(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
+   GDALDriverShadow *arg1 = (GDALDriverShadow *) 0 ;
+   void *argp1 = 0 ;
+   int res1 = 0 ;
+   char *result = 0 ;
+   
+   if (SWIG_GetArgs(interp, objc, objv,"o:osgeo::Driver_LongName_get self ",(void *)0) == TCL_ERROR) SWIG_fail;
+   res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_GDALDriverShadow, 0 |  0 );
+   if (!SWIG_IsOK(res1)) {
+     SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Driver_LongName_get" "', argument " "1"" of type '" "GDALDriverShadow *""'"); 
+   }
+   arg1 = reinterpret_cast< GDALDriverShadow * >(argp1);
+   {
+     CPLErrorReset();
+     result = (char *)GDALDriverShadow_LongName_get(arg1);
+     CPLErr eclass = CPLGetLastErrorType();
+     if ( eclass == CE_Failure || eclass == CE_Fatal ) {
+       SWIG_exception( SWIG_RuntimeError, CPLGetLastErrorMsg() );
+       
+     }
+     
+     
+     
+     
+     
+     
+     
+     
+     
+     
+     
+   }
+   Tcl_SetObjResult(interp,SWIG_FromCharPtr((const char *)result));
+   return TCL_OK;
+ fail:
+   return TCL_ERROR;
+ }
+ 
+ 
+ SWIGINTERN int
+ _wrap_Driver_HelpTopic_get(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
+   GDALDriverShadow *arg1 = (GDALDriverShadow *) 0 ;
+   void *argp1 = 0 ;
+   int res1 = 0 ;
+   char *result = 0 ;
+   
+   if (SWIG_GetArgs(interp, objc, objv,"o:osgeo::Driver_HelpTopic_get self ",(void *)0) == TCL_ERROR) SWIG_fail;
+   res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_GDALDriverShadow, 0 |  0 );
+   if (!SWIG_IsOK(res1)) {
+     SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Driver_HelpTopic_get" "', argument " "1"" of type '" "GDALDriverShadow *""'"); 
+   }
+   arg1 = reinterpret_cast< GDALDriverShadow * >(argp1);
+   {
+     CPLErrorReset();
+     result = (char *)GDALDriverShadow_HelpTopic_get(arg1);
+     CPLErr eclass = CPLGetLastErrorType();
+     if ( eclass == CE_Failure || eclass == CE_Fatal ) {
+       SWIG_exception( SWIG_RuntimeError, CPLGetLastErrorMsg() );
+       
+     }
+     
+     
+     
+     
+     
+     
+     
+     
+     
+     
+     
+   }
+   Tcl_SetObjResult(interp,SWIG_FromCharPtr((const char *)result));
+   return TCL_OK;
+ fail:
+   return TCL_ERROR;
+ }
+ 
+ 
+ SWIGINTERN int
+ _wrap_Driver_Create(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
+   GDALDriverShadow *arg1 = (GDALDriverShadow *) 0 ;
+   char *arg2 = (char *) 0 ;
+   int arg3 ;
+   int arg4 ;
+   int arg5 = (int) 1 ;
+   GDALDataType arg6 = (GDALDataType) GDT_Byte ;
+   char **arg7 = (char **) 0 ;
+   void *argp1 = 0 ;
+   int res1 = 0 ;
+   int res2 ;
+   char *buf2 = 0 ;
+   int alloc2 = 0 ;
+   int val3 ;
+   int ecode3 = 0 ;
+   int val4 ;
+   int ecode4 = 0 ;
+   int val5 ;
+   int ecode5 = 0 ;
+   int val6 ;
+   int ecode6 = 0 ;
+   GDALDatasetShadow *result = 0 ;
+   
+   if (SWIG_GetArgs(interp, objc, objv,"oooo|ooo:osgeo::Driver_Create self name xsize ysize ?bands? ?eType? ?options? ",(void *)0,(void *)0,(void *)0,(void *)0,(void *)0,(void *)0,(void *)0) == TCL_ERROR) SWIG_fail;
+   res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_GDALDriverShadow, 0 |  0 );
+   if (!SWIG_IsOK(res1)) {
+     SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Driver_Create" "', argument " "1"" of type '" "GDALDriverShadow *""'"); 
+   }
+   arg1 = reinterpret_cast< GDALDriverShadow * >(argp1);
+   res2 = SWIG_AsCharPtrAndSize(objv[2], &buf2, NULL, &alloc2);
+   if (!SWIG_IsOK(res2)) {
+     SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "Driver_Create" "', argument " "2"" of type '" "char const *""'");
+   }
+   arg2 = reinterpret_cast< char * >(buf2);
+   ecode3 = SWIG_AsVal_int SWIG_TCL_CALL_ARGS_2(objv[3], &val3);
+   if (!SWIG_IsOK(ecode3)) {
+     SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "Driver_Create" "', argument " "3"" of type '" "int""'");
+   } 
+   arg3 = static_cast< int >(val3);
+   ecode4 = SWIG_AsVal_int SWIG_TCL_CALL_ARGS_2(objv[4], &val4);
+   if (!SWIG_IsOK(ecode4)) {
+     SWIG_exception_fail(SWIG_ArgError(ecode4), "in method '" "Driver_Create" "', argument " "4"" of type '" "int""'");
+   } 
+   arg4 = static_cast< int >(val4);
+   if (objc > 5) {
+     ecode5 = SWIG_AsVal_int SWIG_TCL_CALL_ARGS_2(objv[5], &val5);
+     if (!SWIG_IsOK(ecode5)) {
+       SWIG_exception_fail(SWIG_ArgError(ecode5), "in method '" "Driver_Create" "', argument " "5"" of type '" "int""'");
+     } 
+     arg5 = static_cast< int >(val5);
+   }
+   if (objc > 6) {
+     ecode6 = SWIG_AsVal_int SWIG_TCL_CALL_ARGS_2(objv[6], &val6);
+     if (!SWIG_IsOK(ecode6)) {
+       SWIG_exception_fail(SWIG_ArgError(ecode6), "in method '" "Driver_Create" "', argument " "6"" of type '" "GDALDataType""'");
+     } 
+     arg6 = static_cast< GDALDataType >(val6);
+   }
+   if (objc > 7) {
+     {
+       /* %typemap(in) char **options */
+       int size;
+       if (Tcl_ListObjLength(interp, objv[7], &size) != TCL_OK) {
+         /* Error msg in interp result */
+         SWIG_fail;
+       }
+       if ( !size ) {
+         Tcl_SetResult(interp, (char*) "Input list mustn't be empty", TCL_STATIC);
+         SWIG_fail;
+       }
+       
+       for (int i = 0; i < size; i++) {
+         Tcl_Obj **o = NULL;
+         /* The reference count for the list element is not incremented with the following */
+         if (Tcl_ListObjIndex(interp, objv[7], i, o) != TCL_OK) {
+           /* Error msg in interp result */
+           SWIG_fail;
+         }
+         char *pszItem = Tcl_GetString(*o);
+         arg7 = CSLAddString( arg7, pszItem );
+       }
+     }
+   }
+   {
+     CPLErrorReset();
+     result = (GDALDatasetShadow *)GDALDriverShadow_Create(arg1,(char const *)arg2,arg3,arg4,arg5,arg6,arg7);
+     CPLErr eclass = CPLGetLastErrorType();
+     if ( eclass == CE_Failure || eclass == CE_Fatal ) {
+       SWIG_exception( SWIG_RuntimeError, CPLGetLastErrorMsg() );
+       
+     }
+     
+     
+     
+     
+     
+     
+     
+     
+     
+     
+     
+   }
+   Tcl_SetObjResult(interp, SWIG_NewInstanceObj( SWIG_as_voidptr(result), SWIGTYPE_p_GDALDatasetShadow,0));
+   if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
+   {
+     /* %typemap(freearg) char **options */
+     CSLDestroy( arg7 );
+   }
+   return TCL_OK;
+ fail:
+   if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
+   {
+     /* %typemap(freearg) char **options */
+     CSLDestroy( arg7 );
+   }
+   return TCL_ERROR;
+ }
+ 
+ 
+ SWIGINTERN int
+ _wrap_Driver_CreateCopy(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
+   GDALDriverShadow *arg1 = (GDALDriverShadow *) 0 ;
+   char *arg2 = (char *) 0 ;
+   GDALDatasetShadow *arg3 = (GDALDatasetShadow *) 0 ;
+   int arg4 = (int) 1 ;
+   char **arg5 = (char **) 0 ;
+   GDALProgressFunc arg6 = (GDALProgressFunc) NULL ;
+   void *arg7 = (void *) NULL ;
+   void *argp1 = 0 ;
+   int res1 = 0 ;
+   int res2 ;
+   char *buf2 = 0 ;
+   int alloc2 = 0 ;
+   void *argp3 = 0 ;
+   int res3 = 0 ;
+   int val4 ;
+   int ecode4 = 0 ;
+   GDALDatasetShadow *result = 0 ;
+   
+   /* %typemap(arginit) ( const char* callback_data=NULL)  */
+   TclProgressData *psProgressInfo;
+   psProgressInfo = (TclProgressData *) CPLCalloc(1,sizeof(TclProgressData));
+   psProgressInfo->nLastReported = -1;
+   psProgressInfo->interp = interp;
+   psProgressInfo->psTclCallback = NULL;
+   psProgressInfo->psTclCallbackData = NULL;
+   if (SWIG_GetArgs(interp, objc, objv,"ooo|oooo:osgeo::Driver_CreateCopy self name src ?strict? ?options? ?callback? ?callback_data? ",(void *)0,(void *)0,(void *)0,(void *)0,(void *)0,(void *)0,(void *)0) == TCL_ERROR) SWIG_fail;
+   res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_GDALDriverShadow, 0 |  0 );
+   if (!SWIG_IsOK(res1)) {
+     SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Driver_CreateCopy" "', argument " "1"" of type '" "GDALDriverShadow *""'"); 
+   }
+   arg1 = reinterpret_cast< GDALDriverShadow * >(argp1);
+   res2 = SWIG_AsCharPtrAndSize(objv[2], &buf2, NULL, &alloc2);
+   if (!SWIG_IsOK(res2)) {
+     SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "Driver_CreateCopy" "', argument " "2"" of type '" "char const *""'");
+   }
+   arg2 = reinterpret_cast< char * >(buf2);
+   res3 = SWIG_ConvertPtr(objv[3], &argp3,SWIGTYPE_p_GDALDatasetShadow, 0 |  0 );
+   if (!SWIG_IsOK(res3)) {
+     SWIG_exception_fail(SWIG_ArgError(res3), "in method '" "Driver_CreateCopy" "', argument " "3"" of type '" "GDALDatasetShadow *""'"); 
+   }
+   arg3 = reinterpret_cast< GDALDatasetShadow * >(argp3);
+   if (objc > 4) {
+     ecode4 = SWIG_AsVal_int SWIG_TCL_CALL_ARGS_2(objv[4], &val4);
+     if (!SWIG_IsOK(ecode4)) {
+       SWIG_exception_fail(SWIG_ArgError(ecode4), "in method '" "Driver_CreateCopy" "', argument " "4"" of type '" "int""'");
+     } 
+     arg4 = static_cast< int >(val4);
+   }
+   if (objc > 5) {
+     {
+       /* %typemap(in) char **options */
+       int size;
+       if (Tcl_ListObjLength(interp, objv[5], &size) != TCL_OK) {
+         /* Error msg in interp result */
+         SWIG_fail;
+       }
+       if ( !size ) {
+         Tcl_SetResult(interp, (char*) "Input list mustn't be empty", TCL_STATIC);
+         SWIG_fail;
+       }
+       
+       for (int i = 0; i < size; i++) {
+         Tcl_Obj **o = NULL;
+         /* The reference count for the list element is not incremented with the following */
+         if (Tcl_ListObjIndex(interp, objv[5], i, o) != TCL_OK) {
+           /* Error msg in interp result */
+           SWIG_fail;
+         }
+         char *pszItem = Tcl_GetString(*o);
+         arg5 = CSLAddString( arg5, pszItem );
+       }
+     }
+   }
+   if (objc > 6) {
+     {
+       /* %typemap(in) (GDALProgressFunc callback = NULL) */
+       /* callback_func typemap */
+       if (objv[6] && !strcmp(Tcl_GetString(objv[6]), "")) {
+         void* cbfunction = NULL;
+         SWIG_ConvertPtr( objv[6], 
+           (void**)&cbfunction, 
+           SWIGTYPE_p_f_double_p_q_const__char_p_void__int, 
+           SWIG_POINTER_EXCEPTION | 0 );
+         
+         if ( cbfunction == GDALTermProgress ) {
+           arg6 = GDALTermProgress;
+         } else if ( cbfunction == GDALDummyProgress) {
+           arg6 = GDALDummyProgress;
+         } else if ( cbfunction == GDALScaledProgress) {
+           arg6 = GDALScaledProgress;
+         } else {
+           psProgressInfo->psTclCallback = objv[6];
+           Tcl_IncrRefCount(psProgressInfo->psTclCallback);
+           arg6 = TclProgressProxy;
+         }
+       }
+     }
+   }
+   if (objc > 7) {
+     {
+       /* %typemap(in) ( void* callback_data=NULL)  */
+       psProgressInfo->psTclCallbackData = objv[7];
+       Tcl_IncrRefCount(psProgressInfo->psTclCallbackData);
+       arg7 = psProgressInfo;
+       
+     }
+   }
+   {
+     CPLErrorReset();
+     result = (GDALDatasetShadow *)GDALDriverShadow_CreateCopy(arg1,(char const *)arg2,arg3,arg4,arg5,arg6,arg7);
+     CPLErr eclass = CPLGetLastErrorType();
+     if ( eclass == CE_Failure || eclass == CE_Fatal ) {
+       SWIG_exception( SWIG_RuntimeError, CPLGetLastErrorMsg() );
+       
+     }
+     
+     
+     
+     
+     
+     
+     
+     
+     
+     
+     
+   }
+   Tcl_SetObjResult(interp, SWIG_NewInstanceObj( SWIG_as_voidptr(result), SWIGTYPE_p_GDALDatasetShadow,0));
+   if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
+   {
+     /* %typemap(freearg) char **options */
+     CSLDestroy( arg5 );
+   }
+   {
+     /* %typemap(freearg) ( void* callback_data=NULL)  */
+     Tcl_DecrRefCount(psProgressInfo->psTclCallback);
+     Tcl_DecrRefCount(psProgressInfo->psTclCallbackData);
+     CPLFree(psProgressInfo);
+   }
+   return TCL_OK;
+ fail:
+   if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
+   {
+     /* %typemap(freearg) char **options */
+     CSLDestroy( arg5 );
+   }
+   {
+     /* %typemap(freearg) ( void* callback_data=NULL)  */
+     Tcl_DecrRefCount(psProgressInfo->psTclCallback);
+     Tcl_DecrRefCount(psProgressInfo->psTclCallbackData);
+     CPLFree(psProgressInfo);
+   }
+   return TCL_ERROR;
+ }
+ 
+ 
+ SWIGINTERN int
+ _wrap_Driver_Delete(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
+   GDALDriverShadow *arg1 = (GDALDriverShadow *) 0 ;
+   char *arg2 = (char *) 0 ;
+   void *argp1 = 0 ;
+   int res1 = 0 ;
+   int res2 ;
+   char *buf2 = 0 ;
+   int alloc2 = 0 ;
+   int result;
+   
+   if (SWIG_GetArgs(interp, objc, objv,"oo:osgeo::Driver_Delete self name ",(void *)0,(void *)0) == TCL_ERROR) SWIG_fail;
+   res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_GDALDriverShadow, 0 |  0 );
+   if (!SWIG_IsOK(res1)) {
+     SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Driver_Delete" "', argument " "1"" of type '" "GDALDriverShadow *""'"); 
+   }
+   arg1 = reinterpret_cast< GDALDriverShadow * >(argp1);
+   res2 = SWIG_AsCharPtrAndSize(objv[2], &buf2, NULL, &alloc2);
+   if (!SWIG_IsOK(res2)) {
+     SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "Driver_Delete" "', argument " "2"" of type '" "char const *""'");
+   }
+   arg2 = reinterpret_cast< char * >(buf2);
+   {
+     CPLErrorReset();
+     result = (int)GDALDriverShadow_Delete(arg1,(char const *)arg2);
+     CPLErr eclass = CPLGetLastErrorType();
+     if ( eclass == CE_Failure || eclass == CE_Fatal ) {
+       SWIG_exception( SWIG_RuntimeError, CPLGetLastErrorMsg() );
+       
+     }
+     
+     
+     
+     
+     
+     
+     
+     
+     
+     
+     
+   }
+   Tcl_SetObjResult(interp,SWIG_From_int(static_cast< int >(result)));
+   if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
+   return TCL_OK;
+ fail:
+   if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
+   return TCL_ERROR;
+ }
+ 
+ 
+ SWIGINTERN int
+ _wrap_Driver_Rename(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
+   GDALDriverShadow *arg1 = (GDALDriverShadow *) 0 ;
+   char *arg2 = (char *) 0 ;
+   char *arg3 = (char *) 0 ;
+   void *argp1 = 0 ;
+   int res1 = 0 ;
+   int res2 ;
+   char *buf2 = 0 ;
+   int alloc2 = 0 ;
+   int res3 ;
+   char *buf3 = 0 ;
+   int alloc3 = 0 ;
+   int result;
+   
+   if (SWIG_GetArgs(interp, objc, objv,"ooo:osgeo::Driver_Rename self newName oldName ",(void *)0,(void *)0,(void *)0) == TCL_ERROR) SWIG_fail;
+   res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_GDALDriverShadow, 0 |  0 );
+   if (!SWIG_IsOK(res1)) {
+     SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Driver_Rename" "', argument " "1"" of type '" "GDALDriverShadow *""'"); 
+   }
+   arg1 = reinterpret_cast< GDALDriverShadow * >(argp1);
+   res2 = SWIG_AsCharPtrAndSize(objv[2], &buf2, NULL, &alloc2);
+   if (!SWIG_IsOK(res2)) {
+     SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "Driver_Rename" "', argument " "2"" of type '" "char const *""'");
+   }
+   arg2 = reinterpret_cast< char * >(buf2);
+   res3 = SWIG_AsCharPtrAndSize(objv[3], &buf3, NULL, &alloc3);
+   if (!SWIG_IsOK(res3)) {
+     SWIG_exception_fail(SWIG_ArgError(res3), "in method '" "Driver_Rename" "', argument " "3"" of type '" "char const *""'");
+   }
+   arg3 = reinterpret_cast< char * >(buf3);
+   {
+     CPLErrorReset();
+     result = (int)GDALDriverShadow_Rename(arg1,(char const *)arg2,(char const *)arg3);
+     CPLErr eclass = CPLGetLastErrorType();
+     if ( eclass == CE_Failure || eclass == CE_Fatal ) {
+       SWIG_exception( SWIG_RuntimeError, CPLGetLastErrorMsg() );
+       
+     }
+     
+     
+     
+     
+     
+     
+     
+     
+     
+     
+     
+   }
+   Tcl_SetObjResult(interp,SWIG_From_int(static_cast< int >(result)));
+   if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
+   if (alloc3 == SWIG_NEWOBJ) delete[] buf3;
+   return TCL_OK;
+ fail:
+   if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
+   if (alloc3 == SWIG_NEWOBJ) delete[] buf3;
+   return TCL_ERROR;
+ }
+ 
+ 
+ SWIGINTERN int
+ _wrap_Driver_Register(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
+   GDALDriverShadow *arg1 = (GDALDriverShadow *) 0 ;
+   void *argp1 = 0 ;
+   int res1 = 0 ;
+   int result;
+   
+   if (SWIG_GetArgs(interp, objc, objv,"o:osgeo::Driver_Register self ",(void *)0) == TCL_ERROR) SWIG_fail;
+   res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_GDALDriverShadow, 0 |  0 );
+   if (!SWIG_IsOK(res1)) {
+     SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Driver_Register" "', argument " "1"" of type '" "GDALDriverShadow *""'"); 
+   }
+   arg1 = reinterpret_cast< GDALDriverShadow * >(argp1);
+   {
+     CPLErrorReset();
+     result = (int)GDALDriverShadow_Register(arg1);
+     CPLErr eclass = CPLGetLastErrorType();
+     if ( eclass == CE_Failure || eclass == CE_Fatal ) {
+       SWIG_exception( SWIG_RuntimeError, CPLGetLastErrorMsg() );
+       
+     }
+     
+     
+     
+     
+     
+     
+     
+     
+     
+     
+     
+   }
+   Tcl_SetObjResult(interp,SWIG_From_int(static_cast< int >(result)));
+   return TCL_OK;
+ fail:
+   return TCL_ERROR;
+ }
+ 
+ 
+ SWIGINTERN int
+ _wrap_Driver_Deregister(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
+   GDALDriverShadow *arg1 = (GDALDriverShadow *) 0 ;
+   void *argp1 = 0 ;
+   int res1 = 0 ;
+   
+   if (SWIG_GetArgs(interp, objc, objv,"o:osgeo::Driver_Deregister self ",(void *)0) == TCL_ERROR) SWIG_fail;
+   res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_GDALDriverShadow, 0 |  0 );
+   if (!SWIG_IsOK(res1)) {
+     SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Driver_Deregister" "', argument " "1"" of type '" "GDALDriverShadow *""'"); 
+   }
+   arg1 = reinterpret_cast< GDALDriverShadow * >(argp1);
+   {
+     CPLErrorReset();
+     GDALDriverShadow_Deregister(arg1);
+     CPLErr eclass = CPLGetLastErrorType();
+     if ( eclass == CE_Failure || eclass == CE_Fatal ) {
+       SWIG_exception( SWIG_RuntimeError, CPLGetLastErrorMsg() );
+       
+     }
+     
+     
+     
+     
+     
+     
+     
+     
+     
+     
+     
+   }
+   
+   return TCL_OK;
+ fail:
+   return TCL_ERROR;
+ }
+ 
+ 
+ static swig_method swig_GDALDriverShadow_methods[] = {
+     {"Create", _wrap_Driver_Create}, 
+     {"CreateCopy", _wrap_Driver_CreateCopy}, 
+     {"Delete", _wrap_Driver_Delete}, 
+     {"Rename", _wrap_Driver_Rename}, 
+     {"Register", _wrap_Driver_Register}, 
+     {"Deregister", _wrap_Driver_Deregister}, 
+     {0,0}
+ };
+ static swig_attribute swig_GDALDriverShadow_attributes[] = {
+     { "-ShortName",_wrap_Driver_ShortName_get, 0 },
+     { "-LongName",_wrap_Driver_LongName_get, 0 },
+     { "-HelpTopic",_wrap_Driver_HelpTopic_get, 0 },
+     {0,0,0}
+ };
+ static swig_class *swig_GDALDriverShadow_bases[] = {0,0};
+ static const char * swig_GDALDriverShadow_base_names[] = {"GDALMajorObjectShadow *",0};
+ static swig_class _wrap_class_GDALDriverShadow = { "Driver", &SWIGTYPE_p_GDALDriverShadow,0,0, swig_GDALDriverShadow_methods, swig_GDALDriverShadow_attributes, swig_GDALDriverShadow_bases,swig_GDALDriverShadow_base_names, &swig_module };
+ SWIGINTERN int
+ _wrap_ColorEntry_c1_set(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
+   GDALColorEntry *arg1 = (GDALColorEntry *) 0 ;
+   short arg2 ;
+   GDALColorEntry ce1 ;
+   short val2 ;
+   int ecode2 = 0 ;
+   
+   if (SWIG_GetArgs(interp, objc, objv,"oo:osgeo::ColorEntry_c1_set self c1 ",(void *)0,(void *)0) == TCL_ERROR) SWIG_fail;
+   {
+     /* %typemap(in) GDALColorEntry* */
+     ce1.c1 = 0;
+     ce1.c2 = 0;
+     ce1.c3 = 0;
+     ce1.c4 = 255;
+     /* The following also checks if input is a list */
+     int size;
+     if (Tcl_ListObjLength(interp, objv[1], &size) != TCL_OK) {
+       /* Error msg in interp result */
+       SWIG_fail;
+     }
+     if ( size > 4 ) {
+       Tcl_SetResult(interp, (char*) "ColorEntry sequence too long", TCL_STATIC);
+       SWIG_fail;
+     }
+     if ( size < 3 ) {
+       Tcl_SetResult(interp, (char*) "ColorEntry sequence too short", TCL_STATIC);
+       SWIG_fail;
+     }
+     for( int i = 0; i<size; i++ ) {
+       Tcl_Obj **o = NULL;
+       int val;
+       /* The reference count for the list element is not incremented with the following */
+       if (Tcl_ListObjIndex(interp, objv[1], i, o) != TCL_OK) {
+         /* Error msg in interp result */
+         SWIG_fail;
+       }
+       
+       if (Tcl_GetIntFromObj(interp, *o, &val) != TCL_OK) {
+         /* Error msg in interp result */
+         SWIG_fail;
+       }
+       switch (i) {
+         case 1: ce1.c1 = (short) val; break;
+         case 2: ce1.c2 = (short) val; break;
+         case 3: ce1.c3 = (short) val; break;
+         case 4: ce1.c4 = (short) val; break;
+       }
+     }
+     arg1 = &ce1;
+   }
+   ecode2 = SWIG_AsVal_short SWIG_TCL_CALL_ARGS_2(objv[2], &val2);
+   if (!SWIG_IsOK(ecode2)) {
+     SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "ColorEntry_c1_set" "', argument " "2"" of type '" "short""'");
+   } 
+   arg2 = static_cast< short >(val2);
+   if (arg1) (arg1)->c1 = arg2;
+   
+   return TCL_OK;
+ fail:
+   return TCL_ERROR;
+ }
+ 
+ 
+ SWIGINTERN int
+ _wrap_ColorEntry_c1_get(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
+   GDALColorEntry *arg1 = (GDALColorEntry *) 0 ;
+   GDALColorEntry ce1 ;
+   short result;
+   
+   if (SWIG_GetArgs(interp, objc, objv,"o:osgeo::ColorEntry_c1_get self ",(void *)0) == TCL_ERROR) SWIG_fail;
+   {
+     /* %typemap(in) GDALColorEntry* */
+     ce1.c1 = 0;
+     ce1.c2 = 0;
+     ce1.c3 = 0;
+     ce1.c4 = 255;
+     /* The following also checks if input is a list */
+     int size;
+     if (Tcl_ListObjLength(interp, objv[1], &size) != TCL_OK) {
+       /* Error msg in interp result */
+       SWIG_fail;
+     }
+     if ( size > 4 ) {
+       Tcl_SetResult(interp, (char*) "ColorEntry sequence too long", TCL_STATIC);
+       SWIG_fail;
+     }
+     if ( size < 3 ) {
+       Tcl_SetResult(interp, (char*) "ColorEntry sequence too short", TCL_STATIC);
+       SWIG_fail;
+     }
+     for( int i = 0; i<size; i++ ) {
+       Tcl_Obj **o = NULL;
+       int val;
+       /* The reference count for the list element is not incremented with the following */
+       if (Tcl_ListObjIndex(interp, objv[1], i, o) != TCL_OK) {
+         /* Error msg in interp result */
+         SWIG_fail;
+       }
+       
+       if (Tcl_GetIntFromObj(interp, *o, &val) != TCL_OK) {
+         /* Error msg in interp result */
+         SWIG_fail;
+       }
+       switch (i) {
+         case 1: ce1.c1 = (short) val; break;
+         case 2: ce1.c2 = (short) val; break;
+         case 3: ce1.c3 = (short) val; break;
+         case 4: ce1.c4 = (short) val; break;
+       }
+     }
+     arg1 = &ce1;
+   }
+   result = (short) ((arg1)->c1);
+   Tcl_SetObjResult(interp,SWIG_From_short(static_cast< short >(result)));
+   return TCL_OK;
+ fail:
+   return TCL_ERROR;
+ }
+ 
+ 
+ SWIGINTERN int
+ _wrap_ColorEntry_c2_set(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
+   GDALColorEntry *arg1 = (GDALColorEntry *) 0 ;
+   short arg2 ;
+   GDALColorEntry ce1 ;
+   short val2 ;
+   int ecode2 = 0 ;
+   
+   if (SWIG_GetArgs(interp, objc, objv,"oo:osgeo::ColorEntry_c2_set self c2 ",(void *)0,(void *)0) == TCL_ERROR) SWIG_fail;
+   {
+     /* %typemap(in) GDALColorEntry* */
+     ce1.c1 = 0;
+     ce1.c2 = 0;
+     ce1.c3 = 0;
+     ce1.c4 = 255;
+     /* The following also checks if input is a list */
+     int size;
+     if (Tcl_ListObjLength(interp, objv[1], &size) != TCL_OK) {
+       /* Error msg in interp result */
+       SWIG_fail;
+     }
+     if ( size > 4 ) {
+       Tcl_SetResult(interp, (char*) "ColorEntry sequence too long", TCL_STATIC);
+       SWIG_fail;
+     }
+     if ( size < 3 ) {
+       Tcl_SetResult(interp, (char*) "ColorEntry sequence too short", TCL_STATIC);
+       SWIG_fail;
+     }
+     for( int i = 0; i<size; i++ ) {
+       Tcl_Obj **o = NULL;
+       int val;
+       /* The reference count for the list element is not incremented with the following */
+       if (Tcl_ListObjIndex(interp, objv[1], i, o) != TCL_OK) {
+         /* Error msg in interp result */
+         SWIG_fail;
+       }
+       
+       if (Tcl_GetIntFromObj(interp, *o, &val) != TCL_OK) {
+         /* Error msg in interp result */
+         SWIG_fail;
+       }
+       switch (i) {
+         case 1: ce1.c1 = (short) val; break;
+         case 2: ce1.c2 = (short) val; break;
+         case 3: ce1.c3 = (short) val; break;
+         case 4: ce1.c4 = (short) val; break;
+       }
+     }
+     arg1 = &ce1;
+   }
+   ecode2 = SWIG_AsVal_short SWIG_TCL_CALL_ARGS_2(objv[2], &val2);
+   if (!SWIG_IsOK(ecode2)) {
+     SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "ColorEntry_c2_set" "', argument " "2"" of type '" "short""'");
+   } 
+   arg2 = static_cast< short >(val2);
+   if (arg1) (arg1)->c2 = arg2;
+   
+   return TCL_OK;
+ fail:
+   return TCL_ERROR;
+ }
+ 
+ 
+ SWIGINTERN int
+ _wrap_ColorEntry_c2_get(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
+   GDALColorEntry *arg1 = (GDALColorEntry *) 0 ;
+   GDALColorEntry ce1 ;
+   short result;
+   
+   if (SWIG_GetArgs(interp, objc, objv,"o:osgeo::ColorEntry_c2_get self ",(void *)0) == TCL_ERROR) SWIG_fail;
+   {
+     /* %typemap(in) GDALColorEntry* */
+     ce1.c1 = 0;
+     ce1.c2 = 0;
+     ce1.c3 = 0;
+     ce1.c4 = 255;
+     /* The following also checks if input is a list */
+     int size;
+     if (Tcl_ListObjLength(interp, objv[1], &size) != TCL_OK) {
+       /* Error msg in interp result */
+       SWIG_fail;
+     }
+     if ( size > 4 ) {
+       Tcl_SetResult(interp, (char*) "ColorEntry sequence too long", TCL_STATIC);
+       SWIG_fail;
+     }
+     if ( size < 3 ) {
+       Tcl_SetResult(interp, (char*) "ColorEntry sequence too short", TCL_STATIC);
+       SWIG_fail;
+     }
+     for( int i = 0; i<size; i++ ) {
+       Tcl_Obj **o = NULL;
+       int val;
+       /* The reference count for the list element is not incremented with the following */
+       if (Tcl_ListObjIndex(interp, objv[1], i, o) != TCL_OK) {
+         /* Error msg in interp result */
+         SWIG_fail;
+       }
+       
+       if (Tcl_GetIntFromObj(interp, *o, &val) != TCL_OK) {
+         /* Error msg in interp result */
+         SWIG_fail;
+       }
+       switch (i) {
+         case 1: ce1.c1 = (short) val; break;
+         case 2: ce1.c2 = (short) val; break;
+         case 3: ce1.c3 = (short) val; break;
+         case 4: ce1.c4 = (short) val; break;
+       }
+     }
+     arg1 = &ce1;
+   }
+   result = (short) ((arg1)->c2);
+   Tcl_SetObjResult(interp,SWIG_From_short(static_cast< short >(result)));
+   return TCL_OK;
+ fail:
+   return TCL_ERROR;
+ }
+ 
+ 
+ SWIGINTERN int
+ _wrap_ColorEntry_c3_set(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
+   GDALColorEntry *arg1 = (GDALColorEntry *) 0 ;
+   short arg2 ;
+   GDALColorEntry ce1 ;
+   short val2 ;
+   int ecode2 = 0 ;
+   
+   if (SWIG_GetArgs(interp, objc, objv,"oo:osgeo::ColorEntry_c3_set self c3 ",(void *)0,(void *)0) == TCL_ERROR) SWIG_fail;
+   {
+     /* %typemap(in) GDALColorEntry* */
+     ce1.c1 = 0;
+     ce1.c2 = 0;
+     ce1.c3 = 0;
+     ce1.c4 = 255;
+     /* The following also checks if input is a list */
+     int size;
+     if (Tcl_ListObjLength(interp, objv[1], &size) != TCL_OK) {
+       /* Error msg in interp result */
+       SWIG_fail;
+     }
+     if ( size > 4 ) {
+       Tcl_SetResult(interp, (char*) "ColorEntry sequence too long", TCL_STATIC);
+       SWIG_fail;
+     }
+     if ( size < 3 ) {
+       Tcl_SetResult(interp, (char*) "ColorEntry sequence too short", TCL_STATIC);
+       SWIG_fail;
+     }
+     for( int i = 0; i<size; i++ ) {
+       Tcl_Obj **o = NULL;
+       int val;
+       /* The reference count for the list element is not incremented with the following */
+       if (Tcl_ListObjIndex(interp, objv[1], i, o) != TCL_OK) {
+         /* Error msg in interp result */
+         SWIG_fail;
+       }
+       
+       if (Tcl_GetIntFromObj(interp, *o, &val) != TCL_OK) {
+         /* Error msg in interp result */
+         SWIG_fail;
+       }
+       switch (i) {
+         case 1: ce1.c1 = (short) val; break;
+         case 2: ce1.c2 = (short) val; break;
+         case 3: ce1.c3 = (short) val; break;
+         case 4: ce1.c4 = (short) val; break;
+       }
+     }
+     arg1 = &ce1;
+   }
+   ecode2 = SWIG_AsVal_short SWIG_TCL_CALL_ARGS_2(objv[2], &val2);
+   if (!SWIG_IsOK(ecode2)) {
+     SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "ColorEntry_c3_set" "', argument " "2"" of type '" "short""'");
+   } 
+   arg2 = static_cast< short >(val2);
+   if (arg1) (arg1)->c3 = arg2;
+   
+   return TCL_OK;
+ fail:
+   return TCL_ERROR;
+ }
+ 
+ 
+ SWIGINTERN int
+ _wrap_ColorEntry_c3_get(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
+   GDALColorEntry *arg1 = (GDALColorEntry *) 0 ;
+   GDALColorEntry ce1 ;
+   short result;
+   
+   if (SWIG_GetArgs(interp, objc, objv,"o:osgeo::ColorEntry_c3_get self ",(void *)0) == TCL_ERROR) SWIG_fail;
+   {
+     /* %typemap(in) GDALColorEntry* */
+     ce1.c1 = 0;
+     ce1.c2 = 0;
+     ce1.c3 = 0;
+     ce1.c4 = 255;
+     /* The following also checks if input is a list */
+     int size;
+     if (Tcl_ListObjLength(interp, objv[1], &size) != TCL_OK) {
+       /* Error msg in interp result */
+       SWIG_fail;
+     }
+     if ( size > 4 ) {
+       Tcl_SetResult(interp, (char*) "ColorEntry sequence too long", TCL_STATIC);
+       SWIG_fail;
+     }
+     if ( size < 3 ) {
+       Tcl_SetResult(interp, (char*) "ColorEntry sequence too short", TCL_STATIC);
+       SWIG_fail;
+     }
+     for( int i = 0; i<size; i++ ) {
+       Tcl_Obj **o = NULL;
+       int val;
+       /* The reference count for the list element is not incremented with the following */
+       if (Tcl_ListObjIndex(interp, objv[1], i, o) != TCL_OK) {
+         /* Error msg in interp result */
+         SWIG_fail;
+       }
+       
+       if (Tcl_GetIntFromObj(interp, *o, &val) != TCL_OK) {
+         /* Error msg in interp result */
+         SWIG_fail;
+       }
+       switch (i) {
+         case 1: ce1.c1 = (short) val; break;
+         case 2: ce1.c2 = (short) val; break;
+         case 3: ce1.c3 = (short) val; break;
+         case 4: ce1.c4 = (short) val; break;
+       }
+     }
+     arg1 = &ce1;
+   }
+   result = (short) ((arg1)->c3);
+   Tcl_SetObjResult(interp,SWIG_From_short(static_cast< short >(result)));
+   return TCL_OK;
+ fail:
+   return TCL_ERROR;
+ }
+ 
+ 
+ SWIGINTERN int
+ _wrap_ColorEntry_c4_set(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
+   GDALColorEntry *arg1 = (GDALColorEntry *) 0 ;
+   short arg2 ;
+   GDALColorEntry ce1 ;
+   short val2 ;
+   int ecode2 = 0 ;
+   
+   if (SWIG_GetArgs(interp, objc, objv,"oo:osgeo::ColorEntry_c4_set self c4 ",(void *)0,(void *)0) == TCL_ERROR) SWIG_fail;
+   {
+     /* %typemap(in) GDALColorEntry* */
+     ce1.c1 = 0;
+     ce1.c2 = 0;
+     ce1.c3 = 0;
+     ce1.c4 = 255;
+     /* The following also checks if input is a list */
+     int size;
+     if (Tcl_ListObjLength(interp, objv[1], &size) != TCL_OK) {
+       /* Error msg in interp result */
+       SWIG_fail;
+     }
+     if ( size > 4 ) {
+       Tcl_SetResult(interp, (char*) "ColorEntry sequence too long", TCL_STATIC);
+       SWIG_fail;
+     }
+     if ( size < 3 ) {
+       Tcl_SetResult(interp, (char*) "ColorEntry sequence too short", TCL_STATIC);
+       SWIG_fail;
+     }
+     for( int i = 0; i<size; i++ ) {
+       Tcl_Obj **o = NULL;
+       int val;
+       /* The reference count for the list element is not incremented with the following */
+       if (Tcl_ListObjIndex(interp, objv[1], i, o) != TCL_OK) {
+         /* Error msg in interp result */
+         SWIG_fail;
+       }
+       
+       if (Tcl_GetIntFromObj(interp, *o, &val) != TCL_OK) {
+         /* Error msg in interp result */
+         SWIG_fail;
+       }
+       switch (i) {
+         case 1: ce1.c1 = (short) val; break;
+         case 2: ce1.c2 = (short) val; break;
+         case 3: ce1.c3 = (short) val; break;
+         case 4: ce1.c4 = (short) val; break;
+       }
+     }
+     arg1 = &ce1;
+   }
+   ecode2 = SWIG_AsVal_short SWIG_TCL_CALL_ARGS_2(objv[2], &val2);
+   if (!SWIG_IsOK(ecode2)) {
+     SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "ColorEntry_c4_set" "', argument " "2"" of type '" "short""'");
+   } 
+   arg2 = static_cast< short >(val2);
+   if (arg1) (arg1)->c4 = arg2;
+   
+   return TCL_OK;
+ fail:
+   return TCL_ERROR;
+ }
+ 
+ 
+ SWIGINTERN int
+ _wrap_ColorEntry_c4_get(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
+   GDALColorEntry *arg1 = (GDALColorEntry *) 0 ;
+   GDALColorEntry ce1 ;
+   short result;
+   
+   if (SWIG_GetArgs(interp, objc, objv,"o:osgeo::ColorEntry_c4_get self ",(void *)0) == TCL_ERROR) SWIG_fail;
+   {
+     /* %typemap(in) GDALColorEntry* */
+     ce1.c1 = 0;
+     ce1.c2 = 0;
+     ce1.c3 = 0;
+     ce1.c4 = 255;
+     /* The following also checks if input is a list */
+     int size;
+     if (Tcl_ListObjLength(interp, objv[1], &size) != TCL_OK) {
+       /* Error msg in interp result */
+       SWIG_fail;
+     }
+     if ( size > 4 ) {
+       Tcl_SetResult(interp, (char*) "ColorEntry sequence too long", TCL_STATIC);
+       SWIG_fail;
+     }
+     if ( size < 3 ) {
+       Tcl_SetResult(interp, (char*) "ColorEntry sequence too short", TCL_STATIC);
+       SWIG_fail;
+     }
+     for( int i = 0; i<size; i++ ) {
+       Tcl_Obj **o = NULL;
+       int val;
+       /* The reference count for the list element is not incremented with the following */
+       if (Tcl_ListObjIndex(interp, objv[1], i, o) != TCL_OK) {
+         /* Error msg in interp result */
+         SWIG_fail;
+       }
+       
+       if (Tcl_GetIntFromObj(interp, *o, &val) != TCL_OK) {
+         /* Error msg in interp result */
+         SWIG_fail;
+       }
+       switch (i) {
+         case 1: ce1.c1 = (short) val; break;
+         case 2: ce1.c2 = (short) val; break;
+         case 3: ce1.c3 = (short) val; break;
+         case 4: ce1.c4 = (short) val; break;
+       }
+     }
+     arg1 = &ce1;
+   }
+   result = (short) ((arg1)->c4);
+   Tcl_SetObjResult(interp,SWIG_From_short(static_cast< short >(result)));
+   return TCL_OK;
+ fail:
+   return TCL_ERROR;
+ }
+ 
+ 
+ SWIGINTERN int
+ _wrap_new_ColorEntry(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
+   GDALColorEntry *result = 0 ;
+   
+   if (SWIG_GetArgs(interp, objc, objv,":osgeo::new_ColorEntry ") == TCL_ERROR) SWIG_fail;
+   {
+     CPLErrorReset();
+     result = (GDALColorEntry *)new GDALColorEntry();
+     CPLErr eclass = CPLGetLastErrorType();
+     if ( eclass == CE_Failure || eclass == CE_Fatal ) {
+       SWIG_exception( SWIG_RuntimeError, CPLGetLastErrorMsg() );
+       
+     }
+     
+     
+     
+     
+     
+     
+     
+     
+     
+     
+     
+   }
+   {
+     /* %typemap(out) GDALColorEntry* */
+     Tcl_Obj *out = Tcl_NewListObj(0, NULL);
+     Tcl_Obj *val;
+     val  = Tcl_NewIntObj((*result).c1);
+     if (Tcl_ListObjAppendElement(interp, out, val) != TCL_OK) {
+       Tcl_DecrRefCount(val);
+       Tcl_DecrRefCount(out);
+       SWIG_fail;
+     }
+     val = Tcl_NewIntObj((*result).c2);
+     if (Tcl_ListObjAppendElement(interp, out, val) != TCL_OK) {
+       Tcl_DecrRefCount(val);
+       Tcl_DecrRefCount(out);
+       SWIG_fail;
+     }
+     val = Tcl_NewIntObj((*result).c3);
+     if (Tcl_ListObjAppendElement(interp, out, val) != TCL_OK) {
+       Tcl_DecrRefCount(val);
+       Tcl_DecrRefCount(out);
+       SWIG_fail;
+     }
+     val = Tcl_NewIntObj((*result).c4);
+     if (Tcl_ListObjAppendElement(interp, out, val) != TCL_OK) {
+       Tcl_DecrRefCount(val);
+       Tcl_DecrRefCount(out);
+       SWIG_fail;
+     }
+     Tcl_SetObjResult(interp, out);
+     
+     /* More compact: (If used, the next typemap must be modified as well)
+            Tcl_SetObjResult(interp, Tcl_ObjPrintf("%x%x%x%x", (*result).c1, (*result).c2, (*result).c3, (*result).c4));
+          */
+   }
+   return TCL_OK;
+ fail:
+   return TCL_ERROR;
+ }
+ 
+ 
+ SWIGINTERN int
+ _wrap_delete_ColorEntry(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
+   GDALColorEntry *arg1 = (GDALColorEntry *) 0 ;
+   GDALColorEntry ce1 ;
+   
+   if (SWIG_GetArgs(interp, objc, objv,"o:osgeo::delete_ColorEntry self ",(void *)0) == TCL_ERROR) SWIG_fail;
+   {
+     /* %typemap(in) GDALColorEntry* */
+     ce1.c1 = 0;
+     ce1.c2 = 0;
+     ce1.c3 = 0;
+     ce1.c4 = 255;
+     /* The following also checks if input is a list */
+     int size;
+     if (Tcl_ListObjLength(interp, objv[1], &size) != TCL_OK) {
+       /* Error msg in interp result */
+       SWIG_fail;
+     }
+     if ( size > 4 ) {
+       Tcl_SetResult(interp, (char*) "ColorEntry sequence too long", TCL_STATIC);
+       SWIG_fail;
+     }
+     if ( size < 3 ) {
+       Tcl_SetResult(interp, (char*) "ColorEntry sequence too short", TCL_STATIC);
+       SWIG_fail;
+     }
+     for( int i = 0; i<size; i++ ) {
+       Tcl_Obj **o = NULL;
+       int val;
+       /* The reference count for the list element is not incremented with the following */
+       if (Tcl_ListObjIndex(interp, objv[1], i, o) != TCL_OK) {
+         /* Error msg in interp result */
+         SWIG_fail;
+       }
+       
+       if (Tcl_GetIntFromObj(interp, *o, &val) != TCL_OK) {
+         /* Error msg in interp result */
+         SWIG_fail;
+       }
+       switch (i) {
+         case 1: ce1.c1 = (short) val; break;
+         case 2: ce1.c2 = (short) val; break;
+         case 3: ce1.c3 = (short) val; break;
+         case 4: ce1.c4 = (short) val; break;
+       }
+     }
+     arg1 = &ce1;
+   }
+   {
+     CPLErrorReset();
+     delete arg1;
+     CPLErr eclass = CPLGetLastErrorType();
+     if ( eclass == CE_Failure || eclass == CE_Fatal ) {
+       SWIG_exception( SWIG_RuntimeError, CPLGetLastErrorMsg() );
+       
+     }
+     
+     
+     
+     
+     
+     
+     
+     
+     
+     
+     
+   }
+   
+   return TCL_OK;
+ fail:
+   return TCL_ERROR;
+ }
+ 
+ 
+ SWIGINTERN void swig_delete_ColorEntry(void *obj) {
+ GDALColorEntry *arg1 = (GDALColorEntry *) obj;
+ delete arg1;
+ }
+ static swig_method swig_GDALColorEntry_methods[] = {
+     {0,0}
+ };
+ static swig_attribute swig_GDALColorEntry_attributes[] = {
+     { "-c1",_wrap_ColorEntry_c1_get, _wrap_ColorEntry_c1_set},
+     { "-c2",_wrap_ColorEntry_c2_get, _wrap_ColorEntry_c2_set},
+     { "-c3",_wrap_ColorEntry_c3_get, _wrap_ColorEntry_c3_set},
+     { "-c4",_wrap_ColorEntry_c4_get, _wrap_ColorEntry_c4_set},
+     {0,0,0}
+ };
+ static swig_class *swig_GDALColorEntry_bases[] = {0};
+ static const char * swig_GDALColorEntry_base_names[] = {0};
+ static swig_class _wrap_class_GDALColorEntry = { "ColorEntry", &SWIGTYPE_p_GDALColorEntry,_wrap_new_ColorEntry, swig_delete_ColorEntry, swig_GDALColorEntry_methods, swig_GDALColorEntry_attributes, swig_GDALColorEntry_bases,swig_GDALColorEntry_base_names, &swig_module };
+ SWIGINTERN int
+ _wrap_GCP_GCPX_set(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
+   GDAL_GCP *arg1 = (GDAL_GCP *) 0 ;
+   double arg2 ;
+   void *argp1 = 0 ;
+   int res1 = 0 ;
+   double val2 ;
+   int ecode2 = 0 ;
+   
+   if (SWIG_GetArgs(interp, objc, objv,"oo:osgeo::GCP_GCPX_set self GCPX ",(void *)0,(void *)0) == TCL_ERROR) SWIG_fail;
+   res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_GDAL_GCP, 0 |  0 );
+   if (!SWIG_IsOK(res1)) {
+     SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "GCP_GCPX_set" "', argument " "1"" of type '" "GDAL_GCP *""'"); 
+   }
+   arg1 = reinterpret_cast< GDAL_GCP * >(argp1);
+   ecode2 = SWIG_AsVal_double SWIG_TCL_CALL_ARGS_2(objv[2], &val2);
+   if (!SWIG_IsOK(ecode2)) {
+     SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "GCP_GCPX_set" "', argument " "2"" of type '" "double""'");
+   } 
+   arg2 = static_cast< double >(val2);
+   {
+     CPLErrorReset();
+     GDAL_GCP_GCPX_set(arg1,arg2);
+     CPLErr eclass = CPLGetLastErrorType();
+     if ( eclass == CE_Failure || eclass == CE_Fatal ) {
+       SWIG_exception( SWIG_RuntimeError, CPLGetLastErrorMsg() );
+       
+     }
+     
+     
+     
+     
+     
+     
+     
+     
+     
+     
+     
+   }
+   
+   return TCL_OK;
+ fail:
+   return TCL_ERROR;
+ }
+ 
+ 
+ SWIGINTERN int
+ _wrap_GCP_GCPX_get(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
+   GDAL_GCP *arg1 = (GDAL_GCP *) 0 ;
+   void *argp1 = 0 ;
+   int res1 = 0 ;
+   double result;
+   
+   if (SWIG_GetArgs(interp, objc, objv,"o:osgeo::GCP_GCPX_get self ",(void *)0) == TCL_ERROR) SWIG_fail;
+   res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_GDAL_GCP, 0 |  0 );
+   if (!SWIG_IsOK(res1)) {
+     SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "GCP_GCPX_get" "', argument " "1"" of type '" "GDAL_GCP *""'"); 
+   }
+   arg1 = reinterpret_cast< GDAL_GCP * >(argp1);
+   {
+     CPLErrorReset();
+     result = (double)GDAL_GCP_GCPX_get(arg1);
+     CPLErr eclass = CPLGetLastErrorType();
+     if ( eclass == CE_Failure || eclass == CE_Fatal ) {
+       SWIG_exception( SWIG_RuntimeError, CPLGetLastErrorMsg() );
+       
+     }
+     
+     
+     
+     
+     
+     
+     
+     
+     
+     
+     
+   }
+   Tcl_SetObjResult(interp,SWIG_From_double(static_cast< double >(result)));
+   return TCL_OK;
+ fail:
+   return TCL_ERROR;
+ }
+ 
+ 
+ SWIGINTERN int
+ _wrap_GCP_GCPY_set(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
+   GDAL_GCP *arg1 = (GDAL_GCP *) 0 ;
+   double arg2 ;
+   void *argp1 = 0 ;
+   int res1 = 0 ;
+   double val2 ;
+   int ecode2 = 0 ;
+   
+   if (SWIG_GetArgs(interp, objc, objv,"oo:osgeo::GCP_GCPY_set self GCPY ",(void *)0,(void *)0) == TCL_ERROR) SWIG_fail;
+   res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_GDAL_GCP, 0 |  0 );
+   if (!SWIG_IsOK(res1)) {
+     SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "GCP_GCPY_set" "', argument " "1"" of type '" "GDAL_GCP *""'"); 
+   }
+   arg1 = reinterpret_cast< GDAL_GCP * >(argp1);
+   ecode2 = SWIG_AsVal_double SWIG_TCL_CALL_ARGS_2(objv[2], &val2);
+   if (!SWIG_IsOK(ecode2)) {
+     SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "GCP_GCPY_set" "', argument " "2"" of type '" "double""'");
+   } 
+   arg2 = static_cast< double >(val2);
+   {
+     CPLErrorReset();
+     GDAL_GCP_GCPY_set(arg1,arg2);
+     CPLErr eclass = CPLGetLastErrorType();
+     if ( eclass == CE_Failure || eclass == CE_Fatal ) {
+       SWIG_exception( SWIG_RuntimeError, CPLGetLastErrorMsg() );
+       
+     }
+     
+     
+     
+     
+     
+     
+     
+     
+     
+     
+     
+   }
+   
+   return TCL_OK;
+ fail:
+   return TCL_ERROR;
+ }
+ 
+ 
+ SWIGINTERN int
+ _wrap_GCP_GCPY_get(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
+   GDAL_GCP *arg1 = (GDAL_GCP *) 0 ;
+   void *argp1 = 0 ;
+   int res1 = 0 ;
+   double result;
+   
+   if (SWIG_GetArgs(interp, objc, objv,"o:osgeo::GCP_GCPY_get self ",(void *)0) == TCL_ERROR) SWIG_fail;
+   res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_GDAL_GCP, 0 |  0 );
+   if (!SWIG_IsOK(res1)) {
+     SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "GCP_GCPY_get" "', argument " "1"" of type '" "GDAL_GCP *""'"); 
+   }
+   arg1 = reinterpret_cast< GDAL_GCP * >(argp1);
+   {
+     CPLErrorReset();
+     result = (double)GDAL_GCP_GCPY_get(arg1);
+     CPLErr eclass = CPLGetLastErrorType();
+     if ( eclass == CE_Failure || eclass == CE_Fatal ) {
+       SWIG_exception( SWIG_RuntimeError, CPLGetLastErrorMsg() );
+       
+     }
+     
+     
+     
+     
+     
+     
+     
+     
+     
+     
+     
+   }
+   Tcl_SetObjResult(interp,SWIG_From_double(static_cast< double >(result)));
+   return TCL_OK;
+ fail:
+   return TCL_ERROR;
+ }
+ 
+ 
+ SWIGINTERN int
+ _wrap_GCP_GCPZ_set(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
+   GDAL_GCP *arg1 = (GDAL_GCP *) 0 ;
+   double arg2 ;
+   void *argp1 = 0 ;
+   int res1 = 0 ;
+   double val2 ;
+   int ecode2 = 0 ;
+   
+   if (SWIG_GetArgs(interp, objc, objv,"oo:osgeo::GCP_GCPZ_set self GCPZ ",(void *)0,(void *)0) == TCL_ERROR) SWIG_fail;
+   res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_GDAL_GCP, 0 |  0 );
+   if (!SWIG_IsOK(res1)) {
+     SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "GCP_GCPZ_set" "', argument " "1"" of type '" "GDAL_GCP *""'"); 
+   }
+   arg1 = reinterpret_cast< GDAL_GCP * >(argp1);
+   ecode2 = SWIG_AsVal_double SWIG_TCL_CALL_ARGS_2(objv[2], &val2);
+   if (!SWIG_IsOK(ecode2)) {
+     SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "GCP_GCPZ_set" "', argument " "2"" of type '" "double""'");
+   } 
+   arg2 = static_cast< double >(val2);
+   {
+     CPLErrorReset();
+     GDAL_GCP_GCPZ_set(arg1,arg2);
+     CPLErr eclass = CPLGetLastErrorType();
+     if ( eclass == CE_Failure || eclass == CE_Fatal ) {
+       SWIG_exception( SWIG_RuntimeError, CPLGetLastErrorMsg() );
+       
+     }
+     
+     
+     
+     
+     
+     
+     
+     
+     
+     
+     
+   }
+   
+   return TCL_OK;
+ fail:
+   return TCL_ERROR;
+ }
+ 
+ 
+ SWIGINTERN int
+ _wrap_GCP_GCPZ_get(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
+   GDAL_GCP *arg1 = (GDAL_GCP *) 0 ;
+   void *argp1 = 0 ;
+   int res1 = 0 ;
+   double result;
+   
+   if (SWIG_GetArgs(interp, objc, objv,"o:osgeo::GCP_GCPZ_get self ",(void *)0) == TCL_ERROR) SWIG_fail;
+   res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_GDAL_GCP, 0 |  0 );
+   if (!SWIG_IsOK(res1)) {
+     SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "GCP_GCPZ_get" "', argument " "1"" of type '" "GDAL_GCP *""'"); 
+   }
+   arg1 = reinterpret_cast< GDAL_GCP * >(argp1);
+   {
+     CPLErrorReset();
+     result = (double)GDAL_GCP_GCPZ_get(arg1);
+     CPLErr eclass = CPLGetLastErrorType();
+     if ( eclass == CE_Failure || eclass == CE_Fatal ) {
+       SWIG_exception( SWIG_RuntimeError, CPLGetLastErrorMsg() );
+       
+     }
+     
+     
+     
+     
+     
+     
+     
+     
+     
+     
+     
+   }
+   Tcl_SetObjResult(interp,SWIG_From_double(static_cast< double >(result)));
+   return TCL_OK;
+ fail:
+   return TCL_ERROR;
+ }
+ 
+ 
+ SWIGINTERN int
+ _wrap_GCP_GCPPixel_set(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
+   GDAL_GCP *arg1 = (GDAL_GCP *) 0 ;
+   double arg2 ;
+   void *argp1 = 0 ;
+   int res1 = 0 ;
+   double val2 ;
+   int ecode2 = 0 ;
+   
+   if (SWIG_GetArgs(interp, objc, objv,"oo:osgeo::GCP_GCPPixel_set self GCPPixel ",(void *)0,(void *)0) == TCL_ERROR) SWIG_fail;
+   res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_GDAL_GCP, 0 |  0 );
+   if (!SWIG_IsOK(res1)) {
+     SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "GCP_GCPPixel_set" "', argument " "1"" of type '" "GDAL_GCP *""'"); 
+   }
+   arg1 = reinterpret_cast< GDAL_GCP * >(argp1);
+   ecode2 = SWIG_AsVal_double SWIG_TCL_CALL_ARGS_2(objv[2], &val2);
+   if (!SWIG_IsOK(ecode2)) {
+     SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "GCP_GCPPixel_set" "', argument " "2"" of type '" "double""'");
+   } 
+   arg2 = static_cast< double >(val2);
+   {
+     CPLErrorReset();
+     GDAL_GCP_GCPPixel_set(arg1,arg2);
+     CPLErr eclass = CPLGetLastErrorType();
+     if ( eclass == CE_Failure || eclass == CE_Fatal ) {
+       SWIG_exception( SWIG_RuntimeError, CPLGetLastErrorMsg() );
+       
+     }
+     
+     
+     
+     
+     
+     
+     
+     
+     
+     
+     
+   }
+   
+   return TCL_OK;
+ fail:
+   return TCL_ERROR;
+ }
+ 
+ 
+ SWIGINTERN int
+ _wrap_GCP_GCPPixel_get(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
+   GDAL_GCP *arg1 = (GDAL_GCP *) 0 ;
+   void *argp1 = 0 ;
+   int res1 = 0 ;
+   double result;
+   
+   if (SWIG_GetArgs(interp, objc, objv,"o:osgeo::GCP_GCPPixel_get self ",(void *)0) == TCL_ERROR) SWIG_fail;
+   res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_GDAL_GCP, 0 |  0 );
+   if (!SWIG_IsOK(res1)) {
+     SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "GCP_GCPPixel_get" "', argument " "1"" of type '" "GDAL_GCP *""'"); 
+   }
+   arg1 = reinterpret_cast< GDAL_GCP * >(argp1);
+   {
+     CPLErrorReset();
+     result = (double)GDAL_GCP_GCPPixel_get(arg1);
+     CPLErr eclass = CPLGetLastErrorType();
+     if ( eclass == CE_Failure || eclass == CE_Fatal ) {
+       SWIG_exception( SWIG_RuntimeError, CPLGetLastErrorMsg() );
+       
+     }
+     
+     
+     
+     
+     
+     
+     
+     
+     
+     
+     
+   }
+   Tcl_SetObjResult(interp,SWIG_From_double(static_cast< double >(result)));
+   return TCL_OK;
+ fail:
+   return TCL_ERROR;
+ }
+ 
+ 
+ SWIGINTERN int
+ _wrap_GCP_GCPLine_set(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
+   GDAL_GCP *arg1 = (GDAL_GCP *) 0 ;
+   double arg2 ;
+   void *argp1 = 0 ;
+   int res1 = 0 ;
+   double val2 ;
+   int ecode2 = 0 ;
+   
+   if (SWIG_GetArgs(interp, objc, objv,"oo:osgeo::GCP_GCPLine_set self GCPLine ",(void *)0,(void *)0) == TCL_ERROR) SWIG_fail;
+   res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_GDAL_GCP, 0 |  0 );
+   if (!SWIG_IsOK(res1)) {
+     SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "GCP_GCPLine_set" "', argument " "1"" of type '" "GDAL_GCP *""'"); 
+   }
+   arg1 = reinterpret_cast< GDAL_GCP * >(argp1);
+   ecode2 = SWIG_AsVal_double SWIG_TCL_CALL_ARGS_2(objv[2], &val2);
+   if (!SWIG_IsOK(ecode2)) {
+     SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "GCP_GCPLine_set" "', argument " "2"" of type '" "double""'");
+   } 
+   arg2 = static_cast< double >(val2);
+   {
+     CPLErrorReset();
+     GDAL_GCP_GCPLine_set(arg1,arg2);
+     CPLErr eclass = CPLGetLastErrorType();
+     if ( eclass == CE_Failure || eclass == CE_Fatal ) {
+       SWIG_exception( SWIG_RuntimeError, CPLGetLastErrorMsg() );
+       
+     }
+     
+     
+     
+     
+     
+     
+     
+     
+     
+     
+     
+   }
+   
+   return TCL_OK;
+ fail:
+   return TCL_ERROR;
+ }
+ 
+ 
+ SWIGINTERN int
+ _wrap_GCP_GCPLine_get(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
+   GDAL_GCP *arg1 = (GDAL_GCP *) 0 ;
+   void *argp1 = 0 ;
+   int res1 = 0 ;
+   double result;
+   
+   if (SWIG_GetArgs(interp, objc, objv,"o:osgeo::GCP_GCPLine_get self ",(void *)0) == TCL_ERROR) SWIG_fail;
+   res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_GDAL_GCP, 0 |  0 );
+   if (!SWIG_IsOK(res1)) {
+     SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "GCP_GCPLine_get" "', argument " "1"" of type '" "GDAL_GCP *""'"); 
+   }
+   arg1 = reinterpret_cast< GDAL_GCP * >(argp1);
+   {
+     CPLErrorReset();
+     result = (double)GDAL_GCP_GCPLine_get(arg1);
+     CPLErr eclass = CPLGetLastErrorType();
+     if ( eclass == CE_Failure || eclass == CE_Fatal ) {
+       SWIG_exception( SWIG_RuntimeError, CPLGetLastErrorMsg() );
+       
+     }
+     
+     
+     
+     
+     
+     
+     
+     
+     
+     
+     
+   }
+   Tcl_SetObjResult(interp,SWIG_From_double(static_cast< double >(result)));
+   return TCL_OK;
+ fail:
+   return TCL_ERROR;
+ }
+ 
+ 
+ SWIGINTERN int
+ _wrap_GCP_Info_set(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
+   GDAL_GCP *arg1 = (GDAL_GCP *) 0 ;
+   char *arg2 = (char *) 0 ;
+   void *argp1 = 0 ;
+   int res1 = 0 ;
+   int res2 ;
+   char *buf2 = 0 ;
+   int alloc2 = 0 ;
+   
+   if (SWIG_GetArgs(interp, objc, objv,"oo:osgeo::GCP_Info_set self Info ",(void *)0,(void *)0) == TCL_ERROR) SWIG_fail;
+   res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_GDAL_GCP, 0 |  0 );
+   if (!SWIG_IsOK(res1)) {
+     SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "GCP_Info_set" "', argument " "1"" of type '" "GDAL_GCP *""'"); 
+   }
+   arg1 = reinterpret_cast< GDAL_GCP * >(argp1);
+   res2 = SWIG_AsCharPtrAndSize(objv[2], &buf2, NULL, &alloc2);
+   if (!SWIG_IsOK(res2)) {
+     SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "GCP_Info_set" "', argument " "2"" of type '" "char *""'");
+   }
+   arg2 = reinterpret_cast< char * >(buf2);
+   {
+     CPLErrorReset();
+     GDAL_GCP_Info_set(arg1,arg2);
+     CPLErr eclass = CPLGetLastErrorType();
+     if ( eclass == CE_Failure || eclass == CE_Fatal ) {
+       SWIG_exception( SWIG_RuntimeError, CPLGetLastErrorMsg() );
+       
+     }
+     
+     
+     
+     
+     
+     
+     
+     
+     
+     
+     
+   }
+   
+   if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
+   return TCL_OK;
+ fail:
+   if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
+   return TCL_ERROR;
+ }
+ 
+ 
+ SWIGINTERN int
+ _wrap_GCP_Info_get(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
+   GDAL_GCP *arg1 = (GDAL_GCP *) 0 ;
+   void *argp1 = 0 ;
+   int res1 = 0 ;
+   char *result = 0 ;
+   
+   if (SWIG_GetArgs(interp, objc, objv,"o:osgeo::GCP_Info_get self ",(void *)0) == TCL_ERROR) SWIG_fail;
+   res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_GDAL_GCP, 0 |  0 );
+   if (!SWIG_IsOK(res1)) {
+     SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "GCP_Info_get" "', argument " "1"" of type '" "GDAL_GCP *""'"); 
+   }
+   arg1 = reinterpret_cast< GDAL_GCP * >(argp1);
+   {
+     CPLErrorReset();
+     result = (char *)GDAL_GCP_Info_get(arg1);
+     CPLErr eclass = CPLGetLastErrorType();
+     if ( eclass == CE_Failure || eclass == CE_Fatal ) {
+       SWIG_exception( SWIG_RuntimeError, CPLGetLastErrorMsg() );
+       
+     }
+     
+     
+     
+     
+     
+     
+     
+     
+     
+     
+     
+   }
+   Tcl_SetObjResult(interp,SWIG_FromCharPtr((const char *)result));
+   return TCL_OK;
+ fail:
+   return TCL_ERROR;
+ }
+ 
+ 
+ SWIGINTERN int
+ _wrap_GCP_Id_set(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
+   GDAL_GCP *arg1 = (GDAL_GCP *) 0 ;
+   char *arg2 = (char *) 0 ;
+   void *argp1 = 0 ;
+   int res1 = 0 ;
+   int res2 ;
+   char *buf2 = 0 ;
+   int alloc2 = 0 ;
+   
+   if (SWIG_GetArgs(interp, objc, objv,"oo:osgeo::GCP_Id_set self Id ",(void *)0,(void *)0) == TCL_ERROR) SWIG_fail;
+   res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_GDAL_GCP, 0 |  0 );
+   if (!SWIG_IsOK(res1)) {
+     SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "GCP_Id_set" "', argument " "1"" of type '" "GDAL_GCP *""'"); 
+   }
+   arg1 = reinterpret_cast< GDAL_GCP * >(argp1);
+   res2 = SWIG_AsCharPtrAndSize(objv[2], &buf2, NULL, &alloc2);
+   if (!SWIG_IsOK(res2)) {
+     SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "GCP_Id_set" "', argument " "2"" of type '" "char *""'");
+   }
+   arg2 = reinterpret_cast< char * >(buf2);
+   {
+     CPLErrorReset();
+     GDAL_GCP_Id_set(arg1,arg2);
+     CPLErr eclass = CPLGetLastErrorType();
+     if ( eclass == CE_Failure || eclass == CE_Fatal ) {
+       SWIG_exception( SWIG_RuntimeError, CPLGetLastErrorMsg() );
+       
+     }
+     
+     
+     
+     
+     
+     
+     
+     
+     
+     
+     
+   }
+   
+   if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
+   return TCL_OK;
+ fail:
+   if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
+   return TCL_ERROR;
+ }
+ 
+ 
+ SWIGINTERN int
+ _wrap_GCP_Id_get(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
+   GDAL_GCP *arg1 = (GDAL_GCP *) 0 ;
+   void *argp1 = 0 ;
+   int res1 = 0 ;
+   char *result = 0 ;
+   
+   if (SWIG_GetArgs(interp, objc, objv,"o:osgeo::GCP_Id_get self ",(void *)0) == TCL_ERROR) SWIG_fail;
+   res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_GDAL_GCP, 0 |  0 );
+   if (!SWIG_IsOK(res1)) {
+     SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "GCP_Id_get" "', argument " "1"" of type '" "GDAL_GCP *""'"); 
+   }
+   arg1 = reinterpret_cast< GDAL_GCP * >(argp1);
+   {
+     CPLErrorReset();
+     result = (char *)GDAL_GCP_Id_get(arg1);
+     CPLErr eclass = CPLGetLastErrorType();
+     if ( eclass == CE_Failure || eclass == CE_Fatal ) {
+       SWIG_exception( SWIG_RuntimeError, CPLGetLastErrorMsg() );
+       
+     }
+     
+     
+     
+     
+     
+     
+     
+     
+     
+     
+     
+   }
+   Tcl_SetObjResult(interp,SWIG_FromCharPtr((const char *)result));
+   return TCL_OK;
+ fail:
+   return TCL_ERROR;
+ }
+ 
+ 
+ SWIGINTERN int
+ _wrap_new_GCP(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
+   double arg1 = (double) 0.0 ;
+   double arg2 = (double) 0.0 ;
+   double arg3 = (double) 0.0 ;
+   double arg4 = (double) 0.0 ;
+   double arg5 = (double) 0.0 ;
+   char *arg6 = (char *) "" ;
+   char *arg7 = (char *) "" ;
+   double val1 ;
+   int ecode1 = 0 ;
+   double val2 ;
+   int ecode2 = 0 ;
+   double val3 ;
+   int ecode3 = 0 ;
+   double val4 ;
+   int ecode4 = 0 ;
+   double val5 ;
+   int ecode5 = 0 ;
+   int res6 ;
+   char *buf6 = 0 ;
+   int alloc6 = 0 ;
+   int res7 ;
+   char *buf7 = 0 ;
+   int alloc7 = 0 ;
+   GDAL_GCP *result = 0 ;
+   
+   if (SWIG_GetArgs(interp, objc, objv,"|ooooooo:osgeo::new_GCP ?x? ?y? ?z? ?pixel? ?line? ?info? ?id? ",(void *)0,(void *)0,(void *)0,(void *)0,(void *)0,(void *)0,(void *)0) == TCL_ERROR) SWIG_fail;
+   if (objc > 1) {
+     ecode1 = SWIG_AsVal_double SWIG_TCL_CALL_ARGS_2(objv[1], &val1);
+     if (!SWIG_IsOK(ecode1)) {
+       SWIG_exception_fail(SWIG_ArgError(ecode1), "in method '" "new_GCP" "', argument " "1"" of type '" "double""'");
+     } 
+     arg1 = static_cast< double >(val1);
+   }
+   if (objc > 2) {
+     ecode2 = SWIG_AsVal_double SWIG_TCL_CALL_ARGS_2(objv[2], &val2);
+     if (!SWIG_IsOK(ecode2)) {
+       SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "new_GCP" "', argument " "2"" of type '" "double""'");
+     } 
+     arg2 = static_cast< double >(val2);
+   }
+   if (objc > 3) {
+     ecode3 = SWIG_AsVal_double SWIG_TCL_CALL_ARGS_2(objv[3], &val3);
+     if (!SWIG_IsOK(ecode3)) {
+       SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "new_GCP" "', argument " "3"" of type '" "double""'");
+     } 
+     arg3 = static_cast< double >(val3);
+   }
+   if (objc > 4) {
+     ecode4 = SWIG_AsVal_double SWIG_TCL_CALL_ARGS_2(objv[4], &val4);
+     if (!SWIG_IsOK(ecode4)) {
+       SWIG_exception_fail(SWIG_ArgError(ecode4), "in method '" "new_GCP" "', argument " "4"" of type '" "double""'");
+     } 
+     arg4 = static_cast< double >(val4);
+   }
+   if (objc > 5) {
+     ecode5 = SWIG_AsVal_double SWIG_TCL_CALL_ARGS_2(objv[5], &val5);
+     if (!SWIG_IsOK(ecode5)) {
+       SWIG_exception_fail(SWIG_ArgError(ecode5), "in method '" "new_GCP" "', argument " "5"" of type '" "double""'");
+     } 
+     arg5 = static_cast< double >(val5);
+   }
+   if (objc > 6) {
+     res6 = SWIG_AsCharPtrAndSize(objv[6], &buf6, NULL, &alloc6);
+     if (!SWIG_IsOK(res6)) {
+       SWIG_exception_fail(SWIG_ArgError(res6), "in method '" "new_GCP" "', argument " "6"" of type '" "char const *""'");
+     }
+     arg6 = reinterpret_cast< char * >(buf6);
+   }
+   if (objc > 7) {
+     res7 = SWIG_AsCharPtrAndSize(objv[7], &buf7, NULL, &alloc7);
+     if (!SWIG_IsOK(res7)) {
+       SWIG_exception_fail(SWIG_ArgError(res7), "in method '" "new_GCP" "', argument " "7"" of type '" "char const *""'");
+     }
+     arg7 = reinterpret_cast< char * >(buf7);
+   }
+   {
+     CPLErrorReset();
+     result = (GDAL_GCP *)new_GDAL_GCP(arg1,arg2,arg3,arg4,arg5,(char const *)arg6,(char const *)arg7);
+     CPLErr eclass = CPLGetLastErrorType();
+     if ( eclass == CE_Failure || eclass == CE_Fatal ) {
+       SWIG_exception( SWIG_RuntimeError, CPLGetLastErrorMsg() );
+       
+     }
+     
+     
+     
+     
+     
+     
+     
+     
+     
+     
+     
+   }
+   Tcl_SetObjResult(interp, SWIG_NewInstanceObj( SWIG_as_voidptr(result), SWIGTYPE_p_GDAL_GCP,0));
+   if (alloc6 == SWIG_NEWOBJ) delete[] buf6;
+   if (alloc7 == SWIG_NEWOBJ) delete[] buf7;
+   return TCL_OK;
+ fail:
+   if (alloc6 == SWIG_NEWOBJ) delete[] buf6;
+   if (alloc7 == SWIG_NEWOBJ) delete[] buf7;
+   return TCL_ERROR;
+ }
+ 
+ 
+ SWIGINTERN int
+ _wrap_delete_GCP(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
+   GDAL_GCP *arg1 = (GDAL_GCP *) 0 ;
+   void *argp1 = 0 ;
+   int res1 = 0 ;
+   
+   if (SWIG_GetArgs(interp, objc, objv,"o:osgeo::delete_GCP self ",(void *)0) == TCL_ERROR) SWIG_fail;
+   res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_GDAL_GCP, SWIG_POINTER_DISOWN |  0 );
+   if (!SWIG_IsOK(res1)) {
+     SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "delete_GCP" "', argument " "1"" of type '" "GDAL_GCP *""'"); 
+   }
+   arg1 = reinterpret_cast< GDAL_GCP * >(argp1);
+   {
+     CPLErrorReset();
+     delete_GDAL_GCP(arg1);
+     CPLErr eclass = CPLGetLastErrorType();
+     if ( eclass == CE_Failure || eclass == CE_Fatal ) {
+       SWIG_exception( SWIG_RuntimeError, CPLGetLastErrorMsg() );
+       
+     }
+     
+     
+     
+     
+     
+     
+     
+     
+     
+     
+     
+   }
+   
+   return TCL_OK;
+ fail:
+   return TCL_ERROR;
+ }
+ 
+ 
+ SWIGINTERN void swig_delete_GCP(void *obj) {
+ GDAL_GCP *arg1 = (GDAL_GCP *) obj;
+ delete_GDAL_GCP(arg1);
+ }
+ static swig_method swig_GDAL_GCP_methods[] = {
+     {0,0}
+ };
+ static swig_attribute swig_GDAL_GCP_attributes[] = {
+     { "-GCPX",_wrap_GCP_GCPX_get, _wrap_GCP_GCPX_set},
+     { "-GCPY",_wrap_GCP_GCPY_get, _wrap_GCP_GCPY_set},
+     { "-GCPZ",_wrap_GCP_GCPZ_get, _wrap_GCP_GCPZ_set},
+     { "-GCPPixel",_wrap_GCP_GCPPixel_get, _wrap_GCP_GCPPixel_set},
+     { "-GCPLine",_wrap_GCP_GCPLine_get, _wrap_GCP_GCPLine_set},
+     { "-Info",_wrap_GCP_Info_get, _wrap_GCP_Info_set},
+     { "-Id",_wrap_GCP_Id_get, _wrap_GCP_Id_set},
+     {0,0,0}
+ };
+ static swig_class *swig_GDAL_GCP_bases[] = {0};
+ static const char * swig_GDAL_GCP_base_names[] = {0};
+ static swig_class _wrap_class_GDAL_GCP = { "GCP", &SWIGTYPE_p_GDAL_GCP,_wrap_new_GCP, swig_delete_GCP, swig_GDAL_GCP_methods, swig_GDAL_GCP_attributes, swig_GDAL_GCP_bases,swig_GDAL_GCP_base_names, &swig_module };
+ SWIGINTERN int
+ _wrap_GDAL_GCP_GCPX_get(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
+   GDAL_GCP *arg1 = (GDAL_GCP *) 0 ;
+   void *argp1 = 0 ;
+   int res1 = 0 ;
+   double result;
+   
+   if (SWIG_GetArgs(interp, objc, objv,"o:osgeo::GDAL_GCP_GCPX_get h ",(void *)0) == TCL_ERROR) SWIG_fail;
+   res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_GDAL_GCP, 0 |  0 );
+   if (!SWIG_IsOK(res1)) {
+     SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "GDAL_GCP_GCPX_get" "', argument " "1"" of type '" "GDAL_GCP *""'"); 
+   }
+   arg1 = reinterpret_cast< GDAL_GCP * >(argp1);
+   {
+     CPLErrorReset();
+     result = (double)GDAL_GCP_GCPX_get(arg1);
+     CPLErr eclass = CPLGetLastErrorType();
+     if ( eclass == CE_Failure || eclass == CE_Fatal ) {
+       SWIG_exception( SWIG_RuntimeError, CPLGetLastErrorMsg() );
+       
+     }
+     
+     
+     
+     
+     
+     
+     
+     
+     
+     
+     
+   }
+   Tcl_SetObjResult(interp,SWIG_From_double(static_cast< double >(result)));
+   return TCL_OK;
+ fail:
+   return TCL_ERROR;
+ }
+ 
+ 
+ SWIGINTERN int
+ _wrap_GDAL_GCP_GCPX_set(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
+   GDAL_GCP *arg1 = (GDAL_GCP *) 0 ;
+   double arg2 ;
+   void *argp1 = 0 ;
+   int res1 = 0 ;
+   double val2 ;
+   int ecode2 = 0 ;
+   
+   if (SWIG_GetArgs(interp, objc, objv,"oo:osgeo::GDAL_GCP_GCPX_set h val ",(void *)0,(void *)0) == TCL_ERROR) SWIG_fail;
+   res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_GDAL_GCP, 0 |  0 );
+   if (!SWIG_IsOK(res1)) {
+     SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "GDAL_GCP_GCPX_set" "', argument " "1"" of type '" "GDAL_GCP *""'"); 
+   }
+   arg1 = reinterpret_cast< GDAL_GCP * >(argp1);
+   ecode2 = SWIG_AsVal_double SWIG_TCL_CALL_ARGS_2(objv[2], &val2);
+   if (!SWIG_IsOK(ecode2)) {
+     SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "GDAL_GCP_GCPX_set" "', argument " "2"" of type '" "double""'");
+   } 
+   arg2 = static_cast< double >(val2);
+   {
+     CPLErrorReset();
+     GDAL_GCP_GCPX_set(arg1,arg2);
+     CPLErr eclass = CPLGetLastErrorType();
+     if ( eclass == CE_Failure || eclass == CE_Fatal ) {
+       SWIG_exception( SWIG_RuntimeError, CPLGetLastErrorMsg() );
+       
+     }
+     
+     
+     
+     
+     
+     
+     
+     
+     
+     
+     
+   }
+   
+   return TCL_OK;
+ fail:
+   return TCL_ERROR;
+ }
+ 
+ 
+ SWIGINTERN int
+ _wrap_GDAL_GCP_GCPY_get(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
+   GDAL_GCP *arg1 = (GDAL_GCP *) 0 ;
+   void *argp1 = 0 ;
+   int res1 = 0 ;
+   double result;
+   
+   if (SWIG_GetArgs(interp, objc, objv,"o:osgeo::GDAL_GCP_GCPY_get h ",(void *)0) == TCL_ERROR) SWIG_fail;
+   res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_GDAL_GCP, 0 |  0 );
+   if (!SWIG_IsOK(res1)) {
+     SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "GDAL_GCP_GCPY_get" "', argument " "1"" of type '" "GDAL_GCP *""'"); 
+   }
+   arg1 = reinterpret_cast< GDAL_GCP * >(argp1);
+   {
+     CPLErrorReset();
+     result = (double)GDAL_GCP_GCPY_get(arg1);
+     CPLErr eclass = CPLGetLastErrorType();
+     if ( eclass == CE_Failure || eclass == CE_Fatal ) {
+       SWIG_exception( SWIG_RuntimeError, CPLGetLastErrorMsg() );
+       
+     }
+     
+     
+     
+     
+     
+     
+     
+     
+     
+     
+     
+   }
+   Tcl_SetObjResult(interp,SWIG_From_double(static_cast< double >(result)));
+   return TCL_OK;
+ fail:
+   return TCL_ERROR;
+ }
+ 
+ 
+ SWIGINTERN int
+ _wrap_GDAL_GCP_GCPY_set(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
+   GDAL_GCP *arg1 = (GDAL_GCP *) 0 ;
+   double arg2 ;
+   void *argp1 = 0 ;
+   int res1 = 0 ;
+   double val2 ;
+   int ecode2 = 0 ;
+   
+   if (SWIG_GetArgs(interp, objc, objv,"oo:osgeo::GDAL_GCP_GCPY_set h val ",(void *)0,(void *)0) == TCL_ERROR) SWIG_fail;
+   res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_GDAL_GCP, 0 |  0 );
+   if (!SWIG_IsOK(res1)) {
+     SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "GDAL_GCP_GCPY_set" "', argument " "1"" of type '" "GDAL_GCP *""'"); 
+   }
+   arg1 = reinterpret_cast< GDAL_GCP * >(argp1);
+   ecode2 = SWIG_AsVal_double SWIG_TCL_CALL_ARGS_2(objv[2], &val2);
+   if (!SWIG_IsOK(ecode2)) {
+     SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "GDAL_GCP_GCPY_set" "', argument " "2"" of type '" "double""'");
+   } 
+   arg2 = static_cast< double >(val2);
+   {
+     CPLErrorReset();
+     GDAL_GCP_GCPY_set(arg1,arg2);
+     CPLErr eclass = CPLGetLastErrorType();
+     if ( eclass == CE_Failure || eclass == CE_Fatal ) {
+       SWIG_exception( SWIG_RuntimeError, CPLGetLastErrorMsg() );
+       
+     }
+     
+     
+     
+     
+     
+     
+     
+     
+     
+     
+     
+   }
+   
+   return TCL_OK;
+ fail:
+   return TCL_ERROR;
+ }
+ 
+ 
+ SWIGINTERN int
+ _wrap_GDAL_GCP_GCPZ_get(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
+   GDAL_GCP *arg1 = (GDAL_GCP *) 0 ;
+   void *argp1 = 0 ;
+   int res1 = 0 ;
+   double result;
+   
+   if (SWIG_GetArgs(interp, objc, objv,"o:osgeo::GDAL_GCP_GCPZ_get h ",(void *)0) == TCL_ERROR) SWIG_fail;
+   res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_GDAL_GCP, 0 |  0 );
+   if (!SWIG_IsOK(res1)) {
+     SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "GDAL_GCP_GCPZ_get" "', argument " "1"" of type '" "GDAL_GCP *""'"); 
+   }
+   arg1 = reinterpret_cast< GDAL_GCP * >(argp1);
+   {
+     CPLErrorReset();
+     result = (double)GDAL_GCP_GCPZ_get(arg1);
+     CPLErr eclass = CPLGetLastErrorType();
+     if ( eclass == CE_Failure || eclass == CE_Fatal ) {
+       SWIG_exception( SWIG_RuntimeError, CPLGetLastErrorMsg() );
+       
+     }
+     
+     
+     
+     
+     
+     
+     
+     
+     
+     
+     
+   }
+   Tcl_SetObjResult(interp,SWIG_From_double(static_cast< double >(result)));
+   return TCL_OK;
+ fail:
+   return TCL_ERROR;
+ }
+ 
+ 
+ SWIGINTERN int
+ _wrap_GDAL_GCP_GCPZ_set(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
+   GDAL_GCP *arg1 = (GDAL_GCP *) 0 ;
+   double arg2 ;
+   void *argp1 = 0 ;
+   int res1 = 0 ;
+   double val2 ;
+   int ecode2 = 0 ;
+   
+   if (SWIG_GetArgs(interp, objc, objv,"oo:osgeo::GDAL_GCP_GCPZ_set h val ",(void *)0,(void *)0) == TCL_ERROR) SWIG_fail;
+   res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_GDAL_GCP, 0 |  0 );
+   if (!SWIG_IsOK(res1)) {
+     SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "GDAL_GCP_GCPZ_set" "', argument " "1"" of type '" "GDAL_GCP *""'"); 
+   }
+   arg1 = reinterpret_cast< GDAL_GCP * >(argp1);
+   ecode2 = SWIG_AsVal_double SWIG_TCL_CALL_ARGS_2(objv[2], &val2);
+   if (!SWIG_IsOK(ecode2)) {
+     SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "GDAL_GCP_GCPZ_set" "', argument " "2"" of type '" "double""'");
+   } 
+   arg2 = static_cast< double >(val2);
+   {
+     CPLErrorReset();
+     GDAL_GCP_GCPZ_set(arg1,arg2);
+     CPLErr eclass = CPLGetLastErrorType();
+     if ( eclass == CE_Failure || eclass == CE_Fatal ) {
+       SWIG_exception( SWIG_RuntimeError, CPLGetLastErrorMsg() );
+       
+     }
+     
+     
+     
+     
+     
+     
+     
+     
+     
+     
+     
+   }
+   
+   return TCL_OK;
+ fail:
+   return TCL_ERROR;
+ }
+ 
+ 
+ SWIGINTERN int
+ _wrap_GDAL_GCP_GCPPixel_get(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
+   GDAL_GCP *arg1 = (GDAL_GCP *) 0 ;
+   void *argp1 = 0 ;
+   int res1 = 0 ;
+   double result;
+   
+   if (SWIG_GetArgs(interp, objc, objv,"o:osgeo::GDAL_GCP_GCPPixel_get h ",(void *)0) == TCL_ERROR) SWIG_fail;
+   res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_GDAL_GCP, 0 |  0 );
+   if (!SWIG_IsOK(res1)) {
+     SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "GDAL_GCP_GCPPixel_get" "', argument " "1"" of type '" "GDAL_GCP *""'"); 
+   }
+   arg1 = reinterpret_cast< GDAL_GCP * >(argp1);
+   {
+     CPLErrorReset();
+     result = (double)GDAL_GCP_GCPPixel_get(arg1);
+     CPLErr eclass = CPLGetLastErrorType();
+     if ( eclass == CE_Failure || eclass == CE_Fatal ) {
+       SWIG_exception( SWIG_RuntimeError, CPLGetLastErrorMsg() );
+       
+     }
+     
+     
+     
+     
+     
+     
+     
+     
+     
+     
+     
+   }
+   Tcl_SetObjResult(interp,SWIG_From_double(static_cast< double >(result)));
+   return TCL_OK;
+ fail:
+   return TCL_ERROR;
+ }
+ 
+ 
+ SWIGINTERN int
+ _wrap_GDAL_GCP_GCPPixel_set(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
+   GDAL_GCP *arg1 = (GDAL_GCP *) 0 ;
+   double arg2 ;
+   void *argp1 = 0 ;
+   int res1 = 0 ;
+   double val2 ;
+   int ecode2 = 0 ;
+   
+   if (SWIG_GetArgs(interp, objc, objv,"oo:osgeo::GDAL_GCP_GCPPixel_set h val ",(void *)0,(void *)0) == TCL_ERROR) SWIG_fail;
+   res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_GDAL_GCP, 0 |  0 );
+   if (!SWIG_IsOK(res1)) {
+     SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "GDAL_GCP_GCPPixel_set" "', argument " "1"" of type '" "GDAL_GCP *""'"); 
+   }
+   arg1 = reinterpret_cast< GDAL_GCP * >(argp1);
+   ecode2 = SWIG_AsVal_double SWIG_TCL_CALL_ARGS_2(objv[2], &val2);
+   if (!SWIG_IsOK(ecode2)) {
+     SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "GDAL_GCP_GCPPixel_set" "', argument " "2"" of type '" "double""'");
+   } 
+   arg2 = static_cast< double >(val2);
+   {
+     CPLErrorReset();
+     GDAL_GCP_GCPPixel_set(arg1,arg2);
+     CPLErr eclass = CPLGetLastErrorType();
+     if ( eclass == CE_Failure || eclass == CE_Fatal ) {
+       SWIG_exception( SWIG_RuntimeError, CPLGetLastErrorMsg() );
+       
+     }
+     
+     
+     
+     
+     
+     
+     
+     
+     
+     
+     
+   }
+   
+   return TCL_OK;
+ fail:
+   return TCL_ERROR;
+ }
+ 
+ 
+ SWIGINTERN int
+ _wrap_GDAL_GCP_GCPLine_get(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
+   GDAL_GCP *arg1 = (GDAL_GCP *) 0 ;
+   void *argp1 = 0 ;
+   int res1 = 0 ;
+   double result;
+   
+   if (SWIG_GetArgs(interp, objc, objv,"o:osgeo::GDAL_GCP_GCPLine_get h ",(void *)0) == TCL_ERROR) SWIG_fail;
+   res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_GDAL_GCP, 0 |  0 );
+   if (!SWIG_IsOK(res1)) {
+     SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "GDAL_GCP_GCPLine_get" "', argument " "1"" of type '" "GDAL_GCP *""'"); 
+   }
+   arg1 = reinterpret_cast< GDAL_GCP * >(argp1);
+   {
+     CPLErrorReset();
+     result = (double)GDAL_GCP_GCPLine_get(arg1);
+     CPLErr eclass = CPLGetLastErrorType();
+     if ( eclass == CE_Failure || eclass == CE_Fatal ) {
+       SWIG_exception( SWIG_RuntimeError, CPLGetLastErrorMsg() );
+       
+     }
+     
+     
+     
+     
+     
+     
+     
+     
+     
+     
+     
+   }
+   Tcl_SetObjResult(interp,SWIG_From_double(static_cast< double >(result)));
+   return TCL_OK;
+ fail:
+   return TCL_ERROR;
+ }
+ 
+ 
+ SWIGINTERN int
+ _wrap_GDAL_GCP_GCPLine_set(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
+   GDAL_GCP *arg1 = (GDAL_GCP *) 0 ;
+   double arg2 ;
+   void *argp1 = 0 ;
+   int res1 = 0 ;
+   double val2 ;
+   int ecode2 = 0 ;
+   
+   if (SWIG_GetArgs(interp, objc, objv,"oo:osgeo::GDAL_GCP_GCPLine_set h val ",(void *)0,(void *)0) == TCL_ERROR) SWIG_fail;
+   res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_GDAL_GCP, 0 |  0 );
+   if (!SWIG_IsOK(res1)) {
+     SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "GDAL_GCP_GCPLine_set" "', argument " "1"" of type '" "GDAL_GCP *""'"); 
+   }
+   arg1 = reinterpret_cast< GDAL_GCP * >(argp1);
+   ecode2 = SWIG_AsVal_double SWIG_TCL_CALL_ARGS_2(objv[2], &val2);
+   if (!SWIG_IsOK(ecode2)) {
+     SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "GDAL_GCP_GCPLine_set" "', argument " "2"" of type '" "double""'");
+   } 
+   arg2 = static_cast< double >(val2);
+   {
+     CPLErrorReset();
+     GDAL_GCP_GCPLine_set(arg1,arg2);
+     CPLErr eclass = CPLGetLastErrorType();
+     if ( eclass == CE_Failure || eclass == CE_Fatal ) {
+       SWIG_exception( SWIG_RuntimeError, CPLGetLastErrorMsg() );
+       
+     }
+     
+     
+     
+     
+     
+     
+     
+     
+     
+     
+     
+   }
+   
+   return TCL_OK;
+ fail:
+   return TCL_ERROR;
+ }
+ 
+ 
+ SWIGINTERN int
+ _wrap_GDAL_GCP_Info_get(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
+   GDAL_GCP *arg1 = (GDAL_GCP *) 0 ;
+   void *argp1 = 0 ;
+   int res1 = 0 ;
+   char *result = 0 ;
+   
+   if (SWIG_GetArgs(interp, objc, objv,"o:osgeo::GDAL_GCP_Info_get h ",(void *)0) == TCL_ERROR) SWIG_fail;
+   res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_GDAL_GCP, 0 |  0 );
+   if (!SWIG_IsOK(res1)) {
+     SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "GDAL_GCP_Info_get" "', argument " "1"" of type '" "GDAL_GCP *""'"); 
+   }
+   arg1 = reinterpret_cast< GDAL_GCP * >(argp1);
+   {
+     CPLErrorReset();
+     result = (char *)GDAL_GCP_Info_get(arg1);
+     CPLErr eclass = CPLGetLastErrorType();
+     if ( eclass == CE_Failure || eclass == CE_Fatal ) {
+       SWIG_exception( SWIG_RuntimeError, CPLGetLastErrorMsg() );
+       
+     }
+     
+     
+     
+     
+     
+     
+     
+     
+     
+     
+     
+   }
+   Tcl_SetObjResult(interp,SWIG_FromCharPtr((const char *)result));
+   return TCL_OK;
+ fail:
+   return TCL_ERROR;
+ }
+ 
+ 
+ SWIGINTERN int
+ _wrap_GDAL_GCP_Info_set(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
+   GDAL_GCP *arg1 = (GDAL_GCP *) 0 ;
+   char *arg2 = (char *) 0 ;
+   void *argp1 = 0 ;
+   int res1 = 0 ;
+   int res2 ;
+   char *buf2 = 0 ;
+   int alloc2 = 0 ;
+   
+   if (SWIG_GetArgs(interp, objc, objv,"oo:osgeo::GDAL_GCP_Info_set h val ",(void *)0,(void *)0) == TCL_ERROR) SWIG_fail;
+   res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_GDAL_GCP, 0 |  0 );
+   if (!SWIG_IsOK(res1)) {
+     SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "GDAL_GCP_Info_set" "', argument " "1"" of type '" "GDAL_GCP *""'"); 
+   }
+   arg1 = reinterpret_cast< GDAL_GCP * >(argp1);
+   res2 = SWIG_AsCharPtrAndSize(objv[2], &buf2, NULL, &alloc2);
+   if (!SWIG_IsOK(res2)) {
+     SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "GDAL_GCP_Info_set" "', argument " "2"" of type '" "char const *""'");
+   }
+   arg2 = reinterpret_cast< char * >(buf2);
+   {
+     CPLErrorReset();
+     GDAL_GCP_Info_set(arg1,(char const *)arg2);
+     CPLErr eclass = CPLGetLastErrorType();
+     if ( eclass == CE_Failure || eclass == CE_Fatal ) {
+       SWIG_exception( SWIG_RuntimeError, CPLGetLastErrorMsg() );
+       
+     }
+     
+     
+     
+     
+     
+     
+     
+     
+     
+     
+     
+   }
+   
+   if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
+   return TCL_OK;
+ fail:
+   if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
+   return TCL_ERROR;
+ }
+ 
+ 
+ SWIGINTERN int
+ _wrap_GDAL_GCP_Id_get(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
+   GDAL_GCP *arg1 = (GDAL_GCP *) 0 ;
+   void *argp1 = 0 ;
+   int res1 = 0 ;
+   char *result = 0 ;
+   
+   if (SWIG_GetArgs(interp, objc, objv,"o:osgeo::GDAL_GCP_Id_get h ",(void *)0) == TCL_ERROR) SWIG_fail;
+   res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_GDAL_GCP, 0 |  0 );
+   if (!SWIG_IsOK(res1)) {
+     SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "GDAL_GCP_Id_get" "', argument " "1"" of type '" "GDAL_GCP *""'"); 
+   }
+   arg1 = reinterpret_cast< GDAL_GCP * >(argp1);
+   {
+     CPLErrorReset();
+     result = (char *)GDAL_GCP_Id_get(arg1);
+     CPLErr eclass = CPLGetLastErrorType();
+     if ( eclass == CE_Failure || eclass == CE_Fatal ) {
+       SWIG_exception( SWIG_RuntimeError, CPLGetLastErrorMsg() );
+       
+     }
+     
+     
+     
+     
+     
+     
+     
+     
+     
+     
+     
+   }
+   Tcl_SetObjResult(interp,SWIG_FromCharPtr((const char *)result));
+   return TCL_OK;
+ fail:
+   return TCL_ERROR;
+ }
+ 
+ 
+ SWIGINTERN int
+ _wrap_GDAL_GCP_Id_set(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
+   GDAL_GCP *arg1 = (GDAL_GCP *) 0 ;
+   char *arg2 = (char *) 0 ;
+   void *argp1 = 0 ;
+   int res1 = 0 ;
+   int res2 ;
+   char *buf2 = 0 ;
+   int alloc2 = 0 ;
+   
+   if (SWIG_GetArgs(interp, objc, objv,"oo:osgeo::GDAL_GCP_Id_set h val ",(void *)0,(void *)0) == TCL_ERROR) SWIG_fail;
+   res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_GDAL_GCP, 0 |  0 );
+   if (!SWIG_IsOK(res1)) {
+     SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "GDAL_GCP_Id_set" "', argument " "1"" of type '" "GDAL_GCP *""'"); 
+   }
+   arg1 = reinterpret_cast< GDAL_GCP * >(argp1);
+   res2 = SWIG_AsCharPtrAndSize(objv[2], &buf2, NULL, &alloc2);
+   if (!SWIG_IsOK(res2)) {
+     SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "GDAL_GCP_Id_set" "', argument " "2"" of type '" "char const *""'");
+   }
+   arg2 = reinterpret_cast< char * >(buf2);
+   {
+     CPLErrorReset();
+     GDAL_GCP_Id_set(arg1,(char const *)arg2);
+     CPLErr eclass = CPLGetLastErrorType();
+     if ( eclass == CE_Failure || eclass == CE_Fatal ) {
+       SWIG_exception( SWIG_RuntimeError, CPLGetLastErrorMsg() );
+       
+     }
+     
+     
+     
+     
+     
+     
+     
+     
+     
+     
+     
+   }
+   
+   if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
+   return TCL_OK;
+ fail:
+   if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
+   return TCL_ERROR;
+ }
+ 
+ 
+ SWIGINTERN int
+ _wrap_GDAL_GCP_get_GCPX(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
+   GDAL_GCP *arg1 = (GDAL_GCP *) 0 ;
+   void *argp1 = 0 ;
+   int res1 = 0 ;
+   double result;
+   
+   if (SWIG_GetArgs(interp, objc, objv,"o:osgeo::GDAL_GCP_get_GCPX h ",(void *)0) == TCL_ERROR) SWIG_fail;
+   res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_GDAL_GCP, 0 |  0 );
+   if (!SWIG_IsOK(res1)) {
+     SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "GDAL_GCP_get_GCPX" "', argument " "1"" of type '" "GDAL_GCP *""'"); 
+   }
+   arg1 = reinterpret_cast< GDAL_GCP * >(argp1);
+   {
+     CPLErrorReset();
+     result = (double)GDAL_GCP_get_GCPX(arg1);
+     CPLErr eclass = CPLGetLastErrorType();
+     if ( eclass == CE_Failure || eclass == CE_Fatal ) {
+       SWIG_exception( SWIG_RuntimeError, CPLGetLastErrorMsg() );
+       
+     }
+     
+     
+     
+     
+     
+     
+     
+     
+     
+     
+     
+   }
+   Tcl_SetObjResult(interp,SWIG_From_double(static_cast< double >(result)));
+   return TCL_OK;
+ fail:
+   return TCL_ERROR;
+ }
+ 
+ 
+ SWIGINTERN int
+ _wrap_GDAL_GCP_set_GCPX(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
+   GDAL_GCP *arg1 = (GDAL_GCP *) 0 ;
+   double arg2 ;
+   void *argp1 = 0 ;
+   int res1 = 0 ;
+   double val2 ;
+   int ecode2 = 0 ;
+   
+   if (SWIG_GetArgs(interp, objc, objv,"oo:osgeo::GDAL_GCP_set_GCPX h val ",(void *)0,(void *)0) == TCL_ERROR) SWIG_fail;
+   res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_GDAL_GCP, 0 |  0 );
+   if (!SWIG_IsOK(res1)) {
+     SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "GDAL_GCP_set_GCPX" "', argument " "1"" of type '" "GDAL_GCP *""'"); 
+   }
+   arg1 = reinterpret_cast< GDAL_GCP * >(argp1);
+   ecode2 = SWIG_AsVal_double SWIG_TCL_CALL_ARGS_2(objv[2], &val2);
+   if (!SWIG_IsOK(ecode2)) {
+     SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "GDAL_GCP_set_GCPX" "', argument " "2"" of type '" "double""'");
+   } 
+   arg2 = static_cast< double >(val2);
+   {
+     CPLErrorReset();
+     GDAL_GCP_set_GCPX(arg1,arg2);
+     CPLErr eclass = CPLGetLastErrorType();
+     if ( eclass == CE_Failure || eclass == CE_Fatal ) {
+       SWIG_exception( SWIG_RuntimeError, CPLGetLastErrorMsg() );
+       
+     }
+     
+     
+     
+     
+     
+     
+     
+     
+     
+     
+     
+   }
+   
+   return TCL_OK;
+ fail:
+   return TCL_ERROR;
+ }
+ 
+ 
+ SWIGINTERN int
+ _wrap_GDAL_GCP_get_GCPY(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
+   GDAL_GCP *arg1 = (GDAL_GCP *) 0 ;
+   void *argp1 = 0 ;
+   int res1 = 0 ;
+   double result;
+   
+   if (SWIG_GetArgs(interp, objc, objv,"o:osgeo::GDAL_GCP_get_GCPY h ",(void *)0) == TCL_ERROR) SWIG_fail;
+   res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_GDAL_GCP, 0 |  0 );
+   if (!SWIG_IsOK(res1)) {
+     SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "GDAL_GCP_get_GCPY" "', argument " "1"" of type '" "GDAL_GCP *""'"); 
+   }
+   arg1 = reinterpret_cast< GDAL_GCP * >(argp1);
+   {
+     CPLErrorReset();
+     result = (double)GDAL_GCP_get_GCPY(arg1);
+     CPLErr eclass = CPLGetLastErrorType();
+     if ( eclass == CE_Failure || eclass == CE_Fatal ) {
+       SWIG_exception( SWIG_RuntimeError, CPLGetLastErrorMsg() );
+       
+     }
+     
+     
+     
+     
+     
+     
+     
+     
+     
+     
+     
+   }
+   Tcl_SetObjResult(interp,SWIG_From_double(static_cast< double >(result)));
+   return TCL_OK;
+ fail:
+   return TCL_ERROR;
+ }
+ 
+ 
+ SWIGINTERN int
+ _wrap_GDAL_GCP_set_GCPY(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
+   GDAL_GCP *arg1 = (GDAL_GCP *) 0 ;
+   double arg2 ;
+   void *argp1 = 0 ;
+   int res1 = 0 ;
+   double val2 ;
+   int ecode2 = 0 ;
+   
+   if (SWIG_GetArgs(interp, objc, objv,"oo:osgeo::GDAL_GCP_set_GCPY h val ",(void *)0,(void *)0) == TCL_ERROR) SWIG_fail;
+   res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_GDAL_GCP, 0 |  0 );
+   if (!SWIG_IsOK(res1)) {
+     SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "GDAL_GCP_set_GCPY" "', argument " "1"" of type '" "GDAL_GCP *""'"); 
+   }
+   arg1 = reinterpret_cast< GDAL_GCP * >(argp1);
+   ecode2 = SWIG_AsVal_double SWIG_TCL_CALL_ARGS_2(objv[2], &val2);
+   if (!SWIG_IsOK(ecode2)) {
+     SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "GDAL_GCP_set_GCPY" "', argument " "2"" of type '" "double""'");
+   } 
+   arg2 = static_cast< double >(val2);
+   {
+     CPLErrorReset();
+     GDAL_GCP_set_GCPY(arg1,arg2);
+     CPLErr eclass = CPLGetLastErrorType();
+     if ( eclass == CE_Failure || eclass == CE_Fatal ) {
+       SWIG_exception( SWIG_RuntimeError, CPLGetLastErrorMsg() );
+       
+     }
+     
+     
+     
+     
+     
+     
+     
+     
+     
+     
+     
+   }
+   
+   return TCL_OK;
+ fail:
+   return TCL_ERROR;
+ }
+ 
+ 
+ SWIGINTERN int
+ _wrap_GDAL_GCP_get_GCPZ(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
+   GDAL_GCP *arg1 = (GDAL_GCP *) 0 ;
+   void *argp1 = 0 ;
+   int res1 = 0 ;
+   double result;
+   
+   if (SWIG_GetArgs(interp, objc, objv,"o:osgeo::GDAL_GCP_get_GCPZ h ",(void *)0) == TCL_ERROR) SWIG_fail;
+   res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_GDAL_GCP, 0 |  0 );
+   if (!SWIG_IsOK(res1)) {
+     SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "GDAL_GCP_get_GCPZ" "', argument " "1"" of type '" "GDAL_GCP *""'"); 
+   }
+   arg1 = reinterpret_cast< GDAL_GCP * >(argp1);
+   {
+     CPLErrorReset();
+     result = (double)GDAL_GCP_get_GCPZ(arg1);
+     CPLErr eclass = CPLGetLastErrorType();
+     if ( eclass == CE_Failure || eclass == CE_Fatal ) {
+       SWIG_exception( SWIG_RuntimeError, CPLGetLastErrorMsg() );
+       
+     }
+     
+     
+     
+     
+     
+     
+     
+     
+     
+     
+     
+   }
+   Tcl_SetObjResult(interp,SWIG_From_double(static_cast< double >(result)));
+   return TCL_OK;
+ fail:
+   return TCL_ERROR;
+ }
+ 
+ 
+ SWIGINTERN int
+ _wrap_GDAL_GCP_set_GCPZ(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
+   GDAL_GCP *arg1 = (GDAL_GCP *) 0 ;
+   double arg2 ;
+   void *argp1 = 0 ;
+   int res1 = 0 ;
+   double val2 ;
+   int ecode2 = 0 ;
+   
+   if (SWIG_GetArgs(interp, objc, objv,"oo:osgeo::GDAL_GCP_set_GCPZ h val ",(void *)0,(void *)0) == TCL_ERROR) SWIG_fail;
+   res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_GDAL_GCP, 0 |  0 );
+   if (!SWIG_IsOK(res1)) {
+     SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "GDAL_GCP_set_GCPZ" "', argument " "1"" of type '" "GDAL_GCP *""'"); 
+   }
+   arg1 = reinterpret_cast< GDAL_GCP * >(argp1);
+   ecode2 = SWIG_AsVal_double SWIG_TCL_CALL_ARGS_2(objv[2], &val2);
+   if (!SWIG_IsOK(ecode2)) {
+     SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "GDAL_GCP_set_GCPZ" "', argument " "2"" of type '" "double""'");
+   } 
+   arg2 = static_cast< double >(val2);
+   {
+     CPLErrorReset();
+     GDAL_GCP_set_GCPZ(arg1,arg2);
+     CPLErr eclass = CPLGetLastErrorType();
+     if ( eclass == CE_Failure || eclass == CE_Fatal ) {
+       SWIG_exception( SWIG_RuntimeError, CPLGetLastErrorMsg() );
+       
+     }
+     
+     
+     
+     
+     
+     
+     
+     
+     
+     
+     
+   }
+   
+   return TCL_OK;
+ fail:
+   return TCL_ERROR;
+ }
+ 
+ 
+ SWIGINTERN int
+ _wrap_GDAL_GCP_get_GCPPixel(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
+   GDAL_GCP *arg1 = (GDAL_GCP *) 0 ;
+   void *argp1 = 0 ;
+   int res1 = 0 ;
+   double result;
+   
+   if (SWIG_GetArgs(interp, objc, objv,"o:osgeo::GDAL_GCP_get_GCPPixel h ",(void *)0) == TCL_ERROR) SWIG_fail;
+   res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_GDAL_GCP, 0 |  0 );
+   if (!SWIG_IsOK(res1)) {
+     SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "GDAL_GCP_get_GCPPixel" "', argument " "1"" of type '" "GDAL_GCP *""'"); 
+   }
+   arg1 = reinterpret_cast< GDAL_GCP * >(argp1);
+   {
+     CPLErrorReset();
+     result = (double)GDAL_GCP_get_GCPPixel(arg1);
+     CPLErr eclass = CPLGetLastErrorType();
+     if ( eclass == CE_Failure || eclass == CE_Fatal ) {
+       SWIG_exception( SWIG_RuntimeError, CPLGetLastErrorMsg() );
+       
+     }
+     
+     
+     
+     
+     
+     
+     
+     
+     
+     
+     
+   }
+   Tcl_SetObjResult(interp,SWIG_From_double(static_cast< double >(result)));
+   return TCL_OK;
+ fail:
+   return TCL_ERROR;
+ }
+ 
+ 
+ SWIGINTERN int
+ _wrap_GDAL_GCP_set_GCPPixel(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
+   GDAL_GCP *arg1 = (GDAL_GCP *) 0 ;
+   double arg2 ;
+   void *argp1 = 0 ;
+   int res1 = 0 ;
+   double val2 ;
+   int ecode2 = 0 ;
+   
+   if (SWIG_GetArgs(interp, objc, objv,"oo:osgeo::GDAL_GCP_set_GCPPixel h val ",(void *)0,(void *)0) == TCL_ERROR) SWIG_fail;
+   res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_GDAL_GCP, 0 |  0 );
+   if (!SWIG_IsOK(res1)) {
+     SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "GDAL_GCP_set_GCPPixel" "', argument " "1"" of type '" "GDAL_GCP *""'"); 
+   }
+   arg1 = reinterpret_cast< GDAL_GCP * >(argp1);
+   ecode2 = SWIG_AsVal_double SWIG_TCL_CALL_ARGS_2(objv[2], &val2);
+   if (!SWIG_IsOK(ecode2)) {
+     SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "GDAL_GCP_set_GCPPixel" "', argument " "2"" of type '" "double""'");
+   } 
+   arg2 = static_cast< double >(val2);
+   {
+     CPLErrorReset();
+     GDAL_GCP_set_GCPPixel(arg1,arg2);
+     CPLErr eclass = CPLGetLastErrorType();
+     if ( eclass == CE_Failure || eclass == CE_Fatal ) {
+       SWIG_exception( SWIG_RuntimeError, CPLGetLastErrorMsg() );
+       
+     }
+     
+     
+     
+     
+     
+     
+     
+     
+     
+     
+     
+   }
+   
+   return TCL_OK;
+ fail:
+   return TCL_ERROR;
+ }
+ 
+ 
+ SWIGINTERN int
+ _wrap_GDAL_GCP_get_GCPLine(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
+   GDAL_GCP *arg1 = (GDAL_GCP *) 0 ;
+   void *argp1 = 0 ;
+   int res1 = 0 ;
+   double result;
+   
+   if (SWIG_GetArgs(interp, objc, objv,"o:osgeo::GDAL_GCP_get_GCPLine h ",(void *)0) == TCL_ERROR) SWIG_fail;
+   res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_GDAL_GCP, 0 |  0 );
+   if (!SWIG_IsOK(res1)) {
+     SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "GDAL_GCP_get_GCPLine" "', argument " "1"" of type '" "GDAL_GCP *""'"); 
+   }
+   arg1 = reinterpret_cast< GDAL_GCP * >(argp1);
+   {
+     CPLErrorReset();
+     result = (double)GDAL_GCP_get_GCPLine(arg1);
+     CPLErr eclass = CPLGetLastErrorType();
+     if ( eclass == CE_Failure || eclass == CE_Fatal ) {
+       SWIG_exception( SWIG_RuntimeError, CPLGetLastErrorMsg() );
+       
+     }
+     
+     
+     
+     
+     
+     
+     
+     
+     
+     
+     
+   }
+   Tcl_SetObjResult(interp,SWIG_From_double(static_cast< double >(result)));
+   return TCL_OK;
+ fail:
+   return TCL_ERROR;
+ }
+ 
+ 
+ SWIGINTERN int
+ _wrap_GDAL_GCP_set_GCPLine(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
+   GDAL_GCP *arg1 = (GDAL_GCP *) 0 ;
+   double arg2 ;
+   void *argp1 = 0 ;
+   int res1 = 0 ;
+   double val2 ;
+   int ecode2 = 0 ;
+   
+   if (SWIG_GetArgs(interp, objc, objv,"oo:osgeo::GDAL_GCP_set_GCPLine h val ",(void *)0,(void *)0) == TCL_ERROR) SWIG_fail;
+   res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_GDAL_GCP, 0 |  0 );
+   if (!SWIG_IsOK(res1)) {
+     SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "GDAL_GCP_set_GCPLine" "', argument " "1"" of type '" "GDAL_GCP *""'"); 
+   }
+   arg1 = reinterpret_cast< GDAL_GCP * >(argp1);
+   ecode2 = SWIG_AsVal_double SWIG_TCL_CALL_ARGS_2(objv[2], &val2);
+   if (!SWIG_IsOK(ecode2)) {
+     SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "GDAL_GCP_set_GCPLine" "', argument " "2"" of type '" "double""'");
+   } 
+   arg2 = static_cast< double >(val2);
+   {
+     CPLErrorReset();
+     GDAL_GCP_set_GCPLine(arg1,arg2);
+     CPLErr eclass = CPLGetLastErrorType();
+     if ( eclass == CE_Failure || eclass == CE_Fatal ) {
+       SWIG_exception( SWIG_RuntimeError, CPLGetLastErrorMsg() );
+       
+     }
+     
+     
+     
+     
+     
+     
+     
+     
+     
+     
+     
+   }
+   
+   return TCL_OK;
+ fail:
+   return TCL_ERROR;
+ }
+ 
+ 
+ SWIGINTERN int
+ _wrap_GDAL_GCP_get_Info(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
+   GDAL_GCP *arg1 = (GDAL_GCP *) 0 ;
+   void *argp1 = 0 ;
+   int res1 = 0 ;
+   char *result = 0 ;
+   
+   if (SWIG_GetArgs(interp, objc, objv,"o:osgeo::GDAL_GCP_get_Info h ",(void *)0) == TCL_ERROR) SWIG_fail;
+   res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_GDAL_GCP, 0 |  0 );
+   if (!SWIG_IsOK(res1)) {
+     SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "GDAL_GCP_get_Info" "', argument " "1"" of type '" "GDAL_GCP *""'"); 
+   }
+   arg1 = reinterpret_cast< GDAL_GCP * >(argp1);
+   {
+     CPLErrorReset();
+     result = (char *)GDAL_GCP_get_Info(arg1);
+     CPLErr eclass = CPLGetLastErrorType();
+     if ( eclass == CE_Failure || eclass == CE_Fatal ) {
+       SWIG_exception( SWIG_RuntimeError, CPLGetLastErrorMsg() );
+       
+     }
+     
+     
+     
+     
+     
+     
+     
+     
+     
+     
+     
+   }
+   Tcl_SetObjResult(interp,SWIG_FromCharPtr((const char *)result));
+   return TCL_OK;
+ fail:
+   return TCL_ERROR;
+ }
+ 
+ 
+ SWIGINTERN int
+ _wrap_GDAL_GCP_set_Info(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
+   GDAL_GCP *arg1 = (GDAL_GCP *) 0 ;
+   char *arg2 = (char *) 0 ;
+   void *argp1 = 0 ;
+   int res1 = 0 ;
+   int res2 ;
+   char *buf2 = 0 ;
+   int alloc2 = 0 ;
+   
+   if (SWIG_GetArgs(interp, objc, objv,"oo:osgeo::GDAL_GCP_set_Info h val ",(void *)0,(void *)0) == TCL_ERROR) SWIG_fail;
+   res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_GDAL_GCP, 0 |  0 );
+   if (!SWIG_IsOK(res1)) {
+     SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "GDAL_GCP_set_Info" "', argument " "1"" of type '" "GDAL_GCP *""'"); 
+   }
+   arg1 = reinterpret_cast< GDAL_GCP * >(argp1);
+   res2 = SWIG_AsCharPtrAndSize(objv[2], &buf2, NULL, &alloc2);
+   if (!SWIG_IsOK(res2)) {
+     SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "GDAL_GCP_set_Info" "', argument " "2"" of type '" "char const *""'");
+   }
+   arg2 = reinterpret_cast< char * >(buf2);
+   {
+     CPLErrorReset();
+     GDAL_GCP_set_Info(arg1,(char const *)arg2);
+     CPLErr eclass = CPLGetLastErrorType();
+     if ( eclass == CE_Failure || eclass == CE_Fatal ) {
+       SWIG_exception( SWIG_RuntimeError, CPLGetLastErrorMsg() );
+       
+     }
+     
+     
+     
+     
+     
+     
+     
+     
+     
+     
+     
+   }
+   
+   if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
+   return TCL_OK;
+ fail:
+   if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
+   return TCL_ERROR;
+ }
+ 
+ 
+ SWIGINTERN int
+ _wrap_GDAL_GCP_get_Id(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
+   GDAL_GCP *arg1 = (GDAL_GCP *) 0 ;
+   void *argp1 = 0 ;
+   int res1 = 0 ;
+   char *result = 0 ;
+   
+   if (SWIG_GetArgs(interp, objc, objv,"o:osgeo::GDAL_GCP_get_Id h ",(void *)0) == TCL_ERROR) SWIG_fail;
+   res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_GDAL_GCP, 0 |  0 );
+   if (!SWIG_IsOK(res1)) {
+     SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "GDAL_GCP_get_Id" "', argument " "1"" of type '" "GDAL_GCP *""'"); 
+   }
+   arg1 = reinterpret_cast< GDAL_GCP * >(argp1);
+   {
+     CPLErrorReset();
+     result = (char *)GDAL_GCP_get_Id(arg1);
+     CPLErr eclass = CPLGetLastErrorType();
+     if ( eclass == CE_Failure || eclass == CE_Fatal ) {
+       SWIG_exception( SWIG_RuntimeError, CPLGetLastErrorMsg() );
+       
+     }
+     
+     
+     
+     
+     
+     
+     
+     
+     
+     
+     
+   }
+   Tcl_SetObjResult(interp,SWIG_FromCharPtr((const char *)result));
+   return TCL_OK;
+ fail:
+   return TCL_ERROR;
+ }
+ 
+ 
+ SWIGINTERN int
+ _wrap_GDAL_GCP_set_Id(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
+   GDAL_GCP *arg1 = (GDAL_GCP *) 0 ;
+   char *arg2 = (char *) 0 ;
+   void *argp1 = 0 ;
+   int res1 = 0 ;
+   int res2 ;
+   char *buf2 = 0 ;
+   int alloc2 = 0 ;
+   
+   if (SWIG_GetArgs(interp, objc, objv,"oo:osgeo::GDAL_GCP_set_Id h val ",(void *)0,(void *)0) == TCL_ERROR) SWIG_fail;
+   res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_GDAL_GCP, 0 |  0 );
+   if (!SWIG_IsOK(res1)) {
+     SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "GDAL_GCP_set_Id" "', argument " "1"" of type '" "GDAL_GCP *""'"); 
+   }
+   arg1 = reinterpret_cast< GDAL_GCP * >(argp1);
+   res2 = SWIG_AsCharPtrAndSize(objv[2], &buf2, NULL, &alloc2);
+   if (!SWIG_IsOK(res2)) {
+     SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "GDAL_GCP_set_Id" "', argument " "2"" of type '" "char const *""'");
+   }
+   arg2 = reinterpret_cast< char * >(buf2);
+   {
+     CPLErrorReset();
+     GDAL_GCP_set_Id(arg1,(char const *)arg2);
+     CPLErr eclass = CPLGetLastErrorType();
+     if ( eclass == CE_Failure || eclass == CE_Fatal ) {
+       SWIG_exception( SWIG_RuntimeError, CPLGetLastErrorMsg() );
+       
+     }
+     
+     
+     
+     
+     
+     
+     
+     
+     
+     
+     
+   }
+   
+   if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
+   return TCL_OK;
+ fail:
+   if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
+   return TCL_ERROR;
+ }
+ 
+ 
+ SWIGINTERN int
+ _wrap_GCPsToGeoTransform(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
+   int arg1 ;
+   GDAL_GCP *arg2 = (GDAL_GCP *) 0 ;
+   double *arg3 ;
+   int arg4 = (int) 1 ;
+   GDAL_GCP *tmpGCPList1 ;
+   double argout3[6] ;
+   int val4 ;
+   int ecode4 = 0 ;
+   FALSE_IS_ERR result;
+   
+   {
+     /* %typemap(in,numinputs=0) (double argout3[ANY]) */
+     arg3 = argout3;
+   }
+   if (SWIG_GetArgs(interp, objc, objv,"o|o:osgeo::GCPsToGeoTransform nGCPs ?pGCPs? ?bApproxOK? ",(void *)0,(void *)0) == TCL_ERROR) SWIG_fail;
+   {
+     /* %typemap(in,numinputs=1) (int nGCPs, GDAL_GCP const *pGCPs ) */
+     /* The following also checks if input is a list */
+     if (Tcl_ListObjLength(interp, objv[1], &arg1) != TCL_OK) {
+       /* Error msg in interp result */
+       SWIG_fail;
+     }
+     if ( !arg1 ) {
+       Tcl_SetResult(interp, (char*) "Input list mustn't be empty", TCL_STATIC);
+       SWIG_fail;
+     }
+     
+     tmpGCPList1 = (GDAL_GCP*) CPLMalloc(arg1*sizeof(GDAL_GCP));
+     arg2 = tmpGCPList1;
+     for( int i = 0; i<arg1; i++ ) {
+       Tcl_Obj **o = NULL;
+       /* The reference count for the list element is not incremented with the following */
+       if (Tcl_ListObjIndex(interp, objv[1], i, o) != TCL_OK) {
+         /* Error msg in interp result */
+         SWIG_fail;
+       }
+       
+       GDAL_GCP *item = 0;
+       SWIG_ConvertPtr( *o, (void**)&item, SWIGTYPE_p_GDAL_GCP, SWIG_POINTER_EXCEPTION | 0 );
+       if ( ! item ) {
+         SWIG_fail;
+       }
+       
+       memcpy( (void*) tmpGCPList1, (void*) item, sizeof( GDAL_GCP ) );
+       ++tmpGCPList1;
+     }
+   }
+   if (objc > 2) {
+     ecode4 = SWIG_AsVal_int SWIG_TCL_CALL_ARGS_2(objv[2], &val4);
+     if (!SWIG_IsOK(ecode4)) {
+       SWIG_exception_fail(SWIG_ArgError(ecode4), "in method '" "GCPsToGeoTransform" "', argument " "4"" of type '" "int""'");
+     } 
+     arg4 = static_cast< int >(val4);
+   }
+   {
+     CPLErrorReset();
+     result = GDALGCPsToGeoTransform(arg1,(GDAL_GCP const *)arg2,arg3,arg4);
+     CPLErr eclass = CPLGetLastErrorType();
+     if ( eclass == CE_Failure || eclass == CE_Fatal ) {
+       SWIG_exception( SWIG_RuntimeError, CPLGetLastErrorMsg() );
+       
+     }
+     
+     
+     
+     
+     
+     
+     
+     
+     
+     
+     
+   }
+   /*%typemap(out) IF_FALSE_RETURN_NONE */
+   {
+     /* %typemap(argout) (double argout[ANY]) */
+     Tcl_Obj *out = CreateListFromDoubleArray( interp, arg3, 6 );
+     if (out == NULL) SWIG_fail;
+     Tcl_ListObjAppendElement(interp,Tcl_GetObjResult(interp),out);
+   }
+   {
+     /* %typemap(freearg) (int nGCPs, GDAL_GCP const *pGCPs ) */
+     if (arg2) {
+       CPLFree( (void*) arg2 );
+     }
+   }
+   {
+     /* %typemap(ret) IF_FALSE_RETURN_NONE */
+     if (result == 0 ) {
+       Tcl_ResetResult(interp); /* NONE = Empty string */
+     }
+   }
+   return TCL_OK;
+ fail:
+   {
+     /* %typemap(freearg) (int nGCPs, GDAL_GCP const *pGCPs ) */
+     if (arg2) {
+       CPLFree( (void*) arg2 );
+     }
+   }
+   return TCL_ERROR;
+ }
+ 
+ 
+ SWIGINTERN int
+ _wrap_Dataset_RasterXSize_get(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
+   GDALDatasetShadow *arg1 = (GDALDatasetShadow *) 0 ;
+   void *argp1 = 0 ;
+   int res1 = 0 ;
+   int result;
+   
+   if (SWIG_GetArgs(interp, objc, objv,"o:osgeo::Dataset_RasterXSize_get self ",(void *)0) == TCL_ERROR) SWIG_fail;
+   res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_GDALDatasetShadow, 0 |  0 );
+   if (!SWIG_IsOK(res1)) {
+     SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Dataset_RasterXSize_get" "', argument " "1"" of type '" "GDALDatasetShadow *""'"); 
+   }
+   arg1 = reinterpret_cast< GDALDatasetShadow * >(argp1);
+   {
+     CPLErrorReset();
+     result = (int)GDALDatasetShadow_RasterXSize_get(arg1);
+     CPLErr eclass = CPLGetLastErrorType();
+     if ( eclass == CE_Failure || eclass == CE_Fatal ) {
+       SWIG_exception( SWIG_RuntimeError, CPLGetLastErrorMsg() );
+       
+     }
+     
+     
+     
+     
+     
+     
+     
+     
+     
+     
+     
+   }
+   Tcl_SetObjResult(interp,SWIG_From_int(static_cast< int >(result)));
+   return TCL_OK;
+ fail:
+   return TCL_ERROR;
+ }
+ 
+ 
+ SWIGINTERN int
+ _wrap_Dataset_RasterYSize_get(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
+   GDALDatasetShadow *arg1 = (GDALDatasetShadow *) 0 ;
+   void *argp1 = 0 ;
+   int res1 = 0 ;
+   int result;
+   
+   if (SWIG_GetArgs(interp, objc, objv,"o:osgeo::Dataset_RasterYSize_get self ",(void *)0) == TCL_ERROR) SWIG_fail;
+   res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_GDALDatasetShadow, 0 |  0 );
+   if (!SWIG_IsOK(res1)) {
+     SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Dataset_RasterYSize_get" "', argument " "1"" of type '" "GDALDatasetShadow *""'"); 
+   }
+   arg1 = reinterpret_cast< GDALDatasetShadow * >(argp1);
+   {
+     CPLErrorReset();
+     result = (int)GDALDatasetShadow_RasterYSize_get(arg1);
+     CPLErr eclass = CPLGetLastErrorType();
+     if ( eclass == CE_Failure || eclass == CE_Fatal ) {
+       SWIG_exception( SWIG_RuntimeError, CPLGetLastErrorMsg() );
+       
+     }
+     
+     
+     
+     
+     
+     
+     
+     
+     
+     
+     
+   }
+   Tcl_SetObjResult(interp,SWIG_From_int(static_cast< int >(result)));
+   return TCL_OK;
+ fail:
+   return TCL_ERROR;
+ }
+ 
+ 
+ SWIGINTERN int
+ _wrap_Dataset_RasterCount_get(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
+   GDALDatasetShadow *arg1 = (GDALDatasetShadow *) 0 ;
+   void *argp1 = 0 ;
+   int res1 = 0 ;
+   int result;
+   
+   if (SWIG_GetArgs(interp, objc, objv,"o:osgeo::Dataset_RasterCount_get self ",(void *)0) == TCL_ERROR) SWIG_fail;
+   res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_GDALDatasetShadow, 0 |  0 );
+   if (!SWIG_IsOK(res1)) {
+     SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Dataset_RasterCount_get" "', argument " "1"" of type '" "GDALDatasetShadow *""'"); 
+   }
+   arg1 = reinterpret_cast< GDALDatasetShadow * >(argp1);
+   {
+     CPLErrorReset();
+     result = (int)GDALDatasetShadow_RasterCount_get(arg1);
+     CPLErr eclass = CPLGetLastErrorType();
+     if ( eclass == CE_Failure || eclass == CE_Fatal ) {
+       SWIG_exception( SWIG_RuntimeError, CPLGetLastErrorMsg() );
+       
+     }
+     
+     
+     
+     
+     
+     
+     
+     
+     
+     
+     
+   }
+   Tcl_SetObjResult(interp,SWIG_From_int(static_cast< int >(result)));
+   return TCL_OK;
+ fail:
+   return TCL_ERROR;
+ }
+ 
+ 
+ SWIGINTERN int
+ _wrap_delete_Dataset(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
+   GDALDatasetShadow *arg1 = (GDALDatasetShadow *) 0 ;
+   void *argp1 = 0 ;
+   int res1 = 0 ;
+   
+   if (SWIG_GetArgs(interp, objc, objv,"o:osgeo::delete_Dataset self ",(void *)0) == TCL_ERROR) SWIG_fail;
+   res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_GDALDatasetShadow, SWIG_POINTER_DISOWN |  0 );
+   if (!SWIG_IsOK(res1)) {
+     SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "delete_Dataset" "', argument " "1"" of type '" "GDALDatasetShadow *""'"); 
+   }
+   arg1 = reinterpret_cast< GDALDatasetShadow * >(argp1);
+   {
+     CPLErrorReset();
+     delete_GDALDatasetShadow(arg1);
+     CPLErr eclass = CPLGetLastErrorType();
+     if ( eclass == CE_Failure || eclass == CE_Fatal ) {
+       SWIG_exception( SWIG_RuntimeError, CPLGetLastErrorMsg() );
+       
+     }
+     
+     
+     
+     
+     
+     
+     
+     
+     
+     
+     
+   }
+   
+   return TCL_OK;
+ fail:
+   return TCL_ERROR;
+ }
+ 
+ 
+ SWIGINTERN int
+ _wrap_Dataset_GetDriver(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
+   GDALDatasetShadow *arg1 = (GDALDatasetShadow *) 0 ;
+   void *argp1 = 0 ;
+   int res1 = 0 ;
+   GDALDriverShadow *result = 0 ;
+   
+   if (SWIG_GetArgs(interp, objc, objv,"o:osgeo::Dataset_GetDriver self ",(void *)0) == TCL_ERROR) SWIG_fail;
+   res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_GDALDatasetShadow, 0 |  0 );
+   if (!SWIG_IsOK(res1)) {
+     SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Dataset_GetDriver" "', argument " "1"" of type '" "GDALDatasetShadow *""'"); 
+   }
+   arg1 = reinterpret_cast< GDALDatasetShadow * >(argp1);
+   {
+     CPLErrorReset();
+     result = (GDALDriverShadow *)GDALDatasetShadow_GetDriver(arg1);
+     CPLErr eclass = CPLGetLastErrorType();
+     if ( eclass == CE_Failure || eclass == CE_Fatal ) {
+       SWIG_exception( SWIG_RuntimeError, CPLGetLastErrorMsg() );
+       
+     }
+     
+     
+     
+     
+     
+     
+     
+     
+     
+     
+     
+   }
+   Tcl_SetObjResult(interp, SWIG_NewInstanceObj( SWIG_as_voidptr(result), SWIGTYPE_p_GDALDriverShadow,0));
+   return TCL_OK;
+ fail:
+   return TCL_ERROR;
+ }
+ 
+ 
+ SWIGINTERN int
+ _wrap_Dataset_GetRasterBand(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
+   GDALDatasetShadow *arg1 = (GDALDatasetShadow *) 0 ;
+   int arg2 ;
+   void *argp1 = 0 ;
+   int res1 = 0 ;
+   int val2 ;
+   int ecode2 = 0 ;
+   GDALRasterBandShadow *result = 0 ;
+   
+   if (SWIG_GetArgs(interp, objc, objv,"oo:osgeo::Dataset_GetRasterBand self nBand ",(void *)0,(void *)0) == TCL_ERROR) SWIG_fail;
+   res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_GDALDatasetShadow, 0 |  0 );
+   if (!SWIG_IsOK(res1)) {
+     SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Dataset_GetRasterBand" "', argument " "1"" of type '" "GDALDatasetShadow *""'"); 
+   }
+   arg1 = reinterpret_cast< GDALDatasetShadow * >(argp1);
+   ecode2 = SWIG_AsVal_int SWIG_TCL_CALL_ARGS_2(objv[2], &val2);
+   if (!SWIG_IsOK(ecode2)) {
+     SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "Dataset_GetRasterBand" "', argument " "2"" of type '" "int""'");
+   } 
+   arg2 = static_cast< int >(val2);
+   {
+     CPLErrorReset();
+     result = (GDALRasterBandShadow *)GDALDatasetShadow_GetRasterBand(arg1,arg2);
+     CPLErr eclass = CPLGetLastErrorType();
+     if ( eclass == CE_Failure || eclass == CE_Fatal ) {
+       SWIG_exception( SWIG_RuntimeError, CPLGetLastErrorMsg() );
+       
+     }
+     
+     
+     
+     
+     
+     
+     
+     
+     
+     
+     
+   }
+   Tcl_SetObjResult(interp, SWIG_NewInstanceObj( SWIG_as_voidptr(result), SWIGTYPE_p_GDALRasterBandShadow,0));
+   return TCL_OK;
+ fail:
+   return TCL_ERROR;
+ }
+ 
+ 
+ SWIGINTERN int
+ _wrap_Dataset_GetProjection(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
+   GDALDatasetShadow *arg1 = (GDALDatasetShadow *) 0 ;
+   void *argp1 = 0 ;
+   int res1 = 0 ;
+   char *result = 0 ;
+   
+   if (SWIG_GetArgs(interp, objc, objv,"o:osgeo::Dataset_GetProjection self ",(void *)0) == TCL_ERROR) SWIG_fail;
+   res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_GDALDatasetShadow, 0 |  0 );
+   if (!SWIG_IsOK(res1)) {
+     SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Dataset_GetProjection" "', argument " "1"" of type '" "GDALDatasetShadow *""'"); 
+   }
+   arg1 = reinterpret_cast< GDALDatasetShadow * >(argp1);
+   {
+     CPLErrorReset();
+     result = (char *)GDALDatasetShadow_GetProjection(arg1);
+     CPLErr eclass = CPLGetLastErrorType();
+     if ( eclass == CE_Failure || eclass == CE_Fatal ) {
+       SWIG_exception( SWIG_RuntimeError, CPLGetLastErrorMsg() );
+       
+     }
+     
+     
+     
+     
+     
+     
+     
+     
+     
+     
+     
+   }
+   Tcl_SetObjResult(interp,SWIG_FromCharPtr((const char *)result));
+   return TCL_OK;
+ fail:
+   return TCL_ERROR;
+ }
+ 
+ 
+ SWIGINTERN int
+ _wrap_Dataset_GetProjectionRef(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
+   GDALDatasetShadow *arg1 = (GDALDatasetShadow *) 0 ;
+   void *argp1 = 0 ;
+   int res1 = 0 ;
+   char *result = 0 ;
+   
+   if (SWIG_GetArgs(interp, objc, objv,"o:osgeo::Dataset_GetProjectionRef self ",(void *)0) == TCL_ERROR) SWIG_fail;
+   res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_GDALDatasetShadow, 0 |  0 );
+   if (!SWIG_IsOK(res1)) {
+     SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Dataset_GetProjectionRef" "', argument " "1"" of type '" "GDALDatasetShadow *""'"); 
+   }
+   arg1 = reinterpret_cast< GDALDatasetShadow * >(argp1);
+   {
+     CPLErrorReset();
+     result = (char *)GDALDatasetShadow_GetProjectionRef(arg1);
+     CPLErr eclass = CPLGetLastErrorType();
+     if ( eclass == CE_Failure || eclass == CE_Fatal ) {
+       SWIG_exception( SWIG_RuntimeError, CPLGetLastErrorMsg() );
+       
+     }
+     
+     
+     
+     
+     
+     
+     
+     
+     
+     
+     
+   }
+   Tcl_SetObjResult(interp,SWIG_FromCharPtr((const char *)result));
+   return TCL_OK;
+ fail:
+   return TCL_ERROR;
+ }
+ 
+ 
+ SWIGINTERN int
+ _wrap_Dataset_SetProjection(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
+   GDALDatasetShadow *arg1 = (GDALDatasetShadow *) 0 ;
+   char *arg2 = (char *) 0 ;
+   void *argp1 = 0 ;
+   int res1 = 0 ;
+   int res2 ;
+   char *buf2 = 0 ;
+   int alloc2 = 0 ;
+   CPLErr result;
+   
+   if (SWIG_GetArgs(interp, objc, objv,"oo:osgeo::Dataset_SetProjection self prj ",(void *)0,(void *)0) == TCL_ERROR) SWIG_fail;
+   res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_GDALDatasetShadow, 0 |  0 );
+   if (!SWIG_IsOK(res1)) {
+     SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Dataset_SetProjection" "', argument " "1"" of type '" "GDALDatasetShadow *""'"); 
+   }
+   arg1 = reinterpret_cast< GDALDatasetShadow * >(argp1);
+   res2 = SWIG_AsCharPtrAndSize(objv[2], &buf2, NULL, &alloc2);
+   if (!SWIG_IsOK(res2)) {
+     SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "Dataset_SetProjection" "', argument " "2"" of type '" "char const *""'");
+   }
+   arg2 = reinterpret_cast< char * >(buf2);
+   {
+     CPLErrorReset();
+     result = (CPLErr)GDALDatasetShadow_SetProjection(arg1,(char const *)arg2);
+     CPLErr eclass = CPLGetLastErrorType();
+     if ( eclass == CE_Failure || eclass == CE_Fatal ) {
+       SWIG_exception( SWIG_RuntimeError, CPLGetLastErrorMsg() );
+       
+     }
+     
+     
+     
+     
+     
+     
+     
+     
+     
+     
+     
+   }
+   Tcl_SetObjResult(interp,SWIG_From_int(static_cast< int >(result)));
+   if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
+   return TCL_OK;
+ fail:
+   if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
+   return TCL_ERROR;
+ }
+ 
+ 
+ SWIGINTERN int
+ _wrap_Dataset_GetGeoTransform(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
+   GDALDatasetShadow *arg1 = (GDALDatasetShadow *) 0 ;
+   double *arg2 ;
+   void *argp1 = 0 ;
+   int res1 = 0 ;
+   double argout2[6] ;
+   
+   {
+     /* %typemap(in,numinputs=0) (double argout2[ANY]) */
+     arg2 = argout2;
+   }
+   if (SWIG_GetArgs(interp, objc, objv,"o:osgeo::Dataset_GetGeoTransform self ",(void *)0) == TCL_ERROR) SWIG_fail;
+   res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_GDALDatasetShadow, 0 |  0 );
+   if (!SWIG_IsOK(res1)) {
+     SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Dataset_GetGeoTransform" "', argument " "1"" of type '" "GDALDatasetShadow *""'"); 
+   }
+   arg1 = reinterpret_cast< GDALDatasetShadow * >(argp1);
+   {
+     CPLErrorReset();
+     GDALDatasetShadow_GetGeoTransform(arg1,arg2);
+     CPLErr eclass = CPLGetLastErrorType();
+     if ( eclass == CE_Failure || eclass == CE_Fatal ) {
+       SWIG_exception( SWIG_RuntimeError, CPLGetLastErrorMsg() );
+       
+     }
+     
+     
+     
+     
+     
+     
+     
+     
+     
+     
+     
+   }
+   
+   {
+     /* %typemap(argout) (double argout[ANY]) */
+     Tcl_Obj *out = CreateListFromDoubleArray( interp, arg2, 6 );
+     if (out == NULL) SWIG_fail;
+     Tcl_ListObjAppendElement(interp,Tcl_GetObjResult(interp),out);
+   }
+   return TCL_OK;
+ fail:
+   return TCL_ERROR;
+ }
+ 
+ 
+ SWIGINTERN int
+ _wrap_Dataset_SetGeoTransform(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
+   GDALDatasetShadow *arg1 = (GDALDatasetShadow *) 0 ;
+   double *arg2 ;
+   void *argp1 = 0 ;
+   int res1 = 0 ;
+   double argin2[6] ;
+   CPLErr result;
+   
+   if (SWIG_GetArgs(interp, objc, objv,"oo:osgeo::Dataset_SetGeoTransform self argin ",(void *)0,(void *)0) == TCL_ERROR) SWIG_fail;
+   res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_GDALDatasetShadow, 0 |  0 );
+   if (!SWIG_IsOK(res1)) {
+     SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Dataset_SetGeoTransform" "', argument " "1"" of type '" "GDALDatasetShadow *""'"); 
+   }
+   arg1 = reinterpret_cast< GDALDatasetShadow * >(argp1);
+   {
+     /* %typemap(in) (double argin2[ANY]) */
+     arg2 = argin2;
+     int lst_size;
+     /* The following also checks if input is a list */
+     if (Tcl_ListObjLength(interp, objv[2], &lst_size) != TCL_OK) {
+       /* Error msg in interp result */
+       SWIG_fail;
+     }
+     if ( lst_size != 6 ) {
+       Tcl_SetResult(interp, (char*) "List must have length ##size", TCL_STATIC);
+       SWIG_fail;
+     }
+     for (unsigned int i=0; i<6; i++) {
+       Tcl_Obj **o = NULL;
+       if (Tcl_ListObjIndex(interp, objv[2], i, o) != TCL_OK) {
+         /* ref count is not incremented */
+         /* Error msg in interp result */
+         SWIG_fail;
+       }
+       
+       double val;
+       if (Tcl_GetDoubleFromObj(interp, *o, &val ) != TCL_OK) {
+         /* Error msg in interp result */
+         SWIG_fail;
+       }
+       arg2[i] = val;
+     }
+   }
+   {
+     CPLErrorReset();
+     result = (CPLErr)GDALDatasetShadow_SetGeoTransform(arg1,arg2);
+     CPLErr eclass = CPLGetLastErrorType();
+     if ( eclass == CE_Failure || eclass == CE_Fatal ) {
+       SWIG_exception( SWIG_RuntimeError, CPLGetLastErrorMsg() );
+       
+     }
+     
+     
+     
+     
+     
+     
+     
+     
+     
+     
+     
+   }
+   Tcl_SetObjResult(interp,SWIG_From_int(static_cast< int >(result)));
+   return TCL_OK;
+ fail:
+   return TCL_ERROR;
+ }
+ 
+ 
+ SWIGINTERN int
+ _wrap_Dataset_BuildOverviews(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
+   GDALDatasetShadow *arg1 = (GDALDatasetShadow *) 0 ;
+   char *arg2 = (char *) "NEAREST" ;
+   int arg3 = (int) 0 ;
+   int *arg4 = (int *) 0 ;
+   GDALProgressFunc arg5 = (GDALProgressFunc) NULL ;
+   void *arg6 = (void *) NULL ;
+   void *argp1 = 0 ;
+   int res1 = 0 ;
+   int res2 ;
+   char *buf2 = 0 ;
+   int alloc2 = 0 ;
+   int result;
+   
+   /* %typemap(arginit) ( const char* callback_data=NULL)  */
+   TclProgressData *psProgressInfo;
+   psProgressInfo = (TclProgressData *) CPLCalloc(1,sizeof(TclProgressData));
+   psProgressInfo->nLastReported = -1;
+   psProgressInfo->interp = interp;
+   psProgressInfo->psTclCallback = NULL;
+   psProgressInfo->psTclCallbackData = NULL;
+   if (SWIG_GetArgs(interp, objc, objv,"o|oooo:osgeo::Dataset_BuildOverviews self ?resampling? ?overviewlist? ?pOverviews? ?callback? ?callback_data? ",(void *)0,(void *)0,(void *)0,(void *)0,(void *)0) == TCL_ERROR) SWIG_fail;
+   res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_GDALDatasetShadow, 0 |  0 );
+   if (!SWIG_IsOK(res1)) {
+     SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Dataset_BuildOverviews" "', argument " "1"" of type '" "GDALDatasetShadow *""'"); 
+   }
+   arg1 = reinterpret_cast< GDALDatasetShadow * >(argp1);
+   if (objc > 2) {
+     res2 = SWIG_AsCharPtrAndSize(objv[2], &buf2, NULL, &alloc2);
+     if (!SWIG_IsOK(res2)) {
+       SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "Dataset_BuildOverviews" "', argument " "2"" of type '" "char const *""'");
+     }
+     arg2 = reinterpret_cast< char * >(buf2);
+   }
+   if (objc > 3) {
+     {
+       /* %typemap(in,numinputs=1) (int nList, int* pList)*/
+       /* The following also checks if input is a list */
+       if (Tcl_ListObjLength(interp, objv[3], &arg3) != TCL_OK) {
+         /* Error msg in interp result */
+         SWIG_fail;
+       }
+       if ( !arg3 ) {
+         Tcl_SetResult(interp, (char*) "Input list mustn't be empty", TCL_STATIC);
+         SWIG_fail;
+       }
+       
+       arg4 = (int*) CPLMalloc(arg3*sizeof(int));
+       
+       for( int i = 0; i<arg3; i++ ) {
+         Tcl_Obj **o = NULL;
+         if (Tcl_ListObjIndex(interp, objv[3], i, o) != TCL_OK) {
+           /* ref count is not incremented */
+           /* Error msg in interp result */
+           SWIG_fail;
+         }
+         
+         int val;
+         if (Tcl_GetIntFromObj(interp, *o, &val ) != TCL_OK) {
+           /* Error msg in interp result */
+           SWIG_fail;
+         }
+         arg4[i] = val;
+       }
+     }
+   }
+   if (objc > 4) {
+     {
+       /* %typemap(in) (GDALProgressFunc callback = NULL) */
+       /* callback_func typemap */
+       if (objv[4] && !strcmp(Tcl_GetString(objv[4]), "")) {
+         void* cbfunction = NULL;
+         SWIG_ConvertPtr( objv[4], 
+           (void**)&cbfunction, 
+           SWIGTYPE_p_f_double_p_q_const__char_p_void__int, 
+           SWIG_POINTER_EXCEPTION | 0 );
+         
+         if ( cbfunction == GDALTermProgress ) {
+           arg5 = GDALTermProgress;
+         } else if ( cbfunction == GDALDummyProgress) {
+           arg5 = GDALDummyProgress;
+         } else if ( cbfunction == GDALScaledProgress) {
+           arg5 = GDALScaledProgress;
+         } else {
+           psProgressInfo->psTclCallback = objv[4];
+           Tcl_IncrRefCount(psProgressInfo->psTclCallback);
+           arg5 = TclProgressProxy;
+         }
+       }
+     }
+   }
+   if (objc > 5) {
+     {
+       /* %typemap(in) ( void* callback_data=NULL)  */
+       psProgressInfo->psTclCallbackData = objv[5];
+       Tcl_IncrRefCount(psProgressInfo->psTclCallbackData);
+       arg6 = psProgressInfo;
+       
+     }
+   }
+   {
+     CPLErrorReset();
+     result = (int)GDALDatasetShadow_BuildOverviews(arg1,(char const *)arg2,arg3,arg4,arg5,arg6);
+     CPLErr eclass = CPLGetLastErrorType();
+     if ( eclass == CE_Failure || eclass == CE_Fatal ) {
+       SWIG_exception( SWIG_RuntimeError, CPLGetLastErrorMsg() );
+       
+     }
+     
+     
+     
+     
+     
+     
+     
+     
+     
+     
+     
+   }
+   Tcl_SetObjResult(interp,SWIG_From_int(static_cast< int >(result)));
+   if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
+   {
+     /* %typemap(freearg) (int nList, int* pList) */
+     if (arg4) {
+       CPLFree((void*) arg4);
+     }
+   }
+   {
+     /* %typemap(freearg) ( void* callback_data=NULL)  */
+     Tcl_DecrRefCount(psProgressInfo->psTclCallback);
+     Tcl_DecrRefCount(psProgressInfo->psTclCallbackData);
+     CPLFree(psProgressInfo);
+   }
+   return TCL_OK;
+ fail:
+   if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
+   {
+     /* %typemap(freearg) (int nList, int* pList) */
+     if (arg4) {
+       CPLFree((void*) arg4);
+     }
+   }
+   {
+     /* %typemap(freearg) ( void* callback_data=NULL)  */
+     Tcl_DecrRefCount(psProgressInfo->psTclCallback);
+     Tcl_DecrRefCount(psProgressInfo->psTclCallbackData);
+     CPLFree(psProgressInfo);
+   }
+   return TCL_ERROR;
+ }
+ 
+ 
+ SWIGINTERN int
+ _wrap_Dataset_GetGCPCount(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
+   GDALDatasetShadow *arg1 = (GDALDatasetShadow *) 0 ;
+   void *argp1 = 0 ;
+   int res1 = 0 ;
+   int result;
+   
+   if (SWIG_GetArgs(interp, objc, objv,"o:osgeo::Dataset_GetGCPCount self ",(void *)0) == TCL_ERROR) SWIG_fail;
+   res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_GDALDatasetShadow, 0 |  0 );
+   if (!SWIG_IsOK(res1)) {
+     SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Dataset_GetGCPCount" "', argument " "1"" of type '" "GDALDatasetShadow *""'"); 
+   }
+   arg1 = reinterpret_cast< GDALDatasetShadow * >(argp1);
+   {
+     CPLErrorReset();
+     result = (int)GDALDatasetShadow_GetGCPCount(arg1);
+     CPLErr eclass = CPLGetLastErrorType();
+     if ( eclass == CE_Failure || eclass == CE_Fatal ) {
+       SWIG_exception( SWIG_RuntimeError, CPLGetLastErrorMsg() );
+       
+     }
+     
+     
+     
+     
+     
+     
+     
+     
+     
+     
+     
+   }
+   Tcl_SetObjResult(interp,SWIG_From_int(static_cast< int >(result)));
+   return TCL_OK;
+ fail:
+   return TCL_ERROR;
+ }
+ 
+ 
+ SWIGINTERN int
+ _wrap_Dataset_GetGCPProjection(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
+   GDALDatasetShadow *arg1 = (GDALDatasetShadow *) 0 ;
+   void *argp1 = 0 ;
+   int res1 = 0 ;
+   char *result = 0 ;
+   
+   if (SWIG_GetArgs(interp, objc, objv,"o:osgeo::Dataset_GetGCPProjection self ",(void *)0) == TCL_ERROR) SWIG_fail;
+   res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_GDALDatasetShadow, 0 |  0 );
+   if (!SWIG_IsOK(res1)) {
+     SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Dataset_GetGCPProjection" "', argument " "1"" of type '" "GDALDatasetShadow *""'"); 
+   }
+   arg1 = reinterpret_cast< GDALDatasetShadow * >(argp1);
+   {
+     CPLErrorReset();
+     result = (char *)GDALDatasetShadow_GetGCPProjection(arg1);
+     CPLErr eclass = CPLGetLastErrorType();
+     if ( eclass == CE_Failure || eclass == CE_Fatal ) {
+       SWIG_exception( SWIG_RuntimeError, CPLGetLastErrorMsg() );
+       
+     }
+     
+     
+     
+     
+     
+     
+     
+     
+     
+     
+     
+   }
+   Tcl_SetObjResult(interp,SWIG_FromCharPtr((const char *)result));
+   return TCL_OK;
+ fail:
+   return TCL_ERROR;
+ }
+ 
+ 
+ SWIGINTERN int
+ _wrap_Dataset_GetGCPs(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
+   GDALDatasetShadow *arg1 = (GDALDatasetShadow *) 0 ;
+   int *arg2 = (int *) 0 ;
+   GDAL_GCP **arg3 = (GDAL_GCP **) 0 ;
+   void *argp1 = 0 ;
+   int res1 = 0 ;
+   int nGCPs2 = 0 ;
+   GDAL_GCP *pGCPs2 = 0 ;
+   
+   {
+     /* %typemap(in,numinputs=0) (int *nGCPs2, GDAL_GCP const **pGCPs2 ) */
+     arg2 = &nGCPs2;
+     arg3 = &pGCPs2;
+   }
+   if (SWIG_GetArgs(interp, objc, objv,"o:osgeo::Dataset_GetGCPs self ?pGCPs? ",(void *)0) == TCL_ERROR) SWIG_fail;
+   res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_GDALDatasetShadow, 0 |  0 );
+   if (!SWIG_IsOK(res1)) {
+     SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Dataset_GetGCPs" "', argument " "1"" of type '" "GDALDatasetShadow *""'"); 
+   }
+   arg1 = reinterpret_cast< GDALDatasetShadow * >(argp1);
+   {
+     CPLErrorReset();
+     GDALDatasetShadow_GetGCPs(arg1,arg2,(GDAL_GCP const **)arg3);
+     CPLErr eclass = CPLGetLastErrorType();
+     if ( eclass == CE_Failure || eclass == CE_Fatal ) {
+       SWIG_exception( SWIG_RuntimeError, CPLGetLastErrorMsg() );
+       
+     }
+     
+     
+     
+     
+     
+     
+     
+     
+     
+     
+     
+   }
+   
+   {
+     /* %typemap(argout) (int *nGCPs, GDAL_GCP const **pGCPs ) */
+     Tcl_Obj *out = Tcl_NewListObj(0, NULL);;
+     for( int i = 0; i < *arg2; i++ ) {
+       /* We dublicate every GCP (seperate object in memory) */
+       GDAL_GCP *o = new_GDAL_GCP( (*arg3)[i].dfGCPX,
+         (*arg3)[i].dfGCPY,
+         (*arg3)[i].dfGCPZ,
+         (*arg3)[i].dfGCPPixel,
+         (*arg3)[i].dfGCPLine,
+         (*arg3)[i].pszInfo,
+         (*arg3)[i].pszId );
+       if (Tcl_ListObjAppendElement(interp, out, SWIG_NewPointerObj((void*)o,SWIGTYPE_p_GDAL_GCP,1)) != TCL_OK) {
+         delete_GDAL_GCP(o);
+         /* Note: XXX I assume here that by freeing this list, the respective GDAL_GCP memory of each pointer is fred automatically */
+         Tcl_DecrRefCount(out);
+         /* Error msg in interp result */
+         SWIG_fail;
+       }
+     }
+     Tcl_SetObjResult(interp, out);
+   }
+   return TCL_OK;
+ fail:
+   return TCL_ERROR;
+ }
+ 
+ 
+ SWIGINTERN int
+ _wrap_Dataset_SetGCPs(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
+   GDALDatasetShadow *arg1 = (GDALDatasetShadow *) 0 ;
+   int arg2 ;
+   GDAL_GCP *arg3 = (GDAL_GCP *) 0 ;
+   char *arg4 = (char *) 0 ;
+   void *argp1 = 0 ;
+   int res1 = 0 ;
+   GDAL_GCP *tmpGCPList2 ;
+   int res4 ;
+   char *buf4 = 0 ;
+   int alloc4 = 0 ;
+   CPLErr result;
+   
+   if (SWIG_GetArgs(interp, objc, objv,"ooo:osgeo::Dataset_SetGCPs self nGCPs pGCPs ?pszGCPProjection? ",(void *)0,(void *)0,(void *)0) == TCL_ERROR) SWIG_fail;
+   res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_GDALDatasetShadow, 0 |  0 );
+   if (!SWIG_IsOK(res1)) {
+     SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Dataset_SetGCPs" "', argument " "1"" of type '" "GDALDatasetShadow *""'"); 
+   }
+   arg1 = reinterpret_cast< GDALDatasetShadow * >(argp1);
+   {
+     /* %typemap(in,numinputs=1) (int nGCPs, GDAL_GCP const *pGCPs ) */
+     /* The following also checks if input is a list */
+     if (Tcl_ListObjLength(interp, objv[2], &arg2) != TCL_OK) {
+       /* Error msg in interp result */
+       SWIG_fail;
+     }
+     if ( !arg2 ) {
+       Tcl_SetResult(interp, (char*) "Input list mustn't be empty", TCL_STATIC);
+       SWIG_fail;
+     }
+     
+     tmpGCPList2 = (GDAL_GCP*) CPLMalloc(arg2*sizeof(GDAL_GCP));
+     arg3 = tmpGCPList2;
+     for( int i = 0; i<arg2; i++ ) {
+       Tcl_Obj **o = NULL;
+       /* The reference count for the list element is not incremented with the following */
+       if (Tcl_ListObjIndex(interp, objv[2], i, o) != TCL_OK) {
+         /* Error msg in interp result */
+         SWIG_fail;
+       }
+       
+       GDAL_GCP *item = 0;
+       SWIG_ConvertPtr( *o, (void**)&item, SWIGTYPE_p_GDAL_GCP, SWIG_POINTER_EXCEPTION | 0 );
+       if ( ! item ) {
+         SWIG_fail;
+       }
+       
+       memcpy( (void*) tmpGCPList2, (void*) item, sizeof( GDAL_GCP ) );
+       ++tmpGCPList2;
+     }
+   }
+   res4 = SWIG_AsCharPtrAndSize(objv[3], &buf4, NULL, &alloc4);
+   if (!SWIG_IsOK(res4)) {
+     SWIG_exception_fail(SWIG_ArgError(res4), "in method '" "Dataset_SetGCPs" "', argument " "4"" of type '" "char const *""'");
+   }
+   arg4 = reinterpret_cast< char * >(buf4);
+   {
+     CPLErrorReset();
+     result = (CPLErr)GDALDatasetShadow_SetGCPs(arg1,arg2,(GDAL_GCP const *)arg3,(char const *)arg4);
+     CPLErr eclass = CPLGetLastErrorType();
+     if ( eclass == CE_Failure || eclass == CE_Fatal ) {
+       SWIG_exception( SWIG_RuntimeError, CPLGetLastErrorMsg() );
+       
+     }
+     
+     
+     
+     
+     
+     
+     
+     
+     
+     
+     
+   }
+   Tcl_SetObjResult(interp,SWIG_From_int(static_cast< int >(result)));
+   {
+     /* %typemap(freearg) (int nGCPs, GDAL_GCP const *pGCPs ) */
+     if (arg3) {
+       CPLFree( (void*) arg3 );
+     }
+   }
+   if (alloc4 == SWIG_NEWOBJ) delete[] buf4;
+   return TCL_OK;
+ fail:
+   {
+     /* %typemap(freearg) (int nGCPs, GDAL_GCP const *pGCPs ) */
+     if (arg3) {
+       CPLFree( (void*) arg3 );
+     }
+   }
+   if (alloc4 == SWIG_NEWOBJ) delete[] buf4;
+   return TCL_ERROR;
+ }
+ 
+ 
+ SWIGINTERN int
+ _wrap_Dataset_FlushCache(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
+   GDALDatasetShadow *arg1 = (GDALDatasetShadow *) 0 ;
+   void *argp1 = 0 ;
+   int res1 = 0 ;
+   
+   if (SWIG_GetArgs(interp, objc, objv,"o:osgeo::Dataset_FlushCache self ",(void *)0) == TCL_ERROR) SWIG_fail;
+   res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_GDALDatasetShadow, 0 |  0 );
+   if (!SWIG_IsOK(res1)) {
+     SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Dataset_FlushCache" "', argument " "1"" of type '" "GDALDatasetShadow *""'"); 
+   }
+   arg1 = reinterpret_cast< GDALDatasetShadow * >(argp1);
+   {
+     CPLErrorReset();
+     GDALDatasetShadow_FlushCache(arg1);
+     CPLErr eclass = CPLGetLastErrorType();
+     if ( eclass == CE_Failure || eclass == CE_Fatal ) {
+       SWIG_exception( SWIG_RuntimeError, CPLGetLastErrorMsg() );
+       
+     }
+     
+     
+     
+     
+     
+     
+     
+     
+     
+     
+     
+   }
+   
+   return TCL_OK;
+ fail:
+   return TCL_ERROR;
+ }
+ 
+ 
+ SWIGINTERN int
+ _wrap_Dataset_AddBand(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
+   GDALDatasetShadow *arg1 = (GDALDatasetShadow *) 0 ;
+   GDALDataType arg2 = (GDALDataType) GDT_Byte ;
+   char **arg3 = (char **) 0 ;
+   void *argp1 = 0 ;
+   int res1 = 0 ;
+   int val2 ;
+   int ecode2 = 0 ;
+   CPLErr result;
+   
+   if (SWIG_GetArgs(interp, objc, objv,"o|oo:osgeo::Dataset_AddBand self ?datatype? ?options? ",(void *)0,(void *)0,(void *)0) == TCL_ERROR) SWIG_fail;
+   res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_GDALDatasetShadow, 0 |  0 );
+   if (!SWIG_IsOK(res1)) {
+     SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Dataset_AddBand" "', argument " "1"" of type '" "GDALDatasetShadow *""'"); 
+   }
+   arg1 = reinterpret_cast< GDALDatasetShadow * >(argp1);
+   if (objc > 2) {
+     ecode2 = SWIG_AsVal_int SWIG_TCL_CALL_ARGS_2(objv[2], &val2);
+     if (!SWIG_IsOK(ecode2)) {
+       SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "Dataset_AddBand" "', argument " "2"" of type '" "GDALDataType""'");
+     } 
+     arg2 = static_cast< GDALDataType >(val2);
+   }
+   if (objc > 3) {
+     {
+       /* %typemap(in) char **options */
+       int size;
+       if (Tcl_ListObjLength(interp, objv[3], &size) != TCL_OK) {
+         /* Error msg in interp result */
+         SWIG_fail;
+       }
+       if ( !size ) {
+         Tcl_SetResult(interp, (char*) "Input list mustn't be empty", TCL_STATIC);
+         SWIG_fail;
+       }
+       
+       for (int i = 0; i < size; i++) {
+         Tcl_Obj **o = NULL;
+         /* The reference count for the list element is not incremented with the following */
+         if (Tcl_ListObjIndex(interp, objv[3], i, o) != TCL_OK) {
+           /* Error msg in interp result */
+           SWIG_fail;
+         }
+         char *pszItem = Tcl_GetString(*o);
+         arg3 = CSLAddString( arg3, pszItem );
+       }
+     }
+   }
+   {
+     CPLErrorReset();
+     result = (CPLErr)GDALDatasetShadow_AddBand(arg1,arg2,arg3);
+     CPLErr eclass = CPLGetLastErrorType();
+     if ( eclass == CE_Failure || eclass == CE_Fatal ) {
+       SWIG_exception( SWIG_RuntimeError, CPLGetLastErrorMsg() );
+       
+     }
+     
+     
+     
+     
+     
+     
+     
+     
+     
+     
+     
+   }
+   Tcl_SetObjResult(interp,SWIG_From_int(static_cast< int >(result)));
+   {
+     /* %typemap(freearg) char **options */
+     CSLDestroy( arg3 );
+   }
+   return TCL_OK;
+ fail:
+   {
+     /* %typemap(freearg) char **options */
+     CSLDestroy( arg3 );
+   }
+   return TCL_ERROR;
+ }
+ 
+ 
+ SWIGINTERN int
+ _wrap_Dataset_CreateMaskBand(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
+   GDALDatasetShadow *arg1 = (GDALDatasetShadow *) 0 ;
+   int arg2 ;
+   void *argp1 = 0 ;
+   int res1 = 0 ;
+   int val2 ;
+   int ecode2 = 0 ;
+   CPLErr result;
+   
+   if (SWIG_GetArgs(interp, objc, objv,"oo:osgeo::Dataset_CreateMaskBand self nFlags ",(void *)0,(void *)0) == TCL_ERROR) SWIG_fail;
+   res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_GDALDatasetShadow, 0 |  0 );
+   if (!SWIG_IsOK(res1)) {
+     SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Dataset_CreateMaskBand" "', argument " "1"" of type '" "GDALDatasetShadow *""'"); 
+   }
+   arg1 = reinterpret_cast< GDALDatasetShadow * >(argp1);
+   ecode2 = SWIG_AsVal_int SWIG_TCL_CALL_ARGS_2(objv[2], &val2);
+   if (!SWIG_IsOK(ecode2)) {
+     SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "Dataset_CreateMaskBand" "', argument " "2"" of type '" "int""'");
+   } 
+   arg2 = static_cast< int >(val2);
+   {
+     CPLErrorReset();
+     result = (CPLErr)GDALDatasetShadow_CreateMaskBand(arg1,arg2);
+     CPLErr eclass = CPLGetLastErrorType();
+     if ( eclass == CE_Failure || eclass == CE_Fatal ) {
+       SWIG_exception( SWIG_RuntimeError, CPLGetLastErrorMsg() );
+       
+     }
+     
+     
+     
+     
+     
+     
+     
+     
+     
+     
+     
+   }
+   Tcl_SetObjResult(interp,SWIG_From_int(static_cast< int >(result)));
+   return TCL_OK;
+ fail:
+   return TCL_ERROR;
+ }
+ 
+ 
+ SWIGINTERN int
+ _wrap_Dataset_GetFileList(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
+   GDALDatasetShadow *arg1 = (GDALDatasetShadow *) 0 ;
+   void *argp1 = 0 ;
+   int res1 = 0 ;
+   char **result = 0 ;
+   
+   if (SWIG_GetArgs(interp, objc, objv,"o:osgeo::Dataset_GetFileList self ",(void *)0) == TCL_ERROR) SWIG_fail;
+   res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_GDALDatasetShadow, 0 |  0 );
+   if (!SWIG_IsOK(res1)) {
+     SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Dataset_GetFileList" "', argument " "1"" of type '" "GDALDatasetShadow *""'"); 
+   }
+   arg1 = reinterpret_cast< GDALDatasetShadow * >(argp1);
+   {
+     CPLErrorReset();
+     result = (char **)GDALDatasetShadow_GetFileList(arg1);
+     CPLErr eclass = CPLGetLastErrorType();
+     if ( eclass == CE_Failure || eclass == CE_Fatal ) {
+       SWIG_exception( SWIG_RuntimeError, CPLGetLastErrorMsg() );
+       
+     }
+     
+     
+     
+     
+     
+     
+     
+     
+     
+     
+     
+   }
+   {
+     /* %typemap(out) char **options -> ( string ) */
+     char **stringarray = result;
+     if ( stringarray == NULL ) {
+       Tcl_ResetResult(interp); /* NONE = Empty string */
+     } else {
+       int len = CSLCount( stringarray );
+       Tcl_Obj *out = Tcl_NewListObj(0, NULL);
+       for ( int i = 0; i < len; ++i ) {
+         Tcl_Obj *o = Tcl_NewStringObj( stringarray[i], -1 );
+         if (Tcl_ListObjAppendElement(interp, out, o) != TCL_OK) {
+           Tcl_DecrRefCount(o);
+           Tcl_DecrRefCount(out);
+           /* Error msg in interp result */
+           SWIG_fail;
+         }
+       }
+       Tcl_SetObjResult(interp, out);
+     }
+   }
+   return TCL_OK;
+ fail:
+   return TCL_ERROR;
+ }
+ 
+ 
+ SWIGINTERN int
+ _wrap_Dataset_WriteRaster(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
+   GDALDatasetShadow *arg1 = (GDALDatasetShadow *) 0 ;
+   int arg2 ;
+   int arg3 ;
+   int arg4 ;
+   int arg5 ;
+   int arg6 ;
+   char *arg7 = (char *) 0 ;
+   int *arg8 = (int *) 0 ;
+   int *arg9 = (int *) 0 ;
+   GDALDataType *arg10 = (GDALDataType *) 0 ;
+   int arg11 = (int) 0 ;
+   int *arg12 = (int *) 0 ;
+   void *argp1 = 0 ;
+   int res1 = 0 ;
+   int val2 ;
+   int ecode2 = 0 ;
+   int val3 ;
+   int ecode3 = 0 ;
+   int val4 ;
+   int ecode4 = 0 ;
+   int val5 ;
+   int ecode5 = 0 ;
+   void *argp8 = 0 ;
+   int res8 = 0 ;
+   void *argp9 = 0 ;
+   int res9 = 0 ;
+   void *argp10 = 0 ;
+   int res10 = 0 ;
+   CPLErr result;
+   
+   if (SWIG_GetArgs(interp, objc, objv,"oooooo|oooo:osgeo::Dataset_WriteRaster self xoff yoff xsize ysize buf_len ?buf_string? ?buf_xsize? ?buf_ysize? ?buf_type? ?band_list? ?pband_list? ",(void *)0,(void *)0,(void *)0,(void *)0,(void *)0,(void *)0,(void *)0,(void *)0,(void *)0,(void *)0) == TCL_ERROR) SWIG_fail;
+   res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_GDALDatasetShadow, 0 |  0 );
+   if (!SWIG_IsOK(res1)) {
+     SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Dataset_WriteRaster" "', argument " "1"" of type '" "GDALDatasetShadow *""'"); 
+   }
+   arg1 = reinterpret_cast< GDALDatasetShadow * >(argp1);
+   ecode2 = SWIG_AsVal_int SWIG_TCL_CALL_ARGS_2(objv[2], &val2);
+   if (!SWIG_IsOK(ecode2)) {
+     SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "Dataset_WriteRaster" "', argument " "2"" of type '" "int""'");
+   } 
+   arg2 = static_cast< int >(val2);
+   ecode3 = SWIG_AsVal_int SWIG_TCL_CALL_ARGS_2(objv[3], &val3);
+   if (!SWIG_IsOK(ecode3)) {
+     SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "Dataset_WriteRaster" "', argument " "3"" of type '" "int""'");
+   } 
+   arg3 = static_cast< int >(val3);
+   ecode4 = SWIG_AsVal_int SWIG_TCL_CALL_ARGS_2(objv[4], &val4);
+   if (!SWIG_IsOK(ecode4)) {
+     SWIG_exception_fail(SWIG_ArgError(ecode4), "in method '" "Dataset_WriteRaster" "', argument " "4"" of type '" "int""'");
+   } 
+   arg4 = static_cast< int >(val4);
+   ecode5 = SWIG_AsVal_int SWIG_TCL_CALL_ARGS_2(objv[5], &val5);
+   if (!SWIG_IsOK(ecode5)) {
+     SWIG_exception_fail(SWIG_ArgError(ecode5), "in method '" "Dataset_WriteRaster" "', argument " "5"" of type '" "int""'");
+   } 
+   arg5 = static_cast< int >(val5);
+   {
+     /* %typemap(in,numinputs=1) (int nLen, char *pBuf ) */
+     /* Storage is handled by the respective Tcl_Obj. It should considered read-only. */
+     arg7 = Tcl_GetStringFromObj(objv[6], &arg6);
+   }
+   if (objc > 7) {
+     res8 = SWIG_ConvertPtr(objv[7], &argp8,SWIGTYPE_p_int, 0 |  0 );
+     if (!SWIG_IsOK(res8)) {
+       SWIG_exception_fail(SWIG_ArgError(res8), "in method '" "Dataset_WriteRaster" "', argument " "8"" of type '" "int *""'"); 
+     }
+     arg8 = reinterpret_cast< int * >(argp8);
+   }
+   if (objc > 8) {
+     res9 = SWIG_ConvertPtr(objv[8], &argp9,SWIGTYPE_p_int, 0 |  0 );
+     if (!SWIG_IsOK(res9)) {
+       SWIG_exception_fail(SWIG_ArgError(res9), "in method '" "Dataset_WriteRaster" "', argument " "9"" of type '" "int *""'"); 
+     }
+     arg9 = reinterpret_cast< int * >(argp9);
+   }
+   if (objc > 9) {
+     res10 = SWIG_ConvertPtr(objv[9], &argp10,SWIGTYPE_p_int, 0 |  0 );
+     if (!SWIG_IsOK(res10)) {
+       SWIG_exception_fail(SWIG_ArgError(res10), "in method '" "Dataset_WriteRaster" "', argument " "10"" of type '" "GDALDataType *""'"); 
+     }
+     arg10 = reinterpret_cast< GDALDataType * >(argp10);
+   }
+   if (objc > 10) {
+     {
+       /* %typemap(in,numinputs=1) (int nList, int* pList)*/
+       /* The following also checks if input is a list */
+       if (Tcl_ListObjLength(interp, objv[10], &arg11) != TCL_OK) {
+         /* Error msg in interp result */
+         SWIG_fail;
+       }
+       if ( !arg11 ) {
+         Tcl_SetResult(interp, (char*) "Input list mustn't be empty", TCL_STATIC);
+         SWIG_fail;
+       }
+       
+       arg12 = (int*) CPLMalloc(arg11*sizeof(int));
+       
+       for( int i = 0; i<arg11; i++ ) {
+         Tcl_Obj **o = NULL;
+         if (Tcl_ListObjIndex(interp, objv[10], i, o) != TCL_OK) {
+           /* ref count is not incremented */
+           /* Error msg in interp result */
+           SWIG_fail;
+         }
+         
+         int val;
+         if (Tcl_GetIntFromObj(interp, *o, &val ) != TCL_OK) {
+           /* Error msg in interp result */
+           SWIG_fail;
+         }
+         arg12[i] = val;
+       }
+     }
+   }
+   {
+     CPLErrorReset();
+     result = (CPLErr)GDALDatasetShadow_WriteRaster(arg1,arg2,arg3,arg4,arg5,arg6,arg7,arg8,arg9,arg10,arg11,arg12);
+     CPLErr eclass = CPLGetLastErrorType();
+     if ( eclass == CE_Failure || eclass == CE_Fatal ) {
+       SWIG_exception( SWIG_RuntimeError, CPLGetLastErrorMsg() );
+       
+     }
+     
+     
+     
+     
+     
+     
+     
+     
+     
+     
+     
+   }
+   Tcl_SetObjResult(interp,SWIG_From_int(static_cast< int >(result)));
+   {
+     /* %typemap(freearg) (int nList, int* pList) */
+     if (arg12) {
+       CPLFree((void*) arg12);
+     }
+   }
+   return TCL_OK;
+ fail:
+   {
+     /* %typemap(freearg) (int nList, int* pList) */
+     if (arg12) {
+       CPLFree((void*) arg12);
+     }
+   }
+   return TCL_ERROR;
+ }
+ 
+ 
+ SWIGINTERN int
+ _wrap_Dataset_ReadRaster(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
+   GDALDatasetShadow *arg1 = (GDALDatasetShadow *) 0 ;
+   int arg2 ;
+   int arg3 ;
+   int arg4 ;
+   int arg5 ;
+   int *arg6 = (int *) 0 ;
+   char **arg7 = (char **) 0 ;
+   int *arg8 = (int *) 0 ;
+   int *arg9 = (int *) 0 ;
+   GDALDataType *arg10 = (GDALDataType *) 0 ;
+   int arg11 = (int) 0 ;
+   int *arg12 = (int *) 0 ;
+   void *argp1 = 0 ;
+   int res1 = 0 ;
+   int val2 ;
+   int ecode2 = 0 ;
+   int val3 ;
+   int ecode3 = 0 ;
+   int val4 ;
+   int ecode4 = 0 ;
+   int val5 ;
+   int ecode5 = 0 ;
+   int nLen6 = 0 ;
+   char *pBuf6 = 0 ;
+   void *argp8 = 0 ;
+   int res8 = 0 ;
+   void *argp9 = 0 ;
+   int res9 = 0 ;
+   void *argp10 = 0 ;
+   int res10 = 0 ;
+   CPLErr result;
+   
+   {
+     /* %typemap(in,numinputs=0) (int *nLen6, char **pBuf6 ) */
+     arg6 = &nLen6;
+     arg7 = &pBuf6;
+   }
+   if (SWIG_GetArgs(interp, objc, objv,"ooooo|oooo:osgeo::Dataset_ReadRaster self xoff yoff xsize ysize ?buf? ?buf_xsize? ?buf_ysize? ?buf_type? ?band_list? ?pband_list? ",(void *)0,(void *)0,(void *)0,(void *)0,(void *)0,(void *)0,(void *)0,(void *)0,(void *)0) == TCL_ERROR) SWIG_fail;
+   res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_GDALDatasetShadow, 0 |  0 );
+   if (!SWIG_IsOK(res1)) {
+     SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Dataset_ReadRaster" "', argument " "1"" of type '" "GDALDatasetShadow *""'"); 
+   }
+   arg1 = reinterpret_cast< GDALDatasetShadow * >(argp1);
+   ecode2 = SWIG_AsVal_int SWIG_TCL_CALL_ARGS_2(objv[2], &val2);
+   if (!SWIG_IsOK(ecode2)) {
+     SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "Dataset_ReadRaster" "', argument " "2"" of type '" "int""'");
+   } 
+   arg2 = static_cast< int >(val2);
+   ecode3 = SWIG_AsVal_int SWIG_TCL_CALL_ARGS_2(objv[3], &val3);
+   if (!SWIG_IsOK(ecode3)) {
+     SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "Dataset_ReadRaster" "', argument " "3"" of type '" "int""'");
+   } 
+   arg3 = static_cast< int >(val3);
+   ecode4 = SWIG_AsVal_int SWIG_TCL_CALL_ARGS_2(objv[4], &val4);
+   if (!SWIG_IsOK(ecode4)) {
+     SWIG_exception_fail(SWIG_ArgError(ecode4), "in method '" "Dataset_ReadRaster" "', argument " "4"" of type '" "int""'");
+   } 
+   arg4 = static_cast< int >(val4);
+   ecode5 = SWIG_AsVal_int SWIG_TCL_CALL_ARGS_2(objv[5], &val5);
+   if (!SWIG_IsOK(ecode5)) {
+     SWIG_exception_fail(SWIG_ArgError(ecode5), "in method '" "Dataset_ReadRaster" "', argument " "5"" of type '" "int""'");
+   } 
+   arg5 = static_cast< int >(val5);
+   if (objc > 6) {
+     res8 = SWIG_ConvertPtr(objv[6], &argp8,SWIGTYPE_p_int, 0 |  0 );
+     if (!SWIG_IsOK(res8)) {
+       SWIG_exception_fail(SWIG_ArgError(res8), "in method '" "Dataset_ReadRaster" "', argument " "8"" of type '" "int *""'"); 
+     }
+     arg8 = reinterpret_cast< int * >(argp8);
+   }
+   if (objc > 7) {
+     res9 = SWIG_ConvertPtr(objv[7], &argp9,SWIGTYPE_p_int, 0 |  0 );
+     if (!SWIG_IsOK(res9)) {
+       SWIG_exception_fail(SWIG_ArgError(res9), "in method '" "Dataset_ReadRaster" "', argument " "9"" of type '" "int *""'"); 
+     }
+     arg9 = reinterpret_cast< int * >(argp9);
+   }
+   if (objc > 8) {
+     res10 = SWIG_ConvertPtr(objv[8], &argp10,SWIGTYPE_p_int, 0 |  0 );
+     if (!SWIG_IsOK(res10)) {
+       SWIG_exception_fail(SWIG_ArgError(res10), "in method '" "Dataset_ReadRaster" "', argument " "10"" of type '" "GDALDataType *""'"); 
+     }
+     arg10 = reinterpret_cast< GDALDataType * >(argp10);
+   }
+   if (objc > 9) {
+     {
+       /* %typemap(in,numinputs=1) (int nList, int* pList)*/
+       /* The following also checks if input is a list */
+       if (Tcl_ListObjLength(interp, objv[9], &arg11) != TCL_OK) {
+         /* Error msg in interp result */
+         SWIG_fail;
+       }
+       if ( !arg11 ) {
+         Tcl_SetResult(interp, (char*) "Input list mustn't be empty", TCL_STATIC);
+         SWIG_fail;
+       }
+       
+       arg12 = (int*) CPLMalloc(arg11*sizeof(int));
+       
+       for( int i = 0; i<arg11; i++ ) {
+         Tcl_Obj **o = NULL;
+         if (Tcl_ListObjIndex(interp, objv[9], i, o) != TCL_OK) {
+           /* ref count is not incremented */
+           /* Error msg in interp result */
+           SWIG_fail;
+         }
+         
+         int val;
+         if (Tcl_GetIntFromObj(interp, *o, &val ) != TCL_OK) {
+           /* Error msg in interp result */
+           SWIG_fail;
+         }
+         arg12[i] = val;
+       }
+     }
+   }
+   {
+     CPLErrorReset();
+     result = (CPLErr)GDALDatasetShadow_ReadRaster(arg1,arg2,arg3,arg4,arg5,arg6,arg7,arg8,arg9,arg10,arg11,arg12);
+     CPLErr eclass = CPLGetLastErrorType();
+     if ( eclass == CE_Failure || eclass == CE_Fatal ) {
+       SWIG_exception( SWIG_RuntimeError, CPLGetLastErrorMsg() );
+       
+     }
+     
+     
+     
+     
+     
+     
+     
+     
+     
+     
+     
+   }
+   Tcl_SetObjResult(interp,SWIG_From_int(static_cast< int >(result)));
+   {
+     /* %typemap(argout) (int *nLen, char **pBuf ) */
+     Tcl_SetObjResult(interp, Tcl_NewStringObj( *arg7, *arg6 ));
+   }
+   {
+     /* %typemap(freearg) (int nList, int* pList) */
+     if (arg12) {
+       CPLFree((void*) arg12);
+     }
+   }
+   return TCL_OK;
+ fail:
+   {
+     /* %typemap(freearg) (int nList, int* pList) */
+     if (arg12) {
+       CPLFree((void*) arg12);
+     }
+   }
+   return TCL_ERROR;
+ }
+ 
+ 
+ SWIGINTERN void swig_delete_Dataset(void *obj) {
+ GDALDatasetShadow *arg1 = (GDALDatasetShadow *) obj;
+ delete_GDALDatasetShadow(arg1);
+ }
+ static swig_method swig_GDALDatasetShadow_methods[] = {
+     {"GetDriver", _wrap_Dataset_GetDriver}, 
+     {"GetRasterBand", _wrap_Dataset_GetRasterBand}, 
+     {"GetProjection", _wrap_Dataset_GetProjection}, 
+     {"GetProjectionRef", _wrap_Dataset_GetProjectionRef}, 
+     {"SetProjection", _wrap_Dataset_SetProjection}, 
+     {"GetGeoTransform", _wrap_Dataset_GetGeoTransform}, 
+     {"SetGeoTransform", _wrap_Dataset_SetGeoTransform}, 
+     {"BuildOverviews", _wrap_Dataset_BuildOverviews}, 
+     {"GetGCPCount", _wrap_Dataset_GetGCPCount}, 
+     {"GetGCPProjection", _wrap_Dataset_GetGCPProjection}, 
+     {"GetGCPs", _wrap_Dataset_GetGCPs}, 
+     {"SetGCPs", _wrap_Dataset_SetGCPs}, 
+     {"FlushCache", _wrap_Dataset_FlushCache}, 
+     {"AddBand", _wrap_Dataset_AddBand}, 
+     {"CreateMaskBand", _wrap_Dataset_CreateMaskBand}, 
+     {"GetFileList", _wrap_Dataset_GetFileList}, 
+     {"WriteRaster", _wrap_Dataset_WriteRaster}, 
+     {"ReadRaster", _wrap_Dataset_ReadRaster}, 
+     {0,0}
+ };
+ static swig_attribute swig_GDALDatasetShadow_attributes[] = {
+     { "-RasterXSize",_wrap_Dataset_RasterXSize_get, 0 },
+     { "-RasterYSize",_wrap_Dataset_RasterYSize_get, 0 },
+     { "-RasterCount",_wrap_Dataset_RasterCount_get, 0 },
+     {0,0,0}
+ };
+ static swig_class *swig_GDALDatasetShadow_bases[] = {0,0};
+ static const char * swig_GDALDatasetShadow_base_names[] = {"GDALMajorObjectShadow *",0};
+ static swig_class _wrap_class_GDALDatasetShadow = { "Dataset", &SWIGTYPE_p_GDALDatasetShadow,0, swig_delete_Dataset, swig_GDALDatasetShadow_methods, swig_GDALDatasetShadow_attributes, swig_GDALDatasetShadow_bases,swig_GDALDatasetShadow_base_names, &swig_module };
+ SWIGINTERN int
+ _wrap_Band_XSize_get(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
+   GDALRasterBandShadow *arg1 = (GDALRasterBandShadow *) 0 ;
+   void *argp1 = 0 ;
+   int res1 = 0 ;
+   int result;
+   
+   if (SWIG_GetArgs(interp, objc, objv,"o:osgeo::Band_XSize_get self ",(void *)0) == TCL_ERROR) SWIG_fail;
+   res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_GDALRasterBandShadow, 0 |  0 );
+   if (!SWIG_IsOK(res1)) {
+     SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Band_XSize_get" "', argument " "1"" of type '" "GDALRasterBandShadow *""'"); 
+   }
+   arg1 = reinterpret_cast< GDALRasterBandShadow * >(argp1);
+   {
+     CPLErrorReset();
+     result = (int)GDALRasterBandShadow_XSize_get(arg1);
+     CPLErr eclass = CPLGetLastErrorType();
+     if ( eclass == CE_Failure || eclass == CE_Fatal ) {
+       SWIG_exception( SWIG_RuntimeError, CPLGetLastErrorMsg() );
+       
+     }
+     
+     
+     
+     
+     
+     
+     
+     
+     
+     
+     
+   }
+   Tcl_SetObjResult(interp,SWIG_From_int(static_cast< int >(result)));
+   return TCL_OK;
+ fail:
+   return TCL_ERROR;
+ }
+ 
+ 
+ SWIGINTERN int
+ _wrap_Band_YSize_get(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
+   GDALRasterBandShadow *arg1 = (GDALRasterBandShadow *) 0 ;
+   void *argp1 = 0 ;
+   int res1 = 0 ;
+   int result;
+   
+   if (SWIG_GetArgs(interp, objc, objv,"o:osgeo::Band_YSize_get self ",(void *)0) == TCL_ERROR) SWIG_fail;
+   res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_GDALRasterBandShadow, 0 |  0 );
+   if (!SWIG_IsOK(res1)) {
+     SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Band_YSize_get" "', argument " "1"" of type '" "GDALRasterBandShadow *""'"); 
+   }
+   arg1 = reinterpret_cast< GDALRasterBandShadow * >(argp1);
+   {
+     CPLErrorReset();
+     result = (int)GDALRasterBandShadow_YSize_get(arg1);
+     CPLErr eclass = CPLGetLastErrorType();
+     if ( eclass == CE_Failure || eclass == CE_Fatal ) {
+       SWIG_exception( SWIG_RuntimeError, CPLGetLastErrorMsg() );
+       
+     }
+     
+     
+     
+     
+     
+     
+     
+     
+     
+     
+     
+   }
+   Tcl_SetObjResult(interp,SWIG_From_int(static_cast< int >(result)));
+   return TCL_OK;
+ fail:
+   return TCL_ERROR;
+ }
+ 
+ 
+ SWIGINTERN int
+ _wrap_Band_DataType_get(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
+   GDALRasterBandShadow *arg1 = (GDALRasterBandShadow *) 0 ;
+   void *argp1 = 0 ;
+   int res1 = 0 ;
+   GDALDataType result;
+   
+   if (SWIG_GetArgs(interp, objc, objv,"o:osgeo::Band_DataType_get self ",(void *)0) == TCL_ERROR) SWIG_fail;
+   res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_GDALRasterBandShadow, 0 |  0 );
+   if (!SWIG_IsOK(res1)) {
+     SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Band_DataType_get" "', argument " "1"" of type '" "GDALRasterBandShadow *""'"); 
+   }
+   arg1 = reinterpret_cast< GDALRasterBandShadow * >(argp1);
+   {
+     CPLErrorReset();
+     result = (GDALDataType)GDALRasterBandShadow_DataType_get(arg1);
+     CPLErr eclass = CPLGetLastErrorType();
+     if ( eclass == CE_Failure || eclass == CE_Fatal ) {
+       SWIG_exception( SWIG_RuntimeError, CPLGetLastErrorMsg() );
+       
+     }
+     
+     
+     
+     
+     
+     
+     
+     
+     
+     
+     
+   }
+   Tcl_SetObjResult(interp,SWIG_From_int(static_cast< int >(result)));
+   return TCL_OK;
+ fail:
+   return TCL_ERROR;
+ }
+ 
+ 
+ SWIGINTERN int
+ _wrap_Band_GetBlockSize(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
+   GDALRasterBandShadow *arg1 = (GDALRasterBandShadow *) 0 ;
+   int *arg2 = (int *) 0 ;
+   int *arg3 = (int *) 0 ;
+   void *argp1 = 0 ;
+   int res1 = 0 ;
+   int temp2 ;
+   int res2 = SWIG_TMPOBJ ;
+   int temp3 ;
+   int res3 = SWIG_TMPOBJ ;
+   
+   arg2 = &temp2;
+   arg3 = &temp3;
+   if (SWIG_GetArgs(interp, objc, objv,"o:osgeo::Band_GetBlockSize self ",(void *)0) == TCL_ERROR) SWIG_fail;
+   res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_GDALRasterBandShadow, 0 |  0 );
+   if (!SWIG_IsOK(res1)) {
+     SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Band_GetBlockSize" "', argument " "1"" of type '" "GDALRasterBandShadow *""'"); 
+   }
+   arg1 = reinterpret_cast< GDALRasterBandShadow * >(argp1);
+   {
+     CPLErrorReset();
+     GDALRasterBandShadow_GetBlockSize(arg1,arg2,arg3);
+     CPLErr eclass = CPLGetLastErrorType();
+     if ( eclass == CE_Failure || eclass == CE_Fatal ) {
+       SWIG_exception( SWIG_RuntimeError, CPLGetLastErrorMsg() );
+       
+     }
+     
+     
+     
+     
+     
+     
+     
+     
+     
+     
+     
+   }
+   
+   if (SWIG_IsTmpObj(res2)) {
+     Tcl_ListObjAppendElement(interp,Tcl_GetObjResult(interp),SWIG_From_int((*arg2)));
+   } else {
+     int new_flags = SWIG_IsNewObj(res2) ? (SWIG_POINTER_OWN |  0 ) :  0 ;
+     Tcl_ListObjAppendElement(interp,Tcl_GetObjResult(interp),SWIG_NewPointerObj((void*)(arg2), SWIGTYPE_p_int, new_flags));
+   }
+   if (SWIG_IsTmpObj(res3)) {
+     Tcl_ListObjAppendElement(interp,Tcl_GetObjResult(interp),SWIG_From_int((*arg3)));
+   } else {
+     int new_flags = SWIG_IsNewObj(res3) ? (SWIG_POINTER_OWN |  0 ) :  0 ;
+     Tcl_ListObjAppendElement(interp,Tcl_GetObjResult(interp),SWIG_NewPointerObj((void*)(arg3), SWIGTYPE_p_int, new_flags));
+   }
+   return TCL_OK;
+ fail:
+   return TCL_ERROR;
+ }
+ 
+ 
+ SWIGINTERN int
+ _wrap_Band_GetRasterColorInterpretation(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
+   GDALRasterBandShadow *arg1 = (GDALRasterBandShadow *) 0 ;
+   void *argp1 = 0 ;
+   int res1 = 0 ;
+   GDALColorInterp result;
+   
+   if (SWIG_GetArgs(interp, objc, objv,"o:osgeo::Band_GetRasterColorInterpretation self ",(void *)0) == TCL_ERROR) SWIG_fail;
+   res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_GDALRasterBandShadow, 0 |  0 );
+   if (!SWIG_IsOK(res1)) {
+     SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Band_GetRasterColorInterpretation" "', argument " "1"" of type '" "GDALRasterBandShadow *""'"); 
+   }
+   arg1 = reinterpret_cast< GDALRasterBandShadow * >(argp1);
+   {
+     CPLErrorReset();
+     result = (GDALColorInterp)GDALRasterBandShadow_GetRasterColorInterpretation(arg1);
+     CPLErr eclass = CPLGetLastErrorType();
+     if ( eclass == CE_Failure || eclass == CE_Fatal ) {
+       SWIG_exception( SWIG_RuntimeError, CPLGetLastErrorMsg() );
+       
+     }
+     
+     
+     
+     
+     
+     
+     
+     
+     
+     
+     
+   }
+   Tcl_SetObjResult(interp,SWIG_From_int(static_cast< int >(result)));
+   return TCL_OK;
+ fail:
+   return TCL_ERROR;
+ }
+ 
+ 
+ SWIGINTERN int
+ _wrap_Band_SetRasterColorInterpretation(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
+   GDALRasterBandShadow *arg1 = (GDALRasterBandShadow *) 0 ;
+   GDALColorInterp arg2 ;
+   void *argp1 = 0 ;
+   int res1 = 0 ;
+   int val2 ;
+   int ecode2 = 0 ;
+   CPLErr result;
+   
+   if (SWIG_GetArgs(interp, objc, objv,"oo:osgeo::Band_SetRasterColorInterpretation self val ",(void *)0,(void *)0) == TCL_ERROR) SWIG_fail;
+   res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_GDALRasterBandShadow, 0 |  0 );
+   if (!SWIG_IsOK(res1)) {
+     SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Band_SetRasterColorInterpretation" "', argument " "1"" of type '" "GDALRasterBandShadow *""'"); 
+   }
+   arg1 = reinterpret_cast< GDALRasterBandShadow * >(argp1);
+   ecode2 = SWIG_AsVal_int SWIG_TCL_CALL_ARGS_2(objv[2], &val2);
+   if (!SWIG_IsOK(ecode2)) {
+     SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "Band_SetRasterColorInterpretation" "', argument " "2"" of type '" "GDALColorInterp""'");
+   } 
+   arg2 = static_cast< GDALColorInterp >(val2);
+   {
+     CPLErrorReset();
+     result = (CPLErr)GDALRasterBandShadow_SetRasterColorInterpretation(arg1,arg2);
+     CPLErr eclass = CPLGetLastErrorType();
+     if ( eclass == CE_Failure || eclass == CE_Fatal ) {
+       SWIG_exception( SWIG_RuntimeError, CPLGetLastErrorMsg() );
+       
+     }
+     
+     
+     
+     
+     
+     
+     
+     
+     
+     
+     
+   }
+   Tcl_SetObjResult(interp,SWIG_From_int(static_cast< int >(result)));
+   return TCL_OK;
+ fail:
+   return TCL_ERROR;
+ }
+ 
+ 
+ SWIGINTERN int
+ _wrap_Band_GetNoDataValue(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
+   GDALRasterBandShadow *arg1 = (GDALRasterBandShadow *) 0 ;
+   double *arg2 = (double *) 0 ;
+   int *arg3 = (int *) 0 ;
+   void *argp1 = 0 ;
+   int res1 = 0 ;
+   double tmpval2 ;
+   int tmphasval2 ;
+   
+   {
+     /* %typemap(tcl,in,numinputs=0) (double *val, int*hasval) */
+     arg2 = &tmpval2;
+     arg3 = &tmphasval2;
+   }
+   if (SWIG_GetArgs(interp, objc, objv,"o:osgeo::Band_GetNoDataValue self ?hasval? ",(void *)0) == TCL_ERROR) SWIG_fail;
+   res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_GDALRasterBandShadow, 0 |  0 );
+   if (!SWIG_IsOK(res1)) {
+     SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Band_GetNoDataValue" "', argument " "1"" of type '" "GDALRasterBandShadow *""'"); 
+   }
+   arg1 = reinterpret_cast< GDALRasterBandShadow * >(argp1);
+   {
+     CPLErrorReset();
+     GDALRasterBandShadow_GetNoDataValue(arg1,arg2,arg3);
+     CPLErr eclass = CPLGetLastErrorType();
+     if ( eclass == CE_Failure || eclass == CE_Fatal ) {
+       SWIG_exception( SWIG_RuntimeError, CPLGetLastErrorMsg() );
+       
+     }
+     
+     
+     
+     
+     
+     
+     
+     
+     
+     
+     
+   }
+   
+   {
+     /* %typemap(tcl,argout) (double *val, int*hasval) */
+     Tcl_Obj *r;
+     if ( !*arg3 ) {
+       r = Tcl_NewObj(); /* NONE */
+     } else {
+       r = Tcl_NewDoubleObj( *arg2 );
+     }
+     Tcl_ListObjAppendElement(interp,Tcl_GetObjResult(interp),r);
+   }
+   return TCL_OK;
+ fail:
+   return TCL_ERROR;
+ }
+ 
+ 
+ SWIGINTERN int
+ _wrap_Band_SetNoDataValue(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
+   GDALRasterBandShadow *arg1 = (GDALRasterBandShadow *) 0 ;
+   double arg2 ;
+   void *argp1 = 0 ;
+   int res1 = 0 ;
+   double val2 ;
+   int ecode2 = 0 ;
+   CPLErr result;
+   
+   if (SWIG_GetArgs(interp, objc, objv,"oo:osgeo::Band_SetNoDataValue self d ",(void *)0,(void *)0) == TCL_ERROR) SWIG_fail;
+   res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_GDALRasterBandShadow, 0 |  0 );
+   if (!SWIG_IsOK(res1)) {
+     SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Band_SetNoDataValue" "', argument " "1"" of type '" "GDALRasterBandShadow *""'"); 
+   }
+   arg1 = reinterpret_cast< GDALRasterBandShadow * >(argp1);
+   ecode2 = SWIG_AsVal_double SWIG_TCL_CALL_ARGS_2(objv[2], &val2);
+   if (!SWIG_IsOK(ecode2)) {
+     SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "Band_SetNoDataValue" "', argument " "2"" of type '" "double""'");
+   } 
+   arg2 = static_cast< double >(val2);
+   {
+     CPLErrorReset();
+     result = (CPLErr)GDALRasterBandShadow_SetNoDataValue(arg1,arg2);
+     CPLErr eclass = CPLGetLastErrorType();
+     if ( eclass == CE_Failure || eclass == CE_Fatal ) {
+       SWIG_exception( SWIG_RuntimeError, CPLGetLastErrorMsg() );
+       
+     }
+     
+     
+     
+     
+     
+     
+     
+     
+     
+     
+     
+   }
+   Tcl_SetObjResult(interp,SWIG_From_int(static_cast< int >(result)));
+   return TCL_OK;
+ fail:
+   return TCL_ERROR;
+ }
+ 
+ 
+ SWIGINTERN int
+ _wrap_Band_GetRasterCategoryNames(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
+   GDALRasterBandShadow *arg1 = (GDALRasterBandShadow *) 0 ;
+   void *argp1 = 0 ;
+   int res1 = 0 ;
+   char **result = 0 ;
+   
+   if (SWIG_GetArgs(interp, objc, objv,"o:osgeo::Band_GetRasterCategoryNames self ",(void *)0) == TCL_ERROR) SWIG_fail;
+   res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_GDALRasterBandShadow, 0 |  0 );
+   if (!SWIG_IsOK(res1)) {
+     SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Band_GetRasterCategoryNames" "', argument " "1"" of type '" "GDALRasterBandShadow *""'"); 
+   }
+   arg1 = reinterpret_cast< GDALRasterBandShadow * >(argp1);
+   {
+     CPLErrorReset();
+     result = (char **)GDALRasterBandShadow_GetRasterCategoryNames(arg1);
+     CPLErr eclass = CPLGetLastErrorType();
+     if ( eclass == CE_Failure || eclass == CE_Fatal ) {
+       SWIG_exception( SWIG_RuntimeError, CPLGetLastErrorMsg() );
+       
+     }
+     
+     
+     
+     
+     
+     
+     
+     
+     
+     
+     
+   }
+   {
+     /* %typemap(out) char **options -> ( string ) */
+     char **stringarray = result;
+     if ( stringarray == NULL ) {
+       Tcl_ResetResult(interp); /* NONE = Empty string */
+     } else {
+       int len = CSLCount( stringarray );
+       Tcl_Obj *out = Tcl_NewListObj(0, NULL);
+       for ( int i = 0; i < len; ++i ) {
+         Tcl_Obj *o = Tcl_NewStringObj( stringarray[i], -1 );
+         if (Tcl_ListObjAppendElement(interp, out, o) != TCL_OK) {
+           Tcl_DecrRefCount(o);
+           Tcl_DecrRefCount(out);
+           /* Error msg in interp result */
+           SWIG_fail;
+         }
+       }
+       Tcl_SetObjResult(interp, out);
+     }
+   }
+   return TCL_OK;
+ fail:
+   return TCL_ERROR;
+ }
+ 
+ 
+ SWIGINTERN int
+ _wrap_Band_SetRasterCategoryNames(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
+   GDALRasterBandShadow *arg1 = (GDALRasterBandShadow *) 0 ;
+   char **arg2 = (char **) 0 ;
+   void *argp1 = 0 ;
+   int res1 = 0 ;
+   CPLErr result;
+   
+   if (SWIG_GetArgs(interp, objc, objv,"oo:osgeo::Band_SetRasterCategoryNames self names ",(void *)0,(void *)0) == TCL_ERROR) SWIG_fail;
+   res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_GDALRasterBandShadow, 0 |  0 );
+   if (!SWIG_IsOK(res1)) {
+     SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Band_SetRasterCategoryNames" "', argument " "1"" of type '" "GDALRasterBandShadow *""'"); 
+   }
+   arg1 = reinterpret_cast< GDALRasterBandShadow * >(argp1);
+   {
+     /* %typemap(in) char **options */
+     int size;
+     if (Tcl_ListObjLength(interp, objv[2], &size) != TCL_OK) {
+       /* Error msg in interp result */
+       SWIG_fail;
+     }
+     if ( !size ) {
+       Tcl_SetResult(interp, (char*) "Input list mustn't be empty", TCL_STATIC);
+       SWIG_fail;
+     }
+     
+     for (int i = 0; i < size; i++) {
+       Tcl_Obj **o = NULL;
+       /* The reference count for the list element is not incremented with the following */
+       if (Tcl_ListObjIndex(interp, objv[2], i, o) != TCL_OK) {
+         /* Error msg in interp result */
+         SWIG_fail;
+       }
+       char *pszItem = Tcl_GetString(*o);
+       arg2 = CSLAddString( arg2, pszItem );
+     }
+   }
+   {
+     CPLErrorReset();
+     result = (CPLErr)GDALRasterBandShadow_SetRasterCategoryNames(arg1,arg2);
+     CPLErr eclass = CPLGetLastErrorType();
+     if ( eclass == CE_Failure || eclass == CE_Fatal ) {
+       SWIG_exception( SWIG_RuntimeError, CPLGetLastErrorMsg() );
+       
+     }
+     
+     
+     
+     
+     
+     
+     
+     
+     
+     
+     
+   }
+   Tcl_SetObjResult(interp,SWIG_From_int(static_cast< int >(result)));
+   {
+     /* %typemap(freearg) char **options */
+     CSLDestroy( arg2 );
+   }
+   return TCL_OK;
+ fail:
+   {
+     /* %typemap(freearg) char **options */
+     CSLDestroy( arg2 );
+   }
+   return TCL_ERROR;
+ }
+ 
+ 
+ SWIGINTERN int
+ _wrap_Band_GetMinimum(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
+   GDALRasterBandShadow *arg1 = (GDALRasterBandShadow *) 0 ;
+   double *arg2 = (double *) 0 ;
+   int *arg3 = (int *) 0 ;
+   void *argp1 = 0 ;
+   int res1 = 0 ;
+   double tmpval2 ;
+   int tmphasval2 ;
+   
+   {
+     /* %typemap(tcl,in,numinputs=0) (double *val, int*hasval) */
+     arg2 = &tmpval2;
+     arg3 = &tmphasval2;
+   }
+   if (SWIG_GetArgs(interp, objc, objv,"o:osgeo::Band_GetMinimum self ?hasval? ",(void *)0) == TCL_ERROR) SWIG_fail;
+   res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_GDALRasterBandShadow, 0 |  0 );
+   if (!SWIG_IsOK(res1)) {
+     SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Band_GetMinimum" "', argument " "1"" of type '" "GDALRasterBandShadow *""'"); 
+   }
+   arg1 = reinterpret_cast< GDALRasterBandShadow * >(argp1);
+   {
+     CPLErrorReset();
+     GDALRasterBandShadow_GetMinimum(arg1,arg2,arg3);
+     CPLErr eclass = CPLGetLastErrorType();
+     if ( eclass == CE_Failure || eclass == CE_Fatal ) {
+       SWIG_exception( SWIG_RuntimeError, CPLGetLastErrorMsg() );
+       
+     }
+     
+     
+     
+     
+     
+     
+     
+     
+     
+     
+     
+   }
+   
+   {
+     /* %typemap(tcl,argout) (double *val, int*hasval) */
+     Tcl_Obj *r;
+     if ( !*arg3 ) {
+       r = Tcl_NewObj(); /* NONE */
+     } else {
+       r = Tcl_NewDoubleObj( *arg2 );
+     }
+     Tcl_ListObjAppendElement(interp,Tcl_GetObjResult(interp),r);
+   }
+   return TCL_OK;
+ fail:
+   return TCL_ERROR;
+ }
+ 
+ 
+ SWIGINTERN int
+ _wrap_Band_GetMaximum(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
+   GDALRasterBandShadow *arg1 = (GDALRasterBandShadow *) 0 ;
+   double *arg2 = (double *) 0 ;
+   int *arg3 = (int *) 0 ;
+   void *argp1 = 0 ;
+   int res1 = 0 ;
+   double tmpval2 ;
+   int tmphasval2 ;
+   
+   {
+     /* %typemap(tcl,in,numinputs=0) (double *val, int*hasval) */
+     arg2 = &tmpval2;
+     arg3 = &tmphasval2;
+   }
+   if (SWIG_GetArgs(interp, objc, objv,"o:osgeo::Band_GetMaximum self ?hasval? ",(void *)0) == TCL_ERROR) SWIG_fail;
+   res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_GDALRasterBandShadow, 0 |  0 );
+   if (!SWIG_IsOK(res1)) {
+     SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Band_GetMaximum" "', argument " "1"" of type '" "GDALRasterBandShadow *""'"); 
+   }
+   arg1 = reinterpret_cast< GDALRasterBandShadow * >(argp1);
+   {
+     CPLErrorReset();
+     GDALRasterBandShadow_GetMaximum(arg1,arg2,arg3);
+     CPLErr eclass = CPLGetLastErrorType();
+     if ( eclass == CE_Failure || eclass == CE_Fatal ) {
+       SWIG_exception( SWIG_RuntimeError, CPLGetLastErrorMsg() );
+       
+     }
+     
+     
+     
+     
+     
+     
+     
+     
+     
+     
+     
+   }
+   
+   {
+     /* %typemap(tcl,argout) (double *val, int*hasval) */
+     Tcl_Obj *r;
+     if ( !*arg3 ) {
+       r = Tcl_NewObj(); /* NONE */
+     } else {
+       r = Tcl_NewDoubleObj( *arg2 );
+     }
+     Tcl_ListObjAppendElement(interp,Tcl_GetObjResult(interp),r);
+   }
+   return TCL_OK;
+ fail:
+   return TCL_ERROR;
+ }
+ 
+ 
+ SWIGINTERN int
+ _wrap_Band_GetOffset(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
+   GDALRasterBandShadow *arg1 = (GDALRasterBandShadow *) 0 ;
+   double *arg2 = (double *) 0 ;
+   int *arg3 = (int *) 0 ;
+   void *argp1 = 0 ;
+   int res1 = 0 ;
+   double tmpval2 ;
+   int tmphasval2 ;
+   
+   {
+     /* %typemap(tcl,in,numinputs=0) (double *val, int*hasval) */
+     arg2 = &tmpval2;
+     arg3 = &tmphasval2;
+   }
+   if (SWIG_GetArgs(interp, objc, objv,"o:osgeo::Band_GetOffset self ?hasval? ",(void *)0) == TCL_ERROR) SWIG_fail;
+   res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_GDALRasterBandShadow, 0 |  0 );
+   if (!SWIG_IsOK(res1)) {
+     SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Band_GetOffset" "', argument " "1"" of type '" "GDALRasterBandShadow *""'"); 
+   }
+   arg1 = reinterpret_cast< GDALRasterBandShadow * >(argp1);
+   {
+     CPLErrorReset();
+     GDALRasterBandShadow_GetOffset(arg1,arg2,arg3);
+     CPLErr eclass = CPLGetLastErrorType();
+     if ( eclass == CE_Failure || eclass == CE_Fatal ) {
+       SWIG_exception( SWIG_RuntimeError, CPLGetLastErrorMsg() );
+       
+     }
+     
+     
+     
+     
+     
+     
+     
+     
+     
+     
+     
+   }
+   
+   {
+     /* %typemap(tcl,argout) (double *val, int*hasval) */
+     Tcl_Obj *r;
+     if ( !*arg3 ) {
+       r = Tcl_NewObj(); /* NONE */
+     } else {
+       r = Tcl_NewDoubleObj( *arg2 );
+     }
+     Tcl_ListObjAppendElement(interp,Tcl_GetObjResult(interp),r);
+   }
+   return TCL_OK;
+ fail:
+   return TCL_ERROR;
+ }
+ 
+ 
+ SWIGINTERN int
+ _wrap_Band_GetScale(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
+   GDALRasterBandShadow *arg1 = (GDALRasterBandShadow *) 0 ;
+   double *arg2 = (double *) 0 ;
+   int *arg3 = (int *) 0 ;
+   void *argp1 = 0 ;
+   int res1 = 0 ;
+   double tmpval2 ;
+   int tmphasval2 ;
+   
+   {
+     /* %typemap(tcl,in,numinputs=0) (double *val, int*hasval) */
+     arg2 = &tmpval2;
+     arg3 = &tmphasval2;
+   }
+   if (SWIG_GetArgs(interp, objc, objv,"o:osgeo::Band_GetScale self ?hasval? ",(void *)0) == TCL_ERROR) SWIG_fail;
+   res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_GDALRasterBandShadow, 0 |  0 );
+   if (!SWIG_IsOK(res1)) {
+     SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Band_GetScale" "', argument " "1"" of type '" "GDALRasterBandShadow *""'"); 
+   }
+   arg1 = reinterpret_cast< GDALRasterBandShadow * >(argp1);
+   {
+     CPLErrorReset();
+     GDALRasterBandShadow_GetScale(arg1,arg2,arg3);
+     CPLErr eclass = CPLGetLastErrorType();
+     if ( eclass == CE_Failure || eclass == CE_Fatal ) {
+       SWIG_exception( SWIG_RuntimeError, CPLGetLastErrorMsg() );
+       
+     }
+     
+     
+     
+     
+     
+     
+     
+     
+     
+     
+     
+   }
+   
+   {
+     /* %typemap(tcl,argout) (double *val, int*hasval) */
+     Tcl_Obj *r;
+     if ( !*arg3 ) {
+       r = Tcl_NewObj(); /* NONE */
+     } else {
+       r = Tcl_NewDoubleObj( *arg2 );
+     }
+     Tcl_ListObjAppendElement(interp,Tcl_GetObjResult(interp),r);
+   }
+   return TCL_OK;
+ fail:
+   return TCL_ERROR;
+ }
+ 
+ 
+ SWIGINTERN int
+ _wrap_Band_GetStatistics(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
+   GDALRasterBandShadow *arg1 = (GDALRasterBandShadow *) 0 ;
+   int arg2 ;
+   int arg3 ;
+   double *arg4 = (double *) 0 ;
+   double *arg5 = (double *) 0 ;
+   double *arg6 = (double *) 0 ;
+   double *arg7 = (double *) 0 ;
+   void *argp1 = 0 ;
+   int res1 = 0 ;
+   int val2 ;
+   int ecode2 = 0 ;
+   int val3 ;
+   int ecode3 = 0 ;
+   double temp4 ;
+   int res4 = SWIG_TMPOBJ ;
+   double temp5 ;
+   int res5 = SWIG_TMPOBJ ;
+   double temp6 ;
+   int res6 = SWIG_TMPOBJ ;
+   double temp7 ;
+   int res7 = SWIG_TMPOBJ ;
+   CPLErr result;
+   
+   arg4 = &temp4;
+   arg5 = &temp5;
+   arg6 = &temp6;
+   arg7 = &temp7;
+   if (SWIG_GetArgs(interp, objc, objv,"ooo:osgeo::Band_GetStatistics self approx_ok force ",(void *)0,(void *)0,(void *)0) == TCL_ERROR) SWIG_fail;
+   res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_GDALRasterBandShadow, 0 |  0 );
+   if (!SWIG_IsOK(res1)) {
+     SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Band_GetStatistics" "', argument " "1"" of type '" "GDALRasterBandShadow *""'"); 
+   }
+   arg1 = reinterpret_cast< GDALRasterBandShadow * >(argp1);
+   ecode2 = SWIG_AsVal_int SWIG_TCL_CALL_ARGS_2(objv[2], &val2);
+   if (!SWIG_IsOK(ecode2)) {
+     SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "Band_GetStatistics" "', argument " "2"" of type '" "int""'");
+   } 
+   arg2 = static_cast< int >(val2);
+   ecode3 = SWIG_AsVal_int SWIG_TCL_CALL_ARGS_2(objv[3], &val3);
+   if (!SWIG_IsOK(ecode3)) {
+     SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "Band_GetStatistics" "', argument " "3"" of type '" "int""'");
+   } 
+   arg3 = static_cast< int >(val3);
+   {
+     CPLErrorReset();
+     result = (CPLErr)GDALRasterBandShadow_GetStatistics(arg1,arg2,arg3,arg4,arg5,arg6,arg7);
+     CPLErr eclass = CPLGetLastErrorType();
+     if ( eclass == CE_Failure || eclass == CE_Fatal ) {
+       SWIG_exception( SWIG_RuntimeError, CPLGetLastErrorMsg() );
+       
+     }
+     
+     
+     
+     
+     
+     
+     
+     
+     
+     
+     
+   }
+   {
+     /* %typemap(out) IF_ERROR_RETURN_NONE */
+     /* (do not return the error code) */
+   }
+   if (SWIG_IsTmpObj(res4)) {
+     Tcl_ListObjAppendElement(interp,Tcl_GetObjResult(interp),SWIG_From_double((*arg4)));
+   } else {
+     int new_flags = SWIG_IsNewObj(res4) ? (SWIG_POINTER_OWN |  0 ) :  0 ;
+     Tcl_ListObjAppendElement(interp,Tcl_GetObjResult(interp),SWIG_NewPointerObj((void*)(arg4), SWIGTYPE_p_double, new_flags));
+   }
+   if (SWIG_IsTmpObj(res5)) {
+     Tcl_ListObjAppendElement(interp,Tcl_GetObjResult(interp),SWIG_From_double((*arg5)));
+   } else {
+     int new_flags = SWIG_IsNewObj(res5) ? (SWIG_POINTER_OWN |  0 ) :  0 ;
+     Tcl_ListObjAppendElement(interp,Tcl_GetObjResult(interp),SWIG_NewPointerObj((void*)(arg5), SWIGTYPE_p_double, new_flags));
+   }
+   if (SWIG_IsTmpObj(res6)) {
+     Tcl_ListObjAppendElement(interp,Tcl_GetObjResult(interp),SWIG_From_double((*arg6)));
+   } else {
+     int new_flags = SWIG_IsNewObj(res6) ? (SWIG_POINTER_OWN |  0 ) :  0 ;
+     Tcl_ListObjAppendElement(interp,Tcl_GetObjResult(interp),SWIG_NewPointerObj((void*)(arg6), SWIGTYPE_p_double, new_flags));
+   }
+   if (SWIG_IsTmpObj(res7)) {
+     Tcl_ListObjAppendElement(interp,Tcl_GetObjResult(interp),SWIG_From_double((*arg7)));
+   } else {
+     int new_flags = SWIG_IsNewObj(res7) ? (SWIG_POINTER_OWN |  0 ) :  0 ;
+     Tcl_ListObjAppendElement(interp,Tcl_GetObjResult(interp),SWIG_NewPointerObj((void*)(arg7), SWIGTYPE_p_double, new_flags));
+   }
+   return TCL_OK;
+ fail:
+   return TCL_ERROR;
+ }
+ 
+ 
+ SWIGINTERN int
+ _wrap_Band_SetStatistics(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
+   GDALRasterBandShadow *arg1 = (GDALRasterBandShadow *) 0 ;
+   double arg2 ;
+   double arg3 ;
+   double arg4 ;
+   double arg5 ;
+   void *argp1 = 0 ;
+   int res1 = 0 ;
+   double val2 ;
+   int ecode2 = 0 ;
+   double val3 ;
+   int ecode3 = 0 ;
+   double val4 ;
+   int ecode4 = 0 ;
+   double val5 ;
+   int ecode5 = 0 ;
+   CPLErr result;
+   
+   if (SWIG_GetArgs(interp, objc, objv,"ooooo:osgeo::Band_SetStatistics self min max mean stddev ",(void *)0,(void *)0,(void *)0,(void *)0,(void *)0) == TCL_ERROR) SWIG_fail;
+   res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_GDALRasterBandShadow, 0 |  0 );
+   if (!SWIG_IsOK(res1)) {
+     SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Band_SetStatistics" "', argument " "1"" of type '" "GDALRasterBandShadow *""'"); 
+   }
+   arg1 = reinterpret_cast< GDALRasterBandShadow * >(argp1);
+   ecode2 = SWIG_AsVal_double SWIG_TCL_CALL_ARGS_2(objv[2], &val2);
+   if (!SWIG_IsOK(ecode2)) {
+     SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "Band_SetStatistics" "', argument " "2"" of type '" "double""'");
+   } 
+   arg2 = static_cast< double >(val2);
+   ecode3 = SWIG_AsVal_double SWIG_TCL_CALL_ARGS_2(objv[3], &val3);
+   if (!SWIG_IsOK(ecode3)) {
+     SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "Band_SetStatistics" "', argument " "3"" of type '" "double""'");
+   } 
+   arg3 = static_cast< double >(val3);
+   ecode4 = SWIG_AsVal_double SWIG_TCL_CALL_ARGS_2(objv[4], &val4);
+   if (!SWIG_IsOK(ecode4)) {
+     SWIG_exception_fail(SWIG_ArgError(ecode4), "in method '" "Band_SetStatistics" "', argument " "4"" of type '" "double""'");
+   } 
+   arg4 = static_cast< double >(val4);
+   ecode5 = SWIG_AsVal_double SWIG_TCL_CALL_ARGS_2(objv[5], &val5);
+   if (!SWIG_IsOK(ecode5)) {
+     SWIG_exception_fail(SWIG_ArgError(ecode5), "in method '" "Band_SetStatistics" "', argument " "5"" of type '" "double""'");
+   } 
+   arg5 = static_cast< double >(val5);
+   {
+     CPLErrorReset();
+     result = (CPLErr)GDALRasterBandShadow_SetStatistics(arg1,arg2,arg3,arg4,arg5);
+     CPLErr eclass = CPLGetLastErrorType();
+     if ( eclass == CE_Failure || eclass == CE_Fatal ) {
+       SWIG_exception( SWIG_RuntimeError, CPLGetLastErrorMsg() );
+       
+     }
+     
+     
+     
+     
+     
+     
+     
+     
+     
+     
+     
+   }
+   Tcl_SetObjResult(interp,SWIG_From_int(static_cast< int >(result)));
+   return TCL_OK;
+ fail:
+   return TCL_ERROR;
+ }
+ 
+ 
+ SWIGINTERN int
+ _wrap_Band_GetOverviewCount(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
+   GDALRasterBandShadow *arg1 = (GDALRasterBandShadow *) 0 ;
+   void *argp1 = 0 ;
+   int res1 = 0 ;
+   int result;
+   
+   if (SWIG_GetArgs(interp, objc, objv,"o:osgeo::Band_GetOverviewCount self ",(void *)0) == TCL_ERROR) SWIG_fail;
+   res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_GDALRasterBandShadow, 0 |  0 );
+   if (!SWIG_IsOK(res1)) {
+     SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Band_GetOverviewCount" "', argument " "1"" of type '" "GDALRasterBandShadow *""'"); 
+   }
+   arg1 = reinterpret_cast< GDALRasterBandShadow * >(argp1);
+   {
+     CPLErrorReset();
+     result = (int)GDALRasterBandShadow_GetOverviewCount(arg1);
+     CPLErr eclass = CPLGetLastErrorType();
+     if ( eclass == CE_Failure || eclass == CE_Fatal ) {
+       SWIG_exception( SWIG_RuntimeError, CPLGetLastErrorMsg() );
+       
+     }
+     
+     
+     
+     
+     
+     
+     
+     
+     
+     
+     
+   }
+   Tcl_SetObjResult(interp,SWIG_From_int(static_cast< int >(result)));
+   return TCL_OK;
+ fail:
+   return TCL_ERROR;
+ }
+ 
+ 
+ SWIGINTERN int
+ _wrap_Band_GetOverview(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
+   GDALRasterBandShadow *arg1 = (GDALRasterBandShadow *) 0 ;
+   int arg2 ;
+   void *argp1 = 0 ;
+   int res1 = 0 ;
+   int val2 ;
+   int ecode2 = 0 ;
+   GDALRasterBandShadow *result = 0 ;
+   
+   if (SWIG_GetArgs(interp, objc, objv,"oo:osgeo::Band_GetOverview self i ",(void *)0,(void *)0) == TCL_ERROR) SWIG_fail;
+   res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_GDALRasterBandShadow, 0 |  0 );
+   if (!SWIG_IsOK(res1)) {
+     SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Band_GetOverview" "', argument " "1"" of type '" "GDALRasterBandShadow *""'"); 
+   }
+   arg1 = reinterpret_cast< GDALRasterBandShadow * >(argp1);
+   ecode2 = SWIG_AsVal_int SWIG_TCL_CALL_ARGS_2(objv[2], &val2);
+   if (!SWIG_IsOK(ecode2)) {
+     SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "Band_GetOverview" "', argument " "2"" of type '" "int""'");
+   } 
+   arg2 = static_cast< int >(val2);
+   {
+     CPLErrorReset();
+     result = (GDALRasterBandShadow *)GDALRasterBandShadow_GetOverview(arg1,arg2);
+     CPLErr eclass = CPLGetLastErrorType();
+     if ( eclass == CE_Failure || eclass == CE_Fatal ) {
+       SWIG_exception( SWIG_RuntimeError, CPLGetLastErrorMsg() );
+       
+     }
+     
+     
+     
+     
+     
+     
+     
+     
+     
+     
+     
+   }
+   Tcl_SetObjResult(interp, SWIG_NewInstanceObj( SWIG_as_voidptr(result), SWIGTYPE_p_GDALRasterBandShadow,0));
+   return TCL_OK;
+ fail:
+   return TCL_ERROR;
+ }
+ 
+ 
+ SWIGINTERN int
+ _wrap_Band_Checksum(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
+   GDALRasterBandShadow *arg1 = (GDALRasterBandShadow *) 0 ;
+   int arg2 = (int) 0 ;
+   int arg3 = (int) 0 ;
+   int *arg4 = (int *) 0 ;
+   int *arg5 = (int *) 0 ;
+   void *argp1 = 0 ;
+   int res1 = 0 ;
+   int val2 ;
+   int ecode2 = 0 ;
+   int val3 ;
+   int ecode3 = 0 ;
+   void *argp4 = 0 ;
+   int res4 = 0 ;
+   void *argp5 = 0 ;
+   int res5 = 0 ;
+   int result;
+   
+   if (SWIG_GetArgs(interp, objc, objv,"o|oooo:osgeo::Band_Checksum self ?xoff? ?yoff? ?xsize? ?ysize? ",(void *)0,(void *)0,(void *)0,(void *)0,(void *)0) == TCL_ERROR) SWIG_fail;
+   res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_GDALRasterBandShadow, 0 |  0 );
+   if (!SWIG_IsOK(res1)) {
+     SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Band_Checksum" "', argument " "1"" of type '" "GDALRasterBandShadow *""'"); 
+   }
+   arg1 = reinterpret_cast< GDALRasterBandShadow * >(argp1);
+   if (objc > 2) {
+     ecode2 = SWIG_AsVal_int SWIG_TCL_CALL_ARGS_2(objv[2], &val2);
+     if (!SWIG_IsOK(ecode2)) {
+       SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "Band_Checksum" "', argument " "2"" of type '" "int""'");
+     } 
+     arg2 = static_cast< int >(val2);
+   }
+   if (objc > 3) {
+     ecode3 = SWIG_AsVal_int SWIG_TCL_CALL_ARGS_2(objv[3], &val3);
+     if (!SWIG_IsOK(ecode3)) {
+       SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "Band_Checksum" "', argument " "3"" of type '" "int""'");
+     } 
+     arg3 = static_cast< int >(val3);
+   }
+   if (objc > 4) {
+     res4 = SWIG_ConvertPtr(objv[4], &argp4,SWIGTYPE_p_int, 0 |  0 );
+     if (!SWIG_IsOK(res4)) {
+       SWIG_exception_fail(SWIG_ArgError(res4), "in method '" "Band_Checksum" "', argument " "4"" of type '" "int *""'"); 
+     }
+     arg4 = reinterpret_cast< int * >(argp4);
+   }
+   if (objc > 5) {
+     res5 = SWIG_ConvertPtr(objv[5], &argp5,SWIGTYPE_p_int, 0 |  0 );
+     if (!SWIG_IsOK(res5)) {
+       SWIG_exception_fail(SWIG_ArgError(res5), "in method '" "Band_Checksum" "', argument " "5"" of type '" "int *""'"); 
+     }
+     arg5 = reinterpret_cast< int * >(argp5);
+   }
+   {
+     CPLErrorReset();
+     result = (int)GDALRasterBandShadow_Checksum(arg1,arg2,arg3,arg4,arg5);
+     CPLErr eclass = CPLGetLastErrorType();
+     if ( eclass == CE_Failure || eclass == CE_Fatal ) {
+       SWIG_exception( SWIG_RuntimeError, CPLGetLastErrorMsg() );
+       
+     }
+     
+     
+     
+     
+     
+     
+     
+     
+     
+     
+     
+   }
+   Tcl_SetObjResult(interp,SWIG_From_int(static_cast< int >(result)));
+   return TCL_OK;
+ fail:
+   return TCL_ERROR;
+ }
+ 
+ 
+ SWIGINTERN int
+ _wrap_Band_ComputeRasterMinMax(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
+   GDALRasterBandShadow *arg1 = (GDALRasterBandShadow *) 0 ;
+   double *arg2 ;
+   int arg3 = (int) 0 ;
+   void *argp1 = 0 ;
+   int res1 = 0 ;
+   double argout2[2] ;
+   int val3 ;
+   int ecode3 = 0 ;
+   
+   {
+     /* %typemap(in,numinputs=0) (double argout2[ANY]) */
+     arg2 = argout2;
+   }
+   if (SWIG_GetArgs(interp, objc, objv,"o|o:osgeo::Band_ComputeRasterMinMax self ?approx_ok? ",(void *)0,(void *)0) == TCL_ERROR) SWIG_fail;
+   res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_GDALRasterBandShadow, 0 |  0 );
+   if (!SWIG_IsOK(res1)) {
+     SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Band_ComputeRasterMinMax" "', argument " "1"" of type '" "GDALRasterBandShadow *""'"); 
+   }
+   arg1 = reinterpret_cast< GDALRasterBandShadow * >(argp1);
+   if (objc > 2) {
+     ecode3 = SWIG_AsVal_int SWIG_TCL_CALL_ARGS_2(objv[2], &val3);
+     if (!SWIG_IsOK(ecode3)) {
+       SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "Band_ComputeRasterMinMax" "', argument " "3"" of type '" "int""'");
+     } 
+     arg3 = static_cast< int >(val3);
+   }
+   {
+     CPLErrorReset();
+     GDALRasterBandShadow_ComputeRasterMinMax(arg1,arg2,arg3);
+     CPLErr eclass = CPLGetLastErrorType();
+     if ( eclass == CE_Failure || eclass == CE_Fatal ) {
+       SWIG_exception( SWIG_RuntimeError, CPLGetLastErrorMsg() );
+       
+     }
+     
+     
+     
+     
+     
+     
+     
+     
+     
+     
+     
+   }
+   
+   {
+     /* %typemap(argout) (double argout[ANY]) */
+     Tcl_Obj *out = CreateListFromDoubleArray( interp, arg2, 2 );
+     if (out == NULL) SWIG_fail;
+     Tcl_ListObjAppendElement(interp,Tcl_GetObjResult(interp),out);
+   }
+   return TCL_OK;
+ fail:
+   return TCL_ERROR;
+ }
+ 
+ 
+ SWIGINTERN int
+ _wrap_Band_ComputeBandStats(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
+   GDALRasterBandShadow *arg1 = (GDALRasterBandShadow *) 0 ;
+   double *arg2 ;
+   int arg3 = (int) 1 ;
+   void *argp1 = 0 ;
+   int res1 = 0 ;
+   double argout2[2] ;
+   int val3 ;
+   int ecode3 = 0 ;
+   
+   {
+     /* %typemap(in,numinputs=0) (double argout2[ANY]) */
+     arg2 = argout2;
+   }
+   if (SWIG_GetArgs(interp, objc, objv,"o|o:osgeo::Band_ComputeBandStats self ?samplestep? ",(void *)0,(void *)0) == TCL_ERROR) SWIG_fail;
+   res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_GDALRasterBandShadow, 0 |  0 );
+   if (!SWIG_IsOK(res1)) {
+     SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Band_ComputeBandStats" "', argument " "1"" of type '" "GDALRasterBandShadow *""'"); 
+   }
+   arg1 = reinterpret_cast< GDALRasterBandShadow * >(argp1);
+   if (objc > 2) {
+     ecode3 = SWIG_AsVal_int SWIG_TCL_CALL_ARGS_2(objv[2], &val3);
+     if (!SWIG_IsOK(ecode3)) {
+       SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "Band_ComputeBandStats" "', argument " "3"" of type '" "int""'");
+     } 
+     arg3 = static_cast< int >(val3);
+   }
+   {
+     CPLErrorReset();
+     GDALRasterBandShadow_ComputeBandStats(arg1,arg2,arg3);
+     CPLErr eclass = CPLGetLastErrorType();
+     if ( eclass == CE_Failure || eclass == CE_Fatal ) {
+       SWIG_exception( SWIG_RuntimeError, CPLGetLastErrorMsg() );
+       
+     }
+     
+     
+     
+     
+     
+     
+     
+     
+     
+     
+     
+   }
+   
+   {
+     /* %typemap(argout) (double argout[ANY]) */
+     Tcl_Obj *out = CreateListFromDoubleArray( interp, arg2, 2 );
+     if (out == NULL) SWIG_fail;
+     Tcl_ListObjAppendElement(interp,Tcl_GetObjResult(interp),out);
+   }
+   return TCL_OK;
+ fail:
+   return TCL_ERROR;
+ }
+ 
+ 
+ SWIGINTERN int
+ _wrap_Band_Fill(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
+   GDALRasterBandShadow *arg1 = (GDALRasterBandShadow *) 0 ;
+   double arg2 ;
+   double arg3 = (double) 0.0 ;
+   void *argp1 = 0 ;
+   int res1 = 0 ;
+   double val2 ;
+   int ecode2 = 0 ;
+   double val3 ;
+   int ecode3 = 0 ;
+   CPLErr result;
+   
+   if (SWIG_GetArgs(interp, objc, objv,"oo|o:osgeo::Band_Fill self real_fill ?imag_fill? ",(void *)0,(void *)0,(void *)0) == TCL_ERROR) SWIG_fail;
+   res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_GDALRasterBandShadow, 0 |  0 );
+   if (!SWIG_IsOK(res1)) {
+     SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Band_Fill" "', argument " "1"" of type '" "GDALRasterBandShadow *""'"); 
+   }
+   arg1 = reinterpret_cast< GDALRasterBandShadow * >(argp1);
+   ecode2 = SWIG_AsVal_double SWIG_TCL_CALL_ARGS_2(objv[2], &val2);
+   if (!SWIG_IsOK(ecode2)) {
+     SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "Band_Fill" "', argument " "2"" of type '" "double""'");
+   } 
+   arg2 = static_cast< double >(val2);
+   if (objc > 3) {
+     ecode3 = SWIG_AsVal_double SWIG_TCL_CALL_ARGS_2(objv[3], &val3);
+     if (!SWIG_IsOK(ecode3)) {
+       SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "Band_Fill" "', argument " "3"" of type '" "double""'");
+     } 
+     arg3 = static_cast< double >(val3);
+   }
+   {
+     CPLErrorReset();
+     result = (CPLErr)GDALRasterBandShadow_Fill(arg1,arg2,arg3);
+     CPLErr eclass = CPLGetLastErrorType();
+     if ( eclass == CE_Failure || eclass == CE_Fatal ) {
+       SWIG_exception( SWIG_RuntimeError, CPLGetLastErrorMsg() );
+       
+     }
+     
+     
+     
+     
+     
+     
+     
+     
+     
+     
+     
+   }
+   Tcl_SetObjResult(interp,SWIG_From_int(static_cast< int >(result)));
+   return TCL_OK;
+ fail:
+   return TCL_ERROR;
+ }
+ 
+ 
+ SWIGINTERN int
+ _wrap_Band_ReadRaster(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
+   GDALRasterBandShadow *arg1 = (GDALRasterBandShadow *) 0 ;
+   int arg2 ;
+   int arg3 ;
+   int arg4 ;
+   int arg5 ;
+   int *arg6 = (int *) 0 ;
+   char **arg7 = (char **) 0 ;
+   int *arg8 = (int *) 0 ;
+   int *arg9 = (int *) 0 ;
+   int *arg10 = (int *) 0 ;
+   void *argp1 = 0 ;
+   int res1 = 0 ;
+   int val2 ;
+   int ecode2 = 0 ;
+   int val3 ;
+   int ecode3 = 0 ;
+   int val4 ;
+   int ecode4 = 0 ;
+   int val5 ;
+   int ecode5 = 0 ;
+   int nLen6 = 0 ;
+   char *pBuf6 = 0 ;
+   void *argp8 = 0 ;
+   int res8 = 0 ;
+   void *argp9 = 0 ;
+   int res9 = 0 ;
+   void *argp10 = 0 ;
+   int res10 = 0 ;
+   CPLErr result;
+   
+   {
+     /* %typemap(in,numinputs=0) (int *nLen6, char **pBuf6 ) */
+     arg6 = &nLen6;
+     arg7 = &pBuf6;
+   }
+   if (SWIG_GetArgs(interp, objc, objv,"ooooo|ooo:osgeo::Band_ReadRaster self xoff yoff xsize ysize ?buf? ?buf_xsize? ?buf_ysize? ?buf_type? ",(void *)0,(void *)0,(void *)0,(void *)0,(void *)0,(void *)0,(void *)0,(void *)0) == TCL_ERROR) SWIG_fail;
+   res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_GDALRasterBandShadow, 0 |  0 );
+   if (!SWIG_IsOK(res1)) {
+     SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Band_ReadRaster" "', argument " "1"" of type '" "GDALRasterBandShadow *""'"); 
+   }
+   arg1 = reinterpret_cast< GDALRasterBandShadow * >(argp1);
+   ecode2 = SWIG_AsVal_int SWIG_TCL_CALL_ARGS_2(objv[2], &val2);
+   if (!SWIG_IsOK(ecode2)) {
+     SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "Band_ReadRaster" "', argument " "2"" of type '" "int""'");
+   } 
+   arg2 = static_cast< int >(val2);
+   ecode3 = SWIG_AsVal_int SWIG_TCL_CALL_ARGS_2(objv[3], &val3);
+   if (!SWIG_IsOK(ecode3)) {
+     SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "Band_ReadRaster" "', argument " "3"" of type '" "int""'");
+   } 
+   arg3 = static_cast< int >(val3);
+   ecode4 = SWIG_AsVal_int SWIG_TCL_CALL_ARGS_2(objv[4], &val4);
+   if (!SWIG_IsOK(ecode4)) {
+     SWIG_exception_fail(SWIG_ArgError(ecode4), "in method '" "Band_ReadRaster" "', argument " "4"" of type '" "int""'");
+   } 
+   arg4 = static_cast< int >(val4);
+   ecode5 = SWIG_AsVal_int SWIG_TCL_CALL_ARGS_2(objv[5], &val5);
+   if (!SWIG_IsOK(ecode5)) {
+     SWIG_exception_fail(SWIG_ArgError(ecode5), "in method '" "Band_ReadRaster" "', argument " "5"" of type '" "int""'");
+   } 
+   arg5 = static_cast< int >(val5);
+   if (objc > 6) {
+     res8 = SWIG_ConvertPtr(objv[6], &argp8,SWIGTYPE_p_int, 0 |  0 );
+     if (!SWIG_IsOK(res8)) {
+       SWIG_exception_fail(SWIG_ArgError(res8), "in method '" "Band_ReadRaster" "', argument " "8"" of type '" "int *""'"); 
+     }
+     arg8 = reinterpret_cast< int * >(argp8);
+   }
+   if (objc > 7) {
+     res9 = SWIG_ConvertPtr(objv[7], &argp9,SWIGTYPE_p_int, 0 |  0 );
+     if (!SWIG_IsOK(res9)) {
+       SWIG_exception_fail(SWIG_ArgError(res9), "in method '" "Band_ReadRaster" "', argument " "9"" of type '" "int *""'"); 
+     }
+     arg9 = reinterpret_cast< int * >(argp9);
+   }
+   if (objc > 8) {
+     res10 = SWIG_ConvertPtr(objv[8], &argp10,SWIGTYPE_p_int, 0 |  0 );
+     if (!SWIG_IsOK(res10)) {
+       SWIG_exception_fail(SWIG_ArgError(res10), "in method '" "Band_ReadRaster" "', argument " "10"" of type '" "int *""'"); 
+     }
+     arg10 = reinterpret_cast< int * >(argp10);
+   }
+   {
+     CPLErrorReset();
+     result = (CPLErr)GDALRasterBandShadow_ReadRaster(arg1,arg2,arg3,arg4,arg5,arg6,arg7,arg8,arg9,arg10);
+     CPLErr eclass = CPLGetLastErrorType();
+     if ( eclass == CE_Failure || eclass == CE_Fatal ) {
+       SWIG_exception( SWIG_RuntimeError, CPLGetLastErrorMsg() );
+       
+     }
+     
+     
+     
+     
+     
+     
+     
+     
+     
+     
+     
+   }
+   Tcl_SetObjResult(interp,SWIG_From_int(static_cast< int >(result)));
+   {
+     /* %typemap(argout) (int *nLen, char **pBuf ) */
+     Tcl_SetObjResult(interp, Tcl_NewStringObj( *arg7, *arg6 ));
+   }
+   return TCL_OK;
+ fail:
+   return TCL_ERROR;
+ }
+ 
+ 
+ SWIGINTERN int
+ _wrap_Band_WriteRaster(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
+   GDALRasterBandShadow *arg1 = (GDALRasterBandShadow *) 0 ;
+   int arg2 ;
+   int arg3 ;
+   int arg4 ;
+   int arg5 ;
+   int arg6 ;
+   char *arg7 = (char *) 0 ;
+   int *arg8 = (int *) 0 ;
+   int *arg9 = (int *) 0 ;
+   int *arg10 = (int *) 0 ;
+   void *argp1 = 0 ;
+   int res1 = 0 ;
+   int val2 ;
+   int ecode2 = 0 ;
+   int val3 ;
+   int ecode3 = 0 ;
+   int val4 ;
+   int ecode4 = 0 ;
+   int val5 ;
+   int ecode5 = 0 ;
+   void *argp8 = 0 ;
+   int res8 = 0 ;
+   void *argp9 = 0 ;
+   int res9 = 0 ;
+   void *argp10 = 0 ;
+   int res10 = 0 ;
+   CPLErr result;
+   
+   if (SWIG_GetArgs(interp, objc, objv,"oooooo|ooo:osgeo::Band_WriteRaster self xoff yoff xsize ysize buf_len ?buf_string? ?buf_xsize? ?buf_ysize? ?buf_type? ",(void *)0,(void *)0,(void *)0,(void *)0,(void *)0,(void *)0,(void *)0,(void *)0,(void *)0) == TCL_ERROR) SWIG_fail;
+   res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_GDALRasterBandShadow, 0 |  0 );
+   if (!SWIG_IsOK(res1)) {
+     SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Band_WriteRaster" "', argument " "1"" of type '" "GDALRasterBandShadow *""'"); 
+   }
+   arg1 = reinterpret_cast< GDALRasterBandShadow * >(argp1);
+   ecode2 = SWIG_AsVal_int SWIG_TCL_CALL_ARGS_2(objv[2], &val2);
+   if (!SWIG_IsOK(ecode2)) {
+     SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "Band_WriteRaster" "', argument " "2"" of type '" "int""'");
+   } 
+   arg2 = static_cast< int >(val2);
+   ecode3 = SWIG_AsVal_int SWIG_TCL_CALL_ARGS_2(objv[3], &val3);
+   if (!SWIG_IsOK(ecode3)) {
+     SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "Band_WriteRaster" "', argument " "3"" of type '" "int""'");
+   } 
+   arg3 = static_cast< int >(val3);
+   ecode4 = SWIG_AsVal_int SWIG_TCL_CALL_ARGS_2(objv[4], &val4);
+   if (!SWIG_IsOK(ecode4)) {
+     SWIG_exception_fail(SWIG_ArgError(ecode4), "in method '" "Band_WriteRaster" "', argument " "4"" of type '" "int""'");
+   } 
+   arg4 = static_cast< int >(val4);
+   ecode5 = SWIG_AsVal_int SWIG_TCL_CALL_ARGS_2(objv[5], &val5);
+   if (!SWIG_IsOK(ecode5)) {
+     SWIG_exception_fail(SWIG_ArgError(ecode5), "in method '" "Band_WriteRaster" "', argument " "5"" of type '" "int""'");
+   } 
+   arg5 = static_cast< int >(val5);
+   {
+     /* %typemap(in,numinputs=1) (int nLen, char *pBuf ) */
+     /* Storage is handled by the respective Tcl_Obj. It should considered read-only. */
+     arg7 = Tcl_GetStringFromObj(objv[6], &arg6);
+   }
+   if (objc > 7) {
+     res8 = SWIG_ConvertPtr(objv[7], &argp8,SWIGTYPE_p_int, 0 |  0 );
+     if (!SWIG_IsOK(res8)) {
+       SWIG_exception_fail(SWIG_ArgError(res8), "in method '" "Band_WriteRaster" "', argument " "8"" of type '" "int *""'"); 
+     }
+     arg8 = reinterpret_cast< int * >(argp8);
+   }
+   if (objc > 8) {
+     res9 = SWIG_ConvertPtr(objv[8], &argp9,SWIGTYPE_p_int, 0 |  0 );
+     if (!SWIG_IsOK(res9)) {
+       SWIG_exception_fail(SWIG_ArgError(res9), "in method '" "Band_WriteRaster" "', argument " "9"" of type '" "int *""'"); 
+     }
+     arg9 = reinterpret_cast< int * >(argp9);
+   }
+   if (objc > 9) {
+     res10 = SWIG_ConvertPtr(objv[9], &argp10,SWIGTYPE_p_int, 0 |  0 );
+     if (!SWIG_IsOK(res10)) {
+       SWIG_exception_fail(SWIG_ArgError(res10), "in method '" "Band_WriteRaster" "', argument " "10"" of type '" "int *""'"); 
+     }
+     arg10 = reinterpret_cast< int * >(argp10);
+   }
+   {
+     CPLErrorReset();
+     result = (CPLErr)GDALRasterBandShadow_WriteRaster(arg1,arg2,arg3,arg4,arg5,arg6,arg7,arg8,arg9,arg10);
+     CPLErr eclass = CPLGetLastErrorType();
+     if ( eclass == CE_Failure || eclass == CE_Fatal ) {
+       SWIG_exception( SWIG_RuntimeError, CPLGetLastErrorMsg() );
+       
+     }
+     
+     
+     
+     
+     
+     
+     
+     
+     
+     
+     
+   }
+   Tcl_SetObjResult(interp,SWIG_From_int(static_cast< int >(result)));
+   return TCL_OK;
+ fail:
+   return TCL_ERROR;
+ }
+ 
+ 
+ SWIGINTERN int
+ _wrap_Band_FlushCache(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
+   GDALRasterBandShadow *arg1 = (GDALRasterBandShadow *) 0 ;
+   void *argp1 = 0 ;
+   int res1 = 0 ;
+   
+   if (SWIG_GetArgs(interp, objc, objv,"o:osgeo::Band_FlushCache self ",(void *)0) == TCL_ERROR) SWIG_fail;
+   res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_GDALRasterBandShadow, 0 |  0 );
+   if (!SWIG_IsOK(res1)) {
+     SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Band_FlushCache" "', argument " "1"" of type '" "GDALRasterBandShadow *""'"); 
+   }
+   arg1 = reinterpret_cast< GDALRasterBandShadow * >(argp1);
+   {
+     CPLErrorReset();
+     GDALRasterBandShadow_FlushCache(arg1);
+     CPLErr eclass = CPLGetLastErrorType();
+     if ( eclass == CE_Failure || eclass == CE_Fatal ) {
+       SWIG_exception( SWIG_RuntimeError, CPLGetLastErrorMsg() );
+       
+     }
+     
+     
+     
+     
+     
+     
+     
+     
+     
+     
+     
+   }
+   
+   return TCL_OK;
+ fail:
+   return TCL_ERROR;
+ }
+ 
+ 
+ SWIGINTERN int
+ _wrap_Band_GetRasterColorTable(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
+   GDALRasterBandShadow *arg1 = (GDALRasterBandShadow *) 0 ;
+   void *argp1 = 0 ;
+   int res1 = 0 ;
+   GDALColorTableShadow *result = 0 ;
+   
+   if (SWIG_GetArgs(interp, objc, objv,"o:osgeo::Band_GetRasterColorTable self ",(void *)0) == TCL_ERROR) SWIG_fail;
+   res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_GDALRasterBandShadow, 0 |  0 );
+   if (!SWIG_IsOK(res1)) {
+     SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Band_GetRasterColorTable" "', argument " "1"" of type '" "GDALRasterBandShadow *""'"); 
+   }
+   arg1 = reinterpret_cast< GDALRasterBandShadow * >(argp1);
+   {
+     CPLErrorReset();
+     result = (GDALColorTableShadow *)GDALRasterBandShadow_GetRasterColorTable(arg1);
+     CPLErr eclass = CPLGetLastErrorType();
+     if ( eclass == CE_Failure || eclass == CE_Fatal ) {
+       SWIG_exception( SWIG_RuntimeError, CPLGetLastErrorMsg() );
+       
+     }
+     
+     
+     
+     
+     
+     
+     
+     
+     
+     
+     
+   }
+   Tcl_SetObjResult(interp, SWIG_NewInstanceObj( SWIG_as_voidptr(result), SWIGTYPE_p_GDALColorTableShadow,0));
+   return TCL_OK;
+ fail:
+   return TCL_ERROR;
+ }
+ 
+ 
+ SWIGINTERN int
+ _wrap_Band_GetColorTable(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
+   GDALRasterBandShadow *arg1 = (GDALRasterBandShadow *) 0 ;
+   void *argp1 = 0 ;
+   int res1 = 0 ;
+   GDALColorTableShadow *result = 0 ;
+   
+   if (SWIG_GetArgs(interp, objc, objv,"o:osgeo::Band_GetColorTable self ",(void *)0) == TCL_ERROR) SWIG_fail;
+   res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_GDALRasterBandShadow, 0 |  0 );
+   if (!SWIG_IsOK(res1)) {
+     SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Band_GetColorTable" "', argument " "1"" of type '" "GDALRasterBandShadow *""'"); 
+   }
+   arg1 = reinterpret_cast< GDALRasterBandShadow * >(argp1);
+   {
+     CPLErrorReset();
+     result = (GDALColorTableShadow *)GDALRasterBandShadow_GetColorTable(arg1);
+     CPLErr eclass = CPLGetLastErrorType();
+     if ( eclass == CE_Failure || eclass == CE_Fatal ) {
+       SWIG_exception( SWIG_RuntimeError, CPLGetLastErrorMsg() );
+       
+     }
+     
+     
+     
+     
+     
+     
+     
+     
+     
+     
+     
+   }
+   Tcl_SetObjResult(interp, SWIG_NewInstanceObj( SWIG_as_voidptr(result), SWIGTYPE_p_GDALColorTableShadow,0));
+   return TCL_OK;
+ fail:
+   return TCL_ERROR;
+ }
+ 
+ 
+ SWIGINTERN int
+ _wrap_Band_SetRasterColorTable(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
+   GDALRasterBandShadow *arg1 = (GDALRasterBandShadow *) 0 ;
+   GDALColorTableShadow *arg2 = (GDALColorTableShadow *) 0 ;
+   void *argp1 = 0 ;
+   int res1 = 0 ;
+   void *argp2 = 0 ;
+   int res2 = 0 ;
+   int result;
+   
+   if (SWIG_GetArgs(interp, objc, objv,"oo:osgeo::Band_SetRasterColorTable self arg ",(void *)0,(void *)0) == TCL_ERROR) SWIG_fail;
+   res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_GDALRasterBandShadow, 0 |  0 );
+   if (!SWIG_IsOK(res1)) {
+     SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Band_SetRasterColorTable" "', argument " "1"" of type '" "GDALRasterBandShadow *""'"); 
+   }
+   arg1 = reinterpret_cast< GDALRasterBandShadow * >(argp1);
+   res2 = SWIG_ConvertPtr(objv[2], &argp2,SWIGTYPE_p_GDALColorTableShadow, 0 |  0 );
+   if (!SWIG_IsOK(res2)) {
+     SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "Band_SetRasterColorTable" "', argument " "2"" of type '" "GDALColorTableShadow *""'"); 
+   }
+   arg2 = reinterpret_cast< GDALColorTableShadow * >(argp2);
+   {
+     CPLErrorReset();
+     result = (int)GDALRasterBandShadow_SetRasterColorTable(arg1,arg2);
+     CPLErr eclass = CPLGetLastErrorType();
+     if ( eclass == CE_Failure || eclass == CE_Fatal ) {
+       SWIG_exception( SWIG_RuntimeError, CPLGetLastErrorMsg() );
+       
+     }
+     
+     
+     
+     
+     
+     
+     
+     
+     
+     
+     
+   }
+   Tcl_SetObjResult(interp,SWIG_From_int(static_cast< int >(result)));
+   return TCL_OK;
+ fail:
+   return TCL_ERROR;
+ }
+ 
+ 
+ SWIGINTERN int
+ _wrap_Band_SetColorTable(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
+   GDALRasterBandShadow *arg1 = (GDALRasterBandShadow *) 0 ;
+   GDALColorTableShadow *arg2 = (GDALColorTableShadow *) 0 ;
+   void *argp1 = 0 ;
+   int res1 = 0 ;
+   void *argp2 = 0 ;
+   int res2 = 0 ;
+   int result;
+   
+   if (SWIG_GetArgs(interp, objc, objv,"oo:osgeo::Band_SetColorTable self arg ",(void *)0,(void *)0) == TCL_ERROR) SWIG_fail;
+   res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_GDALRasterBandShadow, 0 |  0 );
+   if (!SWIG_IsOK(res1)) {
+     SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Band_SetColorTable" "', argument " "1"" of type '" "GDALRasterBandShadow *""'"); 
+   }
+   arg1 = reinterpret_cast< GDALRasterBandShadow * >(argp1);
+   res2 = SWIG_ConvertPtr(objv[2], &argp2,SWIGTYPE_p_GDALColorTableShadow, 0 |  0 );
+   if (!SWIG_IsOK(res2)) {
+     SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "Band_SetColorTable" "', argument " "2"" of type '" "GDALColorTableShadow *""'"); 
+   }
+   arg2 = reinterpret_cast< GDALColorTableShadow * >(argp2);
+   {
+     CPLErrorReset();
+     result = (int)GDALRasterBandShadow_SetColorTable(arg1,arg2);
+     CPLErr eclass = CPLGetLastErrorType();
+     if ( eclass == CE_Failure || eclass == CE_Fatal ) {
+       SWIG_exception( SWIG_RuntimeError, CPLGetLastErrorMsg() );
+       
+     }
+     
+     
+     
+     
+     
+     
+     
+     
+     
+     
+     
+   }
+   Tcl_SetObjResult(interp,SWIG_From_int(static_cast< int >(result)));
+   return TCL_OK;
+ fail:
+   return TCL_ERROR;
+ }
+ 
+ 
+ SWIGINTERN int
+ _wrap_Band_GetDefaultRAT(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
+   GDALRasterBandShadow *arg1 = (GDALRasterBandShadow *) 0 ;
+   void *argp1 = 0 ;
+   int res1 = 0 ;
+   GDALRasterAttributeTableShadow *result = 0 ;
+   
+   if (SWIG_GetArgs(interp, objc, objv,"o:osgeo::Band_GetDefaultRAT self ",(void *)0) == TCL_ERROR) SWIG_fail;
+   res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_GDALRasterBandShadow, 0 |  0 );
+   if (!SWIG_IsOK(res1)) {
+     SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Band_GetDefaultRAT" "', argument " "1"" of type '" "GDALRasterBandShadow *""'"); 
+   }
+   arg1 = reinterpret_cast< GDALRasterBandShadow * >(argp1);
+   {
+     CPLErrorReset();
+     result = (GDALRasterAttributeTableShadow *)GDALRasterBandShadow_GetDefaultRAT(arg1);
+     CPLErr eclass = CPLGetLastErrorType();
+     if ( eclass == CE_Failure || eclass == CE_Fatal ) {
+       SWIG_exception( SWIG_RuntimeError, CPLGetLastErrorMsg() );
+       
+     }
+     
+     
+     
+     
+     
+     
+     
+     
+     
+     
+     
+   }
+   Tcl_SetObjResult(interp, SWIG_NewInstanceObj( SWIG_as_voidptr(result), SWIGTYPE_p_GDALRasterAttributeTableShadow,0));
+   return TCL_OK;
+ fail:
+   return TCL_ERROR;
+ }
+ 
+ 
+ SWIGINTERN int
+ _wrap_Band_SetDefaultRAT(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
+   GDALRasterBandShadow *arg1 = (GDALRasterBandShadow *) 0 ;
+   GDALRasterAttributeTableShadow *arg2 = (GDALRasterAttributeTableShadow *) 0 ;
+   void *argp1 = 0 ;
+   int res1 = 0 ;
+   void *argp2 = 0 ;
+   int res2 = 0 ;
+   int result;
+   
+   if (SWIG_GetArgs(interp, objc, objv,"oo:osgeo::Band_SetDefaultRAT self table ",(void *)0,(void *)0) == TCL_ERROR) SWIG_fail;
+   res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_GDALRasterBandShadow, 0 |  0 );
+   if (!SWIG_IsOK(res1)) {
+     SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Band_SetDefaultRAT" "', argument " "1"" of type '" "GDALRasterBandShadow *""'"); 
+   }
+   arg1 = reinterpret_cast< GDALRasterBandShadow * >(argp1);
+   res2 = SWIG_ConvertPtr(objv[2], &argp2,SWIGTYPE_p_GDALRasterAttributeTableShadow, 0 |  0 );
+   if (!SWIG_IsOK(res2)) {
+     SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "Band_SetDefaultRAT" "', argument " "2"" of type '" "GDALRasterAttributeTableShadow *""'"); 
+   }
+   arg2 = reinterpret_cast< GDALRasterAttributeTableShadow * >(argp2);
+   {
+     CPLErrorReset();
+     result = (int)GDALRasterBandShadow_SetDefaultRAT(arg1,arg2);
+     CPLErr eclass = CPLGetLastErrorType();
+     if ( eclass == CE_Failure || eclass == CE_Fatal ) {
+       SWIG_exception( SWIG_RuntimeError, CPLGetLastErrorMsg() );
+       
+     }
+     
+     
+     
+     
+     
+     
+     
+     
+     
+     
+     
+   }
+   Tcl_SetObjResult(interp,SWIG_From_int(static_cast< int >(result)));
+   return TCL_OK;
+ fail:
+   return TCL_ERROR;
+ }
+ 
+ 
+ SWIGINTERN int
+ _wrap_Band_GetMaskBand(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
+   GDALRasterBandShadow *arg1 = (GDALRasterBandShadow *) 0 ;
+   void *argp1 = 0 ;
+   int res1 = 0 ;
+   GDALRasterBandShadow *result = 0 ;
+   
+   if (SWIG_GetArgs(interp, objc, objv,"o:osgeo::Band_GetMaskBand self ",(void *)0) == TCL_ERROR) SWIG_fail;
+   res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_GDALRasterBandShadow, 0 |  0 );
+   if (!SWIG_IsOK(res1)) {
+     SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Band_GetMaskBand" "', argument " "1"" of type '" "GDALRasterBandShadow *""'"); 
+   }
+   arg1 = reinterpret_cast< GDALRasterBandShadow * >(argp1);
+   {
+     CPLErrorReset();
+     result = (GDALRasterBandShadow *)GDALRasterBandShadow_GetMaskBand(arg1);
+     CPLErr eclass = CPLGetLastErrorType();
+     if ( eclass == CE_Failure || eclass == CE_Fatal ) {
+       SWIG_exception( SWIG_RuntimeError, CPLGetLastErrorMsg() );
+       
+     }
+     
+     
+     
+     
+     
+     
+     
+     
+     
+     
+     
+   }
+   Tcl_SetObjResult(interp, SWIG_NewInstanceObj( SWIG_as_voidptr(result), SWIGTYPE_p_GDALRasterBandShadow,0));
+   return TCL_OK;
+ fail:
+   return TCL_ERROR;
+ }
+ 
+ 
+ SWIGINTERN int
+ _wrap_Band_GetMaskFlags(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
+   GDALRasterBandShadow *arg1 = (GDALRasterBandShadow *) 0 ;
+   void *argp1 = 0 ;
+   int res1 = 0 ;
+   int result;
+   
+   if (SWIG_GetArgs(interp, objc, objv,"o:osgeo::Band_GetMaskFlags self ",(void *)0) == TCL_ERROR) SWIG_fail;
+   res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_GDALRasterBandShadow, 0 |  0 );
+   if (!SWIG_IsOK(res1)) {
+     SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Band_GetMaskFlags" "', argument " "1"" of type '" "GDALRasterBandShadow *""'"); 
+   }
+   arg1 = reinterpret_cast< GDALRasterBandShadow * >(argp1);
+   {
+     CPLErrorReset();
+     result = (int)GDALRasterBandShadow_GetMaskFlags(arg1);
+     CPLErr eclass = CPLGetLastErrorType();
+     if ( eclass == CE_Failure || eclass == CE_Fatal ) {
+       SWIG_exception( SWIG_RuntimeError, CPLGetLastErrorMsg() );
+       
+     }
+     
+     
+     
+     
+     
+     
+     
+     
+     
+     
+     
+   }
+   Tcl_SetObjResult(interp,SWIG_From_int(static_cast< int >(result)));
+   return TCL_OK;
+ fail:
+   return TCL_ERROR;
+ }
+ 
+ 
+ SWIGINTERN int
+ _wrap_Band_CreateMaskBand(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
+   GDALRasterBandShadow *arg1 = (GDALRasterBandShadow *) 0 ;
+   int arg2 ;
+   void *argp1 = 0 ;
+   int res1 = 0 ;
+   int val2 ;
+   int ecode2 = 0 ;
+   CPLErr result;
+   
+   if (SWIG_GetArgs(interp, objc, objv,"oo:osgeo::Band_CreateMaskBand self nFlags ",(void *)0,(void *)0) == TCL_ERROR) SWIG_fail;
+   res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_GDALRasterBandShadow, 0 |  0 );
+   if (!SWIG_IsOK(res1)) {
+     SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Band_CreateMaskBand" "', argument " "1"" of type '" "GDALRasterBandShadow *""'"); 
+   }
+   arg1 = reinterpret_cast< GDALRasterBandShadow * >(argp1);
+   ecode2 = SWIG_AsVal_int SWIG_TCL_CALL_ARGS_2(objv[2], &val2);
+   if (!SWIG_IsOK(ecode2)) {
+     SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "Band_CreateMaskBand" "', argument " "2"" of type '" "int""'");
+   } 
+   arg2 = static_cast< int >(val2);
+   {
+     CPLErrorReset();
+     result = (CPLErr)GDALRasterBandShadow_CreateMaskBand(arg1,arg2);
+     CPLErr eclass = CPLGetLastErrorType();
+     if ( eclass == CE_Failure || eclass == CE_Fatal ) {
+       SWIG_exception( SWIG_RuntimeError, CPLGetLastErrorMsg() );
+       
+     }
+     
+     
+     
+     
+     
+     
+     
+     
+     
+     
+     
+   }
+   Tcl_SetObjResult(interp,SWIG_From_int(static_cast< int >(result)));
+   return TCL_OK;
+ fail:
+   return TCL_ERROR;
+ }
+ 
+ 
+ SWIGINTERN int
+ _wrap_Band_GetHistogram(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
+   GDALRasterBandShadow *arg1 = (GDALRasterBandShadow *) 0 ;
+   double arg2 = (double) -0.5 ;
+   double arg3 = (double) 255.5 ;
+   int arg4 = (int) 256 ;
+   int *arg5 = (int *) NULL ;
+   int arg6 = (int) 0 ;
+   int arg7 = (int) 1 ;
+   GDALProgressFunc arg8 = (GDALProgressFunc) NULL ;
+   void *arg9 = (void *) NULL ;
+   void *argp1 = 0 ;
+   int res1 = 0 ;
+   double val2 ;
+   int ecode2 = 0 ;
+   double val3 ;
+   int ecode3 = 0 ;
+   int val6 ;
+   int ecode6 = 0 ;
+   int val7 ;
+   int ecode7 = 0 ;
+   CPLErr result;
+   
+   {
+     /* %typemap(in) int buckets, int* panHistogram -> list */
+     arg5 = (int *) CPLCalloc(sizeof(int),arg4);
+   }
+   /* %typemap(arginit) ( const char* callback_data=NULL)  */
+   TclProgressData *psProgressInfo;
+   psProgressInfo = (TclProgressData *) CPLCalloc(1,sizeof(TclProgressData));
+   psProgressInfo->nLastReported = -1;
+   psProgressInfo->interp = interp;
+   psProgressInfo->psTclCallback = NULL;
+   psProgressInfo->psTclCallbackData = NULL;
+   if (SWIG_GetArgs(interp, objc, objv,"o|ooooooo:osgeo::Band_GetHistogram self ?min? ?max? ?buckets? ?panHistogram? ?include_out_of_range? ?approx_ok? ?callback? ?callback_data? ",(void *)0,(void *)0,(void *)0,(void *)0,(void *)0,(void *)0,(void *)0,(void *)0) == TCL_ERROR) SWIG_fail;
+   res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_GDALRasterBandShadow, 0 |  0 );
+   if (!SWIG_IsOK(res1)) {
+     SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Band_GetHistogram" "', argument " "1"" of type '" "GDALRasterBandShadow *""'"); 
+   }
+   arg1 = reinterpret_cast< GDALRasterBandShadow * >(argp1);
+   if (objc > 2) {
+     ecode2 = SWIG_AsVal_double SWIG_TCL_CALL_ARGS_2(objv[2], &val2);
+     if (!SWIG_IsOK(ecode2)) {
+       SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "Band_GetHistogram" "', argument " "2"" of type '" "double""'");
+     } 
+     arg2 = static_cast< double >(val2);
+   }
+   if (objc > 3) {
+     ecode3 = SWIG_AsVal_double SWIG_TCL_CALL_ARGS_2(objv[3], &val3);
+     if (!SWIG_IsOK(ecode3)) {
+       SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "Band_GetHistogram" "', argument " "3"" of type '" "double""'");
+     } 
+     arg3 = static_cast< double >(val3);
+   }
+   if (objc > 4) {
+     {
+       /* %typemap(in) int buckets, int* panHistogram -> list */
+       int requested_buckets;
+       SWIG_AsVal_int(interp, objv[4], &requested_buckets);
+       if( requested_buckets != arg4 )
+       {
+         arg4 = requested_buckets;
+         arg5 = (int *) CPLRealloc(arg5,sizeof(int) * requested_buckets);
+       }
+     }
+   }
+   if (objc > 5) {
+     ecode6 = SWIG_AsVal_int SWIG_TCL_CALL_ARGS_2(objv[5], &val6);
+     if (!SWIG_IsOK(ecode6)) {
+       SWIG_exception_fail(SWIG_ArgError(ecode6), "in method '" "Band_GetHistogram" "', argument " "6"" of type '" "int""'");
+     } 
+     arg6 = static_cast< int >(val6);
+   }
+   if (objc > 6) {
+     ecode7 = SWIG_AsVal_int SWIG_TCL_CALL_ARGS_2(objv[6], &val7);
+     if (!SWIG_IsOK(ecode7)) {
+       SWIG_exception_fail(SWIG_ArgError(ecode7), "in method '" "Band_GetHistogram" "', argument " "7"" of type '" "int""'");
+     } 
+     arg7 = static_cast< int >(val7);
+   }
+   if (objc > 7) {
+     {
+       /* %typemap(in) (GDALProgressFunc callback = NULL) */
+       /* callback_func typemap */
+       if (objv[7] && !strcmp(Tcl_GetString(objv[7]), "")) {
+         void* cbfunction = NULL;
+         SWIG_ConvertPtr( objv[7], 
+           (void**)&cbfunction, 
+           SWIGTYPE_p_f_double_p_q_const__char_p_void__int, 
+           SWIG_POINTER_EXCEPTION | 0 );
+         
+         if ( cbfunction == GDALTermProgress ) {
+           arg8 = GDALTermProgress;
+         } else if ( cbfunction == GDALDummyProgress) {
+           arg8 = GDALDummyProgress;
+         } else if ( cbfunction == GDALScaledProgress) {
+           arg8 = GDALScaledProgress;
+         } else {
+           psProgressInfo->psTclCallback = objv[7];
+           Tcl_IncrRefCount(psProgressInfo->psTclCallback);
+           arg8 = TclProgressProxy;
+         }
+       }
+     }
+   }
+   if (objc > 8) {
+     {
+       /* %typemap(in) ( void* callback_data=NULL)  */
+       psProgressInfo->psTclCallbackData = objv[8];
+       Tcl_IncrRefCount(psProgressInfo->psTclCallbackData);
+       arg9 = psProgressInfo;
+       
+     }
+   }
+   {
+     CPLErrorReset();
+     result = (CPLErr)GDALRasterBandShadow_GetHistogram(arg1,arg2,arg3,arg4,arg5,arg6,arg7,arg8,arg9);
+     CPLErr eclass = CPLGetLastErrorType();
+     if ( eclass == CE_Failure || eclass == CE_Fatal ) {
+       SWIG_exception( SWIG_RuntimeError, CPLGetLastErrorMsg() );
+       
+     }
+     
+     
+     
+     
+     
+     
+     
+     
+     
+     
+     
+   }
+   Tcl_SetObjResult(interp,SWIG_From_int(static_cast< int >(result)));
+   {
+     /* %typemap(out) int buckets, int* panHistogram -> list */
+     int *integerarray = arg5;
+     if ( integerarray == NULL ) {
+       Tcl_ResetResult(interp); /* NONE = Empty string */
+     } else {
+       Tcl_Obj *out = Tcl_NewListObj(0, NULL);
+       for( int i=0; i < arg4; i++ ) {
+         Tcl_Obj *o = Tcl_NewLongObj( integerarray[i] );
+         if (Tcl_ListObjAppendElement(interp, out, o) != TCL_OK) {
+           Tcl_DecrRefCount(o);
+           Tcl_DecrRefCount(out);
+           /* Error msg in interp result */
+           SWIG_fail;
+         }
+       }
+       Tcl_SetObjResult(interp, out);
+     }
+   }
+   {
+     /* %typemap(freearg) (int buckets, int* panHistogram)*/
+     if ( arg5 ) {
+       CPLFree( arg5 );
+     }
+   }
+   {
+     /* %typemap(freearg) ( void* callback_data=NULL)  */
+     Tcl_DecrRefCount(psProgressInfo->psTclCallback);
+     Tcl_DecrRefCount(psProgressInfo->psTclCallbackData);
+     CPLFree(psProgressInfo);
+   }
+   return TCL_OK;
+ fail:
+   {
+     /* %typemap(freearg) (int buckets, int* panHistogram)*/
+     if ( arg5 ) {
+       CPLFree( arg5 );
+     }
+   }
+   {
+     /* %typemap(freearg) ( void* callback_data=NULL)  */
+     Tcl_DecrRefCount(psProgressInfo->psTclCallback);
+     Tcl_DecrRefCount(psProgressInfo->psTclCallbackData);
+     CPLFree(psProgressInfo);
+   }
+   return TCL_ERROR;
+ }
+ 
+ 
+ SWIGINTERN int
+ _wrap_Band_GetDefaultHistogram(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
+   GDALRasterBandShadow *arg1 = (GDALRasterBandShadow *) 0 ;
+   double *arg2 = (double *) NULL ;
+   double *arg3 = (double *) NULL ;
+   int *arg4 = (int *) NULL ;
+   int **arg5 = (int **) NULL ;
+   int arg6 = (int) 1 ;
+   GDALProgressFunc arg7 = (GDALProgressFunc) NULL ;
+   void *arg8 = (void *) NULL ;
+   void *argp1 = 0 ;
+   int res1 = 0 ;
+   void *argp2 = 0 ;
+   int res2 = 0 ;
+   void *argp3 = 0 ;
+   int res3 = 0 ;
+   void *argp4 = 0 ;
+   int res4 = 0 ;
+   void *argp5 = 0 ;
+   int res5 = 0 ;
+   int val6 ;
+   int ecode6 = 0 ;
+   CPLErr result;
+   
+   double min_val, max_val;
+   int buckets_val;
+   int *panHistogram;
+   
+   /* frankwdebug */
+   
+   arg2 = &min_val;
+   arg3 = &max_val;
+   arg4 = &buckets_val;
+   arg5 = &panHistogram;
+   /* %typemap(arginit) ( const char* callback_data=NULL)  */
+   TclProgressData *psProgressInfo;
+   psProgressInfo = (TclProgressData *) CPLCalloc(1,sizeof(TclProgressData));
+   psProgressInfo->nLastReported = -1;
+   psProgressInfo->interp = interp;
+   psProgressInfo->psTclCallback = NULL;
+   psProgressInfo->psTclCallbackData = NULL;
+   if (SWIG_GetArgs(interp, objc, objv,"o|ooooooo:osgeo::Band_GetDefaultHistogram self ?min_ret? ?max_ret? ?buckets_ret? ?ppanHistogram? ?force? ?callback? ?callback_data? ",(void *)0,(void *)0,(void *)0,(void *)0,(void *)0,(void *)0,(void *)0,(void *)0) == TCL_ERROR) SWIG_fail;
+   res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_GDALRasterBandShadow, 0 |  0 );
+   if (!SWIG_IsOK(res1)) {
+     SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Band_GetDefaultHistogram" "', argument " "1"" of type '" "GDALRasterBandShadow *""'"); 
+   }
+   arg1 = reinterpret_cast< GDALRasterBandShadow * >(argp1);
+   if (objc > 2) {
+     res2 = SWIG_ConvertPtr(objv[2], &argp2,SWIGTYPE_p_double, 0 |  0 );
+     if (!SWIG_IsOK(res2)) {
+       SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "Band_GetDefaultHistogram" "', argument " "2"" of type '" "double *""'"); 
+     }
+     arg2 = reinterpret_cast< double * >(argp2);
+   }
+   if (objc > 3) {
+     res3 = SWIG_ConvertPtr(objv[3], &argp3,SWIGTYPE_p_double, 0 |  0 );
+     if (!SWIG_IsOK(res3)) {
+       SWIG_exception_fail(SWIG_ArgError(res3), "in method '" "Band_GetDefaultHistogram" "', argument " "3"" of type '" "double *""'"); 
+     }
+     arg3 = reinterpret_cast< double * >(argp3);
+   }
+   if (objc > 4) {
+     res4 = SWIG_ConvertPtr(objv[4], &argp4,SWIGTYPE_p_int, 0 |  0 );
+     if (!SWIG_IsOK(res4)) {
+       SWIG_exception_fail(SWIG_ArgError(res4), "in method '" "Band_GetDefaultHistogram" "', argument " "4"" of type '" "int *""'"); 
+     }
+     arg4 = reinterpret_cast< int * >(argp4);
+   }
+   if (objc > 5) {
+     res5 = SWIG_ConvertPtr(objv[5], &argp5,SWIGTYPE_p_p_int, 0 |  0 );
+     if (!SWIG_IsOK(res5)) {
+       SWIG_exception_fail(SWIG_ArgError(res5), "in method '" "Band_GetDefaultHistogram" "', argument " "5"" of type '" "int **""'"); 
+     }
+     arg5 = reinterpret_cast< int ** >(argp5);
+   }
+   if (objc > 6) {
+     ecode6 = SWIG_AsVal_int SWIG_TCL_CALL_ARGS_2(objv[6], &val6);
+     if (!SWIG_IsOK(ecode6)) {
+       SWIG_exception_fail(SWIG_ArgError(ecode6), "in method '" "Band_GetDefaultHistogram" "', argument " "6"" of type '" "int""'");
+     } 
+     arg6 = static_cast< int >(val6);
+   }
+   if (objc > 7) {
+     {
+       /* %typemap(in) (GDALProgressFunc callback = NULL) */
+       /* callback_func typemap */
+       if (objv[7] && !strcmp(Tcl_GetString(objv[7]), "")) {
+         void* cbfunction = NULL;
+         SWIG_ConvertPtr( objv[7], 
+           (void**)&cbfunction, 
+           SWIGTYPE_p_f_double_p_q_const__char_p_void__int, 
+           SWIG_POINTER_EXCEPTION | 0 );
+         
+         if ( cbfunction == GDALTermProgress ) {
+           arg7 = GDALTermProgress;
+         } else if ( cbfunction == GDALDummyProgress) {
+           arg7 = GDALDummyProgress;
+         } else if ( cbfunction == GDALScaledProgress) {
+           arg7 = GDALScaledProgress;
+         } else {
+           psProgressInfo->psTclCallback = objv[7];
+           Tcl_IncrRefCount(psProgressInfo->psTclCallback);
+           arg7 = TclProgressProxy;
+         }
+       }
+     }
+   }
+   if (objc > 8) {
+     {
+       /* %typemap(in) ( void* callback_data=NULL)  */
+       psProgressInfo->psTclCallbackData = objv[8];
+       Tcl_IncrRefCount(psProgressInfo->psTclCallbackData);
+       arg8 = psProgressInfo;
+       
+     }
+   }
+   {
+     CPLErrorReset();
+     result = (CPLErr)GDALRasterBandShadow_GetDefaultHistogram(arg1,arg2,arg3,arg4,arg5,arg6,arg7,arg8);
+     CPLErr eclass = CPLGetLastErrorType();
+     if ( eclass == CE_Failure || eclass == CE_Fatal ) {
+       SWIG_exception( SWIG_RuntimeError, CPLGetLastErrorMsg() );
+       
+     }
+     
+     
+     
+     
+     
+     
+     
+     
+     
+     
+     
+   }
+   Tcl_SetObjResult(interp,SWIG_From_int(static_cast< int >(result)));
+   {
+     int i;
+     Tcl_Obj *o, *psList = NULL;
+     
+     /* frankwdebug */
+     
+     psList = Tcl_NewListObj(0, NULL);
+     
+     o = Tcl_NewDoubleObj( min_val );
+     if (Tcl_ListObjAppendElement(interp, psList, o) != TCL_OK) {
+       Tcl_DecrRefCount(o);
+       Tcl_DecrRefCount(psList);
+       /* Error msg in interp result */
+       SWIG_fail;
+     }
+     o = Tcl_NewDoubleObj( max_val );
+     if (Tcl_ListObjAppendElement(interp, psList, o) != TCL_OK) {
+       Tcl_DecrRefCount(o);
+       Tcl_DecrRefCount(psList);
+       /* Error msg in interp result */
+       SWIG_fail;
+     }
+     o = Tcl_NewLongObj( buckets_val );
+     if (Tcl_ListObjAppendElement(interp, psList, o) != TCL_OK) {
+       Tcl_DecrRefCount(o);
+       Tcl_DecrRefCount(psList);
+       /* Error msg in interp result */
+       SWIG_fail;
+     }
+     
+     for( i = 0; i < buckets_val; i++ ) {
+       o = Tcl_NewLongObj( panHistogram[i] );
+       if (Tcl_ListObjAppendElement(interp, psList, o) != TCL_OK) {
+         Tcl_DecrRefCount(o);
+         Tcl_DecrRefCount(psList);
+         /* Error msg in interp result */
+         SWIG_fail;
+       }
+     }
+     
+     Tcl_SetObjResult(interp, psList);
+     CPLFree( panHistogram );
+   }
+   {
+     /* %typemap(freearg) ( void* callback_data=NULL)  */
+     Tcl_DecrRefCount(psProgressInfo->psTclCallback);
+     Tcl_DecrRefCount(psProgressInfo->psTclCallbackData);
+     CPLFree(psProgressInfo);
+   }
+   return TCL_OK;
+ fail:
+   {
+     /* %typemap(freearg) ( void* callback_data=NULL)  */
+     Tcl_DecrRefCount(psProgressInfo->psTclCallback);
+     Tcl_DecrRefCount(psProgressInfo->psTclCallbackData);
+     CPLFree(psProgressInfo);
+   }
+   return TCL_ERROR;
+ }
+ 
+ 
+ SWIGINTERN int
+ _wrap_Band_SetDefaultHistogram(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
+   GDALRasterBandShadow *arg1 = (GDALRasterBandShadow *) 0 ;
+   double arg2 ;
+   double arg3 ;
+   int arg4 ;
+   int *arg5 = (int *) 0 ;
+   void *argp1 = 0 ;
+   int res1 = 0 ;
+   double val2 ;
+   int ecode2 = 0 ;
+   double val3 ;
+   int ecode3 = 0 ;
+   int val4 ;
+   int ecode4 = 0 ;
+   void *argp5 = 0 ;
+   int res5 = 0 ;
+   CPLErr result;
+   
+   if (SWIG_GetArgs(interp, objc, objv,"ooooo:osgeo::Band_SetDefaultHistogram self min max buckets_in panHistogram_in ",(void *)0,(void *)0,(void *)0,(void *)0,(void *)0) == TCL_ERROR) SWIG_fail;
+   res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_GDALRasterBandShadow, 0 |  0 );
+   if (!SWIG_IsOK(res1)) {
+     SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Band_SetDefaultHistogram" "', argument " "1"" of type '" "GDALRasterBandShadow *""'"); 
+   }
+   arg1 = reinterpret_cast< GDALRasterBandShadow * >(argp1);
+   ecode2 = SWIG_AsVal_double SWIG_TCL_CALL_ARGS_2(objv[2], &val2);
+   if (!SWIG_IsOK(ecode2)) {
+     SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "Band_SetDefaultHistogram" "', argument " "2"" of type '" "double""'");
+   } 
+   arg2 = static_cast< double >(val2);
+   ecode3 = SWIG_AsVal_double SWIG_TCL_CALL_ARGS_2(objv[3], &val3);
+   if (!SWIG_IsOK(ecode3)) {
+     SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "Band_SetDefaultHistogram" "', argument " "3"" of type '" "double""'");
+   } 
+   arg3 = static_cast< double >(val3);
+   ecode4 = SWIG_AsVal_int SWIG_TCL_CALL_ARGS_2(objv[4], &val4);
+   if (!SWIG_IsOK(ecode4)) {
+     SWIG_exception_fail(SWIG_ArgError(ecode4), "in method '" "Band_SetDefaultHistogram" "', argument " "4"" of type '" "int""'");
+   } 
+   arg4 = static_cast< int >(val4);
+   res5 = SWIG_ConvertPtr(objv[5], &argp5,SWIGTYPE_p_int, 0 |  0 );
+   if (!SWIG_IsOK(res5)) {
+     SWIG_exception_fail(SWIG_ArgError(res5), "in method '" "Band_SetDefaultHistogram" "', argument " "5"" of type '" "int *""'"); 
+   }
+   arg5 = reinterpret_cast< int * >(argp5);
+   {
+     CPLErrorReset();
+     result = (CPLErr)GDALRasterBandShadow_SetDefaultHistogram(arg1,arg2,arg3,arg4,arg5);
+     CPLErr eclass = CPLGetLastErrorType();
+     if ( eclass == CE_Failure || eclass == CE_Fatal ) {
+       SWIG_exception( SWIG_RuntimeError, CPLGetLastErrorMsg() );
+       
+     }
+     
+     
+     
+     
+     
+     
+     
+     
+     
+     
+     
+   }
+   Tcl_SetObjResult(interp,SWIG_From_int(static_cast< int >(result)));
+   return TCL_OK;
+ fail:
+   return TCL_ERROR;
+ }
+ 
+ 
+ static swig_method swig_GDALRasterBandShadow_methods[] = {
+     {"GetBlockSize", _wrap_Band_GetBlockSize}, 
+     {"GetRasterColorInterpretation", _wrap_Band_GetRasterColorInterpretation}, 
+     {"SetRasterColorInterpretation", _wrap_Band_SetRasterColorInterpretation}, 
+     {"GetNoDataValue", _wrap_Band_GetNoDataValue}, 
+     {"SetNoDataValue", _wrap_Band_SetNoDataValue}, 
+     {"GetRasterCategoryNames", _wrap_Band_GetRasterCategoryNames}, 
+     {"SetRasterCategoryNames", _wrap_Band_SetRasterCategoryNames}, 
+     {"GetMinimum", _wrap_Band_GetMinimum}, 
+     {"GetMaximum", _wrap_Band_GetMaximum}, 
+     {"GetOffset", _wrap_Band_GetOffset}, 
+     {"GetScale", _wrap_Band_GetScale}, 
+     {"GetStatistics", _wrap_Band_GetStatistics}, 
+     {"SetStatistics", _wrap_Band_SetStatistics}, 
+     {"GetOverviewCount", _wrap_Band_GetOverviewCount}, 
+     {"GetOverview", _wrap_Band_GetOverview}, 
+     {"Checksum", _wrap_Band_Checksum}, 
+     {"ComputeRasterMinMax", _wrap_Band_ComputeRasterMinMax}, 
+     {"ComputeBandStats", _wrap_Band_ComputeBandStats}, 
+     {"Fill", _wrap_Band_Fill}, 
+     {"ReadRaster", _wrap_Band_ReadRaster}, 
+     {"WriteRaster", _wrap_Band_WriteRaster}, 
+     {"FlushCache", _wrap_Band_FlushCache}, 
+     {"GetRasterColorTable", _wrap_Band_GetRasterColorTable}, 
+     {"GetColorTable", _wrap_Band_GetColorTable}, 
+     {"SetRasterColorTable", _wrap_Band_SetRasterColorTable}, 
+     {"SetColorTable", _wrap_Band_SetColorTable}, 
+     {"GetDefaultRAT", _wrap_Band_GetDefaultRAT}, 
+     {"SetDefaultRAT", _wrap_Band_SetDefaultRAT}, 
+     {"GetMaskBand", _wrap_Band_GetMaskBand}, 
+     {"GetMaskFlags", _wrap_Band_GetMaskFlags}, 
+     {"CreateMaskBand", _wrap_Band_CreateMaskBand}, 
+     {"GetHistogram", _wrap_Band_GetHistogram}, 
+     {"GetDefaultHistogram", _wrap_Band_GetDefaultHistogram}, 
+     {"SetDefaultHistogram", _wrap_Band_SetDefaultHistogram}, 
+     {0,0}
+ };
+ static swig_attribute swig_GDALRasterBandShadow_attributes[] = {
+     { "-XSize",_wrap_Band_XSize_get, 0 },
+     { "-YSize",_wrap_Band_YSize_get, 0 },
+     { "-DataType",_wrap_Band_DataType_get, 0 },
+     {0,0,0}
+ };
+ static swig_class *swig_GDALRasterBandShadow_bases[] = {0,0};
+ static const char * swig_GDALRasterBandShadow_base_names[] = {"GDALMajorObjectShadow *",0};
+ static swig_class _wrap_class_GDALRasterBandShadow = { "Band", &SWIGTYPE_p_GDALRasterBandShadow,0,0, swig_GDALRasterBandShadow_methods, swig_GDALRasterBandShadow_attributes, swig_GDALRasterBandShadow_bases,swig_GDALRasterBandShadow_base_names, &swig_module };
+ SWIGINTERN int
+ _wrap_new_ColorTable(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
+   GDALPaletteInterp arg1 = (GDALPaletteInterp) GPI_RGB ;
+   int val1 ;
+   int ecode1 = 0 ;
+   GDALColorTableShadow *result = 0 ;
+   
+   if (SWIG_GetArgs(interp, objc, objv,"|o:osgeo::new_ColorTable ?palette? ",(void *)0) == TCL_ERROR) SWIG_fail;
+   if (objc > 1) {
+     ecode1 = SWIG_AsVal_int SWIG_TCL_CALL_ARGS_2(objv[1], &val1);
+     if (!SWIG_IsOK(ecode1)) {
+       SWIG_exception_fail(SWIG_ArgError(ecode1), "in method '" "new_ColorTable" "', argument " "1"" of type '" "GDALPaletteInterp""'");
+     } 
+     arg1 = static_cast< GDALPaletteInterp >(val1);
+   }
+   {
+     CPLErrorReset();
+     result = (GDALColorTableShadow *)new_GDALColorTableShadow(arg1);
+     CPLErr eclass = CPLGetLastErrorType();
+     if ( eclass == CE_Failure || eclass == CE_Fatal ) {
+       SWIG_exception( SWIG_RuntimeError, CPLGetLastErrorMsg() );
+       
+     }
+     
+     
+     
+     
+     
+     
+     
+     
+     
+     
+     
+   }
+   Tcl_SetObjResult(interp, SWIG_NewInstanceObj( SWIG_as_voidptr(result), SWIGTYPE_p_GDALColorTableShadow,0));
+   return TCL_OK;
+ fail:
+   return TCL_ERROR;
+ }
+ 
+ 
+ SWIGINTERN int
+ _wrap_delete_ColorTable(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
+   GDALColorTableShadow *arg1 = (GDALColorTableShadow *) 0 ;
+   void *argp1 = 0 ;
+   int res1 = 0 ;
+   
+   if (SWIG_GetArgs(interp, objc, objv,"o:osgeo::delete_ColorTable self ",(void *)0) == TCL_ERROR) SWIG_fail;
+   res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_GDALColorTableShadow, SWIG_POINTER_DISOWN |  0 );
+   if (!SWIG_IsOK(res1)) {
+     SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "delete_ColorTable" "', argument " "1"" of type '" "GDALColorTableShadow *""'"); 
+   }
+   arg1 = reinterpret_cast< GDALColorTableShadow * >(argp1);
+   {
+     CPLErrorReset();
+     delete_GDALColorTableShadow(arg1);
+     CPLErr eclass = CPLGetLastErrorType();
+     if ( eclass == CE_Failure || eclass == CE_Fatal ) {
+       SWIG_exception( SWIG_RuntimeError, CPLGetLastErrorMsg() );
+       
+     }
+     
+     
+     
+     
+     
+     
+     
+     
+     
+     
+     
+   }
+   
+   return TCL_OK;
+ fail:
+   return TCL_ERROR;
+ }
+ 
+ 
+ SWIGINTERN int
+ _wrap_ColorTable_Clone(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
+   GDALColorTableShadow *arg1 = (GDALColorTableShadow *) 0 ;
+   void *argp1 = 0 ;
+   int res1 = 0 ;
+   GDALColorTableShadow *result = 0 ;
+   
+   if (SWIG_GetArgs(interp, objc, objv,"o:osgeo::ColorTable_Clone self ",(void *)0) == TCL_ERROR) SWIG_fail;
+   res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_GDALColorTableShadow, 0 |  0 );
+   if (!SWIG_IsOK(res1)) {
+     SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "ColorTable_Clone" "', argument " "1"" of type '" "GDALColorTableShadow *""'"); 
+   }
+   arg1 = reinterpret_cast< GDALColorTableShadow * >(argp1);
+   {
+     CPLErrorReset();
+     result = (GDALColorTableShadow *)GDALColorTableShadow_Clone(arg1);
+     CPLErr eclass = CPLGetLastErrorType();
+     if ( eclass == CE_Failure || eclass == CE_Fatal ) {
+       SWIG_exception( SWIG_RuntimeError, CPLGetLastErrorMsg() );
+       
+     }
+     
+     
+     
+     
+     
+     
+     
+     
+     
+     
+     
+   }
+   Tcl_SetObjResult(interp, SWIG_NewInstanceObj( SWIG_as_voidptr(result), SWIGTYPE_p_GDALColorTableShadow,0));
+   return TCL_OK;
+ fail:
+   return TCL_ERROR;
+ }
+ 
+ 
+ SWIGINTERN int
+ _wrap_ColorTable_GetPaletteInterpretation(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
+   GDALColorTableShadow *arg1 = (GDALColorTableShadow *) 0 ;
+   void *argp1 = 0 ;
+   int res1 = 0 ;
+   GDALPaletteInterp result;
+   
+   if (SWIG_GetArgs(interp, objc, objv,"o:osgeo::ColorTable_GetPaletteInterpretation self ",(void *)0) == TCL_ERROR) SWIG_fail;
+   res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_GDALColorTableShadow, 0 |  0 );
+   if (!SWIG_IsOK(res1)) {
+     SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "ColorTable_GetPaletteInterpretation" "', argument " "1"" of type '" "GDALColorTableShadow *""'"); 
+   }
+   arg1 = reinterpret_cast< GDALColorTableShadow * >(argp1);
+   {
+     CPLErrorReset();
+     result = (GDALPaletteInterp)GDALColorTableShadow_GetPaletteInterpretation(arg1);
+     CPLErr eclass = CPLGetLastErrorType();
+     if ( eclass == CE_Failure || eclass == CE_Fatal ) {
+       SWIG_exception( SWIG_RuntimeError, CPLGetLastErrorMsg() );
+       
+     }
+     
+     
+     
+     
+     
+     
+     
+     
+     
+     
+     
+   }
+   Tcl_SetObjResult(interp,SWIG_From_int(static_cast< int >(result)));
+   return TCL_OK;
+ fail:
+   return TCL_ERROR;
+ }
+ 
+ 
+ SWIGINTERN int
+ _wrap_ColorTable_GetCount(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
+   GDALColorTableShadow *arg1 = (GDALColorTableShadow *) 0 ;
+   void *argp1 = 0 ;
+   int res1 = 0 ;
+   int result;
+   
+   if (SWIG_GetArgs(interp, objc, objv,"o:osgeo::ColorTable_GetCount self ",(void *)0) == TCL_ERROR) SWIG_fail;
+   res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_GDALColorTableShadow, 0 |  0 );
+   if (!SWIG_IsOK(res1)) {
+     SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "ColorTable_GetCount" "', argument " "1"" of type '" "GDALColorTableShadow *""'"); 
+   }
+   arg1 = reinterpret_cast< GDALColorTableShadow * >(argp1);
+   {
+     CPLErrorReset();
+     result = (int)GDALColorTableShadow_GetColorEntryCount(arg1);
+     CPLErr eclass = CPLGetLastErrorType();
+     if ( eclass == CE_Failure || eclass == CE_Fatal ) {
+       SWIG_exception( SWIG_RuntimeError, CPLGetLastErrorMsg() );
+       
+     }
+     
+     
+     
+     
+     
+     
+     
+     
+     
+     
+     
+   }
+   Tcl_SetObjResult(interp,SWIG_From_int(static_cast< int >(result)));
+   return TCL_OK;
+ fail:
+   return TCL_ERROR;
+ }
+ 
+ 
+ SWIGINTERN int
+ _wrap_ColorTable_GetColorEntry(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
+   GDALColorTableShadow *arg1 = (GDALColorTableShadow *) 0 ;
+   int arg2 ;
+   void *argp1 = 0 ;
+   int res1 = 0 ;
+   int val2 ;
+   int ecode2 = 0 ;
+   GDALColorEntry *result = 0 ;
+   
+   if (SWIG_GetArgs(interp, objc, objv,"oo:osgeo::ColorTable_GetColorEntry self entry ",(void *)0,(void *)0) == TCL_ERROR) SWIG_fail;
+   res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_GDALColorTableShadow, 0 |  0 );
+   if (!SWIG_IsOK(res1)) {
+     SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "ColorTable_GetColorEntry" "', argument " "1"" of type '" "GDALColorTableShadow *""'"); 
+   }
+   arg1 = reinterpret_cast< GDALColorTableShadow * >(argp1);
+   ecode2 = SWIG_AsVal_int SWIG_TCL_CALL_ARGS_2(objv[2], &val2);
+   if (!SWIG_IsOK(ecode2)) {
+     SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "ColorTable_GetColorEntry" "', argument " "2"" of type '" "int""'");
+   } 
+   arg2 = static_cast< int >(val2);
+   {
+     CPLErrorReset();
+     result = (GDALColorEntry *)GDALColorTableShadow_GetColorEntry(arg1,arg2);
+     CPLErr eclass = CPLGetLastErrorType();
+     if ( eclass == CE_Failure || eclass == CE_Fatal ) {
+       SWIG_exception( SWIG_RuntimeError, CPLGetLastErrorMsg() );
+       
+     }
+     
+     
+     
+     
+     
+     
+     
+     
+     
+     
+     
+   }
+   {
+     /* %typemap(out) GDALColorEntry* */
+     Tcl_Obj *out = Tcl_NewListObj(0, NULL);
+     Tcl_Obj *val;
+     val  = Tcl_NewIntObj((*result).c1);
+     if (Tcl_ListObjAppendElement(interp, out, val) != TCL_OK) {
+       Tcl_DecrRefCount(val);
+       Tcl_DecrRefCount(out);
+       SWIG_fail;
+     }
+     val = Tcl_NewIntObj((*result).c2);
+     if (Tcl_ListObjAppendElement(interp, out, val) != TCL_OK) {
+       Tcl_DecrRefCount(val);
+       Tcl_DecrRefCount(out);
+       SWIG_fail;
+     }
+     val = Tcl_NewIntObj((*result).c3);
+     if (Tcl_ListObjAppendElement(interp, out, val) != TCL_OK) {
+       Tcl_DecrRefCount(val);
+       Tcl_DecrRefCount(out);
+       SWIG_fail;
+     }
+     val = Tcl_NewIntObj((*result).c4);
+     if (Tcl_ListObjAppendElement(interp, out, val) != TCL_OK) {
+       Tcl_DecrRefCount(val);
+       Tcl_DecrRefCount(out);
+       SWIG_fail;
+     }
+     Tcl_SetObjResult(interp, out);
+     
+     /* More compact: (If used, the next typemap must be modified as well)
+            Tcl_SetObjResult(interp, Tcl_ObjPrintf("%x%x%x%x", (*result).c1, (*result).c2, (*result).c3, (*result).c4));
+          */
+   }
+   return TCL_OK;
+ fail:
+   return TCL_ERROR;
+ }
+ 
+ 
+ SWIGINTERN int
+ _wrap_ColorTable_GetColorEntryAsRGB(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
+   GDALColorTableShadow *arg1 = (GDALColorTableShadow *) 0 ;
+   int arg2 ;
+   GDALColorEntry *arg3 = (GDALColorEntry *) 0 ;
+   void *argp1 = 0 ;
+   int res1 = 0 ;
+   int val2 ;
+   int ecode2 = 0 ;
+   GDALColorEntry ce3 ;
+   int result;
+   
+   if (SWIG_GetArgs(interp, objc, objv,"ooo:osgeo::ColorTable_GetColorEntryAsRGB self entry centry ",(void *)0,(void *)0,(void *)0) == TCL_ERROR) SWIG_fail;
+   res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_GDALColorTableShadow, 0 |  0 );
+   if (!SWIG_IsOK(res1)) {
+     SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "ColorTable_GetColorEntryAsRGB" "', argument " "1"" of type '" "GDALColorTableShadow *""'"); 
+   }
+   arg1 = reinterpret_cast< GDALColorTableShadow * >(argp1);
+   ecode2 = SWIG_AsVal_int SWIG_TCL_CALL_ARGS_2(objv[2], &val2);
+   if (!SWIG_IsOK(ecode2)) {
+     SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "ColorTable_GetColorEntryAsRGB" "', argument " "2"" of type '" "int""'");
+   } 
+   arg2 = static_cast< int >(val2);
+   {
+     /* %typemap(in) GDALColorEntry* */
+     ce3.c1 = 0;
+     ce3.c2 = 0;
+     ce3.c3 = 0;
+     ce3.c4 = 255;
+     /* The following also checks if input is a list */
+     int size;
+     if (Tcl_ListObjLength(interp, objv[3], &size) != TCL_OK) {
+       /* Error msg in interp result */
+       SWIG_fail;
+     }
+     if ( size > 4 ) {
+       Tcl_SetResult(interp, (char*) "ColorEntry sequence too long", TCL_STATIC);
+       SWIG_fail;
+     }
+     if ( size < 3 ) {
+       Tcl_SetResult(interp, (char*) "ColorEntry sequence too short", TCL_STATIC);
+       SWIG_fail;
+     }
+     for( int i = 0; i<size; i++ ) {
+       Tcl_Obj **o = NULL;
+       int val;
+       /* The reference count for the list element is not incremented with the following */
+       if (Tcl_ListObjIndex(interp, objv[3], i, o) != TCL_OK) {
+         /* Error msg in interp result */
+         SWIG_fail;
+       }
+       
+       if (Tcl_GetIntFromObj(interp, *o, &val) != TCL_OK) {
+         /* Error msg in interp result */
+         SWIG_fail;
+       }
+       switch (i) {
+         case 1: ce3.c1 = (short) val; break;
+         case 2: ce3.c2 = (short) val; break;
+         case 3: ce3.c3 = (short) val; break;
+         case 4: ce3.c4 = (short) val; break;
+       }
+     }
+     arg3 = &ce3;
+   }
+   {
+     CPLErrorReset();
+     result = (int)GDALColorTableShadow_GetColorEntryAsRGB(arg1,arg2,arg3);
+     CPLErr eclass = CPLGetLastErrorType();
+     if ( eclass == CE_Failure || eclass == CE_Fatal ) {
+       SWIG_exception( SWIG_RuntimeError, CPLGetLastErrorMsg() );
+       
+     }
+     
+     
+     
+     
+     
+     
+     
+     
+     
+     
+     
+   }
+   Tcl_SetObjResult(interp,SWIG_From_int(static_cast< int >(result)));
+   return TCL_OK;
+ fail:
+   return TCL_ERROR;
+ }
+ 
+ 
+ SWIGINTERN int
+ _wrap_ColorTable_SetColorEntry(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
+   GDALColorTableShadow *arg1 = (GDALColorTableShadow *) 0 ;
+   int arg2 ;
+   GDALColorEntry *arg3 = (GDALColorEntry *) 0 ;
+   void *argp1 = 0 ;
+   int res1 = 0 ;
+   int val2 ;
+   int ecode2 = 0 ;
+   GDALColorEntry ce3 ;
+   
+   if (SWIG_GetArgs(interp, objc, objv,"ooo:osgeo::ColorTable_SetColorEntry self entry centry ",(void *)0,(void *)0,(void *)0) == TCL_ERROR) SWIG_fail;
+   res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_GDALColorTableShadow, 0 |  0 );
+   if (!SWIG_IsOK(res1)) {
+     SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "ColorTable_SetColorEntry" "', argument " "1"" of type '" "GDALColorTableShadow *""'"); 
+   }
+   arg1 = reinterpret_cast< GDALColorTableShadow * >(argp1);
+   ecode2 = SWIG_AsVal_int SWIG_TCL_CALL_ARGS_2(objv[2], &val2);
+   if (!SWIG_IsOK(ecode2)) {
+     SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "ColorTable_SetColorEntry" "', argument " "2"" of type '" "int""'");
+   } 
+   arg2 = static_cast< int >(val2);
+   {
+     /* %typemap(in) GDALColorEntry* */
+     ce3.c1 = 0;
+     ce3.c2 = 0;
+     ce3.c3 = 0;
+     ce3.c4 = 255;
+     /* The following also checks if input is a list */
+     int size;
+     if (Tcl_ListObjLength(interp, objv[3], &size) != TCL_OK) {
+       /* Error msg in interp result */
+       SWIG_fail;
+     }
+     if ( size > 4 ) {
+       Tcl_SetResult(interp, (char*) "ColorEntry sequence too long", TCL_STATIC);
+       SWIG_fail;
+     }
+     if ( size < 3 ) {
+       Tcl_SetResult(interp, (char*) "ColorEntry sequence too short", TCL_STATIC);
+       SWIG_fail;
+     }
+     for( int i = 0; i<size; i++ ) {
+       Tcl_Obj **o = NULL;
+       int val;
+       /* The reference count for the list element is not incremented with the following */
+       if (Tcl_ListObjIndex(interp, objv[3], i, o) != TCL_OK) {
+         /* Error msg in interp result */
+         SWIG_fail;
+       }
+       
+       if (Tcl_GetIntFromObj(interp, *o, &val) != TCL_OK) {
+         /* Error msg in interp result */
+         SWIG_fail;
+       }
+       switch (i) {
+         case 1: ce3.c1 = (short) val; break;
+         case 2: ce3.c2 = (short) val; break;
+         case 3: ce3.c3 = (short) val; break;
+         case 4: ce3.c4 = (short) val; break;
+       }
+     }
+     arg3 = &ce3;
+   }
+   {
+     CPLErrorReset();
+     GDALColorTableShadow_SetColorEntry(arg1,arg2,(GDALColorEntry const *)arg3);
+     CPLErr eclass = CPLGetLastErrorType();
+     if ( eclass == CE_Failure || eclass == CE_Fatal ) {
+       SWIG_exception( SWIG_RuntimeError, CPLGetLastErrorMsg() );
+       
+     }
+     
+     
+     
+     
+     
+     
+     
+     
+     
+     
+     
+   }
+   
+   return TCL_OK;
+ fail:
+   return TCL_ERROR;
+ }
+ 
+ 
+ SWIGINTERN int
+ _wrap_ColorTable_CreateColorRamp(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
+   GDALColorTableShadow *arg1 = (GDALColorTableShadow *) 0 ;
+   int arg2 ;
+   GDALColorEntry *arg3 = (GDALColorEntry *) 0 ;
+   int arg4 ;
+   GDALColorEntry *arg5 = (GDALColorEntry *) 0 ;
+   void *argp1 = 0 ;
+   int res1 = 0 ;
+   int val2 ;
+   int ecode2 = 0 ;
+   GDALColorEntry ce3 ;
+   int val4 ;
+   int ecode4 = 0 ;
+   GDALColorEntry ce5 ;
+   
+   if (SWIG_GetArgs(interp, objc, objv,"ooooo:osgeo::ColorTable_CreateColorRamp self nStartIndex startcolor nEndIndex endcolor ",(void *)0,(void *)0,(void *)0,(void *)0,(void *)0) == TCL_ERROR) SWIG_fail;
+   res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_GDALColorTableShadow, 0 |  0 );
+   if (!SWIG_IsOK(res1)) {
+     SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "ColorTable_CreateColorRamp" "', argument " "1"" of type '" "GDALColorTableShadow *""'"); 
+   }
+   arg1 = reinterpret_cast< GDALColorTableShadow * >(argp1);
+   ecode2 = SWIG_AsVal_int SWIG_TCL_CALL_ARGS_2(objv[2], &val2);
+   if (!SWIG_IsOK(ecode2)) {
+     SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "ColorTable_CreateColorRamp" "', argument " "2"" of type '" "int""'");
+   } 
+   arg2 = static_cast< int >(val2);
+   {
+     /* %typemap(in) GDALColorEntry* */
+     ce3.c1 = 0;
+     ce3.c2 = 0;
+     ce3.c3 = 0;
+     ce3.c4 = 255;
+     /* The following also checks if input is a list */
+     int size;
+     if (Tcl_ListObjLength(interp, objv[3], &size) != TCL_OK) {
+       /* Error msg in interp result */
+       SWIG_fail;
+     }
+     if ( size > 4 ) {
+       Tcl_SetResult(interp, (char*) "ColorEntry sequence too long", TCL_STATIC);
+       SWIG_fail;
+     }
+     if ( size < 3 ) {
+       Tcl_SetResult(interp, (char*) "ColorEntry sequence too short", TCL_STATIC);
+       SWIG_fail;
+     }
+     for( int i = 0; i<size; i++ ) {
+       Tcl_Obj **o = NULL;
+       int val;
+       /* The reference count for the list element is not incremented with the following */
+       if (Tcl_ListObjIndex(interp, objv[3], i, o) != TCL_OK) {
+         /* Error msg in interp result */
+         SWIG_fail;
+       }
+       
+       if (Tcl_GetIntFromObj(interp, *o, &val) != TCL_OK) {
+         /* Error msg in interp result */
+         SWIG_fail;
+       }
+       switch (i) {
+         case 1: ce3.c1 = (short) val; break;
+         case 2: ce3.c2 = (short) val; break;
+         case 3: ce3.c3 = (short) val; break;
+         case 4: ce3.c4 = (short) val; break;
+       }
+     }
+     arg3 = &ce3;
+   }
+   ecode4 = SWIG_AsVal_int SWIG_TCL_CALL_ARGS_2(objv[4], &val4);
+   if (!SWIG_IsOK(ecode4)) {
+     SWIG_exception_fail(SWIG_ArgError(ecode4), "in method '" "ColorTable_CreateColorRamp" "', argument " "4"" of type '" "int""'");
+   } 
+   arg4 = static_cast< int >(val4);
+   {
+     /* %typemap(in) GDALColorEntry* */
+     ce5.c1 = 0;
+     ce5.c2 = 0;
+     ce5.c3 = 0;
+     ce5.c4 = 255;
+     /* The following also checks if input is a list */
+     int size;
+     if (Tcl_ListObjLength(interp, objv[5], &size) != TCL_OK) {
+       /* Error msg in interp result */
+       SWIG_fail;
+     }
+     if ( size > 4 ) {
+       Tcl_SetResult(interp, (char*) "ColorEntry sequence too long", TCL_STATIC);
+       SWIG_fail;
+     }
+     if ( size < 3 ) {
+       Tcl_SetResult(interp, (char*) "ColorEntry sequence too short", TCL_STATIC);
+       SWIG_fail;
+     }
+     for( int i = 0; i<size; i++ ) {
+       Tcl_Obj **o = NULL;
+       int val;
+       /* The reference count for the list element is not incremented with the following */
+       if (Tcl_ListObjIndex(interp, objv[5], i, o) != TCL_OK) {
+         /* Error msg in interp result */
+         SWIG_fail;
+       }
+       
+       if (Tcl_GetIntFromObj(interp, *o, &val) != TCL_OK) {
+         /* Error msg in interp result */
+         SWIG_fail;
+       }
+       switch (i) {
+         case 1: ce5.c1 = (short) val; break;
+         case 2: ce5.c2 = (short) val; break;
+         case 3: ce5.c3 = (short) val; break;
+         case 4: ce5.c4 = (short) val; break;
+       }
+     }
+     arg5 = &ce5;
+   }
+   {
+     CPLErrorReset();
+     GDALColorTableShadow_CreateColorRamp(arg1,arg2,(GDALColorEntry const *)arg3,arg4,(GDALColorEntry const *)arg5);
+     CPLErr eclass = CPLGetLastErrorType();
+     if ( eclass == CE_Failure || eclass == CE_Fatal ) {
+       SWIG_exception( SWIG_RuntimeError, CPLGetLastErrorMsg() );
+       
+     }
+     
+     
+     
+     
+     
+     
+     
+     
+     
+     
+     
+   }
+   
+   return TCL_OK;
+ fail:
+   return TCL_ERROR;
+ }
+ 
+ 
+ SWIGINTERN void swig_delete_ColorTable(void *obj) {
+ GDALColorTableShadow *arg1 = (GDALColorTableShadow *) obj;
+ delete_GDALColorTableShadow(arg1);
+ }
+ static swig_method swig_GDALColorTableShadow_methods[] = {
+     {"Clone", _wrap_ColorTable_Clone}, 
+     {"GetPaletteInterpretation", _wrap_ColorTable_GetPaletteInterpretation}, 
+     {"GetCount", _wrap_ColorTable_GetCount}, 
+     {"GetColorEntry", _wrap_ColorTable_GetColorEntry}, 
+     {"GetColorEntryAsRGB", _wrap_ColorTable_GetColorEntryAsRGB}, 
+     {"SetColorEntry", _wrap_ColorTable_SetColorEntry}, 
+     {"CreateColorRamp", _wrap_ColorTable_CreateColorRamp}, 
+     {0,0}
+ };
+ static swig_attribute swig_GDALColorTableShadow_attributes[] = {
+     {0,0,0}
+ };
+ static swig_class *swig_GDALColorTableShadow_bases[] = {0};
+ static const char * swig_GDALColorTableShadow_base_names[] = {0};
+ static swig_class _wrap_class_GDALColorTableShadow = { "ColorTable", &SWIGTYPE_p_GDALColorTableShadow,_wrap_new_ColorTable, swig_delete_ColorTable, swig_GDALColorTableShadow_methods, swig_GDALColorTableShadow_attributes, swig_GDALColorTableShadow_bases,swig_GDALColorTableShadow_base_names, &swig_module };
+ SWIGINTERN int
+ _wrap_new_RasterAttributeTable(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
+   GDALRasterAttributeTableShadow *result = 0 ;
+   
+   if (SWIG_GetArgs(interp, objc, objv,":osgeo::new_RasterAttributeTable ") == TCL_ERROR) SWIG_fail;
+   {
+     CPLErrorReset();
+     result = (GDALRasterAttributeTableShadow *)new_GDALRasterAttributeTableShadow();
+     CPLErr eclass = CPLGetLastErrorType();
+     if ( eclass == CE_Failure || eclass == CE_Fatal ) {
+       SWIG_exception( SWIG_RuntimeError, CPLGetLastErrorMsg() );
+       
+     }
+     
+     
+     
+     
+     
+     
+     
+     
+     
+     
+     
+   }
+   Tcl_SetObjResult(interp, SWIG_NewInstanceObj( SWIG_as_voidptr(result), SWIGTYPE_p_GDALRasterAttributeTableShadow,0));
+   return TCL_OK;
+ fail:
+   return TCL_ERROR;
+ }
+ 
+ 
+ SWIGINTERN int
+ _wrap_delete_RasterAttributeTable(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
+   GDALRasterAttributeTableShadow *arg1 = (GDALRasterAttributeTableShadow *) 0 ;
+   void *argp1 = 0 ;
+   int res1 = 0 ;
+   
+   if (SWIG_GetArgs(interp, objc, objv,"o:osgeo::delete_RasterAttributeTable self ",(void *)0) == TCL_ERROR) SWIG_fail;
+   res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_GDALRasterAttributeTableShadow, SWIG_POINTER_DISOWN |  0 );
+   if (!SWIG_IsOK(res1)) {
+     SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "delete_RasterAttributeTable" "', argument " "1"" of type '" "GDALRasterAttributeTableShadow *""'"); 
+   }
+   arg1 = reinterpret_cast< GDALRasterAttributeTableShadow * >(argp1);
+   {
+     CPLErrorReset();
+     delete_GDALRasterAttributeTableShadow(arg1);
+     CPLErr eclass = CPLGetLastErrorType();
+     if ( eclass == CE_Failure || eclass == CE_Fatal ) {
+       SWIG_exception( SWIG_RuntimeError, CPLGetLastErrorMsg() );
+       
+     }
+     
+     
+     
+     
+     
+     
+     
+     
+     
+     
+     
+   }
+   
+   return TCL_OK;
+ fail:
+   return TCL_ERROR;
+ }
+ 
+ 
+ SWIGINTERN int
+ _wrap_RasterAttributeTable_Clone(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
+   GDALRasterAttributeTableShadow *arg1 = (GDALRasterAttributeTableShadow *) 0 ;
+   void *argp1 = 0 ;
+   int res1 = 0 ;
+   GDALRasterAttributeTableShadow *result = 0 ;
+   
+   if (SWIG_GetArgs(interp, objc, objv,"o:osgeo::RasterAttributeTable_Clone self ",(void *)0) == TCL_ERROR) SWIG_fail;
+   res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_GDALRasterAttributeTableShadow, 0 |  0 );
+   if (!SWIG_IsOK(res1)) {
+     SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "RasterAttributeTable_Clone" "', argument " "1"" of type '" "GDALRasterAttributeTableShadow *""'"); 
+   }
+   arg1 = reinterpret_cast< GDALRasterAttributeTableShadow * >(argp1);
+   {
+     CPLErrorReset();
+     result = (GDALRasterAttributeTableShadow *)GDALRasterAttributeTableShadow_Clone(arg1);
+     CPLErr eclass = CPLGetLastErrorType();
+     if ( eclass == CE_Failure || eclass == CE_Fatal ) {
+       SWIG_exception( SWIG_RuntimeError, CPLGetLastErrorMsg() );
+       
+     }
+     
+     
+     
+     
+     
+     
+     
+     
+     
+     
+     
+   }
+   Tcl_SetObjResult(interp, SWIG_NewInstanceObj( SWIG_as_voidptr(result), SWIGTYPE_p_GDALRasterAttributeTableShadow,0));
+   return TCL_OK;
+ fail:
+   return TCL_ERROR;
+ }
+ 
+ 
+ SWIGINTERN int
+ _wrap_RasterAttributeTable_GetColumnCount(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
+   GDALRasterAttributeTableShadow *arg1 = (GDALRasterAttributeTableShadow *) 0 ;
+   void *argp1 = 0 ;
+   int res1 = 0 ;
+   int result;
+   
+   if (SWIG_GetArgs(interp, objc, objv,"o:osgeo::RasterAttributeTable_GetColumnCount self ",(void *)0) == TCL_ERROR) SWIG_fail;
+   res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_GDALRasterAttributeTableShadow, 0 |  0 );
+   if (!SWIG_IsOK(res1)) {
+     SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "RasterAttributeTable_GetColumnCount" "', argument " "1"" of type '" "GDALRasterAttributeTableShadow *""'"); 
+   }
+   arg1 = reinterpret_cast< GDALRasterAttributeTableShadow * >(argp1);
+   {
+     CPLErrorReset();
+     result = (int)GDALRasterAttributeTableShadow_GetColumnCount(arg1);
+     CPLErr eclass = CPLGetLastErrorType();
+     if ( eclass == CE_Failure || eclass == CE_Fatal ) {
+       SWIG_exception( SWIG_RuntimeError, CPLGetLastErrorMsg() );
+       
+     }
+     
+     
+     
+     
+     
+     
+     
+     
+     
+     
+     
+   }
+   Tcl_SetObjResult(interp,SWIG_From_int(static_cast< int >(result)));
+   return TCL_OK;
+ fail:
+   return TCL_ERROR;
+ }
+ 
+ 
+ SWIGINTERN int
+ _wrap_RasterAttributeTable_GetNameOfCol(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
+   GDALRasterAttributeTableShadow *arg1 = (GDALRasterAttributeTableShadow *) 0 ;
+   int arg2 ;
+   void *argp1 = 0 ;
+   int res1 = 0 ;
+   int val2 ;
+   int ecode2 = 0 ;
+   char *result = 0 ;
+   
+   if (SWIG_GetArgs(interp, objc, objv,"oo:osgeo::RasterAttributeTable_GetNameOfCol self iCol ",(void *)0,(void *)0) == TCL_ERROR) SWIG_fail;
+   res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_GDALRasterAttributeTableShadow, 0 |  0 );
+   if (!SWIG_IsOK(res1)) {
+     SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "RasterAttributeTable_GetNameOfCol" "', argument " "1"" of type '" "GDALRasterAttributeTableShadow *""'"); 
+   }
+   arg1 = reinterpret_cast< GDALRasterAttributeTableShadow * >(argp1);
+   ecode2 = SWIG_AsVal_int SWIG_TCL_CALL_ARGS_2(objv[2], &val2);
+   if (!SWIG_IsOK(ecode2)) {
+     SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "RasterAttributeTable_GetNameOfCol" "', argument " "2"" of type '" "int""'");
+   } 
+   arg2 = static_cast< int >(val2);
+   {
+     CPLErrorReset();
+     result = (char *)GDALRasterAttributeTableShadow_GetNameOfCol(arg1,arg2);
+     CPLErr eclass = CPLGetLastErrorType();
+     if ( eclass == CE_Failure || eclass == CE_Fatal ) {
+       SWIG_exception( SWIG_RuntimeError, CPLGetLastErrorMsg() );
+       
+     }
+     
+     
+     
+     
+     
+     
+     
+     
+     
+     
+     
+   }
+   Tcl_SetObjResult(interp,SWIG_FromCharPtr((const char *)result));
+   return TCL_OK;
+ fail:
+   return TCL_ERROR;
+ }
+ 
+ 
+ SWIGINTERN int
+ _wrap_RasterAttributeTable_GetUsageOfCol(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
+   GDALRasterAttributeTableShadow *arg1 = (GDALRasterAttributeTableShadow *) 0 ;
+   int arg2 ;
+   void *argp1 = 0 ;
+   int res1 = 0 ;
+   int val2 ;
+   int ecode2 = 0 ;
+   GDALRATFieldUsage result;
+   
+   if (SWIG_GetArgs(interp, objc, objv,"oo:osgeo::RasterAttributeTable_GetUsageOfCol self iCol ",(void *)0,(void *)0) == TCL_ERROR) SWIG_fail;
+   res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_GDALRasterAttributeTableShadow, 0 |  0 );
+   if (!SWIG_IsOK(res1)) {
+     SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "RasterAttributeTable_GetUsageOfCol" "', argument " "1"" of type '" "GDALRasterAttributeTableShadow *""'"); 
+   }
+   arg1 = reinterpret_cast< GDALRasterAttributeTableShadow * >(argp1);
+   ecode2 = SWIG_AsVal_int SWIG_TCL_CALL_ARGS_2(objv[2], &val2);
+   if (!SWIG_IsOK(ecode2)) {
+     SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "RasterAttributeTable_GetUsageOfCol" "', argument " "2"" of type '" "int""'");
+   } 
+   arg2 = static_cast< int >(val2);
+   {
+     CPLErrorReset();
+     result = (GDALRATFieldUsage)GDALRasterAttributeTableShadow_GetUsageOfCol(arg1,arg2);
+     CPLErr eclass = CPLGetLastErrorType();
+     if ( eclass == CE_Failure || eclass == CE_Fatal ) {
+       SWIG_exception( SWIG_RuntimeError, CPLGetLastErrorMsg() );
+       
+     }
+     
+     
+     
+     
+     
+     
+     
+     
+     
+     
+     
+   }
+   Tcl_SetObjResult(interp,SWIG_From_int(static_cast< int >(result)));
+   return TCL_OK;
+ fail:
+   return TCL_ERROR;
+ }
+ 
+ 
+ SWIGINTERN int
+ _wrap_RasterAttributeTable_GetTypeOfCol(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
+   GDALRasterAttributeTableShadow *arg1 = (GDALRasterAttributeTableShadow *) 0 ;
+   int arg2 ;
+   void *argp1 = 0 ;
+   int res1 = 0 ;
+   int val2 ;
+   int ecode2 = 0 ;
+   GDALRATFieldType result;
+   
+   if (SWIG_GetArgs(interp, objc, objv,"oo:osgeo::RasterAttributeTable_GetTypeOfCol self iCol ",(void *)0,(void *)0) == TCL_ERROR) SWIG_fail;
+   res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_GDALRasterAttributeTableShadow, 0 |  0 );
+   if (!SWIG_IsOK(res1)) {
+     SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "RasterAttributeTable_GetTypeOfCol" "', argument " "1"" of type '" "GDALRasterAttributeTableShadow *""'"); 
+   }
+   arg1 = reinterpret_cast< GDALRasterAttributeTableShadow * >(argp1);
+   ecode2 = SWIG_AsVal_int SWIG_TCL_CALL_ARGS_2(objv[2], &val2);
+   if (!SWIG_IsOK(ecode2)) {
+     SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "RasterAttributeTable_GetTypeOfCol" "', argument " "2"" of type '" "int""'");
+   } 
+   arg2 = static_cast< int >(val2);
+   {
+     CPLErrorReset();
+     result = (GDALRATFieldType)GDALRasterAttributeTableShadow_GetTypeOfCol(arg1,arg2);
+     CPLErr eclass = CPLGetLastErrorType();
+     if ( eclass == CE_Failure || eclass == CE_Fatal ) {
+       SWIG_exception( SWIG_RuntimeError, CPLGetLastErrorMsg() );
+       
+     }
+     
+     
+     
+     
+     
+     
+     
+     
+     
+     
+     
+   }
+   Tcl_SetObjResult(interp,SWIG_From_int(static_cast< int >(result)));
+   return TCL_OK;
+ fail:
+   return TCL_ERROR;
+ }
+ 
+ 
+ SWIGINTERN int
+ _wrap_RasterAttributeTable_GetColOfUsage(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
+   GDALRasterAttributeTableShadow *arg1 = (GDALRasterAttributeTableShadow *) 0 ;
+   GDALRATFieldUsage arg2 ;
+   void *argp1 = 0 ;
+   int res1 = 0 ;
+   int val2 ;
+   int ecode2 = 0 ;
+   int result;
+   
+   if (SWIG_GetArgs(interp, objc, objv,"oo:osgeo::RasterAttributeTable_GetColOfUsage self eUsage ",(void *)0,(void *)0) == TCL_ERROR) SWIG_fail;
+   res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_GDALRasterAttributeTableShadow, 0 |  0 );
+   if (!SWIG_IsOK(res1)) {
+     SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "RasterAttributeTable_GetColOfUsage" "', argument " "1"" of type '" "GDALRasterAttributeTableShadow *""'"); 
+   }
+   arg1 = reinterpret_cast< GDALRasterAttributeTableShadow * >(argp1);
+   ecode2 = SWIG_AsVal_int SWIG_TCL_CALL_ARGS_2(objv[2], &val2);
+   if (!SWIG_IsOK(ecode2)) {
+     SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "RasterAttributeTable_GetColOfUsage" "', argument " "2"" of type '" "GDALRATFieldUsage""'");
+   } 
+   arg2 = static_cast< GDALRATFieldUsage >(val2);
+   {
+     CPLErrorReset();
+     result = (int)GDALRasterAttributeTableShadow_GetColOfUsage(arg1,arg2);
+     CPLErr eclass = CPLGetLastErrorType();
+     if ( eclass == CE_Failure || eclass == CE_Fatal ) {
+       SWIG_exception( SWIG_RuntimeError, CPLGetLastErrorMsg() );
+       
+     }
+     
+     
+     
+     
+     
+     
+     
+     
+     
+     
+     
+   }
+   Tcl_SetObjResult(interp,SWIG_From_int(static_cast< int >(result)));
+   return TCL_OK;
+ fail:
+   return TCL_ERROR;
+ }
+ 
+ 
+ SWIGINTERN int
+ _wrap_RasterAttributeTable_GetRowCount(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
+   GDALRasterAttributeTableShadow *arg1 = (GDALRasterAttributeTableShadow *) 0 ;
+   void *argp1 = 0 ;
+   int res1 = 0 ;
+   int result;
+   
+   if (SWIG_GetArgs(interp, objc, objv,"o:osgeo::RasterAttributeTable_GetRowCount self ",(void *)0) == TCL_ERROR) SWIG_fail;
+   res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_GDALRasterAttributeTableShadow, 0 |  0 );
+   if (!SWIG_IsOK(res1)) {
+     SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "RasterAttributeTable_GetRowCount" "', argument " "1"" of type '" "GDALRasterAttributeTableShadow *""'"); 
+   }
+   arg1 = reinterpret_cast< GDALRasterAttributeTableShadow * >(argp1);
+   {
+     CPLErrorReset();
+     result = (int)GDALRasterAttributeTableShadow_GetRowCount(arg1);
+     CPLErr eclass = CPLGetLastErrorType();
+     if ( eclass == CE_Failure || eclass == CE_Fatal ) {
+       SWIG_exception( SWIG_RuntimeError, CPLGetLastErrorMsg() );
+       
+     }
+     
+     
+     
+     
+     
+     
+     
+     
+     
+     
+     
+   }
+   Tcl_SetObjResult(interp,SWIG_From_int(static_cast< int >(result)));
+   return TCL_OK;
+ fail:
+   return TCL_ERROR;
+ }
+ 
+ 
+ SWIGINTERN int
+ _wrap_RasterAttributeTable_GetValueAsString(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
+   GDALRasterAttributeTableShadow *arg1 = (GDALRasterAttributeTableShadow *) 0 ;
+   int arg2 ;
+   int arg3 ;
+   void *argp1 = 0 ;
+   int res1 = 0 ;
+   int val2 ;
+   int ecode2 = 0 ;
+   int val3 ;
+   int ecode3 = 0 ;
+   char *result = 0 ;
+   
+   if (SWIG_GetArgs(interp, objc, objv,"ooo:osgeo::RasterAttributeTable_GetValueAsString self iRow iCol ",(void *)0,(void *)0,(void *)0) == TCL_ERROR) SWIG_fail;
+   res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_GDALRasterAttributeTableShadow, 0 |  0 );
+   if (!SWIG_IsOK(res1)) {
+     SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "RasterAttributeTable_GetValueAsString" "', argument " "1"" of type '" "GDALRasterAttributeTableShadow *""'"); 
+   }
+   arg1 = reinterpret_cast< GDALRasterAttributeTableShadow * >(argp1);
+   ecode2 = SWIG_AsVal_int SWIG_TCL_CALL_ARGS_2(objv[2], &val2);
+   if (!SWIG_IsOK(ecode2)) {
+     SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "RasterAttributeTable_GetValueAsString" "', argument " "2"" of type '" "int""'");
+   } 
+   arg2 = static_cast< int >(val2);
+   ecode3 = SWIG_AsVal_int SWIG_TCL_CALL_ARGS_2(objv[3], &val3);
+   if (!SWIG_IsOK(ecode3)) {
+     SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "RasterAttributeTable_GetValueAsString" "', argument " "3"" of type '" "int""'");
+   } 
+   arg3 = static_cast< int >(val3);
+   {
+     CPLErrorReset();
+     result = (char *)GDALRasterAttributeTableShadow_GetValueAsString(arg1,arg2,arg3);
+     CPLErr eclass = CPLGetLastErrorType();
+     if ( eclass == CE_Failure || eclass == CE_Fatal ) {
+       SWIG_exception( SWIG_RuntimeError, CPLGetLastErrorMsg() );
+       
+     }
+     
+     
+     
+     
+     
+     
+     
+     
+     
+     
+     
+   }
+   Tcl_SetObjResult(interp,SWIG_FromCharPtr((const char *)result));
+   return TCL_OK;
+ fail:
+   return TCL_ERROR;
+ }
+ 
+ 
+ SWIGINTERN int
+ _wrap_RasterAttributeTable_GetValueAsInt(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
+   GDALRasterAttributeTableShadow *arg1 = (GDALRasterAttributeTableShadow *) 0 ;
+   int arg2 ;
+   int arg3 ;
+   void *argp1 = 0 ;
+   int res1 = 0 ;
+   int val2 ;
+   int ecode2 = 0 ;
+   int val3 ;
+   int ecode3 = 0 ;
+   int result;
+   
+   if (SWIG_GetArgs(interp, objc, objv,"ooo:osgeo::RasterAttributeTable_GetValueAsInt self iRow iCol ",(void *)0,(void *)0,(void *)0) == TCL_ERROR) SWIG_fail;
+   res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_GDALRasterAttributeTableShadow, 0 |  0 );
+   if (!SWIG_IsOK(res1)) {
+     SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "RasterAttributeTable_GetValueAsInt" "', argument " "1"" of type '" "GDALRasterAttributeTableShadow *""'"); 
+   }
+   arg1 = reinterpret_cast< GDALRasterAttributeTableShadow * >(argp1);
+   ecode2 = SWIG_AsVal_int SWIG_TCL_CALL_ARGS_2(objv[2], &val2);
+   if (!SWIG_IsOK(ecode2)) {
+     SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "RasterAttributeTable_GetValueAsInt" "', argument " "2"" of type '" "int""'");
+   } 
+   arg2 = static_cast< int >(val2);
+   ecode3 = SWIG_AsVal_int SWIG_TCL_CALL_ARGS_2(objv[3], &val3);
+   if (!SWIG_IsOK(ecode3)) {
+     SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "RasterAttributeTable_GetValueAsInt" "', argument " "3"" of type '" "int""'");
+   } 
+   arg3 = static_cast< int >(val3);
+   {
+     CPLErrorReset();
+     result = (int)GDALRasterAttributeTableShadow_GetValueAsInt(arg1,arg2,arg3);
+     CPLErr eclass = CPLGetLastErrorType();
+     if ( eclass == CE_Failure || eclass == CE_Fatal ) {
+       SWIG_exception( SWIG_RuntimeError, CPLGetLastErrorMsg() );
+       
+     }
+     
+     
+     
+     
+     
+     
+     
+     
+     
+     
+     
+   }
+   Tcl_SetObjResult(interp,SWIG_From_int(static_cast< int >(result)));
+   return TCL_OK;
+ fail:
+   return TCL_ERROR;
+ }
+ 
+ 
+ SWIGINTERN int
+ _wrap_RasterAttributeTable_GetValueAsDouble(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
+   GDALRasterAttributeTableShadow *arg1 = (GDALRasterAttributeTableShadow *) 0 ;
+   int arg2 ;
+   int arg3 ;
+   void *argp1 = 0 ;
+   int res1 = 0 ;
+   int val2 ;
+   int ecode2 = 0 ;
+   int val3 ;
+   int ecode3 = 0 ;
+   double result;
+   
+   if (SWIG_GetArgs(interp, objc, objv,"ooo:osgeo::RasterAttributeTable_GetValueAsDouble self iRow iCol ",(void *)0,(void *)0,(void *)0) == TCL_ERROR) SWIG_fail;
+   res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_GDALRasterAttributeTableShadow, 0 |  0 );
+   if (!SWIG_IsOK(res1)) {
+     SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "RasterAttributeTable_GetValueAsDouble" "', argument " "1"" of type '" "GDALRasterAttributeTableShadow *""'"); 
+   }
+   arg1 = reinterpret_cast< GDALRasterAttributeTableShadow * >(argp1);
+   ecode2 = SWIG_AsVal_int SWIG_TCL_CALL_ARGS_2(objv[2], &val2);
+   if (!SWIG_IsOK(ecode2)) {
+     SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "RasterAttributeTable_GetValueAsDouble" "', argument " "2"" of type '" "int""'");
+   } 
+   arg2 = static_cast< int >(val2);
+   ecode3 = SWIG_AsVal_int SWIG_TCL_CALL_ARGS_2(objv[3], &val3);
+   if (!SWIG_IsOK(ecode3)) {
+     SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "RasterAttributeTable_GetValueAsDouble" "', argument " "3"" of type '" "int""'");
+   } 
+   arg3 = static_cast< int >(val3);
+   {
+     CPLErrorReset();
+     result = (double)GDALRasterAttributeTableShadow_GetValueAsDouble(arg1,arg2,arg3);
+     CPLErr eclass = CPLGetLastErrorType();
+     if ( eclass == CE_Failure || eclass == CE_Fatal ) {
+       SWIG_exception( SWIG_RuntimeError, CPLGetLastErrorMsg() );
+       
+     }
+     
+     
+     
+     
+     
+     
+     
+     
+     
+     
+     
+   }
+   Tcl_SetObjResult(interp,SWIG_From_double(static_cast< double >(result)));
+   return TCL_OK;
+ fail:
+   return TCL_ERROR;
+ }
+ 
+ 
+ SWIGINTERN int
+ _wrap_RasterAttributeTable_SetValueAsString(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
+   GDALRasterAttributeTableShadow *arg1 = (GDALRasterAttributeTableShadow *) 0 ;
+   int arg2 ;
+   int arg3 ;
+   char *arg4 = (char *) 0 ;
+   void *argp1 = 0 ;
+   int res1 = 0 ;
+   int val2 ;
+   int ecode2 = 0 ;
+   int val3 ;
+   int ecode3 = 0 ;
+   
+   if (SWIG_GetArgs(interp, objc, objv,"oooo:osgeo::RasterAttributeTable_SetValueAsString self iRow iCol pszValue ",(void *)0,(void *)0,(void *)0,(void *)0) == TCL_ERROR) SWIG_fail;
+   res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_GDALRasterAttributeTableShadow, 0 |  0 );
+   if (!SWIG_IsOK(res1)) {
+     SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "RasterAttributeTable_SetValueAsString" "', argument " "1"" of type '" "GDALRasterAttributeTableShadow *""'"); 
+   }
+   arg1 = reinterpret_cast< GDALRasterAttributeTableShadow * >(argp1);
+   ecode2 = SWIG_AsVal_int SWIG_TCL_CALL_ARGS_2(objv[2], &val2);
+   if (!SWIG_IsOK(ecode2)) {
+     SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "RasterAttributeTable_SetValueAsString" "', argument " "2"" of type '" "int""'");
+   } 
+   arg2 = static_cast< int >(val2);
+   ecode3 = SWIG_AsVal_int SWIG_TCL_CALL_ARGS_2(objv[3], &val3);
+   if (!SWIG_IsOK(ecode3)) {
+     SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "RasterAttributeTable_SetValueAsString" "', argument " "3"" of type '" "int""'");
+   } 
+   arg3 = static_cast< int >(val3);
+   {
+     /* %typemap(in) (tostring argin) */
+     arg4 = Tcl_GetString( objv[4] ); 
+   }
+   {
+     CPLErrorReset();
+     GDALRasterAttributeTableShadow_SetValueAsString(arg1,arg2,arg3,(char const *)arg4);
+     CPLErr eclass = CPLGetLastErrorType();
+     if ( eclass == CE_Failure || eclass == CE_Fatal ) {
+       SWIG_exception( SWIG_RuntimeError, CPLGetLastErrorMsg() );
+       
+     }
+     
+     
+     
+     
+     
+     
+     
+     
+     
+     
+     
+   }
+   
+   return TCL_OK;
+ fail:
+   return TCL_ERROR;
+ }
+ 
+ 
+ SWIGINTERN int
+ _wrap_RasterAttributeTable_SetValueAsInt(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
+   GDALRasterAttributeTableShadow *arg1 = (GDALRasterAttributeTableShadow *) 0 ;
+   int arg2 ;
+   int arg3 ;
+   int arg4 ;
+   void *argp1 = 0 ;
+   int res1 = 0 ;
+   int val2 ;
+   int ecode2 = 0 ;
+   int val3 ;
+   int ecode3 = 0 ;
+   int val4 ;
+   int ecode4 = 0 ;
+   
+   if (SWIG_GetArgs(interp, objc, objv,"oooo:osgeo::RasterAttributeTable_SetValueAsInt self iRow iCol nValue ",(void *)0,(void *)0,(void *)0,(void *)0) == TCL_ERROR) SWIG_fail;
+   res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_GDALRasterAttributeTableShadow, 0 |  0 );
+   if (!SWIG_IsOK(res1)) {
+     SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "RasterAttributeTable_SetValueAsInt" "', argument " "1"" of type '" "GDALRasterAttributeTableShadow *""'"); 
+   }
+   arg1 = reinterpret_cast< GDALRasterAttributeTableShadow * >(argp1);
+   ecode2 = SWIG_AsVal_int SWIG_TCL_CALL_ARGS_2(objv[2], &val2);
+   if (!SWIG_IsOK(ecode2)) {
+     SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "RasterAttributeTable_SetValueAsInt" "', argument " "2"" of type '" "int""'");
+   } 
+   arg2 = static_cast< int >(val2);
+   ecode3 = SWIG_AsVal_int SWIG_TCL_CALL_ARGS_2(objv[3], &val3);
+   if (!SWIG_IsOK(ecode3)) {
+     SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "RasterAttributeTable_SetValueAsInt" "', argument " "3"" of type '" "int""'");
+   } 
+   arg3 = static_cast< int >(val3);
+   ecode4 = SWIG_AsVal_int SWIG_TCL_CALL_ARGS_2(objv[4], &val4);
+   if (!SWIG_IsOK(ecode4)) {
+     SWIG_exception_fail(SWIG_ArgError(ecode4), "in method '" "RasterAttributeTable_SetValueAsInt" "', argument " "4"" of type '" "int""'");
+   } 
+   arg4 = static_cast< int >(val4);
+   {
+     CPLErrorReset();
+     GDALRasterAttributeTableShadow_SetValueAsInt(arg1,arg2,arg3,arg4);
+     CPLErr eclass = CPLGetLastErrorType();
+     if ( eclass == CE_Failure || eclass == CE_Fatal ) {
+       SWIG_exception( SWIG_RuntimeError, CPLGetLastErrorMsg() );
+       
+     }
+     
+     
+     
+     
+     
+     
+     
+     
+     
+     
+     
+   }
+   
+   return TCL_OK;
+ fail:
+   return TCL_ERROR;
+ }
+ 
+ 
+ SWIGINTERN int
+ _wrap_RasterAttributeTable_SetValueAsDouble(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
+   GDALRasterAttributeTableShadow *arg1 = (GDALRasterAttributeTableShadow *) 0 ;
+   int arg2 ;
+   int arg3 ;
+   double arg4 ;
+   void *argp1 = 0 ;
+   int res1 = 0 ;
+   int val2 ;
+   int ecode2 = 0 ;
+   int val3 ;
+   int ecode3 = 0 ;
+   double val4 ;
+   int ecode4 = 0 ;
+   
+   if (SWIG_GetArgs(interp, objc, objv,"oooo:osgeo::RasterAttributeTable_SetValueAsDouble self iRow iCol dfValue ",(void *)0,(void *)0,(void *)0,(void *)0) == TCL_ERROR) SWIG_fail;
+   res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_GDALRasterAttributeTableShadow, 0 |  0 );
+   if (!SWIG_IsOK(res1)) {
+     SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "RasterAttributeTable_SetValueAsDouble" "', argument " "1"" of type '" "GDALRasterAttributeTableShadow *""'"); 
+   }
+   arg1 = reinterpret_cast< GDALRasterAttributeTableShadow * >(argp1);
+   ecode2 = SWIG_AsVal_int SWIG_TCL_CALL_ARGS_2(objv[2], &val2);
+   if (!SWIG_IsOK(ecode2)) {
+     SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "RasterAttributeTable_SetValueAsDouble" "', argument " "2"" of type '" "int""'");
+   } 
+   arg2 = static_cast< int >(val2);
+   ecode3 = SWIG_AsVal_int SWIG_TCL_CALL_ARGS_2(objv[3], &val3);
+   if (!SWIG_IsOK(ecode3)) {
+     SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "RasterAttributeTable_SetValueAsDouble" "', argument " "3"" of type '" "int""'");
+   } 
+   arg3 = static_cast< int >(val3);
+   ecode4 = SWIG_AsVal_double SWIG_TCL_CALL_ARGS_2(objv[4], &val4);
+   if (!SWIG_IsOK(ecode4)) {
+     SWIG_exception_fail(SWIG_ArgError(ecode4), "in method '" "RasterAttributeTable_SetValueAsDouble" "', argument " "4"" of type '" "double""'");
+   } 
+   arg4 = static_cast< double >(val4);
+   {
+     CPLErrorReset();
+     GDALRasterAttributeTableShadow_SetValueAsDouble(arg1,arg2,arg3,arg4);
+     CPLErr eclass = CPLGetLastErrorType();
+     if ( eclass == CE_Failure || eclass == CE_Fatal ) {
+       SWIG_exception( SWIG_RuntimeError, CPLGetLastErrorMsg() );
+       
+     }
+     
+     
+     
+     
+     
+     
+     
+     
+     
+     
+     
+   }
+   
+   return TCL_OK;
+ fail:
+   return TCL_ERROR;
+ }
+ 
+ 
+ SWIGINTERN int
+ _wrap_RasterAttributeTable_SetRowCount(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
+   GDALRasterAttributeTableShadow *arg1 = (GDALRasterAttributeTableShadow *) 0 ;
+   int arg2 ;
+   void *argp1 = 0 ;
+   int res1 = 0 ;
+   int val2 ;
+   int ecode2 = 0 ;
+   
+   if (SWIG_GetArgs(interp, objc, objv,"oo:osgeo::RasterAttributeTable_SetRowCount self nCount ",(void *)0,(void *)0) == TCL_ERROR) SWIG_fail;
+   res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_GDALRasterAttributeTableShadow, 0 |  0 );
+   if (!SWIG_IsOK(res1)) {
+     SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "RasterAttributeTable_SetRowCount" "', argument " "1"" of type '" "GDALRasterAttributeTableShadow *""'"); 
+   }
+   arg1 = reinterpret_cast< GDALRasterAttributeTableShadow * >(argp1);
+   ecode2 = SWIG_AsVal_int SWIG_TCL_CALL_ARGS_2(objv[2], &val2);
+   if (!SWIG_IsOK(ecode2)) {
+     SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "RasterAttributeTable_SetRowCount" "', argument " "2"" of type '" "int""'");
+   } 
+   arg2 = static_cast< int >(val2);
+   {
+     CPLErrorReset();
+     GDALRasterAttributeTableShadow_SetRowCount(arg1,arg2);
+     CPLErr eclass = CPLGetLastErrorType();
+     if ( eclass == CE_Failure || eclass == CE_Fatal ) {
+       SWIG_exception( SWIG_RuntimeError, CPLGetLastErrorMsg() );
+       
+     }
+     
+     
+     
+     
+     
+     
+     
+     
+     
+     
+     
+   }
+   
+   return TCL_OK;
+ fail:
+   return TCL_ERROR;
+ }
+ 
+ 
+ SWIGINTERN int
+ _wrap_RasterAttributeTable_CreateColumn(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
+   GDALRasterAttributeTableShadow *arg1 = (GDALRasterAttributeTableShadow *) 0 ;
+   char *arg2 = (char *) 0 ;
+   GDALRATFieldType arg3 ;
+   GDALRATFieldUsage arg4 ;
+   void *argp1 = 0 ;
+   int res1 = 0 ;
+   int res2 ;
+   char *buf2 = 0 ;
+   int alloc2 = 0 ;
+   int val3 ;
+   int ecode3 = 0 ;
+   int val4 ;
+   int ecode4 = 0 ;
+   int result;
+   
+   if (SWIG_GetArgs(interp, objc, objv,"oooo:osgeo::RasterAttributeTable_CreateColumn self pszName eType eUsage ",(void *)0,(void *)0,(void *)0,(void *)0) == TCL_ERROR) SWIG_fail;
+   res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_GDALRasterAttributeTableShadow, 0 |  0 );
+   if (!SWIG_IsOK(res1)) {
+     SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "RasterAttributeTable_CreateColumn" "', argument " "1"" of type '" "GDALRasterAttributeTableShadow *""'"); 
+   }
+   arg1 = reinterpret_cast< GDALRasterAttributeTableShadow * >(argp1);
+   res2 = SWIG_AsCharPtrAndSize(objv[2], &buf2, NULL, &alloc2);
+   if (!SWIG_IsOK(res2)) {
+     SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "RasterAttributeTable_CreateColumn" "', argument " "2"" of type '" "char const *""'");
+   }
+   arg2 = reinterpret_cast< char * >(buf2);
+   ecode3 = SWIG_AsVal_int SWIG_TCL_CALL_ARGS_2(objv[3], &val3);
+   if (!SWIG_IsOK(ecode3)) {
+     SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "RasterAttributeTable_CreateColumn" "', argument " "3"" of type '" "GDALRATFieldType""'");
+   } 
+   arg3 = static_cast< GDALRATFieldType >(val3);
+   ecode4 = SWIG_AsVal_int SWIG_TCL_CALL_ARGS_2(objv[4], &val4);
+   if (!SWIG_IsOK(ecode4)) {
+     SWIG_exception_fail(SWIG_ArgError(ecode4), "in method '" "RasterAttributeTable_CreateColumn" "', argument " "4"" of type '" "GDALRATFieldUsage""'");
+   } 
+   arg4 = static_cast< GDALRATFieldUsage >(val4);
+   {
+     CPLErrorReset();
+     result = (int)GDALRasterAttributeTableShadow_CreateColumn(arg1,(char const *)arg2,arg3,arg4);
+     CPLErr eclass = CPLGetLastErrorType();
+     if ( eclass == CE_Failure || eclass == CE_Fatal ) {
+       SWIG_exception( SWIG_RuntimeError, CPLGetLastErrorMsg() );
+       
+     }
+     
+     
+     
+     
+     
+     
+     
+     
+     
+     
+     
+   }
+   Tcl_SetObjResult(interp,SWIG_From_int(static_cast< int >(result)));
+   if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
+   return TCL_OK;
+ fail:
+   if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
+   return TCL_ERROR;
+ }
+ 
+ 
+ SWIGINTERN int
+ _wrap_RasterAttributeTable_GetRowOfValue(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
+   GDALRasterAttributeTableShadow *arg1 = (GDALRasterAttributeTableShadow *) 0 ;
+   double arg2 ;
+   void *argp1 = 0 ;
+   int res1 = 0 ;
+   double val2 ;
+   int ecode2 = 0 ;
+   int result;
+   
+   if (SWIG_GetArgs(interp, objc, objv,"oo:osgeo::RasterAttributeTable_GetRowOfValue self dfValue ",(void *)0,(void *)0) == TCL_ERROR) SWIG_fail;
+   res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_GDALRasterAttributeTableShadow, 0 |  0 );
+   if (!SWIG_IsOK(res1)) {
+     SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "RasterAttributeTable_GetRowOfValue" "', argument " "1"" of type '" "GDALRasterAttributeTableShadow *""'"); 
+   }
+   arg1 = reinterpret_cast< GDALRasterAttributeTableShadow * >(argp1);
+   ecode2 = SWIG_AsVal_double SWIG_TCL_CALL_ARGS_2(objv[2], &val2);
+   if (!SWIG_IsOK(ecode2)) {
+     SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "RasterAttributeTable_GetRowOfValue" "', argument " "2"" of type '" "double""'");
+   } 
+   arg2 = static_cast< double >(val2);
+   {
+     CPLErrorReset();
+     result = (int)GDALRasterAttributeTableShadow_GetRowOfValue(arg1,arg2);
+     CPLErr eclass = CPLGetLastErrorType();
+     if ( eclass == CE_Failure || eclass == CE_Fatal ) {
+       SWIG_exception( SWIG_RuntimeError, CPLGetLastErrorMsg() );
+       
+     }
+     
+     
+     
+     
+     
+     
+     
+     
+     
+     
+     
+   }
+   Tcl_SetObjResult(interp,SWIG_From_int(static_cast< int >(result)));
+   return TCL_OK;
+ fail:
+   return TCL_ERROR;
+ }
+ 
+ 
+ SWIGINTERN void swig_delete_RasterAttributeTable(void *obj) {
+ GDALRasterAttributeTableShadow *arg1 = (GDALRasterAttributeTableShadow *) obj;
+ delete_GDALRasterAttributeTableShadow(arg1);
+ }
+ static swig_method swig_GDALRasterAttributeTableShadow_methods[] = {
+     {"Clone", _wrap_RasterAttributeTable_Clone}, 
+     {"GetColumnCount", _wrap_RasterAttributeTable_GetColumnCount}, 
+     {"GetNameOfCol", _wrap_RasterAttributeTable_GetNameOfCol}, 
+     {"GetUsageOfCol", _wrap_RasterAttributeTable_GetUsageOfCol}, 
+     {"GetTypeOfCol", _wrap_RasterAttributeTable_GetTypeOfCol}, 
+     {"GetColOfUsage", _wrap_RasterAttributeTable_GetColOfUsage}, 
+     {"GetRowCount", _wrap_RasterAttributeTable_GetRowCount}, 
+     {"GetValueAsString", _wrap_RasterAttributeTable_GetValueAsString}, 
+     {"GetValueAsInt", _wrap_RasterAttributeTable_GetValueAsInt}, 
+     {"GetValueAsDouble", _wrap_RasterAttributeTable_GetValueAsDouble}, 
+     {"SetValueAsString", _wrap_RasterAttributeTable_SetValueAsString}, 
+     {"SetValueAsInt", _wrap_RasterAttributeTable_SetValueAsInt}, 
+     {"SetValueAsDouble", _wrap_RasterAttributeTable_SetValueAsDouble}, 
+     {"SetRowCount", _wrap_RasterAttributeTable_SetRowCount}, 
+     {"CreateColumn", _wrap_RasterAttributeTable_CreateColumn}, 
+     {"GetRowOfValue", _wrap_RasterAttributeTable_GetRowOfValue}, 
+     {0,0}
+ };
+ static swig_attribute swig_GDALRasterAttributeTableShadow_attributes[] = {
+     {0,0,0}
+ };
+ static swig_class *swig_GDALRasterAttributeTableShadow_bases[] = {0};
+ static const char * swig_GDALRasterAttributeTableShadow_base_names[] = {0};
+ static swig_class _wrap_class_GDALRasterAttributeTableShadow = { "RasterAttributeTable", &SWIGTYPE_p_GDALRasterAttributeTableShadow,_wrap_new_RasterAttributeTable, swig_delete_RasterAttributeTable, swig_GDALRasterAttributeTableShadow_methods, swig_GDALRasterAttributeTableShadow_attributes, swig_GDALRasterAttributeTableShadow_bases,swig_GDALRasterAttributeTableShadow_base_names, &swig_module };
+ SWIGINTERN int
+ _wrap_TermProgress_nocb(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
+   double arg1 ;
+   char *arg2 = (char *) NULL ;
+   void *arg3 = (void *) NULL ;
+   double val1 ;
+   int ecode1 = 0 ;
+   int res2 ;
+   char *buf2 = 0 ;
+   int alloc2 = 0 ;
+   int res3 ;
+   int result;
+   
+   if (SWIG_GetArgs(interp, objc, objv,"o|oo:osgeo::TermProgress_nocb dfProgress ?pszMessage? ?pData? ",(void *)0,(void *)0,(void *)0) == TCL_ERROR) SWIG_fail;
+   ecode1 = SWIG_AsVal_double SWIG_TCL_CALL_ARGS_2(objv[1], &val1);
+   if (!SWIG_IsOK(ecode1)) {
+     SWIG_exception_fail(SWIG_ArgError(ecode1), "in method '" "TermProgress_nocb" "', argument " "1"" of type '" "double""'");
+   } 
+   arg1 = static_cast< double >(val1);
+   if (objc > 2) {
+     res2 = SWIG_AsCharPtrAndSize(objv[2], &buf2, NULL, &alloc2);
+     if (!SWIG_IsOK(res2)) {
+       SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "TermProgress_nocb" "', argument " "2"" of type '" "char const *""'");
+     }
+     arg2 = reinterpret_cast< char * >(buf2);
+   }
+   if (objc > 3) {
+     res3 = SWIG_ConvertPtr(objv[3],SWIG_as_voidptrptr(&arg3), 0, 0);
+     if (!SWIG_IsOK(res3)) {
+       SWIG_exception_fail(SWIG_ArgError(res3), "in method '" "TermProgress_nocb" "', argument " "3"" of type '" "void *""'"); 
+     }
+   }
+   {
+     CPLErrorReset();
+     result = (int)GDALTermProgress_nocb(arg1,(char const *)arg2,arg3);
+     CPLErr eclass = CPLGetLastErrorType();
+     if ( eclass == CE_Failure || eclass == CE_Fatal ) {
+       SWIG_exception( SWIG_RuntimeError, CPLGetLastErrorMsg() );
+       
+     }
+     
+     
+     
+     
+     
+     
+     
+     
+     
+     
+     
+   }
+   Tcl_SetObjResult(interp,SWIG_From_int(static_cast< int >(result)));
+   if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
+   return TCL_OK;
+ fail:
+   if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
+   return TCL_ERROR;
+ }
+ 
+ 
+ SWIGINTERN int
+ _wrap_ComputeMedianCutPCT(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
+   GDALRasterBandShadow *arg1 = (GDALRasterBandShadow *) 0 ;
+   GDALRasterBandShadow *arg2 = (GDALRasterBandShadow *) 0 ;
+   GDALRasterBandShadow *arg3 = (GDALRasterBandShadow *) 0 ;
+   int arg4 ;
+   GDALColorTableShadow *arg5 = (GDALColorTableShadow *) 0 ;
+   GDALProgressFunc arg6 = (GDALProgressFunc) NULL ;
+   void *arg7 = (void *) NULL ;
+   void *argp1 = 0 ;
+   int res1 = 0 ;
+   void *argp2 = 0 ;
+   int res2 = 0 ;
+   void *argp3 = 0 ;
+   int res3 = 0 ;
+   int val4 ;
+   int ecode4 = 0 ;
+   void *argp5 = 0 ;
+   int res5 = 0 ;
+   int result;
+   
+   /* %typemap(arginit) ( const char* callback_data=NULL)  */
+   TclProgressData *psProgressInfo;
+   psProgressInfo = (TclProgressData *) CPLCalloc(1,sizeof(TclProgressData));
+   psProgressInfo->nLastReported = -1;
+   psProgressInfo->interp = interp;
+   psProgressInfo->psTclCallback = NULL;
+   psProgressInfo->psTclCallbackData = NULL;
+   if (SWIG_GetArgs(interp, objc, objv,"ooooo|oo:osgeo::ComputeMedianCutPCT red green blue num_colors colors ?callback? ?callback_data? ",(void *)0,(void *)0,(void *)0,(void *)0,(void *)0,(void *)0,(void *)0) == TCL_ERROR) SWIG_fail;
+   res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_GDALRasterBandShadow, 0 |  0 );
+   if (!SWIG_IsOK(res1)) {
+     SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "ComputeMedianCutPCT" "', argument " "1"" of type '" "GDALRasterBandShadow *""'"); 
+   }
+   arg1 = reinterpret_cast< GDALRasterBandShadow * >(argp1);
+   res2 = SWIG_ConvertPtr(objv[2], &argp2,SWIGTYPE_p_GDALRasterBandShadow, 0 |  0 );
+   if (!SWIG_IsOK(res2)) {
+     SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "ComputeMedianCutPCT" "', argument " "2"" of type '" "GDALRasterBandShadow *""'"); 
+   }
+   arg2 = reinterpret_cast< GDALRasterBandShadow * >(argp2);
+   res3 = SWIG_ConvertPtr(objv[3], &argp3,SWIGTYPE_p_GDALRasterBandShadow, 0 |  0 );
+   if (!SWIG_IsOK(res3)) {
+     SWIG_exception_fail(SWIG_ArgError(res3), "in method '" "ComputeMedianCutPCT" "', argument " "3"" of type '" "GDALRasterBandShadow *""'"); 
+   }
+   arg3 = reinterpret_cast< GDALRasterBandShadow * >(argp3);
+   ecode4 = SWIG_AsVal_int SWIG_TCL_CALL_ARGS_2(objv[4], &val4);
+   if (!SWIG_IsOK(ecode4)) {
+     SWIG_exception_fail(SWIG_ArgError(ecode4), "in method '" "ComputeMedianCutPCT" "', argument " "4"" of type '" "int""'");
+   } 
+   arg4 = static_cast< int >(val4);
+   res5 = SWIG_ConvertPtr(objv[5], &argp5,SWIGTYPE_p_GDALColorTableShadow, 0 |  0 );
+   if (!SWIG_IsOK(res5)) {
+     SWIG_exception_fail(SWIG_ArgError(res5), "in method '" "ComputeMedianCutPCT" "', argument " "5"" of type '" "GDALColorTableShadow *""'"); 
+   }
+   arg5 = reinterpret_cast< GDALColorTableShadow * >(argp5);
+   if (objc > 6) {
+     {
+       /* %typemap(in) (GDALProgressFunc callback = NULL) */
+       /* callback_func typemap */
+       if (objv[6] && !strcmp(Tcl_GetString(objv[6]), "")) {
+         void* cbfunction = NULL;
+         SWIG_ConvertPtr( objv[6], 
+           (void**)&cbfunction, 
+           SWIGTYPE_p_f_double_p_q_const__char_p_void__int, 
+           SWIG_POINTER_EXCEPTION | 0 );
+         
+         if ( cbfunction == GDALTermProgress ) {
+           arg6 = GDALTermProgress;
+         } else if ( cbfunction == GDALDummyProgress) {
+           arg6 = GDALDummyProgress;
+         } else if ( cbfunction == GDALScaledProgress) {
+           arg6 = GDALScaledProgress;
+         } else {
+           psProgressInfo->psTclCallback = objv[6];
+           Tcl_IncrRefCount(psProgressInfo->psTclCallback);
+           arg6 = TclProgressProxy;
+         }
+       }
+     }
+   }
+   if (objc > 7) {
+     {
+       /* %typemap(in) ( void* callback_data=NULL)  */
+       psProgressInfo->psTclCallbackData = objv[7];
+       Tcl_IncrRefCount(psProgressInfo->psTclCallbackData);
+       arg7 = psProgressInfo;
+       
+     }
+   }
+   {
+     CPLErrorReset();
+     result = (int)ComputeMedianCutPCT(arg1,arg2,arg3,arg4,arg5,arg6,arg7);
+     CPLErr eclass = CPLGetLastErrorType();
+     if ( eclass == CE_Failure || eclass == CE_Fatal ) {
+       SWIG_exception( SWIG_RuntimeError, CPLGetLastErrorMsg() );
+       
+     }
+     
+     
+     
+     
+     
+     
+     
+     
+     
+     
+     
+   }
+   Tcl_SetObjResult(interp,SWIG_From_int(static_cast< int >(result)));
+   {
+     /* %typemap(freearg) ( void* callback_data=NULL)  */
+     Tcl_DecrRefCount(psProgressInfo->psTclCallback);
+     Tcl_DecrRefCount(psProgressInfo->psTclCallbackData);
+     CPLFree(psProgressInfo);
+   }
+   return TCL_OK;
+ fail:
+   {
+     /* %typemap(freearg) ( void* callback_data=NULL)  */
+     Tcl_DecrRefCount(psProgressInfo->psTclCallback);
+     Tcl_DecrRefCount(psProgressInfo->psTclCallbackData);
+     CPLFree(psProgressInfo);
+   }
+   return TCL_ERROR;
+ }
+ 
+ 
+ SWIGINTERN int
+ _wrap_DitherRGB2PCT(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
+   GDALRasterBandShadow *arg1 = (GDALRasterBandShadow *) 0 ;
+   GDALRasterBandShadow *arg2 = (GDALRasterBandShadow *) 0 ;
+   GDALRasterBandShadow *arg3 = (GDALRasterBandShadow *) 0 ;
+   GDALRasterBandShadow *arg4 = (GDALRasterBandShadow *) 0 ;
+   GDALColorTableShadow *arg5 = (GDALColorTableShadow *) 0 ;
+   GDALProgressFunc arg6 = (GDALProgressFunc) NULL ;
+   void *arg7 = (void *) NULL ;
+   void *argp1 = 0 ;
+   int res1 = 0 ;
+   void *argp2 = 0 ;
+   int res2 = 0 ;
+   void *argp3 = 0 ;
+   int res3 = 0 ;
+   void *argp4 = 0 ;
+   int res4 = 0 ;
+   void *argp5 = 0 ;
+   int res5 = 0 ;
+   int result;
+   
+   /* %typemap(arginit) ( const char* callback_data=NULL)  */
+   TclProgressData *psProgressInfo;
+   psProgressInfo = (TclProgressData *) CPLCalloc(1,sizeof(TclProgressData));
+   psProgressInfo->nLastReported = -1;
+   psProgressInfo->interp = interp;
+   psProgressInfo->psTclCallback = NULL;
+   psProgressInfo->psTclCallbackData = NULL;
+   if (SWIG_GetArgs(interp, objc, objv,"ooooo|oo:osgeo::DitherRGB2PCT red green blue target colors ?callback? ?callback_data? ",(void *)0,(void *)0,(void *)0,(void *)0,(void *)0,(void *)0,(void *)0) == TCL_ERROR) SWIG_fail;
+   res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_GDALRasterBandShadow, 0 |  0 );
+   if (!SWIG_IsOK(res1)) {
+     SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "DitherRGB2PCT" "', argument " "1"" of type '" "GDALRasterBandShadow *""'"); 
+   }
+   arg1 = reinterpret_cast< GDALRasterBandShadow * >(argp1);
+   res2 = SWIG_ConvertPtr(objv[2], &argp2,SWIGTYPE_p_GDALRasterBandShadow, 0 |  0 );
+   if (!SWIG_IsOK(res2)) {
+     SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "DitherRGB2PCT" "', argument " "2"" of type '" "GDALRasterBandShadow *""'"); 
+   }
+   arg2 = reinterpret_cast< GDALRasterBandShadow * >(argp2);
+   res3 = SWIG_ConvertPtr(objv[3], &argp3,SWIGTYPE_p_GDALRasterBandShadow, 0 |  0 );
+   if (!SWIG_IsOK(res3)) {
+     SWIG_exception_fail(SWIG_ArgError(res3), "in method '" "DitherRGB2PCT" "', argument " "3"" of type '" "GDALRasterBandShadow *""'"); 
+   }
+   arg3 = reinterpret_cast< GDALRasterBandShadow * >(argp3);
+   res4 = SWIG_ConvertPtr(objv[4], &argp4,SWIGTYPE_p_GDALRasterBandShadow, 0 |  0 );
+   if (!SWIG_IsOK(res4)) {
+     SWIG_exception_fail(SWIG_ArgError(res4), "in method '" "DitherRGB2PCT" "', argument " "4"" of type '" "GDALRasterBandShadow *""'"); 
+   }
+   arg4 = reinterpret_cast< GDALRasterBandShadow * >(argp4);
+   res5 = SWIG_ConvertPtr(objv[5], &argp5,SWIGTYPE_p_GDALColorTableShadow, 0 |  0 );
+   if (!SWIG_IsOK(res5)) {
+     SWIG_exception_fail(SWIG_ArgError(res5), "in method '" "DitherRGB2PCT" "', argument " "5"" of type '" "GDALColorTableShadow *""'"); 
+   }
+   arg5 = reinterpret_cast< GDALColorTableShadow * >(argp5);
+   if (objc > 6) {
+     {
+       /* %typemap(in) (GDALProgressFunc callback = NULL) */
+       /* callback_func typemap */
+       if (objv[6] && !strcmp(Tcl_GetString(objv[6]), "")) {
+         void* cbfunction = NULL;
+         SWIG_ConvertPtr( objv[6], 
+           (void**)&cbfunction, 
+           SWIGTYPE_p_f_double_p_q_const__char_p_void__int, 
+           SWIG_POINTER_EXCEPTION | 0 );
+         
+         if ( cbfunction == GDALTermProgress ) {
+           arg6 = GDALTermProgress;
+         } else if ( cbfunction == GDALDummyProgress) {
+           arg6 = GDALDummyProgress;
+         } else if ( cbfunction == GDALScaledProgress) {
+           arg6 = GDALScaledProgress;
+         } else {
+           psProgressInfo->psTclCallback = objv[6];
+           Tcl_IncrRefCount(psProgressInfo->psTclCallback);
+           arg6 = TclProgressProxy;
+         }
+       }
+     }
+   }
+   if (objc > 7) {
+     {
+       /* %typemap(in) ( void* callback_data=NULL)  */
+       psProgressInfo->psTclCallbackData = objv[7];
+       Tcl_IncrRefCount(psProgressInfo->psTclCallbackData);
+       arg7 = psProgressInfo;
+       
+     }
+   }
+   {
+     CPLErrorReset();
+     result = (int)DitherRGB2PCT(arg1,arg2,arg3,arg4,arg5,arg6,arg7);
+     CPLErr eclass = CPLGetLastErrorType();
+     if ( eclass == CE_Failure || eclass == CE_Fatal ) {
+       SWIG_exception( SWIG_RuntimeError, CPLGetLastErrorMsg() );
+       
+     }
+     
+     
+     
+     
+     
+     
+     
+     
+     
+     
+     
+   }
+   Tcl_SetObjResult(interp,SWIG_From_int(static_cast< int >(result)));
+   {
+     /* %typemap(freearg) ( void* callback_data=NULL)  */
+     Tcl_DecrRefCount(psProgressInfo->psTclCallback);
+     Tcl_DecrRefCount(psProgressInfo->psTclCallbackData);
+     CPLFree(psProgressInfo);
+   }
+   return TCL_OK;
+ fail:
+   {
+     /* %typemap(freearg) ( void* callback_data=NULL)  */
+     Tcl_DecrRefCount(psProgressInfo->psTclCallback);
+     Tcl_DecrRefCount(psProgressInfo->psTclCallbackData);
+     CPLFree(psProgressInfo);
+   }
+   return TCL_ERROR;
+ }
+ 
+ 
+ SWIGINTERN int
+ _wrap_ReprojectImage(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
+   GDALDatasetShadow *arg1 = (GDALDatasetShadow *) 0 ;
+   GDALDatasetShadow *arg2 = (GDALDatasetShadow *) 0 ;
+   char *arg3 = (char *) NULL ;
+   char *arg4 = (char *) NULL ;
+   GDALResampleAlg arg5 = (GDALResampleAlg) GRA_NearestNeighbour ;
+   double arg6 = (double) 0.0 ;
+   double arg7 = (double) 0.0 ;
+   GDALProgressFunc arg8 = (GDALProgressFunc) NULL ;
+   void *arg9 = (void *) NULL ;
+   void *argp1 = 0 ;
+   int res1 = 0 ;
+   void *argp2 = 0 ;
+   int res2 = 0 ;
+   int res3 ;
+   char *buf3 = 0 ;
+   int alloc3 = 0 ;
+   int res4 ;
+   char *buf4 = 0 ;
+   int alloc4 = 0 ;
+   int val5 ;
+   int ecode5 = 0 ;
+   double val6 ;
+   int ecode6 = 0 ;
+   double val7 ;
+   int ecode7 = 0 ;
+   CPLErr result;
+   
+   /* %typemap(arginit) ( const char* callback_data=NULL)  */
+   TclProgressData *psProgressInfo;
+   psProgressInfo = (TclProgressData *) CPLCalloc(1,sizeof(TclProgressData));
+   psProgressInfo->nLastReported = -1;
+   psProgressInfo->interp = interp;
+   psProgressInfo->psTclCallback = NULL;
+   psProgressInfo->psTclCallbackData = NULL;
+   if (SWIG_GetArgs(interp, objc, objv,"oo|ooooooo:osgeo::ReprojectImage src_ds dst_ds ?src_wkt? ?dst_wkt? ?eResampleAlg? ?WarpMemoryLimit? ?maxerror? ?callback? ?callback_data? ",(void *)0,(void *)0,(void *)0,(void *)0,(void *)0,(void *)0,(void *)0,(void *)0,(void *)0) == TCL_ERROR) SWIG_fail;
+   res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_GDALDatasetShadow, 0 |  0 );
+   if (!SWIG_IsOK(res1)) {
+     SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "ReprojectImage" "', argument " "1"" of type '" "GDALDatasetShadow *""'"); 
+   }
+   arg1 = reinterpret_cast< GDALDatasetShadow * >(argp1);
+   res2 = SWIG_ConvertPtr(objv[2], &argp2,SWIGTYPE_p_GDALDatasetShadow, 0 |  0 );
+   if (!SWIG_IsOK(res2)) {
+     SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "ReprojectImage" "', argument " "2"" of type '" "GDALDatasetShadow *""'"); 
+   }
+   arg2 = reinterpret_cast< GDALDatasetShadow * >(argp2);
+   if (objc > 3) {
+     res3 = SWIG_AsCharPtrAndSize(objv[3], &buf3, NULL, &alloc3);
+     if (!SWIG_IsOK(res3)) {
+       SWIG_exception_fail(SWIG_ArgError(res3), "in method '" "ReprojectImage" "', argument " "3"" of type '" "char const *""'");
+     }
+     arg3 = reinterpret_cast< char * >(buf3);
+   }
+   if (objc > 4) {
+     res4 = SWIG_AsCharPtrAndSize(objv[4], &buf4, NULL, &alloc4);
+     if (!SWIG_IsOK(res4)) {
+       SWIG_exception_fail(SWIG_ArgError(res4), "in method '" "ReprojectImage" "', argument " "4"" of type '" "char const *""'");
+     }
+     arg4 = reinterpret_cast< char * >(buf4);
+   }
+   if (objc > 5) {
+     ecode5 = SWIG_AsVal_int SWIG_TCL_CALL_ARGS_2(objv[5], &val5);
+     if (!SWIG_IsOK(ecode5)) {
+       SWIG_exception_fail(SWIG_ArgError(ecode5), "in method '" "ReprojectImage" "', argument " "5"" of type '" "GDALResampleAlg""'");
+     } 
+     arg5 = static_cast< GDALResampleAlg >(val5);
+   }
+   if (objc > 6) {
+     ecode6 = SWIG_AsVal_double SWIG_TCL_CALL_ARGS_2(objv[6], &val6);
+     if (!SWIG_IsOK(ecode6)) {
+       SWIG_exception_fail(SWIG_ArgError(ecode6), "in method '" "ReprojectImage" "', argument " "6"" of type '" "double""'");
+     } 
+     arg6 = static_cast< double >(val6);
+   }
+   if (objc > 7) {
+     ecode7 = SWIG_AsVal_double SWIG_TCL_CALL_ARGS_2(objv[7], &val7);
+     if (!SWIG_IsOK(ecode7)) {
+       SWIG_exception_fail(SWIG_ArgError(ecode7), "in method '" "ReprojectImage" "', argument " "7"" of type '" "double""'");
+     } 
+     arg7 = static_cast< double >(val7);
+   }
+   if (objc > 8) {
+     {
+       /* %typemap(in) (GDALProgressFunc callback = NULL) */
+       /* callback_func typemap */
+       if (objv[8] && !strcmp(Tcl_GetString(objv[8]), "")) {
+         void* cbfunction = NULL;
+         SWIG_ConvertPtr( objv[8], 
+           (void**)&cbfunction, 
+           SWIGTYPE_p_f_double_p_q_const__char_p_void__int, 
+           SWIG_POINTER_EXCEPTION | 0 );
+         
+         if ( cbfunction == GDALTermProgress ) {
+           arg8 = GDALTermProgress;
+         } else if ( cbfunction == GDALDummyProgress) {
+           arg8 = GDALDummyProgress;
+         } else if ( cbfunction == GDALScaledProgress) {
+           arg8 = GDALScaledProgress;
+         } else {
+           psProgressInfo->psTclCallback = objv[8];
+           Tcl_IncrRefCount(psProgressInfo->psTclCallback);
+           arg8 = TclProgressProxy;
+         }
+       }
+     }
+   }
+   if (objc > 9) {
+     {
+       /* %typemap(in) ( void* callback_data=NULL)  */
+       psProgressInfo->psTclCallbackData = objv[9];
+       Tcl_IncrRefCount(psProgressInfo->psTclCallbackData);
+       arg9 = psProgressInfo;
+       
+     }
+   }
+   {
+     CPLErrorReset();
+     result = (CPLErr)ReprojectImage(arg1,arg2,(char const *)arg3,(char const *)arg4,arg5,arg6,arg7,arg8,arg9);
+     CPLErr eclass = CPLGetLastErrorType();
+     if ( eclass == CE_Failure || eclass == CE_Fatal ) {
+       SWIG_exception( SWIG_RuntimeError, CPLGetLastErrorMsg() );
+       
+     }
+     
+     
+     
+     
+     
+     
+     
+     
+     
+     
+     
+   }
+   Tcl_SetObjResult(interp,SWIG_From_int(static_cast< int >(result)));
+   if (alloc3 == SWIG_NEWOBJ) delete[] buf3;
+   if (alloc4 == SWIG_NEWOBJ) delete[] buf4;
+   {
+     /* %typemap(freearg) ( void* callback_data=NULL)  */
+     Tcl_DecrRefCount(psProgressInfo->psTclCallback);
+     Tcl_DecrRefCount(psProgressInfo->psTclCallbackData);
+     CPLFree(psProgressInfo);
+   }
+   return TCL_OK;
+ fail:
+   if (alloc3 == SWIG_NEWOBJ) delete[] buf3;
+   if (alloc4 == SWIG_NEWOBJ) delete[] buf4;
+   {
+     /* %typemap(freearg) ( void* callback_data=NULL)  */
+     Tcl_DecrRefCount(psProgressInfo->psTclCallback);
+     Tcl_DecrRefCount(psProgressInfo->psTclCallbackData);
+     CPLFree(psProgressInfo);
+   }
+   return TCL_ERROR;
+ }
+ 
+ 
+ SWIGINTERN int
+ _wrap_ComputeProximity(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
+   GDALRasterBandShadow *arg1 = (GDALRasterBandShadow *) 0 ;
+   GDALRasterBandShadow *arg2 = (GDALRasterBandShadow *) 0 ;
+   char **arg3 = (char **) NULL ;
+   GDALProgressFunc arg4 = (GDALProgressFunc) NULL ;
+   void *arg5 = (void *) NULL ;
+   void *argp1 = 0 ;
+   int res1 = 0 ;
+   void *argp2 = 0 ;
+   int res2 = 0 ;
+   int result;
+   
+   /* %typemap(arginit) ( const char* callback_data=NULL)  */
+   TclProgressData *psProgressInfo;
+   psProgressInfo = (TclProgressData *) CPLCalloc(1,sizeof(TclProgressData));
+   psProgressInfo->nLastReported = -1;
+   psProgressInfo->interp = interp;
+   psProgressInfo->psTclCallback = NULL;
+   psProgressInfo->psTclCallbackData = NULL;
+   if (SWIG_GetArgs(interp, objc, objv,"oo|ooo:osgeo::ComputeProximity srcBand proximityBand ?options? ?callback? ?callback_data? ",(void *)0,(void *)0,(void *)0,(void *)0,(void *)0) == TCL_ERROR) SWIG_fail;
+   res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_GDALRasterBandShadow, 0 |  0 );
+   if (!SWIG_IsOK(res1)) {
+     SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "ComputeProximity" "', argument " "1"" of type '" "GDALRasterBandShadow *""'"); 
+   }
+   arg1 = reinterpret_cast< GDALRasterBandShadow * >(argp1);
+   res2 = SWIG_ConvertPtr(objv[2], &argp2,SWIGTYPE_p_GDALRasterBandShadow, 0 |  0 );
+   if (!SWIG_IsOK(res2)) {
+     SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "ComputeProximity" "', argument " "2"" of type '" "GDALRasterBandShadow *""'"); 
+   }
+   arg2 = reinterpret_cast< GDALRasterBandShadow * >(argp2);
+   if (objc > 3) {
+     {
+       /* %typemap(in) char **options */
+       int size;
+       if (Tcl_ListObjLength(interp, objv[3], &size) != TCL_OK) {
+         /* Error msg in interp result */
+         SWIG_fail;
+       }
+       if ( !size ) {
+         Tcl_SetResult(interp, (char*) "Input list mustn't be empty", TCL_STATIC);
+         SWIG_fail;
+       }
+       
+       for (int i = 0; i < size; i++) {
+         Tcl_Obj **o = NULL;
+         /* The reference count for the list element is not incremented with the following */
+         if (Tcl_ListObjIndex(interp, objv[3], i, o) != TCL_OK) {
+           /* Error msg in interp result */
+           SWIG_fail;
+         }
+         char *pszItem = Tcl_GetString(*o);
+         arg3 = CSLAddString( arg3, pszItem );
+       }
+     }
+   }
+   if (objc > 4) {
+     {
+       /* %typemap(in) (GDALProgressFunc callback = NULL) */
+       /* callback_func typemap */
+       if (objv[4] && !strcmp(Tcl_GetString(objv[4]), "")) {
+         void* cbfunction = NULL;
+         SWIG_ConvertPtr( objv[4], 
+           (void**)&cbfunction, 
+           SWIGTYPE_p_f_double_p_q_const__char_p_void__int, 
+           SWIG_POINTER_EXCEPTION | 0 );
+         
+         if ( cbfunction == GDALTermProgress ) {
+           arg4 = GDALTermProgress;
+         } else if ( cbfunction == GDALDummyProgress) {
+           arg4 = GDALDummyProgress;
+         } else if ( cbfunction == GDALScaledProgress) {
+           arg4 = GDALScaledProgress;
+         } else {
+           psProgressInfo->psTclCallback = objv[4];
+           Tcl_IncrRefCount(psProgressInfo->psTclCallback);
+           arg4 = TclProgressProxy;
+         }
+       }
+     }
+   }
+   if (objc > 5) {
+     {
+       /* %typemap(in) ( void* callback_data=NULL)  */
+       psProgressInfo->psTclCallbackData = objv[5];
+       Tcl_IncrRefCount(psProgressInfo->psTclCallbackData);
+       arg5 = psProgressInfo;
+       
+     }
+   }
+   {
+     CPLErrorReset();
+     result = (int)ComputeProximity(arg1,arg2,arg3,arg4,arg5);
+     CPLErr eclass = CPLGetLastErrorType();
+     if ( eclass == CE_Failure || eclass == CE_Fatal ) {
+       SWIG_exception( SWIG_RuntimeError, CPLGetLastErrorMsg() );
+       
+     }
+     
+     
+     
+     
+     
+     
+     
+     
+     
+     
+     
+   }
+   Tcl_SetObjResult(interp,SWIG_From_int(static_cast< int >(result)));
+   {
+     /* %typemap(freearg) char **options */
+     CSLDestroy( arg3 );
+   }
+   {
+     /* %typemap(freearg) ( void* callback_data=NULL)  */
+     Tcl_DecrRefCount(psProgressInfo->psTclCallback);
+     Tcl_DecrRefCount(psProgressInfo->psTclCallbackData);
+     CPLFree(psProgressInfo);
+   }
+   return TCL_OK;
+ fail:
+   {
+     /* %typemap(freearg) char **options */
+     CSLDestroy( arg3 );
+   }
+   {
+     /* %typemap(freearg) ( void* callback_data=NULL)  */
+     Tcl_DecrRefCount(psProgressInfo->psTclCallback);
+     Tcl_DecrRefCount(psProgressInfo->psTclCallbackData);
+     CPLFree(psProgressInfo);
+   }
+   return TCL_ERROR;
+ }
+ 
+ 
+ SWIGINTERN int
+ _wrap_RasterizeLayer(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
+   GDALDatasetShadow *arg1 = (GDALDatasetShadow *) 0 ;
+   int arg2 ;
+   int *arg3 = (int *) 0 ;
+   OGRLayerShadow *arg4 = (OGRLayerShadow *) 0 ;
+   void *arg5 = (void *) NULL ;
+   void *arg6 = (void *) NULL ;
+   int arg7 = (int) 0 ;
+   double *arg8 = (double *) NULL ;
+   char **arg9 = (char **) NULL ;
+   GDALProgressFunc arg10 = (GDALProgressFunc) NULL ;
+   void *arg11 = (void *) NULL ;
+   void *argp1 = 0 ;
+   int res1 = 0 ;
+   void *argp4 = 0 ;
+   int res4 = 0 ;
+   int res5 ;
+   int res6 ;
+   int result;
+   
+   /* %typemap(arginit) ( const char* callback_data=NULL)  */
+   TclProgressData *psProgressInfo;
+   psProgressInfo = (TclProgressData *) CPLCalloc(1,sizeof(TclProgressData));
+   psProgressInfo->nLastReported = -1;
+   psProgressInfo->interp = interp;
+   psProgressInfo->psTclCallback = NULL;
+   psProgressInfo->psTclCallbackData = NULL;
+   if (SWIG_GetArgs(interp, objc, objv,"ooo|oooooo:osgeo::RasterizeLayer dataset bands band_list ?layer? ?pfnTransformer? ?pTransformArg? ?burn_values? ?burn_values_list? ?options? ?callback? ?callback_data? ",(void *)0,(void *)0,(void *)0,(void *)0,(void *)0,(void *)0,(void *)0,(void *)0,(void *)0) == TCL_ERROR) SWIG_fail;
+   res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_GDALDatasetShadow, 0 |  0 );
+   if (!SWIG_IsOK(res1)) {
+     SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "RasterizeLayer" "', argument " "1"" of type '" "GDALDatasetShadow *""'"); 
+   }
+   arg1 = reinterpret_cast< GDALDatasetShadow * >(argp1);
+   {
+     /* %typemap(in,numinputs=1) (int nList, int* pList)*/
+     /* The following also checks if input is a list */
+     if (Tcl_ListObjLength(interp, objv[2], &arg2) != TCL_OK) {
+       /* Error msg in interp result */
+       SWIG_fail;
+     }
+     if ( !arg2 ) {
+       Tcl_SetResult(interp, (char*) "Input list mustn't be empty", TCL_STATIC);
+       SWIG_fail;
+     }
+     
+     arg3 = (int*) CPLMalloc(arg2*sizeof(int));
+     
+     for( int i = 0; i<arg2; i++ ) {
+       Tcl_Obj **o = NULL;
+       if (Tcl_ListObjIndex(interp, objv[2], i, o) != TCL_OK) {
+         /* ref count is not incremented */
+         /* Error msg in interp result */
+         SWIG_fail;
+       }
+       
+       int val;
+       if (Tcl_GetIntFromObj(interp, *o, &val ) != TCL_OK) {
+         /* Error msg in interp result */
+         SWIG_fail;
+       }
+       arg3[i] = val;
+     }
+   }
+   res4 = SWIG_ConvertPtr(objv[3], &argp4,SWIGTYPE_p_OGRLayerShadow, 0 |  0 );
+   if (!SWIG_IsOK(res4)) {
+     SWIG_exception_fail(SWIG_ArgError(res4), "in method '" "RasterizeLayer" "', argument " "4"" of type '" "OGRLayerShadow *""'"); 
+   }
+   arg4 = reinterpret_cast< OGRLayerShadow * >(argp4);
+   if (objc > 4) {
+     res5 = SWIG_ConvertPtr(objv[4],SWIG_as_voidptrptr(&arg5), 0, 0);
+     if (!SWIG_IsOK(res5)) {
+       SWIG_exception_fail(SWIG_ArgError(res5), "in method '" "RasterizeLayer" "', argument " "5"" of type '" "void *""'"); 
+     }
+   }
+   if (objc > 5) {
+     res6 = SWIG_ConvertPtr(objv[5],SWIG_as_voidptrptr(&arg6), 0, 0);
+     if (!SWIG_IsOK(res6)) {
+       SWIG_exception_fail(SWIG_ArgError(res6), "in method '" "RasterizeLayer" "', argument " "6"" of type '" "void *""'"); 
+     }
+   }
+   if (objc > 6) {
+     {
+       /* %typemap(in,numinputs=1) (int nList, double* pList)*/
+       /* The following also checks if input is a list */
+       if (Tcl_ListObjLength(interp, objv[6], &arg7) != TCL_OK) {
+         /* Error msg in interp result */
+         SWIG_fail;
+       }
+       if ( !arg7 ) {
+         Tcl_SetResult(interp, (char*) "Input list mustn't be empty", TCL_STATIC);
+         SWIG_fail;
+       }
+       
+       arg8 = (double*) CPLMalloc(arg7*sizeof(double));
+       
+       for( int i = 0; i<arg7; i++ ) {
+         Tcl_Obj **o = NULL;
+         if (Tcl_ListObjIndex(interp, objv[6], i, o) != TCL_OK) {
+           /* ref count is not incremented */
+           /* Error msg in interp result */
+           SWIG_fail;
+         }
+         
+         double val;
+         if (Tcl_GetDoubleFromObj(interp, *o, &val ) != TCL_OK) {
+           /* Error msg in interp result */
+           SWIG_fail;
+         }
+         arg8[i] = val;
+       }
+     }
+   }
+   if (objc > 7) {
+     {
+       /* %typemap(in) char **options */
+       int size;
+       if (Tcl_ListObjLength(interp, objv[7], &size) != TCL_OK) {
+         /* Error msg in interp result */
+         SWIG_fail;
+       }
+       if ( !size ) {
+         Tcl_SetResult(interp, (char*) "Input list mustn't be empty", TCL_STATIC);
+         SWIG_fail;
+       }
+       
+       for (int i = 0; i < size; i++) {
+         Tcl_Obj **o = NULL;
+         /* The reference count for the list element is not incremented with the following */
+         if (Tcl_ListObjIndex(interp, objv[7], i, o) != TCL_OK) {
+           /* Error msg in interp result */
+           SWIG_fail;
+         }
+         char *pszItem = Tcl_GetString(*o);
+         arg9 = CSLAddString( arg9, pszItem );
+       }
+     }
+   }
+   if (objc > 8) {
+     {
+       /* %typemap(in) (GDALProgressFunc callback = NULL) */
+       /* callback_func typemap */
+       if (objv[8] && !strcmp(Tcl_GetString(objv[8]), "")) {
+         void* cbfunction = NULL;
+         SWIG_ConvertPtr( objv[8], 
+           (void**)&cbfunction, 
+           SWIGTYPE_p_f_double_p_q_const__char_p_void__int, 
+           SWIG_POINTER_EXCEPTION | 0 );
+         
+         if ( cbfunction == GDALTermProgress ) {
+           arg10 = GDALTermProgress;
+         } else if ( cbfunction == GDALDummyProgress) {
+           arg10 = GDALDummyProgress;
+         } else if ( cbfunction == GDALScaledProgress) {
+           arg10 = GDALScaledProgress;
+         } else {
+           psProgressInfo->psTclCallback = objv[8];
+           Tcl_IncrRefCount(psProgressInfo->psTclCallback);
+           arg10 = TclProgressProxy;
+         }
+       }
+     }
+   }
+   if (objc > 9) {
+     {
+       /* %typemap(in) ( void* callback_data=NULL)  */
+       psProgressInfo->psTclCallbackData = objv[9];
+       Tcl_IncrRefCount(psProgressInfo->psTclCallbackData);
+       arg11 = psProgressInfo;
+       
+     }
+   }
+   {
+     CPLErrorReset();
+     result = (int)RasterizeLayer(arg1,arg2,arg3,arg4,arg5,arg6,arg7,arg8,arg9,arg10,arg11);
+     CPLErr eclass = CPLGetLastErrorType();
+     if ( eclass == CE_Failure || eclass == CE_Fatal ) {
+       SWIG_exception( SWIG_RuntimeError, CPLGetLastErrorMsg() );
+       
+     }
+     
+     
+     
+     
+     
+     
+     
+     
+     
+     
+     
+   }
+   Tcl_SetObjResult(interp,SWIG_From_int(static_cast< int >(result)));
+   {
+     /* %typemap(freearg) (int nList, int* pList) */
+     if (arg3) {
+       CPLFree((void*) arg3);
+     }
+   }
+   {
+     /* %typemap(freearg) (int nList, double* pList) */
+     if (arg8) {
+       CPLFree((void*) arg8);
+     }
+   }
+   {
+     /* %typemap(freearg) char **options */
+     CSLDestroy( arg9 );
+   }
+   {
+     /* %typemap(freearg) ( void* callback_data=NULL)  */
+     Tcl_DecrRefCount(psProgressInfo->psTclCallback);
+     Tcl_DecrRefCount(psProgressInfo->psTclCallbackData);
+     CPLFree(psProgressInfo);
+   }
+   return TCL_OK;
+ fail:
+   {
+     /* %typemap(freearg) (int nList, int* pList) */
+     if (arg3) {
+       CPLFree((void*) arg3);
+     }
+   }
+   {
+     /* %typemap(freearg) (int nList, double* pList) */
+     if (arg8) {
+       CPLFree((void*) arg8);
+     }
+   }
+   {
+     /* %typemap(freearg) char **options */
+     CSLDestroy( arg9 );
+   }
+   {
+     /* %typemap(freearg) ( void* callback_data=NULL)  */
+     Tcl_DecrRefCount(psProgressInfo->psTclCallback);
+     Tcl_DecrRefCount(psProgressInfo->psTclCallbackData);
+     CPLFree(psProgressInfo);
+   }
+   return TCL_ERROR;
+ }
+ 
+ 
+ SWIGINTERN int
+ _wrap_Polygonize(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
+   GDALRasterBandShadow *arg1 = (GDALRasterBandShadow *) 0 ;
+   GDALRasterBandShadow *arg2 = (GDALRasterBandShadow *) 0 ;
+   OGRLayerShadow *arg3 = (OGRLayerShadow *) 0 ;
+   int arg4 ;
+   char **arg5 = (char **) NULL ;
+   GDALProgressFunc arg6 = (GDALProgressFunc) NULL ;
+   void *arg7 = (void *) NULL ;
+   void *argp1 = 0 ;
+   int res1 = 0 ;
+   void *argp2 = 0 ;
+   int res2 = 0 ;
+   void *argp3 = 0 ;
+   int res3 = 0 ;
+   int val4 ;
+   int ecode4 = 0 ;
+   int result;
+   
+   /* %typemap(arginit) ( const char* callback_data=NULL)  */
+   TclProgressData *psProgressInfo;
+   psProgressInfo = (TclProgressData *) CPLCalloc(1,sizeof(TclProgressData));
+   psProgressInfo->nLastReported = -1;
+   psProgressInfo->interp = interp;
+   psProgressInfo->psTclCallback = NULL;
+   psProgressInfo->psTclCallbackData = NULL;
+   if (SWIG_GetArgs(interp, objc, objv,"oooo|ooo:osgeo::Polygonize srcBand maskBand outLayer iPixValField ?options? ?callback? ?callback_data? ",(void *)0,(void *)0,(void *)0,(void *)0,(void *)0,(void *)0,(void *)0) == TCL_ERROR) SWIG_fail;
+   res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_GDALRasterBandShadow, 0 |  0 );
+   if (!SWIG_IsOK(res1)) {
+     SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Polygonize" "', argument " "1"" of type '" "GDALRasterBandShadow *""'"); 
+   }
+   arg1 = reinterpret_cast< GDALRasterBandShadow * >(argp1);
+   res2 = SWIG_ConvertPtr(objv[2], &argp2,SWIGTYPE_p_GDALRasterBandShadow, 0 |  0 );
+   if (!SWIG_IsOK(res2)) {
+     SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "Polygonize" "', argument " "2"" of type '" "GDALRasterBandShadow *""'"); 
+   }
+   arg2 = reinterpret_cast< GDALRasterBandShadow * >(argp2);
+   res3 = SWIG_ConvertPtr(objv[3], &argp3,SWIGTYPE_p_OGRLayerShadow, 0 |  0 );
+   if (!SWIG_IsOK(res3)) {
+     SWIG_exception_fail(SWIG_ArgError(res3), "in method '" "Polygonize" "', argument " "3"" of type '" "OGRLayerShadow *""'"); 
+   }
+   arg3 = reinterpret_cast< OGRLayerShadow * >(argp3);
+   ecode4 = SWIG_AsVal_int SWIG_TCL_CALL_ARGS_2(objv[4], &val4);
+   if (!SWIG_IsOK(ecode4)) {
+     SWIG_exception_fail(SWIG_ArgError(ecode4), "in method '" "Polygonize" "', argument " "4"" of type '" "int""'");
+   } 
+   arg4 = static_cast< int >(val4);
+   if (objc > 5) {
+     {
+       /* %typemap(in) char **options */
+       int size;
+       if (Tcl_ListObjLength(interp, objv[5], &size) != TCL_OK) {
+         /* Error msg in interp result */
+         SWIG_fail;
+       }
+       if ( !size ) {
+         Tcl_SetResult(interp, (char*) "Input list mustn't be empty", TCL_STATIC);
+         SWIG_fail;
+       }
+       
+       for (int i = 0; i < size; i++) {
+         Tcl_Obj **o = NULL;
+         /* The reference count for the list element is not incremented with the following */
+         if (Tcl_ListObjIndex(interp, objv[5], i, o) != TCL_OK) {
+           /* Error msg in interp result */
+           SWIG_fail;
+         }
+         char *pszItem = Tcl_GetString(*o);
+         arg5 = CSLAddString( arg5, pszItem );
+       }
+     }
+   }
+   if (objc > 6) {
+     {
+       /* %typemap(in) (GDALProgressFunc callback = NULL) */
+       /* callback_func typemap */
+       if (objv[6] && !strcmp(Tcl_GetString(objv[6]), "")) {
+         void* cbfunction = NULL;
+         SWIG_ConvertPtr( objv[6], 
+           (void**)&cbfunction, 
+           SWIGTYPE_p_f_double_p_q_const__char_p_void__int, 
+           SWIG_POINTER_EXCEPTION | 0 );
+         
+         if ( cbfunction == GDALTermProgress ) {
+           arg6 = GDALTermProgress;
+         } else if ( cbfunction == GDALDummyProgress) {
+           arg6 = GDALDummyProgress;
+         } else if ( cbfunction == GDALScaledProgress) {
+           arg6 = GDALScaledProgress;
+         } else {
+           psProgressInfo->psTclCallback = objv[6];
+           Tcl_IncrRefCount(psProgressInfo->psTclCallback);
+           arg6 = TclProgressProxy;
+         }
+       }
+     }
+   }
+   if (objc > 7) {
+     {
+       /* %typemap(in) ( void* callback_data=NULL)  */
+       psProgressInfo->psTclCallbackData = objv[7];
+       Tcl_IncrRefCount(psProgressInfo->psTclCallbackData);
+       arg7 = psProgressInfo;
+       
+     }
+   }
+   {
+     CPLErrorReset();
+     result = (int)Polygonize(arg1,arg2,arg3,arg4,arg5,arg6,arg7);
+     CPLErr eclass = CPLGetLastErrorType();
+     if ( eclass == CE_Failure || eclass == CE_Fatal ) {
+       SWIG_exception( SWIG_RuntimeError, CPLGetLastErrorMsg() );
+       
+     }
+     
+     
+     
+     
+     
+     
+     
+     
+     
+     
+     
+   }
+   Tcl_SetObjResult(interp,SWIG_From_int(static_cast< int >(result)));
+   {
+     /* %typemap(freearg) char **options */
+     CSLDestroy( arg5 );
+   }
+   {
+     /* %typemap(freearg) ( void* callback_data=NULL)  */
+     Tcl_DecrRefCount(psProgressInfo->psTclCallback);
+     Tcl_DecrRefCount(psProgressInfo->psTclCallbackData);
+     CPLFree(psProgressInfo);
+   }
+   return TCL_OK;
+ fail:
+   {
+     /* %typemap(freearg) char **options */
+     CSLDestroy( arg5 );
+   }
+   {
+     /* %typemap(freearg) ( void* callback_data=NULL)  */
+     Tcl_DecrRefCount(psProgressInfo->psTclCallback);
+     Tcl_DecrRefCount(psProgressInfo->psTclCallbackData);
+     CPLFree(psProgressInfo);
+   }
+   return TCL_ERROR;
+ }
+ 
+ 
+ SWIGINTERN int
+ _wrap_SieveFilter(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
+   GDALRasterBandShadow *arg1 = (GDALRasterBandShadow *) 0 ;
+   GDALRasterBandShadow *arg2 = (GDALRasterBandShadow *) 0 ;
+   GDALRasterBandShadow *arg3 = (GDALRasterBandShadow *) 0 ;
+   int arg4 ;
+   int arg5 = (int) 4 ;
+   char **arg6 = (char **) NULL ;
+   GDALProgressFunc arg7 = (GDALProgressFunc) NULL ;
+   void *arg8 = (void *) NULL ;
+   void *argp1 = 0 ;
+   int res1 = 0 ;
+   void *argp2 = 0 ;
+   int res2 = 0 ;
+   void *argp3 = 0 ;
+   int res3 = 0 ;
+   int val4 ;
+   int ecode4 = 0 ;
+   int val5 ;
+   int ecode5 = 0 ;
+   int result;
+   
+   /* %typemap(arginit) ( const char* callback_data=NULL)  */
+   TclProgressData *psProgressInfo;
+   psProgressInfo = (TclProgressData *) CPLCalloc(1,sizeof(TclProgressData));
+   psProgressInfo->nLastReported = -1;
+   psProgressInfo->interp = interp;
+   psProgressInfo->psTclCallback = NULL;
+   psProgressInfo->psTclCallbackData = NULL;
+   if (SWIG_GetArgs(interp, objc, objv,"oooo|oooo:osgeo::SieveFilter srcBand maskBand dstBand threshold ?connectedness? ?options? ?callback? ?callback_data? ",(void *)0,(void *)0,(void *)0,(void *)0,(void *)0,(void *)0,(void *)0,(void *)0) == TCL_ERROR) SWIG_fail;
+   res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_GDALRasterBandShadow, 0 |  0 );
+   if (!SWIG_IsOK(res1)) {
+     SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SieveFilter" "', argument " "1"" of type '" "GDALRasterBandShadow *""'"); 
+   }
+   arg1 = reinterpret_cast< GDALRasterBandShadow * >(argp1);
+   res2 = SWIG_ConvertPtr(objv[2], &argp2,SWIGTYPE_p_GDALRasterBandShadow, 0 |  0 );
+   if (!SWIG_IsOK(res2)) {
+     SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "SieveFilter" "', argument " "2"" of type '" "GDALRasterBandShadow *""'"); 
+   }
+   arg2 = reinterpret_cast< GDALRasterBandShadow * >(argp2);
+   res3 = SWIG_ConvertPtr(objv[3], &argp3,SWIGTYPE_p_GDALRasterBandShadow, 0 |  0 );
+   if (!SWIG_IsOK(res3)) {
+     SWIG_exception_fail(SWIG_ArgError(res3), "in method '" "SieveFilter" "', argument " "3"" of type '" "GDALRasterBandShadow *""'"); 
+   }
+   arg3 = reinterpret_cast< GDALRasterBandShadow * >(argp3);
+   ecode4 = SWIG_AsVal_int SWIG_TCL_CALL_ARGS_2(objv[4], &val4);
+   if (!SWIG_IsOK(ecode4)) {
+     SWIG_exception_fail(SWIG_ArgError(ecode4), "in method '" "SieveFilter" "', argument " "4"" of type '" "int""'");
+   } 
+   arg4 = static_cast< int >(val4);
+   if (objc > 5) {
+     ecode5 = SWIG_AsVal_int SWIG_TCL_CALL_ARGS_2(objv[5], &val5);
+     if (!SWIG_IsOK(ecode5)) {
+       SWIG_exception_fail(SWIG_ArgError(ecode5), "in method '" "SieveFilter" "', argument " "5"" of type '" "int""'");
+     } 
+     arg5 = static_cast< int >(val5);
+   }
+   if (objc > 6) {
+     {
+       /* %typemap(in) char **options */
+       int size;
+       if (Tcl_ListObjLength(interp, objv[6], &size) != TCL_OK) {
+         /* Error msg in interp result */
+         SWIG_fail;
+       }
+       if ( !size ) {
+         Tcl_SetResult(interp, (char*) "Input list mustn't be empty", TCL_STATIC);
+         SWIG_fail;
+       }
+       
+       for (int i = 0; i < size; i++) {
+         Tcl_Obj **o = NULL;
+         /* The reference count for the list element is not incremented with the following */
+         if (Tcl_ListObjIndex(interp, objv[6], i, o) != TCL_OK) {
+           /* Error msg in interp result */
+           SWIG_fail;
+         }
+         char *pszItem = Tcl_GetString(*o);
+         arg6 = CSLAddString( arg6, pszItem );
+       }
+     }
+   }
+   if (objc > 7) {
+     {
+       /* %typemap(in) (GDALProgressFunc callback = NULL) */
+       /* callback_func typemap */
+       if (objv[7] && !strcmp(Tcl_GetString(objv[7]), "")) {
+         void* cbfunction = NULL;
+         SWIG_ConvertPtr( objv[7], 
+           (void**)&cbfunction, 
+           SWIGTYPE_p_f_double_p_q_const__char_p_void__int, 
+           SWIG_POINTER_EXCEPTION | 0 );
+         
+         if ( cbfunction == GDALTermProgress ) {
+           arg7 = GDALTermProgress;
+         } else if ( cbfunction == GDALDummyProgress) {
+           arg7 = GDALDummyProgress;
+         } else if ( cbfunction == GDALScaledProgress) {
+           arg7 = GDALScaledProgress;
+         } else {
+           psProgressInfo->psTclCallback = objv[7];
+           Tcl_IncrRefCount(psProgressInfo->psTclCallback);
+           arg7 = TclProgressProxy;
+         }
+       }
+     }
+   }
+   if (objc > 8) {
+     {
+       /* %typemap(in) ( void* callback_data=NULL)  */
+       psProgressInfo->psTclCallbackData = objv[8];
+       Tcl_IncrRefCount(psProgressInfo->psTclCallbackData);
+       arg8 = psProgressInfo;
+       
+     }
+   }
+   {
+     CPLErrorReset();
+     result = (int)SieveFilter(arg1,arg2,arg3,arg4,arg5,arg6,arg7,arg8);
+     CPLErr eclass = CPLGetLastErrorType();
+     if ( eclass == CE_Failure || eclass == CE_Fatal ) {
+       SWIG_exception( SWIG_RuntimeError, CPLGetLastErrorMsg() );
+       
+     }
+     
+     
+     
+     
+     
+     
+     
+     
+     
+     
+     
+   }
+   Tcl_SetObjResult(interp,SWIG_From_int(static_cast< int >(result)));
+   {
+     /* %typemap(freearg) char **options */
+     CSLDestroy( arg6 );
+   }
+   {
+     /* %typemap(freearg) ( void* callback_data=NULL)  */
+     Tcl_DecrRefCount(psProgressInfo->psTclCallback);
+     Tcl_DecrRefCount(psProgressInfo->psTclCallbackData);
+     CPLFree(psProgressInfo);
+   }
+   return TCL_OK;
+ fail:
+   {
+     /* %typemap(freearg) char **options */
+     CSLDestroy( arg6 );
+   }
+   {
+     /* %typemap(freearg) ( void* callback_data=NULL)  */
+     Tcl_DecrRefCount(psProgressInfo->psTclCallback);
+     Tcl_DecrRefCount(psProgressInfo->psTclCallbackData);
+     CPLFree(psProgressInfo);
+   }
+   return TCL_ERROR;
+ }
+ 
+ 
+ SWIGINTERN int
+ _wrap_RegenerateOverviews(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
+   GDALRasterBandShadow *arg1 = (GDALRasterBandShadow *) 0 ;
+   int arg2 ;
+   GDALRasterBandShadow **arg3 = (GDALRasterBandShadow **) 0 ;
+   char *arg4 = (char *) "average" ;
+   GDALProgressFunc arg5 = (GDALProgressFunc) NULL ;
+   void *arg6 = (void *) NULL ;
+   void *argp1 = 0 ;
+   int res1 = 0 ;
+   int res4 ;
+   char *buf4 = 0 ;
+   int alloc4 = 0 ;
+   int result;
+   
+   /* %typemap(arginit) ( const char* callback_data=NULL)  */
+   TclProgressData *psProgressInfo;
+   psProgressInfo = (TclProgressData *) CPLCalloc(1,sizeof(TclProgressData));
+   psProgressInfo->nLastReported = -1;
+   psProgressInfo->interp = interp;
+   psProgressInfo->psTclCallback = NULL;
+   psProgressInfo->psTclCallbackData = NULL;
+   if (SWIG_GetArgs(interp, objc, objv,"oo|ooo:osgeo::RegenerateOverviews srcBand overviewBandCount ?overviewBands? ?resampling? ?callback? ?callback_data? ",(void *)0,(void *)0,(void *)0,(void *)0,(void *)0) == TCL_ERROR) SWIG_fail;
+   res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_GDALRasterBandShadow, 0 |  0 );
+   if (!SWIG_IsOK(res1)) {
+     SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "RegenerateOverviews" "', argument " "1"" of type '" "GDALRasterBandShadow *""'"); 
+   }
+   arg1 = reinterpret_cast< GDALRasterBandShadow * >(argp1);
+   {
+     /*  OBJECT_LIST_INPUT %typemap(in) (int itemcount, GDALRasterBandShadow *optional_##GDALRasterBandShadow)*/
+     if (Tcl_ListObjLength(interp, objv[2], &arg2) != TCL_OK) {
+       /* Error msg in interp result */
+       SWIG_fail;
+     }
+     if ( !arg2 ) {
+       Tcl_SetResult(interp, (char*) "Input list mustn't be empty", TCL_STATIC);
+       SWIG_fail;
+     }
+     
+     arg3 = (GDALRasterBandShadow**) CPLMalloc(arg2*sizeof(GDALRasterBandShadow*));
+     
+     for( int i = 0; i<arg2; i++ ) {
+       Tcl_Obj **o = NULL;
+       if (Tcl_ListObjIndex(interp, objv[2], i, o) != TCL_OK) {
+         /* ref count is not incremented */
+         /* Error msg in interp result */
+         SWIG_fail;
+       }
+       /* No equivalent of SWIG_Python_GetSwigThis for Tcl in SWIG, but we can still use this */
+       //XXX
+       GDALRasterBandShadow* pointer = NULL;
+       SWIG_ConvertPtr( *o, (void**)&pointer, SWIGTYPE_p_GDALRasterBandShadow, SWIG_POINTER_EXCEPTION | 0 );
+       if (!pointer) {
+         SWIG_fail;
+       }
+       arg3[i] = pointer;
+     }
+   }
+   if (objc > 3) {
+     res4 = SWIG_AsCharPtrAndSize(objv[3], &buf4, NULL, &alloc4);
+     if (!SWIG_IsOK(res4)) {
+       SWIG_exception_fail(SWIG_ArgError(res4), "in method '" "RegenerateOverviews" "', argument " "4"" of type '" "char *""'");
+     }
+     arg4 = reinterpret_cast< char * >(buf4);
+   }
+   if (objc > 4) {
+     {
+       /* %typemap(in) (GDALProgressFunc callback = NULL) */
+       /* callback_func typemap */
+       if (objv[4] && !strcmp(Tcl_GetString(objv[4]), "")) {
+         void* cbfunction = NULL;
+         SWIG_ConvertPtr( objv[4], 
+           (void**)&cbfunction, 
+           SWIGTYPE_p_f_double_p_q_const__char_p_void__int, 
+           SWIG_POINTER_EXCEPTION | 0 );
+         
+         if ( cbfunction == GDALTermProgress ) {
+           arg5 = GDALTermProgress;
+         } else if ( cbfunction == GDALDummyProgress) {
+           arg5 = GDALDummyProgress;
+         } else if ( cbfunction == GDALScaledProgress) {
+           arg5 = GDALScaledProgress;
+         } else {
+           psProgressInfo->psTclCallback = objv[4];
+           Tcl_IncrRefCount(psProgressInfo->psTclCallback);
+           arg5 = TclProgressProxy;
+         }
+       }
+     }
+   }
+   if (objc > 5) {
+     {
+       /* %typemap(in) ( void* callback_data=NULL)  */
+       psProgressInfo->psTclCallbackData = objv[5];
+       Tcl_IncrRefCount(psProgressInfo->psTclCallbackData);
+       arg6 = psProgressInfo;
+       
+     }
+   }
+   {
+     CPLErrorReset();
+     result = (int)RegenerateOverviews(arg1,arg2,arg3,arg4,arg5,arg6);
+     CPLErr eclass = CPLGetLastErrorType();
+     if ( eclass == CE_Failure || eclass == CE_Fatal ) {
+       SWIG_exception( SWIG_RuntimeError, CPLGetLastErrorMsg() );
+       
+     }
+     
+     
+     
+     
+     
+     
+     
+     
+     
+     
+     
+   }
+   Tcl_SetObjResult(interp,SWIG_From_int(static_cast< int >(result)));
+   {
+     /* OBJECT_LIST_INPUT %typemap(freearg) (int object_list_count, GDALRasterBandShadow **poObjects)*/
+     CPLFree( arg3 );
+   }
+   if (alloc4 == SWIG_NEWOBJ) delete[] buf4;
+   {
+     /* %typemap(freearg) ( void* callback_data=NULL)  */
+     Tcl_DecrRefCount(psProgressInfo->psTclCallback);
+     Tcl_DecrRefCount(psProgressInfo->psTclCallbackData);
+     CPLFree(psProgressInfo);
+   }
+   return TCL_OK;
+ fail:
+   {
+     /* OBJECT_LIST_INPUT %typemap(freearg) (int object_list_count, GDALRasterBandShadow **poObjects)*/
+     CPLFree( arg3 );
+   }
+   if (alloc4 == SWIG_NEWOBJ) delete[] buf4;
+   {
+     /* %typemap(freearg) ( void* callback_data=NULL)  */
+     Tcl_DecrRefCount(psProgressInfo->psTclCallback);
+     Tcl_DecrRefCount(psProgressInfo->psTclCallbackData);
+     CPLFree(psProgressInfo);
+   }
+   return TCL_ERROR;
+ }
+ 
+ 
+ SWIGINTERN int
+ _wrap_RegenerateOverview(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
+   GDALRasterBandShadow *arg1 = (GDALRasterBandShadow *) 0 ;
+   GDALRasterBandShadow *arg2 = (GDALRasterBandShadow *) 0 ;
+   char *arg3 = (char *) 0 ;
+   GDALProgressFunc arg4 = (GDALProgressFunc) NULL ;
+   void *arg5 = (void *) NULL ;
+   void *argp1 = 0 ;
+   int res1 = 0 ;
+   void *argp2 = 0 ;
+   int res2 = 0 ;
+   int res3 ;
+   char *buf3 = 0 ;
+   int alloc3 = 0 ;
+   int result;
+   
+   /* %typemap(arginit) ( const char* callback_data=NULL)  */
+   TclProgressData *psProgressInfo;
+   psProgressInfo = (TclProgressData *) CPLCalloc(1,sizeof(TclProgressData));
+   psProgressInfo->nLastReported = -1;
+   psProgressInfo->interp = interp;
+   psProgressInfo->psTclCallback = NULL;
+   psProgressInfo->psTclCallbackData = NULL;
+   if (SWIG_GetArgs(interp, objc, objv,"ooo|oo:osgeo::RegenerateOverview srcBand overviewBand resampling ?callback? ?callback_data? ",(void *)0,(void *)0,(void *)0,(void *)0,(void *)0) == TCL_ERROR) SWIG_fail;
+   res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_GDALRasterBandShadow, 0 |  0 );
+   if (!SWIG_IsOK(res1)) {
+     SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "RegenerateOverview" "', argument " "1"" of type '" "GDALRasterBandShadow *""'"); 
+   }
+   arg1 = reinterpret_cast< GDALRasterBandShadow * >(argp1);
+   res2 = SWIG_ConvertPtr(objv[2], &argp2,SWIGTYPE_p_GDALRasterBandShadow, 0 |  0 );
+   if (!SWIG_IsOK(res2)) {
+     SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "RegenerateOverview" "', argument " "2"" of type '" "GDALRasterBandShadow *""'"); 
+   }
+   arg2 = reinterpret_cast< GDALRasterBandShadow * >(argp2);
+   res3 = SWIG_AsCharPtrAndSize(objv[3], &buf3, NULL, &alloc3);
+   if (!SWIG_IsOK(res3)) {
+     SWIG_exception_fail(SWIG_ArgError(res3), "in method '" "RegenerateOverview" "', argument " "3"" of type '" "char *""'");
+   }
+   arg3 = reinterpret_cast< char * >(buf3);
+   if (objc > 4) {
+     {
+       /* %typemap(in) (GDALProgressFunc callback = NULL) */
+       /* callback_func typemap */
+       if (objv[4] && !strcmp(Tcl_GetString(objv[4]), "")) {
+         void* cbfunction = NULL;
+         SWIG_ConvertPtr( objv[4], 
+           (void**)&cbfunction, 
+           SWIGTYPE_p_f_double_p_q_const__char_p_void__int, 
+           SWIG_POINTER_EXCEPTION | 0 );
+         
+         if ( cbfunction == GDALTermProgress ) {
+           arg4 = GDALTermProgress;
+         } else if ( cbfunction == GDALDummyProgress) {
+           arg4 = GDALDummyProgress;
+         } else if ( cbfunction == GDALScaledProgress) {
+           arg4 = GDALScaledProgress;
+         } else {
+           psProgressInfo->psTclCallback = objv[4];
+           Tcl_IncrRefCount(psProgressInfo->psTclCallback);
+           arg4 = TclProgressProxy;
+         }
+       }
+     }
+   }
+   if (objc > 5) {
+     {
+       /* %typemap(in) ( void* callback_data=NULL)  */
+       psProgressInfo->psTclCallbackData = objv[5];
+       Tcl_IncrRefCount(psProgressInfo->psTclCallbackData);
+       arg5 = psProgressInfo;
+       
+     }
+   }
+   {
+     CPLErrorReset();
+     result = (int)RegenerateOverview(arg1,arg2,arg3,arg4,arg5);
+     CPLErr eclass = CPLGetLastErrorType();
+     if ( eclass == CE_Failure || eclass == CE_Fatal ) {
+       SWIG_exception( SWIG_RuntimeError, CPLGetLastErrorMsg() );
+       
+     }
+     
+     
+     
+     
+     
+     
+     
+     
+     
+     
+     
+   }
+   Tcl_SetObjResult(interp,SWIG_From_int(static_cast< int >(result)));
+   if (alloc3 == SWIG_NEWOBJ) delete[] buf3;
+   {
+     /* %typemap(freearg) ( void* callback_data=NULL)  */
+     Tcl_DecrRefCount(psProgressInfo->psTclCallback);
+     Tcl_DecrRefCount(psProgressInfo->psTclCallbackData);
+     CPLFree(psProgressInfo);
+   }
+   return TCL_OK;
+ fail:
+   if (alloc3 == SWIG_NEWOBJ) delete[] buf3;
+   {
+     /* %typemap(freearg) ( void* callback_data=NULL)  */
+     Tcl_DecrRefCount(psProgressInfo->psTclCallback);
+     Tcl_DecrRefCount(psProgressInfo->psTclCallbackData);
+     CPLFree(psProgressInfo);
+   }
+   return TCL_ERROR;
+ }
+ 
+ 
+ SWIGINTERN int
+ _wrap_AutoCreateWarpedVRT(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
+   GDALDatasetShadow *arg1 = (GDALDatasetShadow *) 0 ;
+   char *arg2 = (char *) 0 ;
+   char *arg3 = (char *) 0 ;
+   GDALResampleAlg arg4 = (GDALResampleAlg) GRA_NearestNeighbour ;
+   double arg5 = (double) 0.0 ;
+   void *argp1 = 0 ;
+   int res1 = 0 ;
+   int res2 ;
+   char *buf2 = 0 ;
+   int alloc2 = 0 ;
+   int res3 ;
+   char *buf3 = 0 ;
+   int alloc3 = 0 ;
+   int val4 ;
+   int ecode4 = 0 ;
+   double val5 ;
+   int ecode5 = 0 ;
+   GDALDatasetShadow *result = 0 ;
+   
+   if (SWIG_GetArgs(interp, objc, objv,"o|oooo:osgeo::AutoCreateWarpedVRT src_ds ?src_wkt? ?dst_wkt? ?eResampleAlg? ?maxerror? ",(void *)0,(void *)0,(void *)0,(void *)0,(void *)0) == TCL_ERROR) SWIG_fail;
+   res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_GDALDatasetShadow, 0 |  0 );
+   if (!SWIG_IsOK(res1)) {
+     SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "AutoCreateWarpedVRT" "', argument " "1"" of type '" "GDALDatasetShadow *""'"); 
+   }
+   arg1 = reinterpret_cast< GDALDatasetShadow * >(argp1);
+   if (objc > 2) {
+     res2 = SWIG_AsCharPtrAndSize(objv[2], &buf2, NULL, &alloc2);
+     if (!SWIG_IsOK(res2)) {
+       SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "AutoCreateWarpedVRT" "', argument " "2"" of type '" "char const *""'");
+     }
+     arg2 = reinterpret_cast< char * >(buf2);
+   }
+   if (objc > 3) {
+     res3 = SWIG_AsCharPtrAndSize(objv[3], &buf3, NULL, &alloc3);
+     if (!SWIG_IsOK(res3)) {
+       SWIG_exception_fail(SWIG_ArgError(res3), "in method '" "AutoCreateWarpedVRT" "', argument " "3"" of type '" "char const *""'");
+     }
+     arg3 = reinterpret_cast< char * >(buf3);
+   }
+   if (objc > 4) {
+     ecode4 = SWIG_AsVal_int SWIG_TCL_CALL_ARGS_2(objv[4], &val4);
+     if (!SWIG_IsOK(ecode4)) {
+       SWIG_exception_fail(SWIG_ArgError(ecode4), "in method '" "AutoCreateWarpedVRT" "', argument " "4"" of type '" "GDALResampleAlg""'");
+     } 
+     arg4 = static_cast< GDALResampleAlg >(val4);
+   }
+   if (objc > 5) {
+     ecode5 = SWIG_AsVal_double SWIG_TCL_CALL_ARGS_2(objv[5], &val5);
+     if (!SWIG_IsOK(ecode5)) {
+       SWIG_exception_fail(SWIG_ArgError(ecode5), "in method '" "AutoCreateWarpedVRT" "', argument " "5"" of type '" "double""'");
+     } 
+     arg5 = static_cast< double >(val5);
+   }
+   {
+     CPLErrorReset();
+     result = (GDALDatasetShadow *)AutoCreateWarpedVRT(arg1,(char const *)arg2,(char const *)arg3,arg4,arg5);
+     CPLErr eclass = CPLGetLastErrorType();
+     if ( eclass == CE_Failure || eclass == CE_Fatal ) {
+       SWIG_exception( SWIG_RuntimeError, CPLGetLastErrorMsg() );
+       
+     }
+     
+     
+     
+     
+     
+     
+     
+     
+     
+     
+     
+   }
+   Tcl_SetObjResult(interp, SWIG_NewInstanceObj( SWIG_as_voidptr(result), SWIGTYPE_p_GDALDatasetShadow,0));
+   if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
+   if (alloc3 == SWIG_NEWOBJ) delete[] buf3;
+   return TCL_OK;
+ fail:
+   if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
+   if (alloc3 == SWIG_NEWOBJ) delete[] buf3;
+   return TCL_ERROR;
+ }
+ 
+ 
+ SWIGINTERN int
+ _wrap_new_Transformer(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
+   GDALDatasetShadow *arg1 = (GDALDatasetShadow *) 0 ;
+   GDALDatasetShadow *arg2 = (GDALDatasetShadow *) 0 ;
+   char **arg3 = (char **) 0 ;
+   void *argp1 = 0 ;
+   int res1 = 0 ;
+   void *argp2 = 0 ;
+   int res2 = 0 ;
+   GDALTransformerInfoShadow *result = 0 ;
+   
+   if (SWIG_GetArgs(interp, objc, objv,"ooo:osgeo::new_Transformer src dst options ",(void *)0,(void *)0,(void *)0) == TCL_ERROR) SWIG_fail;
+   res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_GDALDatasetShadow, 0 |  0 );
+   if (!SWIG_IsOK(res1)) {
+     SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "new_Transformer" "', argument " "1"" of type '" "GDALDatasetShadow *""'"); 
+   }
+   arg1 = reinterpret_cast< GDALDatasetShadow * >(argp1);
+   res2 = SWIG_ConvertPtr(objv[2], &argp2,SWIGTYPE_p_GDALDatasetShadow, 0 |  0 );
+   if (!SWIG_IsOK(res2)) {
+     SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "new_Transformer" "', argument " "2"" of type '" "GDALDatasetShadow *""'"); 
+   }
+   arg2 = reinterpret_cast< GDALDatasetShadow * >(argp2);
+   {
+     /* %typemap(in) char **options */
+     int size;
+     if (Tcl_ListObjLength(interp, objv[3], &size) != TCL_OK) {
+       /* Error msg in interp result */
+       SWIG_fail;
+     }
+     if ( !size ) {
+       Tcl_SetResult(interp, (char*) "Input list mustn't be empty", TCL_STATIC);
+       SWIG_fail;
+     }
+     
+     for (int i = 0; i < size; i++) {
+       Tcl_Obj **o = NULL;
+       /* The reference count for the list element is not incremented with the following */
+       if (Tcl_ListObjIndex(interp, objv[3], i, o) != TCL_OK) {
+         /* Error msg in interp result */
+         SWIG_fail;
+       }
+       char *pszItem = Tcl_GetString(*o);
+       arg3 = CSLAddString( arg3, pszItem );
+     }
+   }
+   {
+     CPLErrorReset();
+     result = (GDALTransformerInfoShadow *)new_GDALTransformerInfoShadow(arg1,arg2,arg3);
+     CPLErr eclass = CPLGetLastErrorType();
+     if ( eclass == CE_Failure || eclass == CE_Fatal ) {
+       SWIG_exception( SWIG_RuntimeError, CPLGetLastErrorMsg() );
+       
+     }
+     
+     
+     
+     
+     
+     
+     
+     
+     
+     
+     
+   }
+   Tcl_SetObjResult(interp, SWIG_NewInstanceObj( SWIG_as_voidptr(result), SWIGTYPE_p_GDALTransformerInfoShadow,0));
+   {
+     /* %typemap(freearg) char **options */
+     CSLDestroy( arg3 );
+   }
+   return TCL_OK;
+ fail:
+   {
+     /* %typemap(freearg) char **options */
+     CSLDestroy( arg3 );
+   }
+   return TCL_ERROR;
+ }
+ 
+ 
+ SWIGINTERN int
+ _wrap_delete_Transformer(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
+   GDALTransformerInfoShadow *arg1 = (GDALTransformerInfoShadow *) 0 ;
+   void *argp1 = 0 ;
+   int res1 = 0 ;
+   
+   if (SWIG_GetArgs(interp, objc, objv,"o:osgeo::delete_Transformer self ",(void *)0) == TCL_ERROR) SWIG_fail;
+   res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_GDALTransformerInfoShadow, SWIG_POINTER_DISOWN |  0 );
+   if (!SWIG_IsOK(res1)) {
+     SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "delete_Transformer" "', argument " "1"" of type '" "GDALTransformerInfoShadow *""'"); 
+   }
+   arg1 = reinterpret_cast< GDALTransformerInfoShadow * >(argp1);
+   {
+     CPLErrorReset();
+     delete_GDALTransformerInfoShadow(arg1);
+     CPLErr eclass = CPLGetLastErrorType();
+     if ( eclass == CE_Failure || eclass == CE_Fatal ) {
+       SWIG_exception( SWIG_RuntimeError, CPLGetLastErrorMsg() );
+       
+     }
+     
+     
+     
+     
+     
+     
+     
+     
+     
+     
+     
+   }
+   
+   return TCL_OK;
+ fail:
+   return TCL_ERROR;
+ }
+ 
+ 
+ SWIGINTERN int
+ _wrap_Transformer_TransformPoint__SWIG_0(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
+   GDALTransformerInfoShadow *arg1 = (GDALTransformerInfoShadow *) 0 ;
+   int arg2 ;
+   double *arg3 ;
+   void *argp1 = 0 ;
+   int res1 = 0 ;
+   int val2 ;
+   int ecode2 = 0 ;
+   double argin3[3] ;
+   int result;
+   
+   if (SWIG_GetArgs(interp, objc, objv,"ooo:osgeo::Transformer_TransformPoint self bDstToSrc inout ",(void *)0,(void *)0,(void *)0) == TCL_ERROR) SWIG_fail;
+   res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_GDALTransformerInfoShadow, 0 |  0 );
+   if (!SWIG_IsOK(res1)) {
+     SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Transformer_TransformPoint" "', argument " "1"" of type '" "GDALTransformerInfoShadow *""'"); 
+   }
+   arg1 = reinterpret_cast< GDALTransformerInfoShadow * >(argp1);
+   ecode2 = SWIG_AsVal_int SWIG_TCL_CALL_ARGS_2(objv[2], &val2);
+   if (!SWIG_IsOK(ecode2)) {
+     SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "Transformer_TransformPoint" "', argument " "2"" of type '" "int""'");
+   } 
+   arg2 = static_cast< int >(val2);
+   {
+     /* %typemap(in) (double argin3[ANY]) */
+     arg3 = argin3;
+     int lst_size;
+     /* The following also checks if input is a list */
+     if (Tcl_ListObjLength(interp, objv[3], &lst_size) != TCL_OK) {
+       /* Error msg in interp result */
+       SWIG_fail;
+     }
+     if ( lst_size != 3 ) {
+       Tcl_SetResult(interp, (char*) "List must have length ##size", TCL_STATIC);
+       SWIG_fail;
+     }
+     for (unsigned int i=0; i<3; i++) {
+       Tcl_Obj **o = NULL;
+       if (Tcl_ListObjIndex(interp, objv[3], i, o) != TCL_OK) {
+         /* ref count is not incremented */
+         /* Error msg in interp result */
+         SWIG_fail;
+       }
+       
+       double val;
+       if (Tcl_GetDoubleFromObj(interp, *o, &val ) != TCL_OK) {
+         /* Error msg in interp result */
+         SWIG_fail;
+       }
+       arg3[i] = val;
+     }
+   }
+   {
+     CPLErrorReset();
+     result = (int)GDALTransformerInfoShadow_TransformPoint__SWIG_0(arg1,arg2,arg3);
+     CPLErr eclass = CPLGetLastErrorType();
+     if ( eclass == CE_Failure || eclass == CE_Fatal ) {
+       SWIG_exception( SWIG_RuntimeError, CPLGetLastErrorMsg() );
+       
+     }
+     
+     
+     
+     
+     
+     
+     
+     
+     
+     
+     
+   }
+   Tcl_SetObjResult(interp,SWIG_From_int(static_cast< int >(result)));
+   {
+     /* %typemap(argout) (double argout[ANY]) */
+     Tcl_Obj *out = CreateListFromDoubleArray( interp, arg3, 3 );
+     if (out == NULL) SWIG_fail;
+     Tcl_ListObjAppendElement(interp,Tcl_GetObjResult(interp),out);
+   }
+   return TCL_OK;
+ fail:
+   return TCL_ERROR;
+ }
+ 
+ 
+ SWIGINTERN int
+ _wrap_Transformer_TransformPoint__SWIG_1(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
+   GDALTransformerInfoShadow *arg1 = (GDALTransformerInfoShadow *) 0 ;
+   double *arg2 ;
+   int arg3 ;
+   double arg4 ;
+   double arg5 ;
+   double arg6 = (double) 0.0 ;
+   void *argp1 = 0 ;
+   int res1 = 0 ;
+   double argout2[3] ;
+   int val3 ;
+   int ecode3 = 0 ;
+   double val4 ;
+   int ecode4 = 0 ;
+   double val5 ;
+   int ecode5 = 0 ;
+   double val6 ;
+   int ecode6 = 0 ;
+   int result;
+   
+   {
+     /* %typemap(in,numinputs=0) (double argout2[ANY]) */
+     arg2 = argout2;
+   }
+   if (SWIG_GetArgs(interp, objc, objv,"oooo|o:osgeo::Transformer_TransformPoint self bDstToSrc x y ?z? ",(void *)0,(void *)0,(void *)0,(void *)0,(void *)0) == TCL_ERROR) SWIG_fail;
+   res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_GDALTransformerInfoShadow, 0 |  0 );
+   if (!SWIG_IsOK(res1)) {
+     SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Transformer_TransformPoint" "', argument " "1"" of type '" "GDALTransformerInfoShadow *""'"); 
+   }
+   arg1 = reinterpret_cast< GDALTransformerInfoShadow * >(argp1);
+   ecode3 = SWIG_AsVal_int SWIG_TCL_CALL_ARGS_2(objv[2], &val3);
+   if (!SWIG_IsOK(ecode3)) {
+     SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "Transformer_TransformPoint" "', argument " "3"" of type '" "int""'");
+   } 
+   arg3 = static_cast< int >(val3);
+   ecode4 = SWIG_AsVal_double SWIG_TCL_CALL_ARGS_2(objv[3], &val4);
+   if (!SWIG_IsOK(ecode4)) {
+     SWIG_exception_fail(SWIG_ArgError(ecode4), "in method '" "Transformer_TransformPoint" "', argument " "4"" of type '" "double""'");
+   } 
+   arg4 = static_cast< double >(val4);
+   ecode5 = SWIG_AsVal_double SWIG_TCL_CALL_ARGS_2(objv[4], &val5);
+   if (!SWIG_IsOK(ecode5)) {
+     SWIG_exception_fail(SWIG_ArgError(ecode5), "in method '" "Transformer_TransformPoint" "', argument " "5"" of type '" "double""'");
+   } 
+   arg5 = static_cast< double >(val5);
+   if (objc > 5) {
+     ecode6 = SWIG_AsVal_double SWIG_TCL_CALL_ARGS_2(objv[5], &val6);
+     if (!SWIG_IsOK(ecode6)) {
+       SWIG_exception_fail(SWIG_ArgError(ecode6), "in method '" "Transformer_TransformPoint" "', argument " "6"" of type '" "double""'");
+     } 
+     arg6 = static_cast< double >(val6);
+   }
+   {
+     CPLErrorReset();
+     result = (int)GDALTransformerInfoShadow_TransformPoint__SWIG_1(arg1,arg2,arg3,arg4,arg5,arg6);
+     CPLErr eclass = CPLGetLastErrorType();
+     if ( eclass == CE_Failure || eclass == CE_Fatal ) {
+       SWIG_exception( SWIG_RuntimeError, CPLGetLastErrorMsg() );
+       
+     }
+     
+     
+     
+     
+     
+     
+     
+     
+     
+     
+     
+   }
+   Tcl_SetObjResult(interp,SWIG_From_int(static_cast< int >(result)));
+   {
+     /* %typemap(argout) (double argout[ANY]) */
+     Tcl_Obj *out = CreateListFromDoubleArray( interp, arg2, 3 );
+     if (out == NULL) SWIG_fail;
+     Tcl_ListObjAppendElement(interp,Tcl_GetObjResult(interp),out);
+   }
+   return TCL_OK;
+ fail:
+   return TCL_ERROR;
+ }
+ 
+ 
+ SWIGINTERN int
+ _wrap_Transformer_TransformPoint(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
+   Tcl_Obj *CONST *argv = objv+1;
+   int argc = objc-1;
+   if (argc == 3) {
+     int _v;
+     void *vptr = 0;
+     int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_GDALTransformerInfoShadow, 0);
+     _v = SWIG_CheckState(res);
+     if (_v) {
+       {
+         int res = SWIG_AsVal_int SWIG_TCL_CALL_ARGS_2(argv[1], NULL);
+         _v = SWIG_CheckState(res);
+       }
+       if (_v) {
+         void *vptr = 0;
+         int res = SWIG_ConvertPtr(argv[2], &vptr, SWIGTYPE_p_double, 0);
+         _v = SWIG_CheckState(res);
+         if (_v) {
+           return _wrap_Transformer_TransformPoint__SWIG_0(clientData, interp, objc, argv - 1);
+         }
+       }
+     }
+   }
+   if ((argc >= 4) && (argc <= 5)) {
+     int _v;
+     void *vptr = 0;
+     int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_GDALTransformerInfoShadow, 0);
+     _v = SWIG_CheckState(res);
+     if (_v) {
+       {
+         int res = SWIG_AsVal_int SWIG_TCL_CALL_ARGS_2(argv[1], NULL);
+         _v = SWIG_CheckState(res);
+       }
+       if (_v) {
+         {
+           int res = SWIG_AsVal_double SWIG_TCL_CALL_ARGS_2(argv[2], NULL);
+           _v = SWIG_CheckState(res);
+         }
+         if (_v) {
+           {
+             int res = SWIG_AsVal_double SWIG_TCL_CALL_ARGS_2(argv[3], NULL);
+             _v = SWIG_CheckState(res);
+           }
+           if (_v) {
+             if (argc <= 4) {
+               return _wrap_Transformer_TransformPoint__SWIG_1(clientData, interp, objc, argv - 1);
+             }
+             {
+               int res = SWIG_AsVal_double SWIG_TCL_CALL_ARGS_2(argv[4], NULL);
+               _v = SWIG_CheckState(res);
+             }
+             if (_v) {
+               return _wrap_Transformer_TransformPoint__SWIG_1(clientData, interp, objc, argv - 1);
+             }
+           }
+         }
+       }
+     }
+   }
+   
+   Tcl_SetResult(interp,(char *) "No matching function for overloaded 'Transformer_TransformPoint'", TCL_STATIC);
+   return TCL_ERROR;
+ }
+ 
+ 
+ SWIGINTERN int
+ _wrap_Transformer_TransformPoints(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
+   GDALTransformerInfoShadow *arg1 = (GDALTransformerInfoShadow *) 0 ;
+   int arg2 ;
+   int arg3 ;
+   double *arg4 = (double *) 0 ;
+   double *arg5 = (double *) 0 ;
+   double *arg6 = (double *) 0 ;
+   int *arg7 = (int *) 0 ;
+   void *argp1 = 0 ;
+   int res1 = 0 ;
+   int val2 ;
+   int ecode2 = 0 ;
+   int result;
+   
+   if (SWIG_GetArgs(interp, objc, objv,"ooo:osgeo::Transformer_TransformPoints self bDstToSrc nCount ?x? ?y? ?z? ?panSuccess? ",(void *)0,(void *)0,(void *)0) == TCL_ERROR) SWIG_fail;
+   res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_GDALTransformerInfoShadow, 0 |  0 );
+   if (!SWIG_IsOK(res1)) {
+     SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Transformer_TransformPoints" "', argument " "1"" of type '" "GDALTransformerInfoShadow *""'"); 
+   }
+   arg1 = reinterpret_cast< GDALTransformerInfoShadow * >(argp1);
+   ecode2 = SWIG_AsVal_int SWIG_TCL_CALL_ARGS_2(objv[2], &val2);
+   if (!SWIG_IsOK(ecode2)) {
+     SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "Transformer_TransformPoints" "', argument " "2"" of type '" "int""'");
+   } 
+   arg2 = static_cast< int >(val2);
+   {
+     /*  typemap(in,numinputs=1) (int nCount, double *x, double *y, double *z, int* panSuccess) */
+     /* The following also checks if input is a list */
+     if (Tcl_ListObjLength(interp, objv[3], &arg3) != TCL_OK) {
+       /* Error msg in interp result */
+       SWIG_fail;
+     }
+     if ( !arg3 ) {
+       Tcl_SetResult(interp, (char*) "Input list mustn't be empty", TCL_STATIC);
+       SWIG_fail;
+     }
+     arg4 = (double*) CPLMalloc(arg3*sizeof(double));
+     arg5 = (double*) CPLMalloc(arg3*sizeof(double));
+     arg6 = (double*) CPLMalloc(arg3*sizeof(double));
+     arg7 = (int*) CPLMalloc(arg3*sizeof(int));
+     
+     for( int i = 0; i<arg3; i++ ) {
+       Tcl_Obj **o = NULL;
+       if (Tcl_ListObjIndex(interp, objv[3], i, o) != TCL_OK) {
+         /* ref count is not incremented */
+         /* Error msg in interp result */
+         SWIG_fail;
+       }
+       
+       int size;
+       if (Tcl_ListObjLength(interp, *o, &size) != TCL_OK) {
+         /* Error msg in interp result */
+         SWIG_fail;
+       }
+       if ( size < 2 || size > 3 ) {
+         Tcl_SetResult(interp, (char*) "Not a list of 2 or 3 doubles", TCL_STATIC);
+         SWIG_fail;
+       }
+       
+       double x, y, z = 0;
+       Tcl_Obj **o2 = NULL;
+       if (Tcl_ListObjIndex(interp, *o, 0, o2) != TCL_OK) {
+         /* ref count is not incremented */
+         /* Error msg in interp result */
+         SWIG_fail;
+       }
+       if (Tcl_GetDoubleFromObj(interp, *o2, &x ) != TCL_OK) {
+         /* Error msg in interp result */
+         SWIG_fail;
+       }
+       
+       if (Tcl_ListObjIndex(interp, *o, 1, o2) != TCL_OK) {
+         /* ref count is not incremented */
+         /* Error msg in interp result */
+         SWIG_fail;
+       }
+       if (Tcl_GetDoubleFromObj(interp, *o2, &y ) != TCL_OK) {
+         /* Error msg in interp result */
+         SWIG_fail;
+       }
+       
+       if (size == 3) {
+         if (Tcl_ListObjIndex(interp, *o, 2, o2) != TCL_OK) {
+           /* ref count is not incremented */
+           /* Error msg in interp result */
+           SWIG_fail;
+         }
+         if (Tcl_GetDoubleFromObj(interp, *o2, &z ) != TCL_OK) {
+           /* Error msg in interp result */
+           SWIG_fail;
+         }
+       }
+       
+       (arg4)[i] = x;
+       (arg5)[i] = y;
+       (arg6)[i] = z;
+     }
+   }
+   {
+     CPLErrorReset();
+     result = (int)GDALTransformerInfoShadow_TransformPoints(arg1,arg2,arg3,arg4,arg5,arg6,arg7);
+     CPLErr eclass = CPLGetLastErrorType();
+     if ( eclass == CE_Failure || eclass == CE_Fatal ) {
+       SWIG_exception( SWIG_RuntimeError, CPLGetLastErrorMsg() );
+       
+     }
+     
+     
+     
+     
+     
+     
+     
+     
+     
+     
+     
+   }
+   Tcl_SetObjResult(interp,SWIG_From_int(static_cast< int >(result)));
+   {
+     /* %typemap(argout)  (int nCount, double *x, double *y, double *z, int* panSuccess) */
+     Tcl_Obj *xyz = Tcl_NewListObj(0, NULL);
+     Tcl_Obj *success = Tcl_NewListObj(0, NULL);
+     for( int i=0; i< arg3; i++ ) {
+       Tcl_Obj *tuple = Tcl_NewListObj(0, NULL);
+       Tcl_Obj *val = Tcl_NewDoubleObj((arg4)[i] );
+       if (Tcl_ListObjAppendElement(interp, tuple, val) != TCL_OK) {
+         Tcl_DecrRefCount(val);
+         Tcl_DecrRefCount(tuple);
+         Tcl_DecrRefCount(xyz);
+         Tcl_DecrRefCount(success);
+         /* Error msg in interp result */
+         SWIG_fail;
+       }
+       val = Tcl_NewDoubleObj((arg5)[i] );
+       if (Tcl_ListObjAppendElement(interp, tuple, val) != TCL_OK) {
+         Tcl_DecrRefCount(val);
+         Tcl_DecrRefCount(tuple);
+         Tcl_DecrRefCount(xyz);
+         Tcl_DecrRefCount(success);
+         /* Error msg in interp result */
+         SWIG_fail;
+       }
+       val = Tcl_NewDoubleObj((arg6)[i] );
+       if (Tcl_ListObjAppendElement(interp, tuple, val) != TCL_OK) {
+         Tcl_DecrRefCount(val);
+         Tcl_DecrRefCount(tuple);
+         Tcl_DecrRefCount(xyz);
+         Tcl_DecrRefCount(success);
+         /* Error msg in interp result */
+         SWIG_fail;
+       }
+       
+       if (Tcl_ListObjAppendElement(interp, xyz, tuple) != TCL_OK) {
+         Tcl_DecrRefCount(tuple);
+         Tcl_DecrRefCount(xyz);
+         Tcl_DecrRefCount(success);
+         /* Error msg in interp result */
+         SWIG_fail;
+       }
+       
+       val = Tcl_NewIntObj((arg7)[i] );
+       if (Tcl_ListObjAppendElement(interp, success, val) != TCL_OK) {
+         Tcl_DecrRefCount(val);
+         Tcl_DecrRefCount(xyz);
+         Tcl_DecrRefCount(success);
+         /* Error msg in interp result */
+         SWIG_fail;
+       }
+     }
+     
+     Tcl_Obj *out = Tcl_NewListObj(0, NULL);
+     if (Tcl_ListObjAppendElement(interp, out, xyz) != TCL_OK) {
+       Tcl_DecrRefCount(xyz);
+       Tcl_DecrRefCount(out);
+       Tcl_DecrRefCount(success);
+       /* Error msg in interp result */
+       SWIG_fail;
+     }
+     if (Tcl_ListObjAppendElement(interp, out, success) != TCL_OK) {
+       Tcl_DecrRefCount(success);
+       Tcl_DecrRefCount(out);
+       /* Error msg in interp result */
+       SWIG_fail;
+     }
+     Tcl_SetObjResult(interp, out);
+   }
+   {
+     /* %typemap(freearg)  (int nCount, double *x, double *y, double *z, int* panSuccess) */
+     CPLFree(arg4);
+     CPLFree(arg5);
+     CPLFree(arg6);
+     CPLFree(arg7);
+   }
+   return TCL_OK;
+ fail:
+   {
+     /* %typemap(freearg)  (int nCount, double *x, double *y, double *z, int* panSuccess) */
+     CPLFree(arg4);
+     CPLFree(arg5);
+     CPLFree(arg6);
+     CPLFree(arg7);
+   }
+   return TCL_ERROR;
+ }
+ 
+ 
+ SWIGINTERN void swig_delete_Transformer(void *obj) {
+ GDALTransformerInfoShadow *arg1 = (GDALTransformerInfoShadow *) obj;
+ delete_GDALTransformerInfoShadow(arg1);
+ }
+ static swig_method swig_GDALTransformerInfoShadow_methods[] = {
+     {"TransformPoint", _wrap_Transformer_TransformPoint}, 
+     {"TransformPoints", _wrap_Transformer_TransformPoints}, 
+     {0,0}
+ };
+ static swig_attribute swig_GDALTransformerInfoShadow_attributes[] = {
+     {0,0,0}
+ };
+ static swig_class *swig_GDALTransformerInfoShadow_bases[] = {0};
+ static const char * swig_GDALTransformerInfoShadow_base_names[] = {0};
+ static swig_class _wrap_class_GDALTransformerInfoShadow = { "Transformer", &SWIGTYPE_p_GDALTransformerInfoShadow,_wrap_new_Transformer, swig_delete_Transformer, swig_GDALTransformerInfoShadow_methods, swig_GDALTransformerInfoShadow_attributes, swig_GDALTransformerInfoShadow_bases,swig_GDALTransformerInfoShadow_base_names, &swig_module };
+ SWIGINTERN int
+ _wrap_VersionInfo(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
+   char *arg1 = (char *) "VERSION_NUM" ;
+   int res1 ;
+   char *buf1 = 0 ;
+   int alloc1 = 0 ;
+   char *result = 0 ;
+   
+   if (SWIG_GetArgs(interp, objc, objv,"|o:osgeo::VersionInfo ?request? ",(void *)0) == TCL_ERROR) SWIG_fail;
+   if (objc > 1) {
+     res1 = SWIG_AsCharPtrAndSize(objv[1], &buf1, NULL, &alloc1);
+     if (!SWIG_IsOK(res1)) {
+       SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "VersionInfo" "', argument " "1"" of type '" "char const *""'");
+     }
+     arg1 = reinterpret_cast< char * >(buf1);
+   }
+   {
+     CPLErrorReset();
+     result = (char *)GDALVersionInfo((char const *)arg1);
+     CPLErr eclass = CPLGetLastErrorType();
+     if ( eclass == CE_Failure || eclass == CE_Fatal ) {
+       SWIG_exception( SWIG_RuntimeError, CPLGetLastErrorMsg() );
+       
+     }
+     
+     
+     
+     
+     
+     
+     
+     
+     
+     
+     
+   }
+   Tcl_SetObjResult(interp,SWIG_FromCharPtr((const char *)result));
+   if (alloc1 == SWIG_NEWOBJ) delete[] buf1;
+   return TCL_OK;
+ fail:
+   if (alloc1 == SWIG_NEWOBJ) delete[] buf1;
+   return TCL_ERROR;
+ }
+ 
+ 
+ SWIGINTERN int
+ _wrap_AllRegister(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
+   if (SWIG_GetArgs(interp, objc, objv,":osgeo::AllRegister ") == TCL_ERROR) SWIG_fail;
+   {
+     CPLErrorReset();
+     GDALAllRegister();
+     CPLErr eclass = CPLGetLastErrorType();
+     if ( eclass == CE_Failure || eclass == CE_Fatal ) {
+       SWIG_exception( SWIG_RuntimeError, CPLGetLastErrorMsg() );
+       
+     }
+     
+     
+     
+     
+     
+     
+     
+     
+     
+     
+     
+   }
+   
+   return TCL_OK;
+ fail:
+   return TCL_ERROR;
+ }
+ 
+ 
+ SWIGINTERN int
+ _wrap_GDALDestroyDriverManager(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
+   if (SWIG_GetArgs(interp, objc, objv,":osgeo::GDALDestroyDriverManager ") == TCL_ERROR) SWIG_fail;
+   {
+     CPLErrorReset();
+     GDALDestroyDriverManager();
+     CPLErr eclass = CPLGetLastErrorType();
+     if ( eclass == CE_Failure || eclass == CE_Fatal ) {
+       SWIG_exception( SWIG_RuntimeError, CPLGetLastErrorMsg() );
+       
+     }
+     
+     
+     
+     
+     
+     
+     
+     
+     
+     
+     
+   }
+   
+   return TCL_OK;
+ fail:
+   return TCL_ERROR;
+ }
+ 
+ 
+ SWIGINTERN int
+ _wrap_GetCacheMax(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
+   int result;
+   
+   if (SWIG_GetArgs(interp, objc, objv,":osgeo::GetCacheMax ") == TCL_ERROR) SWIG_fail;
+   {
+     CPLErrorReset();
+     result = (int)GDALGetCacheMax();
+     CPLErr eclass = CPLGetLastErrorType();
+     if ( eclass == CE_Failure || eclass == CE_Fatal ) {
+       SWIG_exception( SWIG_RuntimeError, CPLGetLastErrorMsg() );
+       
+     }
+     
+     
+     
+     
+     
+     
+     
+     
+     
+     
+     
+   }
+   Tcl_SetObjResult(interp,SWIG_From_int(static_cast< int >(result)));
+   return TCL_OK;
+ fail:
+   return TCL_ERROR;
+ }
+ 
+ 
+ SWIGINTERN int
+ _wrap_SetCacheMax(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
+   int arg1 ;
+   int val1 ;
+   int ecode1 = 0 ;
+   
+   if (SWIG_GetArgs(interp, objc, objv,"o:osgeo::SetCacheMax nBytes ",(void *)0) == TCL_ERROR) SWIG_fail;
+   ecode1 = SWIG_AsVal_int SWIG_TCL_CALL_ARGS_2(objv[1], &val1);
+   if (!SWIG_IsOK(ecode1)) {
+     SWIG_exception_fail(SWIG_ArgError(ecode1), "in method '" "SetCacheMax" "', argument " "1"" of type '" "int""'");
+   } 
+   arg1 = static_cast< int >(val1);
+   {
+     CPLErrorReset();
+     GDALSetCacheMax(arg1);
+     CPLErr eclass = CPLGetLastErrorType();
+     if ( eclass == CE_Failure || eclass == CE_Fatal ) {
+       SWIG_exception( SWIG_RuntimeError, CPLGetLastErrorMsg() );
+       
+     }
+     
+     
+     
+     
+     
+     
+     
+     
+     
+     
+     
+   }
+   
+   return TCL_OK;
+ fail:
+   return TCL_ERROR;
+ }
+ 
+ 
+ SWIGINTERN int
+ _wrap_GetCacheUsed(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
+   int result;
+   
+   if (SWIG_GetArgs(interp, objc, objv,":osgeo::GetCacheUsed ") == TCL_ERROR) SWIG_fail;
+   {
+     CPLErrorReset();
+     result = (int)GDALGetCacheUsed();
+     CPLErr eclass = CPLGetLastErrorType();
+     if ( eclass == CE_Failure || eclass == CE_Fatal ) {
+       SWIG_exception( SWIG_RuntimeError, CPLGetLastErrorMsg() );
+       
+     }
+     
+     
+     
+     
+     
+     
+     
+     
+     
+     
+     
+   }
+   Tcl_SetObjResult(interp,SWIG_From_int(static_cast< int >(result)));
+   return TCL_OK;
+ fail:
+   return TCL_ERROR;
+ }
+ 
+ 
+ SWIGINTERN int
+ _wrap_GetDataTypeSize(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
+   GDALDataType arg1 ;
+   int val1 ;
+   int ecode1 = 0 ;
+   int result;
+   
+   if (SWIG_GetArgs(interp, objc, objv,"o:osgeo::GetDataTypeSize GDALDataType ",(void *)0) == TCL_ERROR) SWIG_fail;
+   ecode1 = SWIG_AsVal_int SWIG_TCL_CALL_ARGS_2(objv[1], &val1);
+   if (!SWIG_IsOK(ecode1)) {
+     SWIG_exception_fail(SWIG_ArgError(ecode1), "in method '" "GetDataTypeSize" "', argument " "1"" of type '" "GDALDataType""'");
+   } 
+   arg1 = static_cast< GDALDataType >(val1);
+   {
+     CPLErrorReset();
+     result = (int)GDALGetDataTypeSize(arg1);
+     CPLErr eclass = CPLGetLastErrorType();
+     if ( eclass == CE_Failure || eclass == CE_Fatal ) {
+       SWIG_exception( SWIG_RuntimeError, CPLGetLastErrorMsg() );
+       
+     }
+     
+     
+     
+     
+     
+     
+     
+     
+     
+     
+     
+   }
+   Tcl_SetObjResult(interp,SWIG_From_int(static_cast< int >(result)));
+   return TCL_OK;
+ fail:
+   return TCL_ERROR;
+ }
+ 
+ 
+ SWIGINTERN int
+ _wrap_DataTypeIsComplex(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
+   GDALDataType arg1 ;
+   int val1 ;
+   int ecode1 = 0 ;
+   int result;
+   
+   if (SWIG_GetArgs(interp, objc, objv,"o:osgeo::DataTypeIsComplex GDALDataType ",(void *)0) == TCL_ERROR) SWIG_fail;
+   ecode1 = SWIG_AsVal_int SWIG_TCL_CALL_ARGS_2(objv[1], &val1);
+   if (!SWIG_IsOK(ecode1)) {
+     SWIG_exception_fail(SWIG_ArgError(ecode1), "in method '" "DataTypeIsComplex" "', argument " "1"" of type '" "GDALDataType""'");
+   } 
+   arg1 = static_cast< GDALDataType >(val1);
+   {
+     CPLErrorReset();
+     result = (int)GDALDataTypeIsComplex(arg1);
+     CPLErr eclass = CPLGetLastErrorType();
+     if ( eclass == CE_Failure || eclass == CE_Fatal ) {
+       SWIG_exception( SWIG_RuntimeError, CPLGetLastErrorMsg() );
+       
+     }
+     
+     
+     
+     
+     
+     
+     
+     
+     
+     
+     
+   }
+   Tcl_SetObjResult(interp,SWIG_From_int(static_cast< int >(result)));
+   return TCL_OK;
+ fail:
+   return TCL_ERROR;
+ }
+ 
+ 
+ SWIGINTERN int
+ _wrap_GetDataTypeName(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
+   GDALDataType arg1 ;
+   int val1 ;
+   int ecode1 = 0 ;
+   char *result = 0 ;
+   
+   if (SWIG_GetArgs(interp, objc, objv,"o:osgeo::GetDataTypeName GDALDataType ",(void *)0) == TCL_ERROR) SWIG_fail;
+   ecode1 = SWIG_AsVal_int SWIG_TCL_CALL_ARGS_2(objv[1], &val1);
+   if (!SWIG_IsOK(ecode1)) {
+     SWIG_exception_fail(SWIG_ArgError(ecode1), "in method '" "GetDataTypeName" "', argument " "1"" of type '" "GDALDataType""'");
+   } 
+   arg1 = static_cast< GDALDataType >(val1);
+   {
+     CPLErrorReset();
+     result = (char *)GDALGetDataTypeName(arg1);
+     CPLErr eclass = CPLGetLastErrorType();
+     if ( eclass == CE_Failure || eclass == CE_Fatal ) {
+       SWIG_exception( SWIG_RuntimeError, CPLGetLastErrorMsg() );
+       
+     }
+     
+     
+     
+     
+     
+     
+     
+     
+     
+     
+     
+   }
+   Tcl_SetObjResult(interp,SWIG_FromCharPtr((const char *)result));
+   return TCL_OK;
+ fail:
+   return TCL_ERROR;
+ }
+ 
+ 
+ SWIGINTERN int
+ _wrap_GetDataTypeByName(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
+   char *arg1 = (char *) 0 ;
+   int res1 ;
+   char *buf1 = 0 ;
+   int alloc1 = 0 ;
+   GDALDataType result;
+   
+   if (SWIG_GetArgs(interp, objc, objv,"o:osgeo::GetDataTypeByName char const * ",(void *)0) == TCL_ERROR) SWIG_fail;
+   res1 = SWIG_AsCharPtrAndSize(objv[1], &buf1, NULL, &alloc1);
+   if (!SWIG_IsOK(res1)) {
+     SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "GetDataTypeByName" "', argument " "1"" of type '" "char const *""'");
+   }
+   arg1 = reinterpret_cast< char * >(buf1);
+   {
+     CPLErrorReset();
+     result = (GDALDataType)GDALGetDataTypeByName((char const *)arg1);
+     CPLErr eclass = CPLGetLastErrorType();
+     if ( eclass == CE_Failure || eclass == CE_Fatal ) {
+       SWIG_exception( SWIG_RuntimeError, CPLGetLastErrorMsg() );
+       
+     }
+     
+     
+     
+     
+     
+     
+     
+     
+     
+     
+     
+   }
+   Tcl_SetObjResult(interp,SWIG_From_int(static_cast< int >(result)));
+   if (alloc1 == SWIG_NEWOBJ) delete[] buf1;
+   return TCL_OK;
+ fail:
+   if (alloc1 == SWIG_NEWOBJ) delete[] buf1;
+   return TCL_ERROR;
+ }
+ 
+ 
+ SWIGINTERN int
+ _wrap_GetColorInterpretationName(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
+   GDALColorInterp arg1 ;
+   int val1 ;
+   int ecode1 = 0 ;
+   char *result = 0 ;
+   
+   if (SWIG_GetArgs(interp, objc, objv,"o:osgeo::GetColorInterpretationName GDALColorInterp ",(void *)0) == TCL_ERROR) SWIG_fail;
+   ecode1 = SWIG_AsVal_int SWIG_TCL_CALL_ARGS_2(objv[1], &val1);
+   if (!SWIG_IsOK(ecode1)) {
+     SWIG_exception_fail(SWIG_ArgError(ecode1), "in method '" "GetColorInterpretationName" "', argument " "1"" of type '" "GDALColorInterp""'");
+   } 
+   arg1 = static_cast< GDALColorInterp >(val1);
+   {
+     CPLErrorReset();
+     result = (char *)GDALGetColorInterpretationName(arg1);
+     CPLErr eclass = CPLGetLastErrorType();
+     if ( eclass == CE_Failure || eclass == CE_Fatal ) {
+       SWIG_exception( SWIG_RuntimeError, CPLGetLastErrorMsg() );
+       
+     }
+     
+     
+     
+     
+     
+     
+     
+     
+     
+     
+     
+   }
+   Tcl_SetObjResult(interp,SWIG_FromCharPtr((const char *)result));
+   return TCL_OK;
+ fail:
+   return TCL_ERROR;
+ }
+ 
+ 
+ SWIGINTERN int
+ _wrap_GetPaletteInterpretationName(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
+   GDALPaletteInterp arg1 ;
+   int val1 ;
+   int ecode1 = 0 ;
+   char *result = 0 ;
+   
+   if (SWIG_GetArgs(interp, objc, objv,"o:osgeo::GetPaletteInterpretationName GDALPaletteInterp ",(void *)0) == TCL_ERROR) SWIG_fail;
+   ecode1 = SWIG_AsVal_int SWIG_TCL_CALL_ARGS_2(objv[1], &val1);
+   if (!SWIG_IsOK(ecode1)) {
+     SWIG_exception_fail(SWIG_ArgError(ecode1), "in method '" "GetPaletteInterpretationName" "', argument " "1"" of type '" "GDALPaletteInterp""'");
+   } 
+   arg1 = static_cast< GDALPaletteInterp >(val1);
+   {
+     CPLErrorReset();
+     result = (char *)GDALGetPaletteInterpretationName(arg1);
+     CPLErr eclass = CPLGetLastErrorType();
+     if ( eclass == CE_Failure || eclass == CE_Fatal ) {
+       SWIG_exception( SWIG_RuntimeError, CPLGetLastErrorMsg() );
+       
+     }
+     
+     
+     
+     
+     
+     
+     
+     
+     
+     
+     
+   }
+   Tcl_SetObjResult(interp,SWIG_FromCharPtr((const char *)result));
+   return TCL_OK;
+ fail:
+   return TCL_ERROR;
+ }
+ 
+ 
+ SWIGINTERN int
+ _wrap_DecToDMS(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
+   double arg1 ;
+   char *arg2 = (char *) 0 ;
+   int arg3 = (int) 2 ;
+   double val1 ;
+   int ecode1 = 0 ;
+   int res2 ;
+   char *buf2 = 0 ;
+   int alloc2 = 0 ;
+   int val3 ;
+   int ecode3 = 0 ;
+   char *result = 0 ;
+   
+   if (SWIG_GetArgs(interp, objc, objv,"oo|o:osgeo::DecToDMS double char const * ?int? ",(void *)0,(void *)0,(void *)0) == TCL_ERROR) SWIG_fail;
+   ecode1 = SWIG_AsVal_double SWIG_TCL_CALL_ARGS_2(objv[1], &val1);
+   if (!SWIG_IsOK(ecode1)) {
+     SWIG_exception_fail(SWIG_ArgError(ecode1), "in method '" "DecToDMS" "', argument " "1"" of type '" "double""'");
+   } 
+   arg1 = static_cast< double >(val1);
+   res2 = SWIG_AsCharPtrAndSize(objv[2], &buf2, NULL, &alloc2);
+   if (!SWIG_IsOK(res2)) {
+     SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "DecToDMS" "', argument " "2"" of type '" "char const *""'");
+   }
+   arg2 = reinterpret_cast< char * >(buf2);
+   if (objc > 3) {
+     ecode3 = SWIG_AsVal_int SWIG_TCL_CALL_ARGS_2(objv[3], &val3);
+     if (!SWIG_IsOK(ecode3)) {
+       SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "DecToDMS" "', argument " "3"" of type '" "int""'");
+     } 
+     arg3 = static_cast< int >(val3);
+   }
+   {
+     CPLErrorReset();
+     result = (char *)GDALDecToDMS(arg1,(char const *)arg2,arg3);
+     CPLErr eclass = CPLGetLastErrorType();
+     if ( eclass == CE_Failure || eclass == CE_Fatal ) {
+       SWIG_exception( SWIG_RuntimeError, CPLGetLastErrorMsg() );
+       
+     }
+     
+     
+     
+     
+     
+     
+     
+     
+     
+     
+     
+   }
+   Tcl_SetObjResult(interp,SWIG_FromCharPtr((const char *)result));
+   if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
+   return TCL_OK;
+ fail:
+   if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
+   return TCL_ERROR;
+ }
+ 
+ 
+ SWIGINTERN int
+ _wrap_PackedDMSToDec(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
+   double arg1 ;
+   double val1 ;
+   int ecode1 = 0 ;
+   double result;
+   
+   if (SWIG_GetArgs(interp, objc, objv,"o:osgeo::PackedDMSToDec double ",(void *)0) == TCL_ERROR) SWIG_fail;
+   ecode1 = SWIG_AsVal_double SWIG_TCL_CALL_ARGS_2(objv[1], &val1);
+   if (!SWIG_IsOK(ecode1)) {
+     SWIG_exception_fail(SWIG_ArgError(ecode1), "in method '" "PackedDMSToDec" "', argument " "1"" of type '" "double""'");
+   } 
+   arg1 = static_cast< double >(val1);
+   {
+     CPLErrorReset();
+     result = (double)GDALPackedDMSToDec(arg1);
+     CPLErr eclass = CPLGetLastErrorType();
+     if ( eclass == CE_Failure || eclass == CE_Fatal ) {
+       SWIG_exception( SWIG_RuntimeError, CPLGetLastErrorMsg() );
+       
+     }
+     
+     
+     
+     
+     
+     
+     
+     
+     
+     
+     
+   }
+   Tcl_SetObjResult(interp,SWIG_From_double(static_cast< double >(result)));
+   return TCL_OK;
+ fail:
+   return TCL_ERROR;
+ }
+ 
+ 
+ SWIGINTERN int
+ _wrap_DecToPackedDMS(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
+   double arg1 ;
+   double val1 ;
+   int ecode1 = 0 ;
+   double result;
+   
+   if (SWIG_GetArgs(interp, objc, objv,"o:osgeo::DecToPackedDMS double ",(void *)0) == TCL_ERROR) SWIG_fail;
+   ecode1 = SWIG_AsVal_double SWIG_TCL_CALL_ARGS_2(objv[1], &val1);
+   if (!SWIG_IsOK(ecode1)) {
+     SWIG_exception_fail(SWIG_ArgError(ecode1), "in method '" "DecToPackedDMS" "', argument " "1"" of type '" "double""'");
+   } 
+   arg1 = static_cast< double >(val1);
+   {
+     CPLErrorReset();
+     result = (double)GDALDecToPackedDMS(arg1);
+     CPLErr eclass = CPLGetLastErrorType();
+     if ( eclass == CE_Failure || eclass == CE_Fatal ) {
+       SWIG_exception( SWIG_RuntimeError, CPLGetLastErrorMsg() );
+       
+     }
+     
+     
+     
+     
+     
+     
+     
+     
+     
+     
+     
+   }
+   Tcl_SetObjResult(interp,SWIG_From_double(static_cast< double >(result)));
+   return TCL_OK;
+ fail:
+   return TCL_ERROR;
+ }
+ 
+ 
+ SWIGINTERN int
+ _wrap_ParseXMLString(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
+   char *arg1 = (char *) 0 ;
+   int res1 ;
+   char *buf1 = 0 ;
+   int alloc1 = 0 ;
+   CPLXMLNode *result = 0 ;
+   
+   if (SWIG_GetArgs(interp, objc, objv,"o:osgeo::ParseXMLString char * ",(void *)0) == TCL_ERROR) SWIG_fail;
+   res1 = SWIG_AsCharPtrAndSize(objv[1], &buf1, NULL, &alloc1);
+   if (!SWIG_IsOK(res1)) {
+     SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "ParseXMLString" "', argument " "1"" of type '" "char *""'");
+   }
+   arg1 = reinterpret_cast< char * >(buf1);
+   {
+     CPLErrorReset();
+     result = (CPLXMLNode *)CPLParseXMLString(arg1);
+     CPLErr eclass = CPLGetLastErrorType();
+     if ( eclass == CE_Failure || eclass == CE_Fatal ) {
+       SWIG_exception( SWIG_RuntimeError, CPLGetLastErrorMsg() );
+       
+     }
+     
+     
+     
+     
+     
+     
+     
+     
+     
+     
+     
+   }
+   {
+     /* %typemap(out) (CPLXMLNode*) */
+     
+     Tcl_Obj *out;
+     CPLXMLNode *psXMLTree = result;
+     int         bFakeRoot = FALSE;
+     
+     if( psXMLTree != NULL && psXMLTree->psNext != NULL )
+     {
+       CPLXMLNode *psFirst = psXMLTree;
+       
+       /* create a "pseudo" root if we have multiple elements */
+       psXMLTree = CPLCreateXMLNode( NULL, CXT_Element, "" );
+       psXMLTree->psChild = psFirst;
+       bFakeRoot = TRUE;
+     }
+     
+     out = XMLTreeToTclList( interp, psXMLTree );
+     if ( !out ) SWIG_fail;
+     
+     if( bFakeRoot )
+     {
+       psXMLTree->psChild = NULL;
+       CPLDestroyXMLNode( psXMLTree );
+     }
+     
+     Tcl_SetObjResult(interp, out);
+   }
+   if (alloc1 == SWIG_NEWOBJ) delete[] buf1;
+   {
+     /* %typemap(ret) (CPLXMLNode*) */
+     if ( result ) CPLDestroyXMLNode( result );
+   }
+   return TCL_OK;
+ fail:
+   if (alloc1 == SWIG_NEWOBJ) delete[] buf1;
+   return TCL_ERROR;
+ }
+ 
+ 
+ SWIGINTERN int
+ _wrap_SerializeXMLTree(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
+   CPLXMLNode *arg1 = (CPLXMLNode *) 0 ;
+   char *result = 0 ;
+   
+   if (SWIG_GetArgs(interp, objc, objv,"o:osgeo::SerializeXMLTree xmlnode ",(void *)0) == TCL_ERROR) SWIG_fail;
+   {
+     /* %typemap(tcl,in) (CPLXMLNode* xmlnode ) */
+     arg1 = TclListToXMLTree( interp, objv[1] );
+     if ( !arg1 ) SWIG_fail;
+   }
+   {
+     CPLErrorReset();
+     result = (char *)CPLSerializeXMLTree(arg1);
+     CPLErr eclass = CPLGetLastErrorType();
+     if ( eclass == CE_Failure || eclass == CE_Fatal ) {
+       SWIG_exception( SWIG_RuntimeError, CPLGetLastErrorMsg() );
+       
+     }
+     
+     
+     
+     
+     
+     
+     
+     
+     
+     
+     
+   }
+   Tcl_SetObjResult(interp,SWIG_FromCharPtr((const char *)result));
+   {
+     /* %typemap(freearg) (CPLXMLNode *xmlnode) */
+     if ( arg1 ) CPLDestroyXMLNode( arg1 );
+   }
+   return TCL_OK;
+ fail:
+   {
+     /* %typemap(freearg) (CPLXMLNode *xmlnode) */
+     if ( arg1 ) CPLDestroyXMLNode( arg1 );
+   }
+   return TCL_ERROR;
+ }
+ 
+ 
+ SWIGINTERN int
+ _wrap_GetDriverCount(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
+   int result;
+   
+   if (SWIG_GetArgs(interp, objc, objv,":osgeo::GetDriverCount ") == TCL_ERROR) SWIG_fail;
+   {
+     CPLErrorReset();
+     result = (int)GetDriverCount();
+     CPLErr eclass = CPLGetLastErrorType();
+     if ( eclass == CE_Failure || eclass == CE_Fatal ) {
+       SWIG_exception( SWIG_RuntimeError, CPLGetLastErrorMsg() );
+       
+     }
+     
+     
+     
+     
+     
+     
+     
+     
+     
+     
+     
+   }
+   Tcl_SetObjResult(interp,SWIG_From_int(static_cast< int >(result)));
+   return TCL_OK;
+ fail:
+   return TCL_ERROR;
+ }
+ 
+ 
+ SWIGINTERN int
+ _wrap_GetDriverByName(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
+   char *arg1 = (char *) 0 ;
+   int res1 ;
+   char *buf1 = 0 ;
+   int alloc1 = 0 ;
+   GDALDriverShadow *result = 0 ;
+   
+   if (SWIG_GetArgs(interp, objc, objv,"o:osgeo::GetDriverByName name ",(void *)0) == TCL_ERROR) SWIG_fail;
+   res1 = SWIG_AsCharPtrAndSize(objv[1], &buf1, NULL, &alloc1);
+   if (!SWIG_IsOK(res1)) {
+     SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "GetDriverByName" "', argument " "1"" of type '" "char const *""'");
+   }
+   arg1 = reinterpret_cast< char * >(buf1);
+   {
+     CPLErrorReset();
+     result = (GDALDriverShadow *)GetDriverByName((char const *)arg1);
+     CPLErr eclass = CPLGetLastErrorType();
+     if ( eclass == CE_Failure || eclass == CE_Fatal ) {
+       SWIG_exception( SWIG_RuntimeError, CPLGetLastErrorMsg() );
+       
+     }
+     
+     
+     
+     
+     
+     
+     
+     
+     
+     
+     
+   }
+   Tcl_SetObjResult(interp, SWIG_NewInstanceObj( SWIG_as_voidptr(result), SWIGTYPE_p_GDALDriverShadow,0));
+   if (alloc1 == SWIG_NEWOBJ) delete[] buf1;
+   return TCL_OK;
+ fail:
+   if (alloc1 == SWIG_NEWOBJ) delete[] buf1;
+   return TCL_ERROR;
+ }
+ 
+ 
+ SWIGINTERN int
+ _wrap_GetDriver(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
+   int arg1 ;
+   int val1 ;
+   int ecode1 = 0 ;
+   GDALDriverShadow *result = 0 ;
+   
+   if (SWIG_GetArgs(interp, objc, objv,"o:osgeo::GetDriver i ",(void *)0) == TCL_ERROR) SWIG_fail;
+   ecode1 = SWIG_AsVal_int SWIG_TCL_CALL_ARGS_2(objv[1], &val1);
+   if (!SWIG_IsOK(ecode1)) {
+     SWIG_exception_fail(SWIG_ArgError(ecode1), "in method '" "GetDriver" "', argument " "1"" of type '" "int""'");
+   } 
+   arg1 = static_cast< int >(val1);
+   {
+     CPLErrorReset();
+     result = (GDALDriverShadow *)GetDriver(arg1);
+     CPLErr eclass = CPLGetLastErrorType();
+     if ( eclass == CE_Failure || eclass == CE_Fatal ) {
+       SWIG_exception( SWIG_RuntimeError, CPLGetLastErrorMsg() );
+       
+     }
+     
+     
+     
+     
+     
+     
+     
+     
+     
+     
+     
+   }
+   Tcl_SetObjResult(interp, SWIG_NewInstanceObj( SWIG_as_voidptr(result), SWIGTYPE_p_GDALDriverShadow,0));
+   return TCL_OK;
+ fail:
+   return TCL_ERROR;
+ }
+ 
+ 
+ SWIGINTERN int
+ _wrap_Open(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
+   char *arg1 = (char *) 0 ;
+   GDALAccess arg2 = (GDALAccess) GA_ReadOnly ;
+   int res1 ;
+   char *buf1 = 0 ;
+   int alloc1 = 0 ;
+   int val2 ;
+   int ecode2 = 0 ;
+   GDALDatasetShadow *result = 0 ;
+   
+   if (SWIG_GetArgs(interp, objc, objv,"o|o:osgeo::Open name ?eAccess? ",(void *)0,(void *)0) == TCL_ERROR) SWIG_fail;
+   res1 = SWIG_AsCharPtrAndSize(objv[1], &buf1, NULL, &alloc1);
+   if (!SWIG_IsOK(res1)) {
+     SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Open" "', argument " "1"" of type '" "char const *""'");
+   }
+   arg1 = reinterpret_cast< char * >(buf1);
+   if (objc > 2) {
+     ecode2 = SWIG_AsVal_int SWIG_TCL_CALL_ARGS_2(objv[2], &val2);
+     if (!SWIG_IsOK(ecode2)) {
+       SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "Open" "', argument " "2"" of type '" "GDALAccess""'");
+     } 
+     arg2 = static_cast< GDALAccess >(val2);
+   }
+   {
+     CPLErrorReset();
+     result = (GDALDatasetShadow *)Open((char const *)arg1,arg2);
+     CPLErr eclass = CPLGetLastErrorType();
+     if ( eclass == CE_Failure || eclass == CE_Fatal ) {
+       SWIG_exception( SWIG_RuntimeError, CPLGetLastErrorMsg() );
+       
+     }
+     
+     
+     
+     
+     
+     
+     
+     
+     
+     
+     
+   }
+   Tcl_SetObjResult(interp, SWIG_NewInstanceObj( SWIG_as_voidptr(result), SWIGTYPE_p_GDALDatasetShadow,0));
+   if (alloc1 == SWIG_NEWOBJ) delete[] buf1;
+   return TCL_OK;
+ fail:
+   if (alloc1 == SWIG_NEWOBJ) delete[] buf1;
+   return TCL_ERROR;
+ }
+ 
+ 
+ SWIGINTERN int
+ _wrap_OpenShared(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
+   char *arg1 = (char *) 0 ;
+   GDALAccess arg2 = (GDALAccess) GA_ReadOnly ;
+   int res1 ;
+   char *buf1 = 0 ;
+   int alloc1 = 0 ;
+   int val2 ;
+   int ecode2 = 0 ;
+   GDALDatasetShadow *result = 0 ;
+   
+   if (SWIG_GetArgs(interp, objc, objv,"o|o:osgeo::OpenShared name ?eAccess? ",(void *)0,(void *)0) == TCL_ERROR) SWIG_fail;
+   res1 = SWIG_AsCharPtrAndSize(objv[1], &buf1, NULL, &alloc1);
+   if (!SWIG_IsOK(res1)) {
+     SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "OpenShared" "', argument " "1"" of type '" "char const *""'");
+   }
+   arg1 = reinterpret_cast< char * >(buf1);
+   if (objc > 2) {
+     ecode2 = SWIG_AsVal_int SWIG_TCL_CALL_ARGS_2(objv[2], &val2);
+     if (!SWIG_IsOK(ecode2)) {
+       SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "OpenShared" "', argument " "2"" of type '" "GDALAccess""'");
+     } 
+     arg2 = static_cast< GDALAccess >(val2);
+   }
+   {
+     CPLErrorReset();
+     result = (GDALDatasetShadow *)OpenShared((char const *)arg1,arg2);
+     CPLErr eclass = CPLGetLastErrorType();
+     if ( eclass == CE_Failure || eclass == CE_Fatal ) {
+       SWIG_exception( SWIG_RuntimeError, CPLGetLastErrorMsg() );
+       
+     }
+     
+     
+     
+     
+     
+     
+     
+     
+     
+     
+     
+   }
+   Tcl_SetObjResult(interp, SWIG_NewInstanceObj( SWIG_as_voidptr(result), SWIGTYPE_p_GDALDatasetShadow,0));
+   if (alloc1 == SWIG_NEWOBJ) delete[] buf1;
+   return TCL_OK;
+ fail:
+   if (alloc1 == SWIG_NEWOBJ) delete[] buf1;
+   return TCL_ERROR;
+ }
+ 
+ 
+ SWIGINTERN int
+ _wrap_IdentifyDriver(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
+   char *arg1 = (char *) 0 ;
+   char **arg2 = (char **) NULL ;
+   int res1 ;
+   char *buf1 = 0 ;
+   int alloc1 = 0 ;
+   GDALDriverShadow *result = 0 ;
+   
+   if (SWIG_GetArgs(interp, objc, objv,"o|o:osgeo::IdentifyDriver pszDatasource ?papszSiblings? ",(void *)0,(void *)0) == TCL_ERROR) SWIG_fail;
+   res1 = SWIG_AsCharPtrAndSize(objv[1], &buf1, NULL, &alloc1);
+   if (!SWIG_IsOK(res1)) {
+     SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "IdentifyDriver" "', argument " "1"" of type '" "char const *""'");
+   }
+   arg1 = reinterpret_cast< char * >(buf1);
+   if (objc > 2) {
+     {
+       /* %typemap(in) char **options */
+       int size;
+       if (Tcl_ListObjLength(interp, objv[2], &size) != TCL_OK) {
+         /* Error msg in interp result */
+         SWIG_fail;
+       }
+       if ( !size ) {
+         Tcl_SetResult(interp, (char*) "Input list mustn't be empty", TCL_STATIC);
+         SWIG_fail;
+       }
+       
+       for (int i = 0; i < size; i++) {
+         Tcl_Obj **o = NULL;
+         /* The reference count for the list element is not incremented with the following */
+         if (Tcl_ListObjIndex(interp, objv[2], i, o) != TCL_OK) {
+           /* Error msg in interp result */
+           SWIG_fail;
+         }
+         char *pszItem = Tcl_GetString(*o);
+         arg2 = CSLAddString( arg2, pszItem );
+       }
+     }
+   }
+   {
+     CPLErrorReset();
+     result = (GDALDriverShadow *)IdentifyDriver((char const *)arg1,arg2);
+     CPLErr eclass = CPLGetLastErrorType();
+     if ( eclass == CE_Failure || eclass == CE_Fatal ) {
+       SWIG_exception( SWIG_RuntimeError, CPLGetLastErrorMsg() );
+       
+     }
+     
+     
+     
+     
+     
+     
+     
+     
+     
+     
+     
+   }
+   Tcl_SetObjResult(interp, SWIG_NewInstanceObj( SWIG_as_voidptr(result), SWIGTYPE_p_GDALDriverShadow,0));
+   if (alloc1 == SWIG_NEWOBJ) delete[] buf1;
+   {
+     /* %typemap(freearg) char **options */
+     CSLDestroy( arg2 );
+   }
+   return TCL_OK;
+ fail:
+   if (alloc1 == SWIG_NEWOBJ) delete[] buf1;
+   {
+     /* %typemap(freearg) char **options */
+     CSLDestroy( arg2 );
+   }
+   return TCL_ERROR;
+ }
+ 
+ 
+ SWIGINTERN int
+ _wrap_GeneralCmdLineProcessor(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
+   char **arg1 = (char **) 0 ;
+   int arg2 = (int) 0 ;
+   int val2 ;
+   int ecode2 = 0 ;
+   char **result = 0 ;
+   
+   if (SWIG_GetArgs(interp, objc, objv,"o|o:osgeo::GeneralCmdLineProcessor papszArgv ?nOptions? ",(void *)0,(void *)0) == TCL_ERROR) SWIG_fail;
+   {
+     /* %typemap(in) char **options */
+     int size;
+     if (Tcl_ListObjLength(interp, objv[1], &size) != TCL_OK) {
+       /* Error msg in interp result */
+       SWIG_fail;
+     }
+     if ( !size ) {
+       Tcl_SetResult(interp, (char*) "Input list mustn't be empty", TCL_STATIC);
+       SWIG_fail;
+     }
+     
+     for (int i = 0; i < size; i++) {
+       Tcl_Obj **o = NULL;
+       /* The reference count for the list element is not incremented with the following */
+       if (Tcl_ListObjIndex(interp, objv[1], i, o) != TCL_OK) {
+         /* Error msg in interp result */
+         SWIG_fail;
+       }
+       char *pszItem = Tcl_GetString(*o);
+       arg1 = CSLAddString( arg1, pszItem );
+     }
+   }
+   if (objc > 2) {
+     ecode2 = SWIG_AsVal_int SWIG_TCL_CALL_ARGS_2(objv[2], &val2);
+     if (!SWIG_IsOK(ecode2)) {
+       SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "GeneralCmdLineProcessor" "', argument " "2"" of type '" "int""'");
+     } 
+     arg2 = static_cast< int >(val2);
+   }
+   {
+     CPLErrorReset();
+     result = (char **)GeneralCmdLineProcessor(arg1,arg2);
+     CPLErr eclass = CPLGetLastErrorType();
+     if ( eclass == CE_Failure || eclass == CE_Fatal ) {
+       SWIG_exception( SWIG_RuntimeError, CPLGetLastErrorMsg() );
+       
+     }
+     
+     
+     
+     
+     
+     
+     
+     
+     
+     
+     
+   }
+   {
+     /* %typemap(out) char **options -> ( string ) */
+     char **stringarray = result;
+     if ( stringarray == NULL ) {
+       Tcl_ResetResult(interp); /* NONE = Empty string */
+     } else {
+       int len = CSLCount( stringarray );
+       Tcl_Obj *out = Tcl_NewListObj(0, NULL);
+       for ( int i = 0; i < len; ++i ) {
+         Tcl_Obj *o = Tcl_NewStringObj( stringarray[i], -1 );
+         if (Tcl_ListObjAppendElement(interp, out, o) != TCL_OK) {
+           Tcl_DecrRefCount(o);
+           Tcl_DecrRefCount(out);
+           /* Error msg in interp result */
+           SWIG_fail;
+         }
+       }
+       Tcl_SetObjResult(interp, out);
+     }
+   }
+   {
+     /* %typemap(freearg) char **options */
+     CSLDestroy( arg1 );
+   }
+   return TCL_OK;
+ fail:
+   {
+     /* %typemap(freearg) char **options */
+     CSLDestroy( arg1 );
+   }
+   return TCL_ERROR;
+ }
+ 
+ 
+ 
+ static swig_command_info swig_commands[] = {
+     { SWIG_prefix "DataTypeUnion", (swig_wrapper_func) _wrap_DataTypeUnion, NULL},
+     { SWIG_prefix "UseExceptions", (swig_wrapper_func) _wrap_UseExceptions, NULL},
+     { SWIG_prefix "DontUseExceptions", (swig_wrapper_func) _wrap_DontUseExceptions, NULL},
+     { SWIG_prefix "Debug", (swig_wrapper_func) _wrap_Debug, NULL},
+     { SWIG_prefix "Error", (swig_wrapper_func) _wrap_Error, NULL},
+     { SWIG_prefix "PushErrorHandler", (swig_wrapper_func) _wrap_PushErrorHandler, NULL},
+     { SWIG_prefix "PopErrorHandler", (swig_wrapper_func) _wrap_PopErrorHandler, NULL},
+     { SWIG_prefix "ErrorReset", (swig_wrapper_func) _wrap_ErrorReset, NULL},
+     { SWIG_prefix "EscapeString", (swig_wrapper_func) _wrap_EscapeString, NULL},
+     { SWIG_prefix "GetLastErrorNo", (swig_wrapper_func) _wrap_GetLastErrorNo, NULL},
+     { SWIG_prefix "GetLastErrorType", (swig_wrapper_func) _wrap_GetLastErrorType, NULL},
+     { SWIG_prefix "GetLastErrorMsg", (swig_wrapper_func) _wrap_GetLastErrorMsg, NULL},
+     { SWIG_prefix "PushFinderLocation", (swig_wrapper_func) _wrap_PushFinderLocation, NULL},
+     { SWIG_prefix "PopFinderLocation", (swig_wrapper_func) _wrap_PopFinderLocation, NULL},
+     { SWIG_prefix "FinderClean", (swig_wrapper_func) _wrap_FinderClean, NULL},
+     { SWIG_prefix "FindFile", (swig_wrapper_func) _wrap_FindFile, NULL},
+     { SWIG_prefix "ReadDir", (swig_wrapper_func) _wrap_ReadDir, NULL},
+     { SWIG_prefix "SetConfigOption", (swig_wrapper_func) _wrap_SetConfigOption, NULL},
+     { SWIG_prefix "GetConfigOption", (swig_wrapper_func) _wrap_GetConfigOption, NULL},
+     { SWIG_prefix "CPLBinaryToHex", (swig_wrapper_func) _wrap_CPLBinaryToHex, NULL},
+     { SWIG_prefix "CPLHexToBinary", (swig_wrapper_func) _wrap_CPLHexToBinary, NULL},
+     { SWIG_prefix "MajorObject_GetDescription", (swig_wrapper_func) _wrap_MajorObject_GetDescription, NULL},
+     { SWIG_prefix "MajorObject_SetDescription", (swig_wrapper_func) _wrap_MajorObject_SetDescription, NULL},
+     { SWIG_prefix "MajorObject_GetMetadata_Dict", (swig_wrapper_func) _wrap_MajorObject_GetMetadata_Dict, NULL},
+     { SWIG_prefix "MajorObject_GetMetadata_List", (swig_wrapper_func) _wrap_MajorObject_GetMetadata_List, NULL},
+     { SWIG_prefix "MajorObject_SetMetadata", (swig_wrapper_func) _wrap_MajorObject_SetMetadata, NULL},
+     { SWIG_prefix "MajorObject_GetMetadataItem", (swig_wrapper_func) _wrap_MajorObject_GetMetadataItem, NULL},
+     { SWIG_prefix "MajorObject_SetMetadataItem", (swig_wrapper_func) _wrap_MajorObject_SetMetadataItem, NULL},
+     { SWIG_prefix "MajorObject", (swig_wrapper_func) SWIG_ObjectConstructor, (ClientData)&_wrap_class_GDALMajorObjectShadow},
+     { SWIG_prefix "Driver_ShortName_get", (swig_wrapper_func) _wrap_Driver_ShortName_get, NULL},
+     { SWIG_prefix "Driver_LongName_get", (swig_wrapper_func) _wrap_Driver_LongName_get, NULL},
+     { SWIG_prefix "Driver_HelpTopic_get", (swig_wrapper_func) _wrap_Driver_HelpTopic_get, NULL},
+     { SWIG_prefix "Driver_Create", (swig_wrapper_func) _wrap_Driver_Create, NULL},
+     { SWIG_prefix "Driver_CreateCopy", (swig_wrapper_func) _wrap_Driver_CreateCopy, NULL},
+     { SWIG_prefix "Driver_Delete", (swig_wrapper_func) _wrap_Driver_Delete, NULL},
+     { SWIG_prefix "Driver_Rename", (swig_wrapper_func) _wrap_Driver_Rename, NULL},
+     { SWIG_prefix "Driver_Register", (swig_wrapper_func) _wrap_Driver_Register, NULL},
+     { SWIG_prefix "Driver_Deregister", (swig_wrapper_func) _wrap_Driver_Deregister, NULL},
+     { SWIG_prefix "Driver", (swig_wrapper_func) SWIG_ObjectConstructor, (ClientData)&_wrap_class_GDALDriverShadow},
+     { SWIG_prefix "ColorEntry_c1_set", (swig_wrapper_func) _wrap_ColorEntry_c1_set, NULL},
+     { SWIG_prefix "ColorEntry_c1_get", (swig_wrapper_func) _wrap_ColorEntry_c1_get, NULL},
+     { SWIG_prefix "ColorEntry_c2_set", (swig_wrapper_func) _wrap_ColorEntry_c2_set, NULL},
+     { SWIG_prefix "ColorEntry_c2_get", (swig_wrapper_func) _wrap_ColorEntry_c2_get, NULL},
+     { SWIG_prefix "ColorEntry_c3_set", (swig_wrapper_func) _wrap_ColorEntry_c3_set, NULL},
+     { SWIG_prefix "ColorEntry_c3_get", (swig_wrapper_func) _wrap_ColorEntry_c3_get, NULL},
+     { SWIG_prefix "ColorEntry_c4_set", (swig_wrapper_func) _wrap_ColorEntry_c4_set, NULL},
+     { SWIG_prefix "ColorEntry_c4_get", (swig_wrapper_func) _wrap_ColorEntry_c4_get, NULL},
+     { SWIG_prefix "new_ColorEntry", (swig_wrapper_func) _wrap_new_ColorEntry, NULL},
+     { SWIG_prefix "delete_ColorEntry", (swig_wrapper_func) _wrap_delete_ColorEntry, NULL},
+     { SWIG_prefix "ColorEntry", (swig_wrapper_func) SWIG_ObjectConstructor, (ClientData)&_wrap_class_GDALColorEntry},
+     { SWIG_prefix "GCP_GCPX_set", (swig_wrapper_func) _wrap_GCP_GCPX_set, NULL},
+     { SWIG_prefix "GCP_GCPX_get", (swig_wrapper_func) _wrap_GCP_GCPX_get, NULL},
+     { SWIG_prefix "GCP_GCPY_set", (swig_wrapper_func) _wrap_GCP_GCPY_set, NULL},
+     { SWIG_prefix "GCP_GCPY_get", (swig_wrapper_func) _wrap_GCP_GCPY_get, NULL},
+     { SWIG_prefix "GCP_GCPZ_set", (swig_wrapper_func) _wrap_GCP_GCPZ_set, NULL},
+     { SWIG_prefix "GCP_GCPZ_get", (swig_wrapper_func) _wrap_GCP_GCPZ_get, NULL},
+     { SWIG_prefix "GCP_GCPPixel_set", (swig_wrapper_func) _wrap_GCP_GCPPixel_set, NULL},
+     { SWIG_prefix "GCP_GCPPixel_get", (swig_wrapper_func) _wrap_GCP_GCPPixel_get, NULL},
+     { SWIG_prefix "GCP_GCPLine_set", (swig_wrapper_func) _wrap_GCP_GCPLine_set, NULL},
+     { SWIG_prefix "GCP_GCPLine_get", (swig_wrapper_func) _wrap_GCP_GCPLine_get, NULL},
+     { SWIG_prefix "GCP_Info_set", (swig_wrapper_func) _wrap_GCP_Info_set, NULL},
+     { SWIG_prefix "GCP_Info_get", (swig_wrapper_func) _wrap_GCP_Info_get, NULL},
+     { SWIG_prefix "GCP_Id_set", (swig_wrapper_func) _wrap_GCP_Id_set, NULL},
+     { SWIG_prefix "GCP_Id_get", (swig_wrapper_func) _wrap_GCP_Id_get, NULL},
+     { SWIG_prefix "new_GCP", (swig_wrapper_func) _wrap_new_GCP, NULL},
+     { SWIG_prefix "delete_GCP", (swig_wrapper_func) _wrap_delete_GCP, NULL},
+     { SWIG_prefix "GCP", (swig_wrapper_func) SWIG_ObjectConstructor, (ClientData)&_wrap_class_GDAL_GCP},
+     { SWIG_prefix "GDAL_GCP_GCPX_get", (swig_wrapper_func) _wrap_GDAL_GCP_GCPX_get, NULL},
+     { SWIG_prefix "GDAL_GCP_GCPX_set", (swig_wrapper_func) _wrap_GDAL_GCP_GCPX_set, NULL},
+     { SWIG_prefix "GDAL_GCP_GCPY_get", (swig_wrapper_func) _wrap_GDAL_GCP_GCPY_get, NULL},
+     { SWIG_prefix "GDAL_GCP_GCPY_set", (swig_wrapper_func) _wrap_GDAL_GCP_GCPY_set, NULL},
+     { SWIG_prefix "GDAL_GCP_GCPZ_get", (swig_wrapper_func) _wrap_GDAL_GCP_GCPZ_get, NULL},
+     { SWIG_prefix "GDAL_GCP_GCPZ_set", (swig_wrapper_func) _wrap_GDAL_GCP_GCPZ_set, NULL},
+     { SWIG_prefix "GDAL_GCP_GCPPixel_get", (swig_wrapper_func) _wrap_GDAL_GCP_GCPPixel_get, NULL},
+     { SWIG_prefix "GDAL_GCP_GCPPixel_set", (swig_wrapper_func) _wrap_GDAL_GCP_GCPPixel_set, NULL},
+     { SWIG_prefix "GDAL_GCP_GCPLine_get", (swig_wrapper_func) _wrap_GDAL_GCP_GCPLine_get, NULL},
+     { SWIG_prefix "GDAL_GCP_GCPLine_set", (swig_wrapper_func) _wrap_GDAL_GCP_GCPLine_set, NULL},
+     { SWIG_prefix "GDAL_GCP_Info_get", (swig_wrapper_func) _wrap_GDAL_GCP_Info_get, NULL},
+     { SWIG_prefix "GDAL_GCP_Info_set", (swig_wrapper_func) _wrap_GDAL_GCP_Info_set, NULL},
+     { SWIG_prefix "GDAL_GCP_Id_get", (swig_wrapper_func) _wrap_GDAL_GCP_Id_get, NULL},
+     { SWIG_prefix "GDAL_GCP_Id_set", (swig_wrapper_func) _wrap_GDAL_GCP_Id_set, NULL},
+     { SWIG_prefix "GDAL_GCP_get_GCPX", (swig_wrapper_func) _wrap_GDAL_GCP_get_GCPX, NULL},
+     { SWIG_prefix "GDAL_GCP_set_GCPX", (swig_wrapper_func) _wrap_GDAL_GCP_set_GCPX, NULL},
+     { SWIG_prefix "GDAL_GCP_get_GCPY", (swig_wrapper_func) _wrap_GDAL_GCP_get_GCPY, NULL},
+     { SWIG_prefix "GDAL_GCP_set_GCPY", (swig_wrapper_func) _wrap_GDAL_GCP_set_GCPY, NULL},
+     { SWIG_prefix "GDAL_GCP_get_GCPZ", (swig_wrapper_func) _wrap_GDAL_GCP_get_GCPZ, NULL},
+     { SWIG_prefix "GDAL_GCP_set_GCPZ", (swig_wrapper_func) _wrap_GDAL_GCP_set_GCPZ, NULL},
+     { SWIG_prefix "GDAL_GCP_get_GCPPixel", (swig_wrapper_func) _wrap_GDAL_GCP_get_GCPPixel, NULL},
+     { SWIG_prefix "GDAL_GCP_set_GCPPixel", (swig_wrapper_func) _wrap_GDAL_GCP_set_GCPPixel, NULL},
+     { SWIG_prefix "GDAL_GCP_get_GCPLine", (swig_wrapper_func) _wrap_GDAL_GCP_get_GCPLine, NULL},
+     { SWIG_prefix "GDAL_GCP_set_GCPLine", (swig_wrapper_func) _wrap_GDAL_GCP_set_GCPLine, NULL},
+     { SWIG_prefix "GDAL_GCP_get_Info", (swig_wrapper_func) _wrap_GDAL_GCP_get_Info, NULL},
+     { SWIG_prefix "GDAL_GCP_set_Info", (swig_wrapper_func) _wrap_GDAL_GCP_set_Info, NULL},
+     { SWIG_prefix "GDAL_GCP_get_Id", (swig_wrapper_func) _wrap_GDAL_GCP_get_Id, NULL},
+     { SWIG_prefix "GDAL_GCP_set_Id", (swig_wrapper_func) _wrap_GDAL_GCP_set_Id, NULL},
+     { SWIG_prefix "GCPsToGeoTransform", (swig_wrapper_func) _wrap_GCPsToGeoTransform, NULL},
+     { SWIG_prefix "Dataset_RasterXSize_get", (swig_wrapper_func) _wrap_Dataset_RasterXSize_get, NULL},
+     { SWIG_prefix "Dataset_RasterYSize_get", (swig_wrapper_func) _wrap_Dataset_RasterYSize_get, NULL},
+     { SWIG_prefix "Dataset_RasterCount_get", (swig_wrapper_func) _wrap_Dataset_RasterCount_get, NULL},
+     { SWIG_prefix "delete_Dataset", (swig_wrapper_func) _wrap_delete_Dataset, NULL},
+     { SWIG_prefix "Dataset_GetDriver", (swig_wrapper_func) _wrap_Dataset_GetDriver, NULL},
+     { SWIG_prefix "Dataset_GetRasterBand", (swig_wrapper_func) _wrap_Dataset_GetRasterBand, NULL},
+     { SWIG_prefix "Dataset_GetProjection", (swig_wrapper_func) _wrap_Dataset_GetProjection, NULL},
+     { SWIG_prefix "Dataset_GetProjectionRef", (swig_wrapper_func) _wrap_Dataset_GetProjectionRef, NULL},
+     { SWIG_prefix "Dataset_SetProjection", (swig_wrapper_func) _wrap_Dataset_SetProjection, NULL},
+     { SWIG_prefix "Dataset_GetGeoTransform", (swig_wrapper_func) _wrap_Dataset_GetGeoTransform, NULL},
+     { SWIG_prefix "Dataset_SetGeoTransform", (swig_wrapper_func) _wrap_Dataset_SetGeoTransform, NULL},
+     { SWIG_prefix "Dataset_BuildOverviews", (swig_wrapper_func) _wrap_Dataset_BuildOverviews, NULL},
+     { SWIG_prefix "Dataset_GetGCPCount", (swig_wrapper_func) _wrap_Dataset_GetGCPCount, NULL},
+     { SWIG_prefix "Dataset_GetGCPProjection", (swig_wrapper_func) _wrap_Dataset_GetGCPProjection, NULL},
+     { SWIG_prefix "Dataset_GetGCPs", (swig_wrapper_func) _wrap_Dataset_GetGCPs, NULL},
+     { SWIG_prefix "Dataset_SetGCPs", (swig_wrapper_func) _wrap_Dataset_SetGCPs, NULL},
+     { SWIG_prefix "Dataset_FlushCache", (swig_wrapper_func) _wrap_Dataset_FlushCache, NULL},
+     { SWIG_prefix "Dataset_AddBand", (swig_wrapper_func) _wrap_Dataset_AddBand, NULL},
+     { SWIG_prefix "Dataset_CreateMaskBand", (swig_wrapper_func) _wrap_Dataset_CreateMaskBand, NULL},
+     { SWIG_prefix "Dataset_GetFileList", (swig_wrapper_func) _wrap_Dataset_GetFileList, NULL},
+     { SWIG_prefix "Dataset_WriteRaster", (swig_wrapper_func) _wrap_Dataset_WriteRaster, NULL},
+     { SWIG_prefix "Dataset_ReadRaster", (swig_wrapper_func) _wrap_Dataset_ReadRaster, NULL},
+     { SWIG_prefix "Dataset", (swig_wrapper_func) SWIG_ObjectConstructor, (ClientData)&_wrap_class_GDALDatasetShadow},
+     { SWIG_prefix "Band_XSize_get", (swig_wrapper_func) _wrap_Band_XSize_get, NULL},
+     { SWIG_prefix "Band_YSize_get", (swig_wrapper_func) _wrap_Band_YSize_get, NULL},
+     { SWIG_prefix "Band_DataType_get", (swig_wrapper_func) _wrap_Band_DataType_get, NULL},
+     { SWIG_prefix "Band_GetBlockSize", (swig_wrapper_func) _wrap_Band_GetBlockSize, NULL},
+     { SWIG_prefix "Band_GetRasterColorInterpretation", (swig_wrapper_func) _wrap_Band_GetRasterColorInterpretation, NULL},
+     { SWIG_prefix "Band_SetRasterColorInterpretation", (swig_wrapper_func) _wrap_Band_SetRasterColorInterpretation, NULL},
+     { SWIG_prefix "Band_GetNoDataValue", (swig_wrapper_func) _wrap_Band_GetNoDataValue, NULL},
+     { SWIG_prefix "Band_SetNoDataValue", (swig_wrapper_func) _wrap_Band_SetNoDataValue, NULL},
+     { SWIG_prefix "Band_GetRasterCategoryNames", (swig_wrapper_func) _wrap_Band_GetRasterCategoryNames, NULL},
+     { SWIG_prefix "Band_SetRasterCategoryNames", (swig_wrapper_func) _wrap_Band_SetRasterCategoryNames, NULL},
+     { SWIG_prefix "Band_GetMinimum", (swig_wrapper_func) _wrap_Band_GetMinimum, NULL},
+     { SWIG_prefix "Band_GetMaximum", (swig_wrapper_func) _wrap_Band_GetMaximum, NULL},
+     { SWIG_prefix "Band_GetOffset", (swig_wrapper_func) _wrap_Band_GetOffset, NULL},
+     { SWIG_prefix "Band_GetScale", (swig_wrapper_func) _wrap_Band_GetScale, NULL},
+     { SWIG_prefix "Band_GetStatistics", (swig_wrapper_func) _wrap_Band_GetStatistics, NULL},
+     { SWIG_prefix "Band_SetStatistics", (swig_wrapper_func) _wrap_Band_SetStatistics, NULL},
+     { SWIG_prefix "Band_GetOverviewCount", (swig_wrapper_func) _wrap_Band_GetOverviewCount, NULL},
+     { SWIG_prefix "Band_GetOverview", (swig_wrapper_func) _wrap_Band_GetOverview, NULL},
+     { SWIG_prefix "Band_Checksum", (swig_wrapper_func) _wrap_Band_Checksum, NULL},
+     { SWIG_prefix "Band_ComputeRasterMinMax", (swig_wrapper_func) _wrap_Band_ComputeRasterMinMax, NULL},
+     { SWIG_prefix "Band_ComputeBandStats", (swig_wrapper_func) _wrap_Band_ComputeBandStats, NULL},
+     { SWIG_prefix "Band_Fill", (swig_wrapper_func) _wrap_Band_Fill, NULL},
+     { SWIG_prefix "Band_ReadRaster", (swig_wrapper_func) _wrap_Band_ReadRaster, NULL},
+     { SWIG_prefix "Band_WriteRaster", (swig_wrapper_func) _wrap_Band_WriteRaster, NULL},
+     { SWIG_prefix "Band_FlushCache", (swig_wrapper_func) _wrap_Band_FlushCache, NULL},
+     { SWIG_prefix "Band_GetRasterColorTable", (swig_wrapper_func) _wrap_Band_GetRasterColorTable, NULL},
+     { SWIG_prefix "Band_GetColorTable", (swig_wrapper_func) _wrap_Band_GetColorTable, NULL},
+     { SWIG_prefix "Band_SetRasterColorTable", (swig_wrapper_func) _wrap_Band_SetRasterColorTable, NULL},
+     { SWIG_prefix "Band_SetColorTable", (swig_wrapper_func) _wrap_Band_SetColorTable, NULL},
+     { SWIG_prefix "Band_GetDefaultRAT", (swig_wrapper_func) _wrap_Band_GetDefaultRAT, NULL},
+     { SWIG_prefix "Band_SetDefaultRAT", (swig_wrapper_func) _wrap_Band_SetDefaultRAT, NULL},
+     { SWIG_prefix "Band_GetMaskBand", (swig_wrapper_func) _wrap_Band_GetMaskBand, NULL},
+     { SWIG_prefix "Band_GetMaskFlags", (swig_wrapper_func) _wrap_Band_GetMaskFlags, NULL},
+     { SWIG_prefix "Band_CreateMaskBand", (swig_wrapper_func) _wrap_Band_CreateMaskBand, NULL},
+     { SWIG_prefix "Band_GetHistogram", (swig_wrapper_func) _wrap_Band_GetHistogram, NULL},
+     { SWIG_prefix "Band_GetDefaultHistogram", (swig_wrapper_func) _wrap_Band_GetDefaultHistogram, NULL},
+     { SWIG_prefix "Band_SetDefaultHistogram", (swig_wrapper_func) _wrap_Band_SetDefaultHistogram, NULL},
+     { SWIG_prefix "Band", (swig_wrapper_func) SWIG_ObjectConstructor, (ClientData)&_wrap_class_GDALRasterBandShadow},
+     { SWIG_prefix "new_ColorTable", (swig_wrapper_func) _wrap_new_ColorTable, NULL},
+     { SWIG_prefix "delete_ColorTable", (swig_wrapper_func) _wrap_delete_ColorTable, NULL},
+     { SWIG_prefix "ColorTable_Clone", (swig_wrapper_func) _wrap_ColorTable_Clone, NULL},
+     { SWIG_prefix "ColorTable_GetPaletteInterpretation", (swig_wrapper_func) _wrap_ColorTable_GetPaletteInterpretation, NULL},
+     { SWIG_prefix "ColorTable_GetCount", (swig_wrapper_func) _wrap_ColorTable_GetCount, NULL},
+     { SWIG_prefix "ColorTable_GetColorEntry", (swig_wrapper_func) _wrap_ColorTable_GetColorEntry, NULL},
+     { SWIG_prefix "ColorTable_GetColorEntryAsRGB", (swig_wrapper_func) _wrap_ColorTable_GetColorEntryAsRGB, NULL},
+     { SWIG_prefix "ColorTable_SetColorEntry", (swig_wrapper_func) _wrap_ColorTable_SetColorEntry, NULL},
+     { SWIG_prefix "ColorTable_CreateColorRamp", (swig_wrapper_func) _wrap_ColorTable_CreateColorRamp, NULL},
+     { SWIG_prefix "ColorTable", (swig_wrapper_func) SWIG_ObjectConstructor, (ClientData)&_wrap_class_GDALColorTableShadow},
+     { SWIG_prefix "new_RasterAttributeTable", (swig_wrapper_func) _wrap_new_RasterAttributeTable, NULL},
+     { SWIG_prefix "delete_RasterAttributeTable", (swig_wrapper_func) _wrap_delete_RasterAttributeTable, NULL},
+     { SWIG_prefix "RasterAttributeTable_Clone", (swig_wrapper_func) _wrap_RasterAttributeTable_Clone, NULL},
+     { SWIG_prefix "RasterAttributeTable_GetColumnCount", (swig_wrapper_func) _wrap_RasterAttributeTable_GetColumnCount, NULL},
+     { SWIG_prefix "RasterAttributeTable_GetNameOfCol", (swig_wrapper_func) _wrap_RasterAttributeTable_GetNameOfCol, NULL},
+     { SWIG_prefix "RasterAttributeTable_GetUsageOfCol", (swig_wrapper_func) _wrap_RasterAttributeTable_GetUsageOfCol, NULL},
+     { SWIG_prefix "RasterAttributeTable_GetTypeOfCol", (swig_wrapper_func) _wrap_RasterAttributeTable_GetTypeOfCol, NULL},
+     { SWIG_prefix "RasterAttributeTable_GetColOfUsage", (swig_wrapper_func) _wrap_RasterAttributeTable_GetColOfUsage, NULL},
+     { SWIG_prefix "RasterAttributeTable_GetRowCount", (swig_wrapper_func) _wrap_RasterAttributeTable_GetRowCount, NULL},
+     { SWIG_prefix "RasterAttributeTable_GetValueAsString", (swig_wrapper_func) _wrap_RasterAttributeTable_GetValueAsString, NULL},
+     { SWIG_prefix "RasterAttributeTable_GetValueAsInt", (swig_wrapper_func) _wrap_RasterAttributeTable_GetValueAsInt, NULL},
+     { SWIG_prefix "RasterAttributeTable_GetValueAsDouble", (swig_wrapper_func) _wrap_RasterAttributeTable_GetValueAsDouble, NULL},
+     { SWIG_prefix "RasterAttributeTable_SetValueAsString", (swig_wrapper_func) _wrap_RasterAttributeTable_SetValueAsString, NULL},
+     { SWIG_prefix "RasterAttributeTable_SetValueAsInt", (swig_wrapper_func) _wrap_RasterAttributeTable_SetValueAsInt, NULL},
+     { SWIG_prefix "RasterAttributeTable_SetValueAsDouble", (swig_wrapper_func) _wrap_RasterAttributeTable_SetValueAsDouble, NULL},
+     { SWIG_prefix "RasterAttributeTable_SetRowCount", (swig_wrapper_func) _wrap_RasterAttributeTable_SetRowCount, NULL},
+     { SWIG_prefix "RasterAttributeTable_CreateColumn", (swig_wrapper_func) _wrap_RasterAttributeTable_CreateColumn, NULL},
+     { SWIG_prefix "RasterAttributeTable_GetRowOfValue", (swig_wrapper_func) _wrap_RasterAttributeTable_GetRowOfValue, NULL},
+     { SWIG_prefix "RasterAttributeTable", (swig_wrapper_func) SWIG_ObjectConstructor, (ClientData)&_wrap_class_GDALRasterAttributeTableShadow},
+     { SWIG_prefix "TermProgress_nocb", (swig_wrapper_func) _wrap_TermProgress_nocb, NULL},
+     { SWIG_prefix "ComputeMedianCutPCT", (swig_wrapper_func) _wrap_ComputeMedianCutPCT, NULL},
+     { SWIG_prefix "DitherRGB2PCT", (swig_wrapper_func) _wrap_DitherRGB2PCT, NULL},
+     { SWIG_prefix "ReprojectImage", (swig_wrapper_func) _wrap_ReprojectImage, NULL},
+     { SWIG_prefix "ComputeProximity", (swig_wrapper_func) _wrap_ComputeProximity, NULL},
+     { SWIG_prefix "RasterizeLayer", (swig_wrapper_func) _wrap_RasterizeLayer, NULL},
+     { SWIG_prefix "Polygonize", (swig_wrapper_func) _wrap_Polygonize, NULL},
+     { SWIG_prefix "SieveFilter", (swig_wrapper_func) _wrap_SieveFilter, NULL},
+     { SWIG_prefix "RegenerateOverviews", (swig_wrapper_func) _wrap_RegenerateOverviews, NULL},
+     { SWIG_prefix "RegenerateOverview", (swig_wrapper_func) _wrap_RegenerateOverview, NULL},
+     { SWIG_prefix "AutoCreateWarpedVRT", (swig_wrapper_func) _wrap_AutoCreateWarpedVRT, NULL},
+     { SWIG_prefix "new_Transformer", (swig_wrapper_func) _wrap_new_Transformer, NULL},
+     { SWIG_prefix "delete_Transformer", (swig_wrapper_func) _wrap_delete_Transformer, NULL},
+     { SWIG_prefix "Transformer_TransformPoint", (swig_wrapper_func) _wrap_Transformer_TransformPoint, NULL},
+     { SWIG_prefix "Transformer_TransformPoints", (swig_wrapper_func) _wrap_Transformer_TransformPoints, NULL},
+     { SWIG_prefix "Transformer", (swig_wrapper_func) SWIG_ObjectConstructor, (ClientData)&_wrap_class_GDALTransformerInfoShadow},
+     { SWIG_prefix "VersionInfo", (swig_wrapper_func) _wrap_VersionInfo, NULL},
+     { SWIG_prefix "AllRegister", (swig_wrapper_func) _wrap_AllRegister, NULL},
+     { SWIG_prefix "GDALDestroyDriverManager", (swig_wrapper_func) _wrap_GDALDestroyDriverManager, NULL},
+     { SWIG_prefix "GetCacheMax", (swig_wrapper_func) _wrap_GetCacheMax, NULL},
+     { SWIG_prefix "SetCacheMax", (swig_wrapper_func) _wrap_SetCacheMax, NULL},
+     { SWIG_prefix "GetCacheUsed", (swig_wrapper_func) _wrap_GetCacheUsed, NULL},
+     { SWIG_prefix "GetDataTypeSize", (swig_wrapper_func) _wrap_GetDataTypeSize, NULL},
+     { SWIG_prefix "DataTypeIsComplex", (swig_wrapper_func) _wrap_DataTypeIsComplex, NULL},
+     { SWIG_prefix "GetDataTypeName", (swig_wrapper_func) _wrap_GetDataTypeName, NULL},
+     { SWIG_prefix "GetDataTypeByName", (swig_wrapper_func) _wrap_GetDataTypeByName, NULL},
+     { SWIG_prefix "GetColorInterpretationName", (swig_wrapper_func) _wrap_GetColorInterpretationName, NULL},
+     { SWIG_prefix "GetPaletteInterpretationName", (swig_wrapper_func) _wrap_GetPaletteInterpretationName, NULL},
+     { SWIG_prefix "DecToDMS", (swig_wrapper_func) _wrap_DecToDMS, NULL},
+     { SWIG_prefix "PackedDMSToDec", (swig_wrapper_func) _wrap_PackedDMSToDec, NULL},
+     { SWIG_prefix "DecToPackedDMS", (swig_wrapper_func) _wrap_DecToPackedDMS, NULL},
+     { SWIG_prefix "ParseXMLString", (swig_wrapper_func) _wrap_ParseXMLString, NULL},
+     { SWIG_prefix "SerializeXMLTree", (swig_wrapper_func) _wrap_SerializeXMLTree, NULL},
+     { SWIG_prefix "GetDriverCount", (swig_wrapper_func) _wrap_GetDriverCount, NULL},
+     { SWIG_prefix "GetDriverByName", (swig_wrapper_func) _wrap_GetDriverByName, NULL},
+     { SWIG_prefix "GetDriver", (swig_wrapper_func) _wrap_GetDriver, NULL},
+     { SWIG_prefix "Open", (swig_wrapper_func) _wrap_Open, NULL},
+     { SWIG_prefix "OpenShared", (swig_wrapper_func) _wrap_OpenShared, NULL},
+     { SWIG_prefix "IdentifyDriver", (swig_wrapper_func) _wrap_IdentifyDriver, NULL},
+     { SWIG_prefix "GeneralCmdLineProcessor", (swig_wrapper_func) _wrap_GeneralCmdLineProcessor, NULL},
+     {0, 0, 0}
+ };
+ 
+ static swig_var_info swig_variables[] = {
+     {0,0,0,0}
+ };
+ 
+ static swig_const_info swig_constants[] = {
+     {0,0,0,0,0,0}
+ };
+ 
+ /* -------- TYPE CONVERSION AND EQUIVALENCE RULES (BEGIN) -------- */
+ 
+ static void *_p_GDALDriverShadowTo_p_GDALMajorObjectShadow(void *x, int *SWIGUNUSEDPARM(newmemory)) {
+     return (void *)((GDALMajorObjectShadow *)  ((GDALDriverShadow *) x));
+ }
+ static void *_p_GDALDatasetShadowTo_p_GDALMajorObjectShadow(void *x, int *SWIGUNUSEDPARM(newmemory)) {
+     return (void *)((GDALMajorObjectShadow *)  ((GDALDatasetShadow *) x));
+ }
+ static void *_p_GDALRasterBandShadowTo_p_GDALMajorObjectShadow(void *x, int *SWIGUNUSEDPARM(newmemory)) {
+     return (void *)((GDALMajorObjectShadow *)  ((GDALRasterBandShadow *) x));
+ }
+ static swig_type_info _swigt__p_CPLErrorHandler = {"_p_CPLErrorHandler", "CPLErrorHandler *", 0, 0, (void*)0, 0};
+ static swig_type_info _swigt__p_CPLXMLNode = {"_p_CPLXMLNode", "CPLXMLNode *", 0, 0, (void*)0, 0};
+ static swig_type_info _swigt__p_GByte = {"_p_GByte", "GByte *", 0, 0, (void*)0, 0};
+ static swig_type_info _swigt__p_GDALColorEntry = {"_p_GDALColorEntry", "GDALColorEntry *", 0, 0, (void*)&_wrap_class_GDALColorEntry, 0};
+ static swig_type_info _swigt__p_GDALColorTableShadow = {"_p_GDALColorTableShadow", "GDALColorTableShadow *", 0, 0, (void*)&_wrap_class_GDALColorTableShadow, 0};
+ static swig_type_info _swigt__p_GDALDatasetShadow = {"_p_GDALDatasetShadow", "GDALDatasetShadow *", 0, 0, (void*)&_wrap_class_GDALDatasetShadow, 0};
+ static swig_type_info _swigt__p_GDALDriverShadow = {"_p_GDALDriverShadow", "GDALDriverShadow *", 0, 0, (void*)&_wrap_class_GDALDriverShadow, 0};
+ static swig_type_info _swigt__p_GDALMajorObjectShadow = {"_p_GDALMajorObjectShadow", "GDALMajorObjectShadow *", 0, 0, (void*)&_wrap_class_GDALMajorObjectShadow, 0};
+ static swig_type_info _swigt__p_GDALProgressFunc = {"_p_GDALProgressFunc", "GDALProgressFunc *", 0, 0, (void*)0, 0};
+ static swig_type_info _swigt__p_GDALRasterAttributeTableShadow = {"_p_GDALRasterAttributeTableShadow", "GDALRasterAttributeTableShadow *", 0, 0, (void*)&_wrap_class_GDALRasterAttributeTableShadow, 0};
+ static swig_type_info _swigt__p_GDALRasterBandShadow = {"_p_GDALRasterBandShadow", "GDALRasterBandShadow *", 0, 0, (void*)&_wrap_class_GDALRasterBandShadow, 0};
+ static swig_type_info _swigt__p_GDALTransformerInfoShadow = {"_p_GDALTransformerInfoShadow", "GDALTransformerInfoShadow *", 0, 0, (void*)&_wrap_class_GDALTransformerInfoShadow, 0};
+ static swig_type_info _swigt__p_GDAL_GCP = {"_p_GDAL_GCP", "GDAL_GCP *", 0, 0, (void*)&_wrap_class_GDAL_GCP, 0};
+ static swig_type_info _swigt__p_OGRLayerShadow = {"_p_OGRLayerShadow", "OGRLayerShadow *", 0, 0, (void*)0, 0};
+ static swig_type_info _swigt__p_char = {"_p_char", "char *", 0, 0, (void*)0, 0};
+ static swig_type_info _swigt__p_double = {"_p_double", "double *", 0, 0, (void*)0, 0};
+ static swig_type_info _swigt__p_f_double_p_q_const__char_p_void__int = {"_p_f_double_p_q_const__char_p_void__int", "int (*)(double,char const *,void *)", 0, 0, (void*)0, 0};
+ static swig_type_info _swigt__p_int = {"_p_int", "CPLErr *|GDALRATFieldType *|int *|GDALColorInterp *|GDALAccess *|GDALPaletteInterp *|GDALDataType *|GDALRATFieldUsage *|GDALResampleAlg *", 0, 0, (void*)0, 0};
+ static swig_type_info _swigt__p_p_GDALRasterBandShadow = {"_p_p_GDALRasterBandShadow", "GDALRasterBandShadow **", 0, 0, (void*)0, 0};
+ static swig_type_info _swigt__p_p_GDAL_GCP = {"_p_p_GDAL_GCP", "GDAL_GCP **", 0, 0, (void*)0, 0};
+ static swig_type_info _swigt__p_p_char = {"_p_p_char", "char **", 0, 0, (void*)0, 0};
+ static swig_type_info _swigt__p_p_int = {"_p_p_int", "int **", 0, 0, (void*)0, 0};
+ 
+ static swig_type_info *swig_type_initial[] = {
+   &_swigt__p_CPLErrorHandler,
+   &_swigt__p_CPLXMLNode,
+   &_swigt__p_GByte,
+   &_swigt__p_GDALColorEntry,
+   &_swigt__p_GDALColorTableShadow,
+   &_swigt__p_GDALDatasetShadow,
+   &_swigt__p_GDALDriverShadow,
+   &_swigt__p_GDALMajorObjectShadow,
+   &_swigt__p_GDALProgressFunc,
+   &_swigt__p_GDALRasterAttributeTableShadow,
+   &_swigt__p_GDALRasterBandShadow,
+   &_swigt__p_GDALTransformerInfoShadow,
+   &_swigt__p_GDAL_GCP,
+   &_swigt__p_OGRLayerShadow,
+   &_swigt__p_char,
+   &_swigt__p_double,
+   &_swigt__p_f_double_p_q_const__char_p_void__int,
+   &_swigt__p_int,
+   &_swigt__p_p_GDALRasterBandShadow,
+   &_swigt__p_p_GDAL_GCP,
+   &_swigt__p_p_char,
+   &_swigt__p_p_int,
+ };
+ 
+ static swig_cast_info _swigc__p_CPLErrorHandler[] = {  {&_swigt__p_CPLErrorHandler, 0, 0, 0},{0, 0, 0, 0}};
+ static swig_cast_info _swigc__p_CPLXMLNode[] = {  {&_swigt__p_CPLXMLNode, 0, 0, 0},{0, 0, 0, 0}};
+ static swig_cast_info _swigc__p_GByte[] = {  {&_swigt__p_GByte, 0, 0, 0},{0, 0, 0, 0}};
+ static swig_cast_info _swigc__p_GDALColorEntry[] = {  {&_swigt__p_GDALColorEntry, 0, 0, 0},{0, 0, 0, 0}};
+ static swig_cast_info _swigc__p_GDALColorTableShadow[] = {  {&_swigt__p_GDALColorTableShadow, 0, 0, 0},{0, 0, 0, 0}};
+ static swig_cast_info _swigc__p_GDALDatasetShadow[] = {  {&_swigt__p_GDALDatasetShadow, 0, 0, 0},{0, 0, 0, 0}};
+ static swig_cast_info _swigc__p_GDALDriverShadow[] = {  {&_swigt__p_GDALDriverShadow, 0, 0, 0},{0, 0, 0, 0}};
+ static swig_cast_info _swigc__p_GDALMajorObjectShadow[] = {  {&_swigt__p_GDALMajorObjectShadow, 0, 0, 0},  {&_swigt__p_GDALDriverShadow, _p_GDALDriverShadowTo_p_GDALMajorObjectShadow, 0, 0},  {&_swigt__p_GDALDatasetShadow, _p_GDALDatasetShadowTo_p_GDALMajorObjectShadow, 0, 0},  {&_swigt__p_GDALRasterBandShadow, _p_GDALRasterBandShadowTo_p_GDALMajorObjectShadow, 0, 0},{0, 0, 0, 0}};
+ static swig_cast_info _swigc__p_GDALProgressFunc[] = {  {&_swigt__p_GDALProgressFunc, 0, 0, 0},{0, 0, 0, 0}};
+ static swig_cast_info _swigc__p_GDALRasterAttributeTableShadow[] = {  {&_swigt__p_GDALRasterAttributeTableShadow, 0, 0, 0},{0, 0, 0, 0}};
+ static swig_cast_info _swigc__p_GDALRasterBandShadow[] = {  {&_swigt__p_GDALRasterBandShadow, 0, 0, 0},{0, 0, 0, 0}};
+ static swig_cast_info _swigc__p_GDALTransformerInfoShadow[] = {  {&_swigt__p_GDALTransformerInfoShadow, 0, 0, 0},{0, 0, 0, 0}};
+ static swig_cast_info _swigc__p_GDAL_GCP[] = {  {&_swigt__p_GDAL_GCP, 0, 0, 0},{0, 0, 0, 0}};
+ static swig_cast_info _swigc__p_OGRLayerShadow[] = {  {&_swigt__p_OGRLayerShadow, 0, 0, 0},{0, 0, 0, 0}};
+ static swig_cast_info _swigc__p_char[] = {  {&_swigt__p_char, 0, 0, 0},{0, 0, 0, 0}};
+ static swig_cast_info _swigc__p_double[] = {  {&_swigt__p_double, 0, 0, 0},{0, 0, 0, 0}};
+ static swig_cast_info _swigc__p_f_double_p_q_const__char_p_void__int[] = {  {&_swigt__p_f_double_p_q_const__char_p_void__int, 0, 0, 0},{0, 0, 0, 0}};
+ static swig_cast_info _swigc__p_int[] = {  {&_swigt__p_int, 0, 0, 0},{0, 0, 0, 0}};
+ static swig_cast_info _swigc__p_p_GDALRasterBandShadow[] = {  {&_swigt__p_p_GDALRasterBandShadow, 0, 0, 0},{0, 0, 0, 0}};
+ static swig_cast_info _swigc__p_p_GDAL_GCP[] = {  {&_swigt__p_p_GDAL_GCP, 0, 0, 0},{0, 0, 0, 0}};
+ static swig_cast_info _swigc__p_p_char[] = {  {&_swigt__p_p_char, 0, 0, 0},{0, 0, 0, 0}};
+ static swig_cast_info _swigc__p_p_int[] = {  {&_swigt__p_p_int, 0, 0, 0},{0, 0, 0, 0}};
+ 
+ static swig_cast_info *swig_cast_initial[] = {
+   _swigc__p_CPLErrorHandler,
+   _swigc__p_CPLXMLNode,
+   _swigc__p_GByte,
+   _swigc__p_GDALColorEntry,
+   _swigc__p_GDALColorTableShadow,
+   _swigc__p_GDALDatasetShadow,
+   _swigc__p_GDALDriverShadow,
+   _swigc__p_GDALMajorObjectShadow,
+   _swigc__p_GDALProgressFunc,
+   _swigc__p_GDALRasterAttributeTableShadow,
+   _swigc__p_GDALRasterBandShadow,
+   _swigc__p_GDALTransformerInfoShadow,
+   _swigc__p_GDAL_GCP,
+   _swigc__p_OGRLayerShadow,
+   _swigc__p_char,
+   _swigc__p_double,
+   _swigc__p_f_double_p_q_const__char_p_void__int,
+   _swigc__p_int,
+   _swigc__p_p_GDALRasterBandShadow,
+   _swigc__p_p_GDAL_GCP,
+   _swigc__p_p_char,
+   _swigc__p_p_int,
+ };
+ 
+ 
+ /* -------- TYPE CONVERSION AND EQUIVALENCE RULES (END) -------- */
+ 
+ #ifdef __cplusplus
+ }
+ #endif
+ /* -----------------------------------------------------------------------------
+  * Type initialization:
+  * This problem is tough by the requirement that no dynamic 
+  * memory is used. Also, since swig_type_info structures store pointers to 
+  * swig_cast_info structures and swig_cast_info structures store pointers back
+  * to swig_type_info structures, we need some lookup code at initialization. 
+  * The idea is that swig generates all the structures that are needed. 
+  * The runtime then collects these partially filled structures. 
+  * The SWIG_InitializeModule function takes these initial arrays out of 
+  * swig_module, and does all the lookup, filling in the swig_module.types
+  * array with the correct data and linking the correct swig_cast_info
+  * structures together.
+  *
+  * The generated swig_type_info structures are assigned staticly to an initial 
+  * array. We just loop through that array, and handle each type individually.
+  * First we lookup if this type has been already loaded, and if so, use the
+  * loaded structure instead of the generated one. Then we have to fill in the
+  * cast linked list. The cast data is initially stored in something like a
+  * two-dimensional array. Each row corresponds to a type (there are the same
+  * number of rows as there are in the swig_type_initial array). Each entry in
+  * a column is one of the swig_cast_info structures for that type.
+  * The cast_initial array is actually an array of arrays, because each row has
+  * a variable number of columns. So to actually build the cast linked list,
+  * we find the array of casts associated with the type, and loop through it 
+  * adding the casts to the list. The one last trick we need to do is making
+  * sure the type pointer in the swig_cast_info struct is correct.
+  *
+  * First off, we lookup the cast->type name to see if it is already loaded. 
+  * There are three cases to handle:
+  *  1) If the cast->type has already been loaded AND the type we are adding
+  *     casting info to has not been loaded (it is in this module), THEN we
+  *     replace the cast->type pointer with the type pointer that has already
+  *     been loaded.
+  *  2) If BOTH types (the one we are adding casting info to, and the 
+  *     cast->type) are loaded, THEN the cast info has already been loaded by
+  *     the previous module so we just ignore it.
+  *  3) Finally, if cast->type has not already been loaded, then we add that
+  *     swig_cast_info to the linked list (because the cast->type) pointer will
+  *     be correct.
+  * ----------------------------------------------------------------------------- */
+ 
+ #ifdef __cplusplus
+ extern "C" {
+ #if 0
+ } /* c-mode */
+ #endif
+ #endif
+ 
+ #if 0
+ #define SWIGRUNTIME_DEBUG
+ #endif
+ 
+ 
+ SWIGRUNTIME void
+ SWIG_InitializeModule(void *clientdata) {
+   size_t i;
+   swig_module_info *module_head, *iter;
+   int found, init;
+   
+   clientdata = clientdata;
+   
+   /* check to see if the circular list has been setup, if not, set it up */
+   if (swig_module.next==0) {
+     /* Initialize the swig_module */
+     swig_module.type_initial = swig_type_initial;
+     swig_module.cast_initial = swig_cast_initial;
+     swig_module.next = &swig_module;
+     init = 1;
+   } else {
+     init = 0;
+   }
+   
+   /* Try and load any already created modules */
+   module_head = SWIG_GetModule(clientdata);
+   if (!module_head) {
+     /* This is the first module loaded for this interpreter */
+     /* so set the swig module into the interpreter */
+     SWIG_SetModule(clientdata, &swig_module);
+     module_head = &swig_module;
+   } else {
+     /* the interpreter has loaded a SWIG module, but has it loaded this one? */
+     found=0;
+     iter=module_head;
+     do {
+       if (iter==&swig_module) {
+         found=1;
+         break;
+       }
+       iter=iter->next;
+     } while (iter!= module_head);
+     
+     /* if the is found in the list, then all is done and we may leave */
+     if (found) return;
+     /* otherwise we must add out module into the list */
+     swig_module.next = module_head->next;
+     module_head->next = &swig_module;
+   }
+   
+   /* When multiple interpeters are used, a module could have already been initialized in
+        a different interpreter, but not yet have a pointer in this interpreter.
+        In this case, we do not want to continue adding types... everything should be
+        set up already */
+   if (init == 0) return;
+   
+   /* Now work on filling in swig_module.types */
+ #ifdef SWIGRUNTIME_DEBUG
+   printf("SWIG_InitializeModule: size %d\n", swig_module.size);
+ #endif
+   for (i = 0; i < swig_module.size; ++i) {
+     swig_type_info *type = 0;
+     swig_type_info *ret;
+     swig_cast_info *cast;
+     
+ #ifdef SWIGRUNTIME_DEBUG
+     printf("SWIG_InitializeModule: type %d %s\n", i, swig_module.type_initial[i]->name);
+ #endif
+     
+     /* if there is another module already loaded */
+     if (swig_module.next != &swig_module) {
+       type = SWIG_MangledTypeQueryModule(swig_module.next, &swig_module, swig_module.type_initial[i]->name);
+     }
+     if (type) {
+       /* Overwrite clientdata field */
+ #ifdef SWIGRUNTIME_DEBUG
+       printf("SWIG_InitializeModule: found type %s\n", type->name);
+ #endif
+       if (swig_module.type_initial[i]->clientdata) {
+         type->clientdata = swig_module.type_initial[i]->clientdata;
+ #ifdef SWIGRUNTIME_DEBUG
+         printf("SWIG_InitializeModule: found and overwrite type %s \n", type->name);
+ #endif
+       }
+     } else {
+       type = swig_module.type_initial[i];
+     }
+     
+     /* Insert casting types */
+     cast = swig_module.cast_initial[i];
+     while (cast->type) {
+       /* Don't need to add information already in the list */
+       ret = 0;
+ #ifdef SWIGRUNTIME_DEBUG
+       printf("SWIG_InitializeModule: look cast %s\n", cast->type->name);
+ #endif
+       if (swig_module.next != &swig_module) {
+         ret = SWIG_MangledTypeQueryModule(swig_module.next, &swig_module, cast->type->name);
+ #ifdef SWIGRUNTIME_DEBUG
+         if (ret) printf("SWIG_InitializeModule: found cast %s\n", ret->name);
+ #endif
+       }
+       if (ret) {
+         if (type == swig_module.type_initial[i]) {
+ #ifdef SWIGRUNTIME_DEBUG
+           printf("SWIG_InitializeModule: skip old type %s\n", ret->name);
+ #endif
+           cast->type = ret;
+           ret = 0;
+         } else {
+           /* Check for casting already in the list */
+           swig_cast_info *ocast = SWIG_TypeCheck(ret->name, type);
+ #ifdef SWIGRUNTIME_DEBUG
+           if (ocast) printf("SWIG_InitializeModule: skip old cast %s\n", ret->name);
+ #endif
+           if (!ocast) ret = 0;
+         }
+       }
+       
+       if (!ret) {
+ #ifdef SWIGRUNTIME_DEBUG
+         printf("SWIG_InitializeModule: adding cast %s\n", cast->type->name);
+ #endif
+         if (type->cast) {
+           type->cast->prev = cast;
+           cast->next = type->cast;
+         }
+         type->cast = cast;
+       }
+       cast++;
+     }
+     /* Set entry in modules->types array equal to the type */
+     swig_module.types[i] = type;
+   }
+   swig_module.types[i] = 0;
+   
+ #ifdef SWIGRUNTIME_DEBUG
+   printf("**** SWIG_InitializeModule: Cast List ******\n");
+   for (i = 0; i < swig_module.size; ++i) {
+     int j = 0;
+     swig_cast_info *cast = swig_module.cast_initial[i];
+     printf("SWIG_InitializeModule: type %d %s\n", i, swig_module.type_initial[i]->name);
+     while (cast->type) {
+       printf("SWIG_InitializeModule: cast type %s\n", cast->type->name);
+       cast++;
+       ++j;
+     }
+     printf("---- Total casts: %d\n",j);
+   }
+   printf("**** SWIG_InitializeModule: Cast List ******\n");
+ #endif
+ }
+ 
+ /* This function will propagate the clientdata field of type to
+ * any new swig_type_info structures that have been added into the list
+ * of equivalent types.  It is like calling
+ * SWIG_TypeClientData(type, clientdata) a second time.
+ */
+ SWIGRUNTIME void
+ SWIG_PropagateClientData(void) {
+   size_t i;
+   swig_cast_info *equiv;
+   static int init_run = 0;
+   
+   if (init_run) return;
+   init_run = 1;
+   
+   for (i = 0; i < swig_module.size; i++) {
+     if (swig_module.types[i]->clientdata) {
+       equiv = swig_module.types[i]->cast;
+       while (equiv) {
+         if (!equiv->converter) {
+           if (equiv->type && !equiv->type->clientdata)
+           SWIG_TypeClientData(equiv->type, swig_module.types[i]->clientdata);
+         }
+         equiv = equiv->next;
+       }
+     }
+   }
+ }
+ 
+ #ifdef __cplusplus
+ #if 0
+ {
+   /* c-mode */
+ #endif
+ }
+ #endif
+ 
+ 
+ #ifdef __cplusplus
+ extern "C" {
+ #endif
+   
+   /* -----------------------------------------------------------------------------
+    * constants/methods manipulation
+    * ----------------------------------------------------------------------------- */
+   
+   /* Install Constants */
+   
+   SWIGINTERN void
+   SWIG_Tcl_InstallConstants(Tcl_Interp *interp, swig_const_info constants[]) {
+     int i;
+     Tcl_Obj *obj;
+     
+     if (!swigconstTableinit) {
+       Tcl_InitHashTable(&swigconstTable, TCL_STRING_KEYS);
+       swigconstTableinit = 1;
+     }
+     for (i = 0; constants[i].type; i++) {
+       switch(constants[i].type) {
+       case SWIG_TCL_POINTER:
+         obj = SWIG_NewPointerObj(constants[i].pvalue, *(constants[i]).ptype,0);
+         break;
+       case SWIG_TCL_BINARY:
+         obj = SWIG_NewPackedObj(constants[i].pvalue, constants[i].lvalue, *(constants[i].ptype));
+         break;
+       default:
+         obj = 0;
+         break;
+       }
+       if (obj) {
+         SWIG_Tcl_SetConstantObj(interp, constants[i].name, obj);
+       }
+     }
+   }
+   
+ #ifdef __cplusplus
+ }
+ #endif
+ 
+ /* -----------------------------------------------------------------------------*
+  *  Partial Init method
+  * -----------------------------------------------------------------------------*/
+ 
+ SWIGEXPORT int SWIG_init(Tcl_Interp *interp) {
+   int i;
+   if (interp == 0) return TCL_ERROR;
+ #ifdef USE_TCL_STUBS
+   if (Tcl_InitStubs(interp, (char*)"8.1", 0) == NULL) {
+     return TCL_ERROR;
+   }
+ #endif  
+   Tcl_PkgProvide(interp, (char*)SWIG_name, (char*)SWIG_version);
+   
+ #ifdef SWIG_namespace
+   Tcl_Eval(interp, "namespace eval " SWIG_namespace " { }");
+ #endif
+   
+   SWIG_InitializeModule((void *) interp);
+   SWIG_PropagateClientData();
+   
+   for (i = 0; swig_commands[i].name; i++) {
+     Tcl_CreateObjCommand(interp, (char *) swig_commands[i].name, (swig_wrapper_func) swig_commands[i].wrapper,
+       swig_commands[i].clientdata, NULL);
+   }
+   for (i = 0; swig_variables[i].name; i++) {
+     Tcl_SetVar(interp, (char *) swig_variables[i].name, (char *) "", TCL_GLOBAL_ONLY);
+     Tcl_TraceVar(interp, (char *) swig_variables[i].name, TCL_TRACE_READS | TCL_GLOBAL_ONLY, 
+       (Tcl_VarTraceProc *) swig_variables[i].get, (ClientData) swig_variables[i].addr);
+     Tcl_TraceVar(interp, (char *) swig_variables[i].name, TCL_TRACE_WRITES | TCL_GLOBAL_ONLY, 
+       (Tcl_VarTraceProc *) swig_variables[i].set, (ClientData) swig_variables[i].addr);
+   }
+   
+   SWIG_Tcl_InstallConstants(interp, swig_constants);
+   
+   
+   
+   /* gdal_tcl.i %init code */
+   if ( GDALGetDriverCount() == 0 ) {
+     GDALAllRegister();
+   }
+   
+   /* Setup exception handling */
+   UseExceptions();
+   
+   SWIG_Tcl_SetConstantObj(interp, "osgeo::TermProgress", SWIG_NewFunctionPtrObj((void *)(int (*)(double,char const *,void *))(GDALTermProgress), SWIGTYPE_p_f_double_p_q_const__char_p_void__int));
+   return TCL_OK;
+ }
+ SWIGEXPORT int Gdal_SafeInit(Tcl_Interp *interp) {
+   return SWIG_init(interp);
+ }
+ 
diff -rNc gdal-1.6.1/swig/tcl/GNUmakefile gdal-1.6.1-patched/swig/tcl/GNUmakefile
*** gdal-1.6.1/swig/tcl/GNUmakefile	1970-01-01 02:00:00.000000000 +0200
--- gdal-1.6.1-patched/swig/tcl/GNUmakefile	2009-06-28 16:57:29.000000000 +0300
***************
*** 0 ****
--- 1,56 ----
+ # This makefile generates 4 Tcl extensions - one each for
+ # gdal, ogr, osr, and gdalconstants.
+ 
+ include ../../GDALmake.opt
+ 
+ all: build
+ 
+ BINDING = tcl
+ TCL = tclsh
+ include ../SWIGmake.base
+ 
+ #ZZZ Generate these variables by Configure.in
+ DESTDIR := $(prefix)
+ TCL_BINDING_VERSION = 1.0
+ TCL_MODULES = gdal.so ogr.so gdalconst.so osr.so
+ TCL_INCLUDE_DIR := /usr/include
+ TCL_LIB_DIR := /usr/lib
+ TCL_SO_NAME := tclstub8.5
+ INSTALL_DIR := /usr/local/lib
+ SWIGARGS += -namespace -prefix "osgeo" -pkgversion $(TCL_BINDING_VERSION)
+ 
+ TCL_INCLUDE = -I$(TCL_INCLUDE_DIR)
+ LDFLAGS += -shared -L$(TCL_LIB_DIR)
+ TCL_LIB := -l$(TCL_SO_NAME)
+ 
+ build: $(TCL_MODULES)
+ 
+ clean:
+ 	rm -f *.so
+ 	rm -f *.o
+ 	rm -f *.lo
+ 
+ veryclean: clean
+ 	rm -f $(WRAPPERS)
+ 	rm -frd $(INSTALL_DIR)/osgeo-$(TCL_BINDING_VERSION)
+ 
+ generate: ${WRAPPERS}
+ 
+ $(DESTDIR)$(INSTALL_DIR)/osgeo-$(TCL_BINDING_VERSION):
+ 	mkdir -p $(DESTDIR)$(INSTALL_DIR)/osgeo-$(TCL_BINDING_VERSION)
+ 
+ install: $(DESTDIR)$(INSTALL_DIR)/osgeo-$(TCL_BINDING_VERSION)
+ 	install $(TCL_MODULES) $(DESTDIR)$(INSTALL_DIR)/osgeo-$(TCL_BINDING_VERSION)
+ 	$(TCL) <<< 'pkg_mkIndex $(DESTDIR)$(INSTALL_DIR)/osgeo-$(TCL_BINDING_VERSION) $(TCL_MODULES)'
+ 
+ $(TCL_MODULES): %.so: %_wrap.o
+ 	$(LD) $(LDFLAGS) $(LIBS) $(GDAL_SLIB_LINK) $(TCL_LIB) $< -o $@
+ 
+ %.o: %.cpp
+ 	$(CXX) $(CFLAGS) $(GDAL_INCLUDE) $(TCL_INCLUDE)  -c $<
+ 
+ %.o: %.cxx
+ 	$(CXX) $(CFLAGS) $(GDAL_INCLUDE) $(TCL_INCLUDE) -c $<
+ 
+ %.o: %.c
+ 	$(CC) $(CFLAGS) $(GDAL_INCLUDE)  $(TCL_INCLUDE) -c $<
diff -rNc gdal-1.6.1/swig/tcl/makefile.vc gdal-1.6.1-patched/swig/tcl/makefile.vc
*** gdal-1.6.1/swig/tcl/makefile.vc	1970-01-01 02:00:00.000000000 +0200
--- gdal-1.6.1-patched/swig/tcl/makefile.vc	2009-06-19 13:46:54.000000000 +0300
***************
*** 0 ****
--- 1,68 ----
+ # ZZZ
+ # Use this makefile to build Ruby GDAL bindings on Windows.
+ #
+ #	nmake -f makefile.vc build - Will build the bindings
+ #	nmake -f makefile.vc install - Will install the bindings
+ #		to the local Ruby installation
+ #
+ # Note you must manually set the variable RUBY_DIR, and possibly
+ # RUBY_VERSION.
+ 
+ GDAL_ROOT = ../..
+ !INCLUDE $(GDAL_ROOT)/nmake.opt
+ 
+ RUBY_VERSION = 1.8
+ RUBY_ARCH = i386-mswin32
+ RUBY_SO_NAME = msvcrt-ruby18.lib
+ 
+ RUBY_DIR = C:\Development\ruby
+ RUBY_ARCH_DIR = $(RUBY_DIR)\lib\ruby\$(RUBY_VERSION)\$(RUBY_ARCH)
+ INSTALLATION_DIR = $(RUBY_DIR)\lib\ruby\site_ruby\$(RUBY_VERSION)\i386-msvcrt\gdal
+ 
+ $(INSTALLATION_DIR):
+ 	mkdir $(INSTALLATION_DIR)
+ 
+ install: $(INSTALLATION_DIR)
+ 	cp *.so $(INSTALLATION_DIR)
+ 
+ build: $(INSTALLATION_DIR) gdal.so gdalconst.so ogr.so osr.so
+ 
+ gdal.so: gdal_wrap.obj
+ 	link /dll /debug $(LINKER_FLAGS) $(EXTERNAL_LIBS) \
+ 	/LIBPATH:$(RUBY_DIR)/lib $(RUBY_SO_NAME) $(GDALLIB) \
+     /out:$*.so $*_wrap.obj
+     
+ gdalconst.so: gdalconst_wrap.obj
+ 	link /dll /debug $(LINKER_FLAGS) $(EXTERNAL_LIBS) \
+ 	/LIBPATH:$(RUBY_DIR)/lib $(RUBY_SO_NAME) $(GDALLIB) \
+     /out:$*.so $*_wrap.obj
+ 
+ ogr.so: ogr_wrap.obj
+ 	link /dll /debug $(LINKER_FLAGS) $(EXTERNAL_LIBS) \
+ 	/LIBPATH:$(RUBY_DIR)/lib $(RUBY_SO_NAME) $(GDALLIB) \
+     /out:$*.so $*_wrap.obj
+     
+ osr.so: osr_wrap.obj
+ 	link /dll /debug $(LINKER_FLAGS) $(EXTERNAL_LIBS) \
+ 	/LIBPATH:$(RUBY_DIR)/lib $(RUBY_SO_NAME) $(GDALLIB) \
+     /out:$*.so $*_wrap.obj
+     
+     
+ .c.obj:	
+ 	$(CC) $(CFLAGS) /I $(RUBY_ARCH_DIR) /c $*.c
+ 
+ .cpp.obj:	
+ 	$(CC) $(CFLAGS) /I $(RUBY_ARCH_DIR) /c $*.cpp
+ 
+ clean:	
+ 	-del *.c
+ 	-del *.cpp
+ 	-del *.so
+ 	-del *.dll
+ 	-del *.obj
+ 	-del *.exp
+ 	-del *.ilk
+ 	-del *.pdb
+ 	-del *.lib
+ 	if exist $(RUBY_ARCH_DIR)\gdal\nul rmdir /S /Q $(RUBY_ARCH_DIR)\gdal
+ 
diff -rNc gdal-1.6.1/swig/tcl/ogr_wrap.cpp gdal-1.6.1-patched/swig/tcl/ogr_wrap.cpp
*** gdal-1.6.1/swig/tcl/ogr_wrap.cpp	1970-01-01 02:00:00.000000000 +0200
--- gdal-1.6.1-patched/swig/tcl/ogr_wrap.cpp	2009-06-30 15:40:04.000000000 +0300
***************
*** 0 ****
--- 1,13697 ----
+ /* ----------------------------------------------------------------------------
+  * This file was automatically generated by SWIG (http://www.swig.org).
+  * Version 1.3.36
+  * 
+  * This file is not intended to be easily readable and contains a number of 
+  * coding conventions designed to improve portability and efficiency. Do not make
+  * changes to this file unless you know what you are doing--modify the SWIG 
+  * interface file instead. 
+  * ----------------------------------------------------------------------------- */
+ 
+ 
+ #ifdef __cplusplus
+ template<typename T> class SwigValueWrapper {
+     T *tt;
+ public:
+     SwigValueWrapper() : tt(0) { }
+     SwigValueWrapper(const SwigValueWrapper<T>& rhs) : tt(new T(*rhs.tt)) { }
+     SwigValueWrapper(const T& t) : tt(new T(t)) { }
+     ~SwigValueWrapper() { delete tt; } 
+     SwigValueWrapper& operator=(const T& t) { delete tt; tt = new T(t); return *this; }
+     operator T&() const { return *tt; }
+     T *operator&() { return tt; }
+ private:
+     SwigValueWrapper& operator=(const SwigValueWrapper<T>& rhs);
+ };
+ 
+ template <typename T> T SwigValueInit() {
+   return T();
+ }
+ #endif
+ 
+ /* -----------------------------------------------------------------------------
+  *  This section contains generic SWIG labels for method/variable
+  *  declarations/attributes, and other compiler dependent labels.
+  * ----------------------------------------------------------------------------- */
+ 
+ /* template workaround for compilers that cannot correctly implement the C++ standard */
+ #ifndef SWIGTEMPLATEDISAMBIGUATOR
+ # if defined(__SUNPRO_CC) && (__SUNPRO_CC <= 0x560)
+ #  define SWIGTEMPLATEDISAMBIGUATOR template
+ # elif defined(__HP_aCC)
+ /* Needed even with `aCC -AA' when `aCC -V' reports HP ANSI C++ B3910B A.03.55 */
+ /* If we find a maximum version that requires this, the test would be __HP_aCC <= 35500 for A.03.55 */
+ #  define SWIGTEMPLATEDISAMBIGUATOR template
+ # else
+ #  define SWIGTEMPLATEDISAMBIGUATOR
+ # endif
+ #endif
+ 
+ /* inline attribute */
+ #ifndef SWIGINLINE
+ # if defined(__cplusplus) || (defined(__GNUC__) && !defined(__STRICT_ANSI__))
+ #   define SWIGINLINE inline
+ # else
+ #   define SWIGINLINE
+ # endif
+ #endif
+ 
+ /* attribute recognised by some compilers to avoid 'unused' warnings */
+ #ifndef SWIGUNUSED
+ # if defined(__GNUC__)
+ #   if !(defined(__cplusplus)) || (__GNUC__ > 3 || (__GNUC__ == 3 && __GNUC_MINOR__ >= 4))
+ #     define SWIGUNUSED __attribute__ ((__unused__)) 
+ #   else
+ #     define SWIGUNUSED
+ #   endif
+ # elif defined(__ICC)
+ #   define SWIGUNUSED __attribute__ ((__unused__)) 
+ # else
+ #   define SWIGUNUSED 
+ # endif
+ #endif
+ 
+ #ifndef SWIG_MSC_UNSUPPRESS_4505
+ # if defined(_MSC_VER)
+ #   pragma warning(disable : 4505) /* unreferenced local function has been removed */
+ # endif 
+ #endif
+ 
+ #ifndef SWIGUNUSEDPARM
+ # ifdef __cplusplus
+ #   define SWIGUNUSEDPARM(p)
+ # else
+ #   define SWIGUNUSEDPARM(p) p SWIGUNUSED 
+ # endif
+ #endif
+ 
+ /* internal SWIG method */
+ #ifndef SWIGINTERN
+ # define SWIGINTERN static SWIGUNUSED
+ #endif
+ 
+ /* internal inline SWIG method */
+ #ifndef SWIGINTERNINLINE
+ # define SWIGINTERNINLINE SWIGINTERN SWIGINLINE
+ #endif
+ 
+ /* exporting methods */
+ #if (__GNUC__ >= 4) || (__GNUC__ == 3 && __GNUC_MINOR__ >= 4)
+ #  ifndef GCC_HASCLASSVISIBILITY
+ #    define GCC_HASCLASSVISIBILITY
+ #  endif
+ #endif
+ 
+ #ifndef SWIGEXPORT
+ # if defined(_WIN32) || defined(__WIN32__) || defined(__CYGWIN__)
+ #   if defined(STATIC_LINKED)
+ #     define SWIGEXPORT
+ #   else
+ #     define SWIGEXPORT __declspec(dllexport)
+ #   endif
+ # else
+ #   if defined(__GNUC__) && defined(GCC_HASCLASSVISIBILITY)
+ #     define SWIGEXPORT __attribute__ ((visibility("default")))
+ #   else
+ #     define SWIGEXPORT
+ #   endif
+ # endif
+ #endif
+ 
+ /* calling conventions for Windows */
+ #ifndef SWIGSTDCALL
+ # if defined(_WIN32) || defined(__WIN32__) || defined(__CYGWIN__)
+ #   define SWIGSTDCALL __stdcall
+ # else
+ #   define SWIGSTDCALL
+ # endif 
+ #endif
+ 
+ /* Deal with Microsoft's attempt at deprecating C standard runtime functions */
+ #if !defined(SWIG_NO_CRT_SECURE_NO_DEPRECATE) && defined(_MSC_VER) && !defined(_CRT_SECURE_NO_DEPRECATE)
+ # define _CRT_SECURE_NO_DEPRECATE
+ #endif
+ 
+ /* Deal with Microsoft's attempt at deprecating methods in the standard C++ library */
+ #if !defined(SWIG_NO_SCL_SECURE_NO_DEPRECATE) && defined(_MSC_VER) && !defined(_SCL_SECURE_NO_DEPRECATE)
+ # define _SCL_SECURE_NO_DEPRECATE
+ #endif
+ 
+ 
+ 
+ #include <stdio.h>
+ #include <tcl.h>
+ #include <errno.h>
+ #include <stdlib.h>
+ #include <stdarg.h>
+ #include <ctype.h>
+ 
+ /* -----------------------------------------------------------------------------
+  * swigrun.swg
+  *
+  * This file contains generic CAPI SWIG runtime support for pointer
+  * type checking.
+  * ----------------------------------------------------------------------------- */
+ 
+ /* This should only be incremented when either the layout of swig_type_info changes,
+    or for whatever reason, the runtime changes incompatibly */
+ #define SWIG_RUNTIME_VERSION "4"
+ 
+ /* define SWIG_TYPE_TABLE_NAME as "SWIG_TYPE_TABLE" */
+ #ifdef SWIG_TYPE_TABLE
+ # define SWIG_QUOTE_STRING(x) #x
+ # define SWIG_EXPAND_AND_QUOTE_STRING(x) SWIG_QUOTE_STRING(x)
+ # define SWIG_TYPE_TABLE_NAME SWIG_EXPAND_AND_QUOTE_STRING(SWIG_TYPE_TABLE)
+ #else
+ # define SWIG_TYPE_TABLE_NAME
+ #endif
+ 
+ /*
+   You can use the SWIGRUNTIME and SWIGRUNTIMEINLINE macros for
+   creating a static or dynamic library from the swig runtime code.
+   In 99.9% of the cases, swig just needs to declare them as 'static'.
+   
+   But only do this if is strictly necessary, ie, if you have problems
+   with your compiler or so.
+ */
+ 
+ #ifndef SWIGRUNTIME
+ # define SWIGRUNTIME SWIGINTERN
+ #endif
+ 
+ #ifndef SWIGRUNTIMEINLINE
+ # define SWIGRUNTIMEINLINE SWIGRUNTIME SWIGINLINE
+ #endif
+ 
+ /*  Generic buffer size */
+ #ifndef SWIG_BUFFER_SIZE
+ # define SWIG_BUFFER_SIZE 1024
+ #endif
+ 
+ /* Flags for pointer conversions */
+ #define SWIG_POINTER_DISOWN        0x1
+ #define SWIG_CAST_NEW_MEMORY       0x2
+ 
+ /* Flags for new pointer objects */
+ #define SWIG_POINTER_OWN           0x1
+ 
+ 
+ /* 
+    Flags/methods for returning states.
+    
+    The swig conversion methods, as ConvertPtr, return and integer 
+    that tells if the conversion was successful or not. And if not,
+    an error code can be returned (see swigerrors.swg for the codes).
+    
+    Use the following macros/flags to set or process the returning
+    states.
+    
+    In old swig versions, you usually write code as:
+ 
+      if (SWIG_ConvertPtr(obj,vptr,ty.flags) != -1) {
+        // success code
+      } else {
+        //fail code
+      }
+ 
+    Now you can be more explicit as:
+ 
+     int res = SWIG_ConvertPtr(obj,vptr,ty.flags);
+     if (SWIG_IsOK(res)) {
+       // success code
+     } else {
+       // fail code
+     }
+ 
+    that seems to be the same, but now you can also do
+ 
+     Type *ptr;
+     int res = SWIG_ConvertPtr(obj,(void **)(&ptr),ty.flags);
+     if (SWIG_IsOK(res)) {
+       // success code
+       if (SWIG_IsNewObj(res) {
+         ...
+ 	delete *ptr;
+       } else {
+         ...
+       }
+     } else {
+       // fail code
+     }
+     
+    I.e., now SWIG_ConvertPtr can return new objects and you can
+    identify the case and take care of the deallocation. Of course that
+    requires also to SWIG_ConvertPtr to return new result values, as
+ 
+       int SWIG_ConvertPtr(obj, ptr,...) {         
+         if (<obj is ok>) {			       
+           if (<need new object>) {		       
+             *ptr = <ptr to new allocated object>; 
+             return SWIG_NEWOBJ;		       
+           } else {				       
+             *ptr = <ptr to old object>;	       
+             return SWIG_OLDOBJ;		       
+           } 				       
+         } else {				       
+           return SWIG_BADOBJ;		       
+         }					       
+       }
+ 
+    Of course, returning the plain '0(success)/-1(fail)' still works, but you can be
+    more explicit by returning SWIG_BADOBJ, SWIG_ERROR or any of the
+    swig errors code.
+ 
+    Finally, if the SWIG_CASTRANK_MODE is enabled, the result code
+    allows to return the 'cast rank', for example, if you have this
+ 
+        int food(double)
+        int fooi(int);
+ 
+    and you call
+  
+       food(1)   // cast rank '1'  (1 -> 1.0)
+       fooi(1)   // cast rank '0'
+ 
+    just use the SWIG_AddCast()/SWIG_CheckState()
+ 
+ 
+  */
+ #define SWIG_OK                    (0) 
+ #define SWIG_ERROR                 (-1)
+ #define SWIG_IsOK(r)               (r >= 0)
+ #define SWIG_ArgError(r)           ((r != SWIG_ERROR) ? r : SWIG_TypeError)  
+ 
+ /* The CastRankLimit says how many bits are used for the cast rank */
+ #define SWIG_CASTRANKLIMIT         (1 << 8)
+ /* The NewMask denotes the object was created (using new/malloc) */
+ #define SWIG_NEWOBJMASK            (SWIG_CASTRANKLIMIT  << 1)
+ /* The TmpMask is for in/out typemaps that use temporal objects */
+ #define SWIG_TMPOBJMASK            (SWIG_NEWOBJMASK << 1)
+ /* Simple returning values */
+ #define SWIG_BADOBJ                (SWIG_ERROR)
+ #define SWIG_OLDOBJ                (SWIG_OK)
+ #define SWIG_NEWOBJ                (SWIG_OK | SWIG_NEWOBJMASK)
+ #define SWIG_TMPOBJ                (SWIG_OK | SWIG_TMPOBJMASK)
+ /* Check, add and del mask methods */
+ #define SWIG_AddNewMask(r)         (SWIG_IsOK(r) ? (r | SWIG_NEWOBJMASK) : r)
+ #define SWIG_DelNewMask(r)         (SWIG_IsOK(r) ? (r & ~SWIG_NEWOBJMASK) : r)
+ #define SWIG_IsNewObj(r)           (SWIG_IsOK(r) && (r & SWIG_NEWOBJMASK))
+ #define SWIG_AddTmpMask(r)         (SWIG_IsOK(r) ? (r | SWIG_TMPOBJMASK) : r)
+ #define SWIG_DelTmpMask(r)         (SWIG_IsOK(r) ? (r & ~SWIG_TMPOBJMASK) : r)
+ #define SWIG_IsTmpObj(r)           (SWIG_IsOK(r) && (r & SWIG_TMPOBJMASK))
+ 
+ 
+ /* Cast-Rank Mode */
+ #if defined(SWIG_CASTRANK_MODE)
+ #  ifndef SWIG_TypeRank
+ #    define SWIG_TypeRank             unsigned long
+ #  endif
+ #  ifndef SWIG_MAXCASTRANK            /* Default cast allowed */
+ #    define SWIG_MAXCASTRANK          (2)
+ #  endif
+ #  define SWIG_CASTRANKMASK          ((SWIG_CASTRANKLIMIT) -1)
+ #  define SWIG_CastRank(r)           (r & SWIG_CASTRANKMASK)
+ SWIGINTERNINLINE int SWIG_AddCast(int r) { 
+   return SWIG_IsOK(r) ? ((SWIG_CastRank(r) < SWIG_MAXCASTRANK) ? (r + 1) : SWIG_ERROR) : r;
+ }
+ SWIGINTERNINLINE int SWIG_CheckState(int r) { 
+   return SWIG_IsOK(r) ? SWIG_CastRank(r) + 1 : 0; 
+ }
+ #else /* no cast-rank mode */
+ #  define SWIG_AddCast
+ #  define SWIG_CheckState(r) (SWIG_IsOK(r) ? 1 : 0)
+ #endif
+ 
+ 
+ 
+ 
+ #include <string.h>
+ 
+ #ifdef __cplusplus
+ extern "C" {
+ #endif
+ 
+ typedef void *(*swig_converter_func)(void *, int *);
+ typedef struct swig_type_info *(*swig_dycast_func)(void **);
+ 
+ /* Structure to store information on one type */
+ typedef struct swig_type_info {
+   const char             *name;			/* mangled name of this type */
+   const char             *str;			/* human readable name of this type */
+   swig_dycast_func        dcast;		/* dynamic cast function down a hierarchy */
+   struct swig_cast_info  *cast;			/* linked list of types that can cast into this type */
+   void                   *clientdata;		/* language specific type data */
+   int                    owndata;		/* flag if the structure owns the clientdata */
+ } swig_type_info;
+ 
+ /* Structure to store a type and conversion function used for casting */
+ typedef struct swig_cast_info {
+   swig_type_info         *type;			/* pointer to type that is equivalent to this type */
+   swig_converter_func     converter;		/* function to cast the void pointers */
+   struct swig_cast_info  *next;			/* pointer to next cast in linked list */
+   struct swig_cast_info  *prev;			/* pointer to the previous cast */
+ } swig_cast_info;
+ 
+ /* Structure used to store module information
+  * Each module generates one structure like this, and the runtime collects
+  * all of these structures and stores them in a circularly linked list.*/
+ typedef struct swig_module_info {
+   swig_type_info         **types;		/* Array of pointers to swig_type_info structures that are in this module */
+   size_t                 size;		        /* Number of types in this module */
+   struct swig_module_info *next;		/* Pointer to next element in circularly linked list */
+   swig_type_info         **type_initial;	/* Array of initially generated type structures */
+   swig_cast_info         **cast_initial;	/* Array of initially generated casting structures */
+   void                    *clientdata;		/* Language specific module data */
+ } swig_module_info;
+ 
+ /* 
+   Compare two type names skipping the space characters, therefore
+   "char*" == "char *" and "Class<int>" == "Class<int >", etc.
+ 
+   Return 0 when the two name types are equivalent, as in
+   strncmp, but skipping ' '.
+ */
+ SWIGRUNTIME int
+ SWIG_TypeNameComp(const char *f1, const char *l1,
+ 		  const char *f2, const char *l2) {
+   for (;(f1 != l1) && (f2 != l2); ++f1, ++f2) {
+     while ((*f1 == ' ') && (f1 != l1)) ++f1;
+     while ((*f2 == ' ') && (f2 != l2)) ++f2;
+     if (*f1 != *f2) return (*f1 > *f2) ? 1 : -1;
+   }
+   return (int)((l1 - f1) - (l2 - f2));
+ }
+ 
+ /*
+   Check type equivalence in a name list like <name1>|<name2>|...
+   Return 0 if not equal, 1 if equal
+ */
+ SWIGRUNTIME int
+ SWIG_TypeEquiv(const char *nb, const char *tb) {
+   int equiv = 0;
+   const char* te = tb + strlen(tb);
+   const char* ne = nb;
+   while (!equiv && *ne) {
+     for (nb = ne; *ne; ++ne) {
+       if (*ne == '|') break;
+     }
+     equiv = (SWIG_TypeNameComp(nb, ne, tb, te) == 0) ? 1 : 0;
+     if (*ne) ++ne;
+   }
+   return equiv;
+ }
+ 
+ /*
+   Check type equivalence in a name list like <name1>|<name2>|...
+   Return 0 if equal, -1 if nb < tb, 1 if nb > tb
+ */
+ SWIGRUNTIME int
+ SWIG_TypeCompare(const char *nb, const char *tb) {
+   int equiv = 0;
+   const char* te = tb + strlen(tb);
+   const char* ne = nb;
+   while (!equiv && *ne) {
+     for (nb = ne; *ne; ++ne) {
+       if (*ne == '|') break;
+     }
+     equiv = (SWIG_TypeNameComp(nb, ne, tb, te) == 0) ? 1 : 0;
+     if (*ne) ++ne;
+   }
+   return equiv;
+ }
+ 
+ 
+ /* think of this as a c++ template<> or a scheme macro */
+ #define SWIG_TypeCheck_Template(comparison, ty)         \
+   if (ty) {                                             \
+     swig_cast_info *iter = ty->cast;                    \
+     while (iter) {                                      \
+       if (comparison) {                                 \
+         if (iter == ty->cast) return iter;              \
+         /* Move iter to the top of the linked list */   \
+         iter->prev->next = iter->next;                  \
+         if (iter->next)                                 \
+           iter->next->prev = iter->prev;                \
+         iter->next = ty->cast;                          \
+         iter->prev = 0;                                 \
+         if (ty->cast) ty->cast->prev = iter;            \
+         ty->cast = iter;                                \
+         return iter;                                    \
+       }                                                 \
+       iter = iter->next;                                \
+     }                                                   \
+   }                                                     \
+   return 0
+ 
+ /*
+   Check the typename
+ */
+ SWIGRUNTIME swig_cast_info *
+ SWIG_TypeCheck(const char *c, swig_type_info *ty) {
+   SWIG_TypeCheck_Template(strcmp(iter->type->name, c) == 0, ty);
+ }
+ 
+ /* Same as previous function, except strcmp is replaced with a pointer comparison */
+ SWIGRUNTIME swig_cast_info *
+ SWIG_TypeCheckStruct(swig_type_info *from, swig_type_info *into) {
+   SWIG_TypeCheck_Template(iter->type == from, into);
+ }
+ 
+ /*
+   Cast a pointer up an inheritance hierarchy
+ */
+ SWIGRUNTIMEINLINE void *
+ SWIG_TypeCast(swig_cast_info *ty, void *ptr, int *newmemory) {
+   return ((!ty) || (!ty->converter)) ? ptr : (*ty->converter)(ptr, newmemory);
+ }
+ 
+ /* 
+    Dynamic pointer casting. Down an inheritance hierarchy
+ */
+ SWIGRUNTIME swig_type_info *
+ SWIG_TypeDynamicCast(swig_type_info *ty, void **ptr) {
+   swig_type_info *lastty = ty;
+   if (!ty || !ty->dcast) return ty;
+   while (ty && (ty->dcast)) {
+     ty = (*ty->dcast)(ptr);
+     if (ty) lastty = ty;
+   }
+   return lastty;
+ }
+ 
+ /*
+   Return the name associated with this type
+ */
+ SWIGRUNTIMEINLINE const char *
+ SWIG_TypeName(const swig_type_info *ty) {
+   return ty->name;
+ }
+ 
+ /*
+   Return the pretty name associated with this type,
+   that is an unmangled type name in a form presentable to the user.
+ */
+ SWIGRUNTIME const char *
+ SWIG_TypePrettyName(const swig_type_info *type) {
+   /* The "str" field contains the equivalent pretty names of the
+      type, separated by vertical-bar characters.  We choose
+      to print the last name, as it is often (?) the most
+      specific. */
+   if (!type) return NULL;
+   if (type->str != NULL) {
+     const char *last_name = type->str;
+     const char *s;
+     for (s = type->str; *s; s++)
+       if (*s == '|') last_name = s+1;
+     return last_name;
+   }
+   else
+     return type->name;
+ }
+ 
+ /* 
+    Set the clientdata field for a type
+ */
+ SWIGRUNTIME void
+ SWIG_TypeClientData(swig_type_info *ti, void *clientdata) {
+   swig_cast_info *cast = ti->cast;
+   /* if (ti->clientdata == clientdata) return; */
+   ti->clientdata = clientdata;
+   
+   while (cast) {
+     if (!cast->converter) {
+       swig_type_info *tc = cast->type;
+       if (!tc->clientdata) {
+ 	SWIG_TypeClientData(tc, clientdata);
+       }
+     }    
+     cast = cast->next;
+   }
+ }
+ SWIGRUNTIME void
+ SWIG_TypeNewClientData(swig_type_info *ti, void *clientdata) {
+   SWIG_TypeClientData(ti, clientdata);
+   ti->owndata = 1;
+ }
+   
+ /*
+   Search for a swig_type_info structure only by mangled name
+   Search is a O(log #types)
+   
+   We start searching at module start, and finish searching when start == end.  
+   Note: if start == end at the beginning of the function, we go all the way around
+   the circular list.
+ */
+ SWIGRUNTIME swig_type_info *
+ SWIG_MangledTypeQueryModule(swig_module_info *start, 
+                             swig_module_info *end, 
+ 		            const char *name) {
+   swig_module_info *iter = start;
+   do {
+     if (iter->size) {
+       register size_t l = 0;
+       register size_t r = iter->size - 1;
+       do {
+ 	/* since l+r >= 0, we can (>> 1) instead (/ 2) */
+ 	register size_t i = (l + r) >> 1; 
+ 	const char *iname = iter->types[i]->name;
+ 	if (iname) {
+ 	  register int compare = strcmp(name, iname);
+ 	  if (compare == 0) {	    
+ 	    return iter->types[i];
+ 	  } else if (compare < 0) {
+ 	    if (i) {
+ 	      r = i - 1;
+ 	    } else {
+ 	      break;
+ 	    }
+ 	  } else if (compare > 0) {
+ 	    l = i + 1;
+ 	  }
+ 	} else {
+ 	  break; /* should never happen */
+ 	}
+       } while (l <= r);
+     }
+     iter = iter->next;
+   } while (iter != end);
+   return 0;
+ }
+ 
+ /*
+   Search for a swig_type_info structure for either a mangled name or a human readable name.
+   It first searches the mangled names of the types, which is a O(log #types)
+   If a type is not found it then searches the human readable names, which is O(#types).
+   
+   We start searching at module start, and finish searching when start == end.  
+   Note: if start == end at the beginning of the function, we go all the way around
+   the circular list.
+ */
+ SWIGRUNTIME swig_type_info *
+ SWIG_TypeQueryModule(swig_module_info *start, 
+                      swig_module_info *end, 
+ 		     const char *name) {
+   /* STEP 1: Search the name field using binary search */
+   swig_type_info *ret = SWIG_MangledTypeQueryModule(start, end, name);
+   if (ret) {
+     return ret;
+   } else {
+     /* STEP 2: If the type hasn't been found, do a complete search
+        of the str field (the human readable name) */
+     swig_module_info *iter = start;
+     do {
+       register size_t i = 0;
+       for (; i < iter->size; ++i) {
+ 	if (iter->types[i]->str && (SWIG_TypeEquiv(iter->types[i]->str, name)))
+ 	  return iter->types[i];
+       }
+       iter = iter->next;
+     } while (iter != end);
+   }
+   
+   /* neither found a match */
+   return 0;
+ }
+ 
+ /* 
+    Pack binary data into a string
+ */
+ SWIGRUNTIME char *
+ SWIG_PackData(char *c, void *ptr, size_t sz) {
+   static const char hex[17] = "0123456789abcdef";
+   register const unsigned char *u = (unsigned char *) ptr;
+   register const unsigned char *eu =  u + sz;
+   for (; u != eu; ++u) {
+     register unsigned char uu = *u;
+     *(c++) = hex[(uu & 0xf0) >> 4];
+     *(c++) = hex[uu & 0xf];
+   }
+   return c;
+ }
+ 
+ /* 
+    Unpack binary data from a string
+ */
+ SWIGRUNTIME const char *
+ SWIG_UnpackData(const char *c, void *ptr, size_t sz) {
+   register unsigned char *u = (unsigned char *) ptr;
+   register const unsigned char *eu = u + sz;
+   for (; u != eu; ++u) {
+     register char d = *(c++);
+     register unsigned char uu;
+     if ((d >= '0') && (d <= '9'))
+       uu = ((d - '0') << 4);
+     else if ((d >= 'a') && (d <= 'f'))
+       uu = ((d - ('a'-10)) << 4);
+     else 
+       return (char *) 0;
+     d = *(c++);
+     if ((d >= '0') && (d <= '9'))
+       uu |= (d - '0');
+     else if ((d >= 'a') && (d <= 'f'))
+       uu |= (d - ('a'-10));
+     else 
+       return (char *) 0;
+     *u = uu;
+   }
+   return c;
+ }
+ 
+ /* 
+    Pack 'void *' into a string buffer.
+ */
+ SWIGRUNTIME char *
+ SWIG_PackVoidPtr(char *buff, void *ptr, const char *name, size_t bsz) {
+   char *r = buff;
+   if ((2*sizeof(void *) + 2) > bsz) return 0;
+   *(r++) = '_';
+   r = SWIG_PackData(r,&ptr,sizeof(void *));
+   if (strlen(name) + 1 > (bsz - (r - buff))) return 0;
+   strcpy(r,name);
+   return buff;
+ }
+ 
+ SWIGRUNTIME const char *
+ SWIG_UnpackVoidPtr(const char *c, void **ptr, const char *name) {
+   if (*c != '_') {
+     if (strcmp(c,"NULL") == 0) {
+       *ptr = (void *) 0;
+       return name;
+     } else {
+       return 0;
+     }
+   }
+   return SWIG_UnpackData(++c,ptr,sizeof(void *));
+ }
+ 
+ SWIGRUNTIME char *
+ SWIG_PackDataName(char *buff, void *ptr, size_t sz, const char *name, size_t bsz) {
+   char *r = buff;
+   size_t lname = (name ? strlen(name) : 0);
+   if ((2*sz + 2 + lname) > bsz) return 0;
+   *(r++) = '_';
+   r = SWIG_PackData(r,ptr,sz);
+   if (lname) {
+     strncpy(r,name,lname+1);
+   } else {
+     *r = 0;
+   }
+   return buff;
+ }
+ 
+ SWIGRUNTIME const char *
+ SWIG_UnpackDataName(const char *c, void *ptr, size_t sz, const char *name) {
+   if (*c != '_') {
+     if (strcmp(c,"NULL") == 0) {
+       memset(ptr,0,sz);
+       return name;
+     } else {
+       return 0;
+     }
+   }
+   return SWIG_UnpackData(++c,ptr,sz);
+ }
+ 
+ #ifdef __cplusplus
+ }
+ #endif
+ 
+ /*  Errors in SWIG */
+ #define  SWIG_UnknownError    	   -1 
+ #define  SWIG_IOError        	   -2 
+ #define  SWIG_RuntimeError   	   -3 
+ #define  SWIG_IndexError     	   -4 
+ #define  SWIG_TypeError      	   -5 
+ #define  SWIG_DivisionByZero 	   -6 
+ #define  SWIG_OverflowError  	   -7 
+ #define  SWIG_SyntaxError    	   -8 
+ #define  SWIG_ValueError     	   -9 
+ #define  SWIG_SystemError    	   -10
+ #define  SWIG_AttributeError 	   -11
+ #define  SWIG_MemoryError    	   -12 
+ #define  SWIG_NullReferenceError   -13
+ 
+ 
+ 
+ /* -----------------------------------------------------------------------------
+  * error manipulation
+  * ----------------------------------------------------------------------------- */
+ 
+ SWIGINTERN const char*
+ SWIG_Tcl_ErrorType(int code) {
+   const char* type = 0;
+   switch(code) {
+   case SWIG_MemoryError:
+     type = "MemoryError";
+     break;
+   case SWIG_IOError:
+     type = "IOError";
+     break;
+   case SWIG_RuntimeError:
+     type = "RuntimeError";
+     break;
+   case SWIG_IndexError:
+     type = "IndexError";
+     break;
+   case SWIG_TypeError:
+     type = "TypeError";
+     break;
+   case SWIG_DivisionByZero:
+     type = "ZeroDivisionError";
+     break;
+   case SWIG_OverflowError:
+     type = "OverflowError";
+     break;
+   case SWIG_SyntaxError:
+     type = "SyntaxError";
+     break;
+   case SWIG_ValueError:
+     type = "ValueError";
+     break;
+   case SWIG_SystemError:
+     type = "SystemError";
+     break;
+   case SWIG_AttributeError:
+     type = "AttributeError";
+     break;
+   default:
+     type = "RuntimeError";
+   }
+   return type;
+ }
+ 
+ 
+ SWIGINTERN void
+ SWIG_Tcl_SetErrorObj(Tcl_Interp *interp, const char *ctype, Tcl_Obj *obj)
+ {
+   Tcl_ResetResult(interp);
+   Tcl_SetObjResult(interp, obj);
+   Tcl_SetErrorCode(interp, "SWIG", ctype, NULL);
+ }
+ 
+ SWIGINTERN void
+ SWIG_Tcl_SetErrorMsg(Tcl_Interp *interp, const char *ctype, const char *mesg)
+ {
+   Tcl_ResetResult(interp);
+   Tcl_SetErrorCode(interp, "SWIG", ctype, NULL);
+   Tcl_AppendResult(interp, ctype, " ", mesg, NULL);
+   /*
+   Tcl_AddErrorInfo(interp, ctype);
+   Tcl_AddErrorInfo(interp, " ");
+   Tcl_AddErrorInfo(interp, mesg);
+   */
+ }
+ 
+ SWIGINTERNINLINE void
+ SWIG_Tcl_AddErrorMsg(Tcl_Interp *interp, const char* mesg)
+ {
+   Tcl_AddErrorInfo(interp, mesg);
+ }
+ 
+ 
+ 
+ /* -----------------------------------------------------------------------------
+  * SWIG API. Portion that goes into the runtime
+  * ----------------------------------------------------------------------------- */
+ #ifdef __cplusplus
+ extern "C" {
+ #endif
+ 
+ /* -----------------------------------------------------------------------------
+  * Constant declarations
+  * ----------------------------------------------------------------------------- */
+ 
+ /* Constant Types */
+ #define SWIG_TCL_POINTER 4
+ #define SWIG_TCL_BINARY  5
+ 
+ /* Constant information structure */
+ typedef struct swig_const_info {
+     int type;
+     char *name;
+     long lvalue;
+     double dvalue;
+     void   *pvalue;
+     swig_type_info **ptype;
+ } swig_const_info;
+ 
+ typedef int   (*swig_wrapper)(ClientData, Tcl_Interp *, int, Tcl_Obj *CONST []);
+ typedef int   (*swig_wrapper_func)(ClientData, Tcl_Interp *, int, Tcl_Obj *CONST []);
+ typedef char *(*swig_variable_func)(ClientData, Tcl_Interp *, char *, char *, int);
+ typedef void  (*swig_delete_func)(ClientData);
+ 
+ typedef struct swig_method {
+   const char     *name;
+   swig_wrapper   method;
+ } swig_method;
+ 
+ typedef struct swig_attribute {
+   const char     *name;
+   swig_wrapper   getmethod;
+   swig_wrapper   setmethod;
+ } swig_attribute;
+ 
+ typedef struct swig_class {
+   const char         *name;
+   swig_type_info   **type;
+   swig_wrapper       constructor;
+   void              (*destructor)(void *);
+   swig_method        *methods;
+   swig_attribute     *attributes;
+   struct swig_class **bases;
+   const char              **base_names;
+   swig_module_info   *module;
+ } swig_class;
+ 
+ typedef struct swig_instance {
+   Tcl_Obj       *thisptr;
+   void          *thisvalue;
+   swig_class   *classptr;
+   int            destroy;
+   Tcl_Command    cmdtok;
+ } swig_instance;
+ 
+ /* Structure for command table */
+ typedef struct {
+   const char *name;
+   int       (*wrapper)(ClientData, Tcl_Interp *, int, Tcl_Obj *CONST []);
+   ClientData  clientdata;
+ } swig_command_info;
+ 
+ /* Structure for variable linking table */
+ typedef struct {
+   const char *name;
+   void *addr;
+   char * (*get)(ClientData, Tcl_Interp *, char *, char *, int);
+   char * (*set)(ClientData, Tcl_Interp *, char *, char *, int);
+ } swig_var_info;
+ 
+ 
+ /* -----------------------------------------------------------------------------*
+  *  Install a constant object 
+  * -----------------------------------------------------------------------------*/
+ 
+ static Tcl_HashTable   swigconstTable;
+ static int             swigconstTableinit = 0;
+ 
+ SWIGINTERN void
+ SWIG_Tcl_SetConstantObj(Tcl_Interp *interp, const char* name, Tcl_Obj *obj) {
+   int newobj;
+   Tcl_ObjSetVar2(interp,Tcl_NewStringObj(name,-1), NULL, obj, TCL_GLOBAL_ONLY);
+   Tcl_SetHashValue(Tcl_CreateHashEntry(&swigconstTable, name, &newobj), (ClientData) obj);
+ }
+ 
+ SWIGINTERN Tcl_Obj *
+ SWIG_Tcl_GetConstantObj(const char *key) {
+   Tcl_HashEntry *entryPtr;
+   if (!swigconstTableinit) return 0;
+   entryPtr = Tcl_FindHashEntry(&swigconstTable, key);
+   if (entryPtr) {
+     return (Tcl_Obj *) Tcl_GetHashValue(entryPtr);
+   }
+   return 0;
+ }
+ 
+ #ifdef __cplusplus
+ }
+ #endif
+ 
+ 
+ 
+ /* -----------------------------------------------------------------------------
+  * See the LICENSE file for information on copyright, usage and redistribution
+  * of SWIG, and the README file for authors - http://www.swig.org/release.html.
+  *
+  * tclrun.swg
+  *
+  * This file contains the runtime support for Tcl modules and includes
+  * code for managing global variables and pointer type checking.
+  * ----------------------------------------------------------------------------- */
+ 
+ /* Common SWIG API */
+ 
+ /* for raw pointers */
+ #define SWIG_ConvertPtr(oc, ptr, ty, flags)             SWIG_Tcl_ConvertPtr(interp, oc, ptr, ty, flags)
+ #define SWIG_NewPointerObj(ptr, type, flags)            SWIG_Tcl_NewPointerObj(ptr, type, flags)
+ 
+ /* for raw packed data */
+ #define SWIG_ConvertPacked(obj, ptr, sz, ty)            SWIG_Tcl_ConvertPacked(interp, obj, ptr, sz, ty)
+ #define SWIG_NewPackedObj(ptr, sz, type)                SWIG_Tcl_NewPackedObj(ptr, sz, type)
+ 
+ /* for class or struct pointers */
+ #define SWIG_ConvertInstance(obj, pptr, type, flags)    SWIG_Tcl_ConvertPtr(interp, obj, pptr, type, flags)
+ #define SWIG_NewInstanceObj(thisvalue, type, flags)     SWIG_Tcl_NewInstanceObj(interp, thisvalue, type, flags)
+ 
+ /* for C or C++ function pointers */
+ #define SWIG_ConvertFunctionPtr(obj, pptr, type)        SWIG_Tcl_ConvertPtr(interp, obj, pptr, type, 0)
+ #define SWIG_NewFunctionPtrObj(ptr, type)               SWIG_Tcl_NewPointerObj(ptr, type, 0)
+ 
+ /* for C++ member pointers, ie, member methods */
+ #define SWIG_ConvertMember(obj, ptr, sz, ty)            SWIG_Tcl_ConvertPacked(interp,obj, ptr, sz, ty)
+ #define SWIG_NewMemberObj(ptr, sz, type)                SWIG_Tcl_NewPackedObj(ptr, sz, type)
+ 
+ 
+ /* Runtime API */
+ 
+ #define SWIG_GetModule(clientdata)                      SWIG_Tcl_GetModule((Tcl_Interp *) (clientdata))	     
+ #define SWIG_SetModule(clientdata, pointer)          	SWIG_Tcl_SetModule((Tcl_Interp *) (clientdata), pointer)
+ 
+ 
+ /* Error manipulation */
+ 
+ #define SWIG_ErrorType(code)                            SWIG_Tcl_ErrorType(code)                                      
+ #define SWIG_Error(code, msg)            		SWIG_Tcl_SetErrorMsg(interp, SWIG_Tcl_ErrorType(code), msg)
+ #define SWIG_fail                        		goto fail						    
+ 
+ 
+ /* Tcl-specific SWIG API */
+ 
+ #define SWIG_Acquire(ptr)                               SWIG_Tcl_Acquire(ptr)                                     
+ #define SWIG_MethodCommand                           	SWIG_Tcl_MethodCommand				       
+ #define SWIG_Disown(ptr)                             	SWIG_Tcl_Disown(ptr)				       
+ #define SWIG_ConvertPtrFromString(c, ptr, ty, flags) 	SWIG_Tcl_ConvertPtrFromString(interp, c, ptr, ty, flags)  
+ #define SWIG_MakePtr(c, ptr, ty, flags)              	SWIG_Tcl_MakePtr(c, ptr, ty, flags)		       
+ #define SWIG_PointerTypeFromString(c)                	SWIG_Tcl_PointerTypeFromString(c)			       
+ #define SWIG_GetArgs                                 	SWIG_Tcl_GetArgs					       
+ #define SWIG_GetConstantObj(key)                     	SWIG_Tcl_GetConstantObj(key)			       
+ #define SWIG_ObjectConstructor                       	SWIG_Tcl_ObjectConstructor				       
+ #define SWIG_Thisown(ptr)                            	SWIG_Tcl_Thisown(ptr)				       
+ #define SWIG_ObjectDelete                            	SWIG_Tcl_ObjectDelete				       
+ 
+ 
+ #define SWIG_TCL_DECL_ARGS_2(arg1, arg2)                (Tcl_Interp *interp SWIGUNUSED, arg1, arg2)
+ #define SWIG_TCL_CALL_ARGS_2(arg1, arg2)                (interp, arg1, arg2)
+ /* -----------------------------------------------------------------------------
+  * pointers/data manipulation
+  * ----------------------------------------------------------------------------- */
+ 
+ /* For backward compatibility only */
+ #define SWIG_POINTER_EXCEPTION  0
+ #define SWIG_GetConstant        SWIG_GetConstantObj
+ #define SWIG_Tcl_GetConstant    SWIG_Tcl_GetConstantObj
+ 
+ #include "assert.h"
+ 
+ #ifdef __cplusplus
+ extern "C" {
+ #if 0
+ } /* cc-mode */
+ #endif
+ #endif
+ 
+ /* Object support */
+ 
+ SWIGRUNTIME Tcl_HashTable*
+ SWIG_Tcl_ObjectTable(void) {
+   static Tcl_HashTable  swigobjectTable;
+   static int            swigobjectTableinit = 0;
+   if (!swigobjectTableinit) {
+     Tcl_InitHashTable(&swigobjectTable, TCL_ONE_WORD_KEYS);
+     swigobjectTableinit = 1;
+   }
+   return &swigobjectTable;
+ }
+ 
+ /* Acquire ownership of a pointer */
+ SWIGRUNTIME void
+ SWIG_Tcl_Acquire(void *ptr) {
+   int newobj;
+   Tcl_CreateHashEntry(SWIG_Tcl_ObjectTable(), (char *) ptr, &newobj);
+ }
+ 
+ SWIGRUNTIME int
+ SWIG_Tcl_Thisown(void *ptr) {
+   if (Tcl_FindHashEntry(SWIG_Tcl_ObjectTable(), (char *) ptr)) {
+     return 1;
+   }
+   return 0;
+ }
+ 
+ /* Disown a pointer.  Returns 1 if we owned it to begin with */
+ SWIGRUNTIME int
+ SWIG_Tcl_Disown(void *ptr) {
+   Tcl_HashEntry *entryPtr = Tcl_FindHashEntry(SWIG_Tcl_ObjectTable(), (char *) ptr);
+   if (entryPtr) {
+     Tcl_DeleteHashEntry(entryPtr);
+     return 1;
+   }
+   return 0;
+ }
+ 
+ /* Convert a pointer value */
+ SWIGRUNTIME int
+ SWIG_Tcl_ConvertPtrFromString(Tcl_Interp *interp, const char *c, void **ptr, swig_type_info *ty, int flags) {
+   swig_cast_info *tc;
+   /* Pointer values must start with leading underscore */
+   while (*c != '_') {
+     *ptr = (void *) 0;
+     if (strcmp(c,"NULL") == 0) return SWIG_OK;
+ 
+     /* Empty string: not a pointer */
+     if (*c == 0) return SWIG_ERROR; 
+ 
+     /* Hmmm. It could be an object name. */
+ 
+     /* Check if this is a command at all. Prevents <c> cget -this         */
+     /* from being called when c is not a command, firing the unknown proc */
+     if (Tcl_VarEval(interp,"info commands ", c, (char *) NULL) == TCL_OK) {
+       Tcl_Obj *result = Tcl_GetObjResult(interp);
+       if (*(Tcl_GetStringFromObj(result, NULL)) == 0) {
+         /* It's not a command, so it can't be a pointer */
+         Tcl_ResetResult(interp);
+         return SWIG_ERROR;
+       }
+     } else {
+       /* This will only fail if the argument is multiple words. */
+       /* Multiple words are also not commands.                  */
+       Tcl_ResetResult(interp);
+       return SWIG_ERROR;
+     }
+ 
+     /* Check if this is really a SWIG pointer */
+     if (Tcl_VarEval(interp,c," cget -this", (char *) NULL) != TCL_OK) {
+       Tcl_ResetResult(interp);
+       return SWIG_ERROR;
+     }
+ 
+     c = Tcl_GetStringFromObj(Tcl_GetObjResult(interp), NULL);
+   }
+ 
+   c++;
+   c = SWIG_UnpackData(c,ptr,sizeof(void *));
+   if (ty) {
+     tc = c ? SWIG_TypeCheck(c,ty) : 0;
+     if (!tc) {
+       return SWIG_ERROR;
+     }
+     if (flags & SWIG_POINTER_DISOWN) {
+       SWIG_Disown((void *) *ptr);
+     }
+     {
+       int newmemory = 0;
+       *ptr = SWIG_TypeCast(tc,(void *) *ptr,&newmemory);
+       assert(!newmemory); /* newmemory handling not yet implemented */
+     }
+   }
+   return SWIG_OK;
+ }
+ 
+ /* Convert a pointer value */
+ SWIGRUNTIMEINLINE int
+ SWIG_Tcl_ConvertPtr(Tcl_Interp *interp, Tcl_Obj *oc, void **ptr, swig_type_info *ty, int flags) {
+   return SWIG_Tcl_ConvertPtrFromString(interp, Tcl_GetStringFromObj(oc,NULL), ptr, ty, flags);
+ }
+ 
+ /* Convert a pointer value */
+ SWIGRUNTIME char *
+ SWIG_Tcl_PointerTypeFromString(char *c) {
+   char d;
+   /* Pointer values must start with leading underscore. NULL has no type */
+   if (*c != '_') {
+     return 0;
+   }
+   c++;
+   /* Extract hex value from pointer */
+   while ((d = *c)) {
+     if (!(((d >= '0') && (d <= '9')) || ((d >= 'a') && (d <= 'f')))) break;
+     c++;
+   }
+   return c;
+ }
+ 
+ /* Convert a packed value value */
+ SWIGRUNTIME int
+ SWIG_Tcl_ConvertPacked(Tcl_Interp *SWIGUNUSEDPARM(interp) , Tcl_Obj *obj, void *ptr, int sz, swig_type_info *ty) {
+   swig_cast_info *tc;
+   const char  *c;
+ 
+   if (!obj) goto type_error;
+   c = Tcl_GetStringFromObj(obj,NULL);
+   /* Pointer values must start with leading underscore */
+   if (*c != '_') goto type_error;
+   c++;
+   c = SWIG_UnpackData(c,ptr,sz);
+   if (ty) {
+     tc = SWIG_TypeCheck(c,ty);
+     if (!tc) goto type_error;
+   }
+   return SWIG_OK;
+ 
+  type_error:
+ 
+   return SWIG_ERROR;
+ }
+ 
+ 
+ /* Take a pointer and convert it to a string */
+ SWIGRUNTIME void
+ SWIG_Tcl_MakePtr(char *c, void *ptr, swig_type_info *ty, int flags) {
+   if (ptr) {
+     *(c++) = '_';
+     c = SWIG_PackData(c,&ptr,sizeof(void *));
+     strcpy(c,ty->name);
+   } else {
+     strcpy(c,(char *)"NULL");
+   }
+   flags = 0;
+ }
+ 
+ /* Create a new pointer object */
+ SWIGRUNTIMEINLINE Tcl_Obj *
+ SWIG_Tcl_NewPointerObj(void *ptr, swig_type_info *type, int flags) {
+   Tcl_Obj *robj;
+   char result[SWIG_BUFFER_SIZE];
+   SWIG_MakePtr(result,ptr,type,flags);
+   robj = Tcl_NewStringObj(result,-1);
+   return robj;
+ }
+ 
+ SWIGRUNTIME Tcl_Obj *
+ SWIG_Tcl_NewPackedObj(void *ptr, int sz, swig_type_info *type) {
+   char result[1024];
+   char *r = result;
+   if ((2*sz + 1 + strlen(type->name)) > 1000) return 0;
+   *(r++) = '_';
+   r = SWIG_PackData(r,ptr,sz);
+   strcpy(r,type->name);
+   return Tcl_NewStringObj(result,-1);
+ }
+ 
+ /* -----------------------------------------------------------------------------*
+  *  Get type list 
+  * -----------------------------------------------------------------------------*/
+ 
+ SWIGRUNTIME swig_module_info * 
+ SWIG_Tcl_GetModule(Tcl_Interp *interp) {
+   const char *data;
+   swig_module_info *ret = 0;
+   
+   /* first check if pointer already created */
+   data = Tcl_GetVar(interp, (char *)"swig_runtime_data_type_pointer" SWIG_RUNTIME_VERSION SWIG_TYPE_TABLE_NAME, TCL_GLOBAL_ONLY);
+   if (data) {
+     SWIG_UnpackData(data, &ret, sizeof(swig_type_info **));
+   }
+ 
+   return ret;
+ }
+ 
+ SWIGRUNTIME void
+ SWIG_Tcl_SetModule(Tcl_Interp *interp, swig_module_info *module) {
+   char buf[SWIG_BUFFER_SIZE];
+   char *data;
+ 
+   /* create a new pointer */
+   data = SWIG_PackData(buf, &module, sizeof(swig_type_info **));
+   *data = 0;
+   Tcl_SetVar(interp, (char *)"swig_runtime_data_type_pointer" SWIG_RUNTIME_VERSION SWIG_TYPE_TABLE_NAME, buf, 0);
+ }
+ 
+ /* -----------------------------------------------------------------------------*
+  *  Object auxiliars
+  * -----------------------------------------------------------------------------*/
+ 
+ 
+ SWIGRUNTIME void
+ SWIG_Tcl_ObjectDelete(ClientData clientData) {
+   swig_instance *si = (swig_instance *) clientData;
+   if ((si) && (si->destroy) && (SWIG_Disown(si->thisvalue))) {
+     if (si->classptr->destructor) {
+       (si->classptr->destructor)(si->thisvalue);
+     }
+   }
+   Tcl_DecrRefCount(si->thisptr);
+   free(si);
+ }
+ 
+ /* Function to invoke object methods given an instance */
+ SWIGRUNTIME int
+ SWIG_Tcl_MethodCommand(ClientData clientData, Tcl_Interp *interp, int objc, Tcl_Obj *CONST _objv[]) {
+   char *method,   *attrname;
+   swig_instance   *inst = (swig_instance *) clientData;
+   swig_method     *meth;
+   swig_attribute  *attr;
+   Tcl_Obj         *oldarg;
+   Tcl_Obj         **objv;
+   int              rcode;
+   swig_class      *cls;
+   swig_class      *cls_stack[64];
+   int              cls_stack_bi[64];
+   int              cls_stack_top = 0;
+   int              numconf = 2;
+   int              bi;
+ 
+   objv = (Tcl_Obj **) _objv;
+   if (objc < 2) {
+     Tcl_SetResult(interp, (char *) "wrong # args.", TCL_STATIC);
+     return TCL_ERROR;
+   }
+   method = Tcl_GetStringFromObj(objv[1],NULL);
+   if (strcmp(method,"-acquire") == 0) {
+     inst->destroy = 1;
+     SWIG_Acquire(inst->thisvalue);
+     return TCL_OK;
+   }
+   if (strcmp(method,"-disown") == 0) {
+     if (inst->destroy) {
+       SWIG_Disown(inst->thisvalue);
+     }
+     inst->destroy = 0;
+     return TCL_OK;
+   }
+   if (strcmp(method,"-delete") == 0) {
+     Tcl_DeleteCommandFromToken(interp,inst->cmdtok);
+     return TCL_OK;
+   }
+   cls_stack[cls_stack_top] = inst->classptr;
+   cls_stack_bi[cls_stack_top] = -1;
+   cls = inst->classptr;
+   while (1) {
+     bi = cls_stack_bi[cls_stack_top];
+     cls = cls_stack[cls_stack_top];
+     if (bi != -1) {
+       if (!cls->bases[bi] && cls->base_names[bi]) {
+         /* lookup and cache the base class */
+ 	swig_type_info *info = SWIG_TypeQueryModule(cls->module, cls->module, cls->base_names[bi]);
+ 	if (info) cls->bases[bi] = (swig_class *) info->clientdata;
+       }
+       cls = cls->bases[bi];
+       if (cls) {
+         cls_stack_bi[cls_stack_top]++;
+         cls_stack_top++;
+         cls_stack[cls_stack_top] = cls;
+         cls_stack_bi[cls_stack_top] = -1;
+         continue;
+       }
+     }
+     if (!cls) {
+       cls_stack_top--;
+       if (cls_stack_top < 0) break;
+       else continue;
+     }
+     cls_stack_bi[cls_stack_top]++;
+ 
+     meth = cls->methods;
+     /* Check for methods */
+     while (meth && meth->name) {
+       if (strcmp(meth->name,method) == 0) {
+         oldarg = objv[1];
+         objv[1] = inst->thisptr;
+         Tcl_IncrRefCount(inst->thisptr);
+         rcode = (*meth->method)(clientData,interp,objc,objv);
+         objv[1] = oldarg;
+         Tcl_DecrRefCount(inst->thisptr);
+         return rcode;
+       }
+       meth++;
+     }
+     /* Check class methods for a match */
+     if (strcmp(method,"cget") == 0) {
+       if (objc < 3) {
+         Tcl_SetResult(interp, (char *) "wrong # args.", TCL_STATIC);
+         return TCL_ERROR;
+       }
+       attrname = Tcl_GetStringFromObj(objv[2],NULL);
+       attr = cls->attributes;
+       while (attr && attr->name) {
+         if ((strcmp(attr->name, attrname) == 0) && (attr->getmethod)) {
+           oldarg = objv[1];
+           objv[1] = inst->thisptr;
+           Tcl_IncrRefCount(inst->thisptr);
+           rcode = (*attr->getmethod)(clientData,interp,2, objv);
+           objv[1] = oldarg;
+           Tcl_DecrRefCount(inst->thisptr);
+           return rcode;
+         }
+         attr++;
+       }
+       if (strcmp(attrname, "-this") == 0) {
+         Tcl_SetObjResult(interp, Tcl_DuplicateObj(inst->thisptr));
+         return TCL_OK;
+       }
+       if (strcmp(attrname, "-thisown") == 0) {
+         if (SWIG_Thisown(inst->thisvalue)) {
+           Tcl_SetResult(interp,(char*)"1",TCL_STATIC);
+         } else {
+           Tcl_SetResult(interp,(char*)"0",TCL_STATIC);
+         }
+         return TCL_OK;
+       }
+     } else if (strcmp(method, "configure") == 0) {
+       int i;
+       if (objc < 4) {
+         Tcl_SetResult(interp, (char *) "wrong # args.", TCL_STATIC);
+         return TCL_ERROR;
+       }
+       i = 2;
+       while (i < objc) {
+         attrname = Tcl_GetStringFromObj(objv[i],NULL);
+         attr = cls->attributes;
+         while (attr && attr->name) {
+           if ((strcmp(attr->name, attrname) == 0) && (attr->setmethod)) {
+             oldarg = objv[i];
+             objv[i] = inst->thisptr;
+             Tcl_IncrRefCount(inst->thisptr);
+             rcode = (*attr->setmethod)(clientData,interp,3, &objv[i-1]);
+             objv[i] = oldarg;
+             Tcl_DecrRefCount(inst->thisptr);
+             if (rcode != TCL_OK) return rcode;
+             numconf += 2;
+           }
+           attr++;
+         }
+         i+=2;
+       }
+     }
+   }
+   if (strcmp(method,"configure") == 0) {
+     if (numconf >= objc) {
+       return TCL_OK;
+     } else {
+       Tcl_SetResult(interp,(char *) "Invalid attribute name.", TCL_STATIC);
+       return TCL_ERROR;
+     }
+   }
+   if (strcmp(method,"cget") == 0) {
+     Tcl_SetResult(interp,(char *) "Invalid attribute name.", TCL_STATIC);
+     return TCL_ERROR;
+   }
+   Tcl_SetResult(interp, (char *) "Invalid method. Must be one of: configure cget -acquire -disown -delete", TCL_STATIC);
+   cls = inst->classptr;
+   bi = 0;
+   while (cls) {
+     meth = cls->methods;
+     while (meth && meth->name) {
+       char *cr = (char *) Tcl_GetStringResult(interp);
+       size_t meth_len = strlen(meth->name);
+       char* where = strchr(cr,':');
+       while(where) {
+         where = strstr(where, meth->name);
+         if(where) {
+           if(where[-1] == ' ' && (where[meth_len] == ' ' || where[meth_len]==0)) {
+             break;
+           } else {
+             where++;
+           }
+         }
+       }
+ 
+       if (!where)
+         Tcl_AppendElement(interp, (char *) meth->name);
+       meth++;
+     }
+     cls = inst->classptr->bases[bi++];
+   }
+   return TCL_ERROR;
+ }
+ 
+ /* This function takes the current result and turns it into an object command */
+ SWIGRUNTIME Tcl_Obj *
+ SWIG_Tcl_NewInstanceObj(Tcl_Interp *interp, void *thisvalue, swig_type_info *type, int flags) {
+   Tcl_Obj *robj = SWIG_NewPointerObj(thisvalue, type,0);
+   /* Check to see if this pointer belongs to a class or not */
+   if ((type->clientdata) && (interp)) {
+     Tcl_CmdInfo    ci;
+     char          *name;
+     name = Tcl_GetStringFromObj(robj,NULL);
+     if (!Tcl_GetCommandInfo(interp,name, &ci) || (flags)) {
+       swig_instance *newinst = (swig_instance *) malloc(sizeof(swig_instance));
+       newinst->thisptr = Tcl_DuplicateObj(robj);
+       Tcl_IncrRefCount(newinst->thisptr);
+       newinst->thisvalue = thisvalue;
+       newinst->classptr = (swig_class *) type->clientdata;
+       newinst->destroy = flags;
+       newinst->cmdtok = Tcl_CreateObjCommand(interp, Tcl_GetStringFromObj(robj,NULL), (swig_wrapper_func) SWIG_MethodCommand, (ClientData) newinst, (swig_delete_func) SWIG_ObjectDelete);
+       if (flags) {
+         SWIG_Acquire(thisvalue);
+       }
+     }
+   }
+   return robj;
+ }
+ 
+ /* Function to create objects */
+ SWIGRUNTIME int
+ SWIG_Tcl_ObjectConstructor(ClientData clientData, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
+   Tcl_Obj          *newObj = 0;
+   void             *thisvalue = 0;
+   swig_instance   *newinst = 0;
+   swig_class      *classptr = (swig_class *) clientData;
+   swig_wrapper     cons = 0;
+   char             *name = 0;
+   int               firstarg = 0;
+   int               thisarg = 0;
+   int               destroy = 1;
+ 
+   if (!classptr) {
+     Tcl_SetResult(interp, (char *) "swig: internal runtime error. No class object defined.", TCL_STATIC);
+     return TCL_ERROR;
+   }
+   cons = classptr->constructor;
+   if (objc > 1) {
+     char *s = Tcl_GetStringFromObj(objv[1],NULL);
+     if (strcmp(s,"-this") == 0) {
+       thisarg = 2;
+       cons = 0;
+     } else if (strcmp(s,"-args") == 0) {
+       firstarg = 1;
+     } else if (objc == 2) {
+       firstarg = 1;
+       name = s;
+     } else if (objc >= 3) {
+       char *s1;
+       name = s;
+       s1 = Tcl_GetStringFromObj(objv[2],NULL);
+       if (strcmp(s1,"-this") == 0) {
+ 	thisarg = 3;
+ 	cons = 0;
+       } else {
+ 	firstarg = 1;
+       }
+     }
+   }
+   if (cons) {
+     int result;
+     result = (*cons)(0, interp, objc-firstarg, &objv[firstarg]);
+     if (result != TCL_OK) {
+       return result;
+     }
+     newObj = Tcl_DuplicateObj(Tcl_GetObjResult(interp));
+     if (!name) name = Tcl_GetStringFromObj(newObj,NULL);
+   } else if (thisarg > 0) {
+     if (thisarg < objc) {
+       destroy = 0;
+       newObj = Tcl_DuplicateObj(objv[thisarg]);
+       if (!name) name = Tcl_GetStringFromObj(newObj,NULL);
+     } else {
+       Tcl_SetResult(interp, (char *) "wrong # args.", TCL_STATIC);
+       return TCL_ERROR;
+     }
+   } else {
+     Tcl_SetResult(interp, (char *) "No constructor available.", TCL_STATIC);
+     return TCL_ERROR;
+   }
+   if (SWIG_Tcl_ConvertPtr(interp,newObj, (void **) &thisvalue, *(classptr->type), 0) != SWIG_OK) {
+     Tcl_DecrRefCount(newObj);
+     return TCL_ERROR;
+   }
+   newinst = (swig_instance *) malloc(sizeof(swig_instance));
+   newinst->thisptr = newObj;
+   Tcl_IncrRefCount(newObj);
+   newinst->thisvalue = thisvalue;
+   newinst->classptr = classptr;
+   newinst->destroy = destroy;
+   if (destroy) {
+     SWIG_Acquire(thisvalue);
+   }
+   newinst->cmdtok = Tcl_CreateObjCommand(interp,name, (swig_wrapper) SWIG_MethodCommand, (ClientData) newinst, (swig_delete_func) SWIG_ObjectDelete);
+   return TCL_OK;
+ }
+ 
+ /* -----------------------------------------------------------------------------*
+  *   Get arguments 
+  * -----------------------------------------------------------------------------*/
+ SWIGRUNTIME int
+ SWIG_Tcl_GetArgs(Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[], const char *fmt, ...) {
+   int        argno = 0, opt = 0;
+   long       tempi;
+   double     tempd;
+   const char *c;
+   va_list    ap;
+   void      *vptr;
+   Tcl_Obj   *obj = 0;
+   swig_type_info *ty;
+ 
+   va_start(ap,fmt);
+   for (c = fmt; (*c && (*c != ':') && (*c != ';')); c++,argno++) {
+     if (*c == '|') {
+       opt = 1;
+       c++;
+     }
+     if (argno >= (objc-1)) {
+       if (!opt) {
+         Tcl_SetResult(interp, (char *) "Wrong number of arguments ", TCL_STATIC);
+         goto argerror;
+       } else {
+         va_end(ap);
+         return TCL_OK;
+       }
+     }
+ 
+     vptr = va_arg(ap,void *);
+     if (vptr) {
+       if (isupper(*c)) {
+         obj = SWIG_Tcl_GetConstantObj(Tcl_GetStringFromObj(objv[argno+1],0));
+         if (!obj) obj = objv[argno+1];
+       } else {
+         obj = objv[argno+1];
+       }
+       switch(*c) {
+       case 'i': case 'I':
+       case 'l': case 'L':
+       case 'h': case 'H':
+       case 'b': case 'B':
+         if (Tcl_GetLongFromObj(interp,obj,&tempi) != TCL_OK) goto argerror;
+         if ((*c == 'i') || (*c == 'I')) *((int *)vptr) = (int)tempi;
+         else if ((*c == 'l') || (*c == 'L')) *((long *)vptr) = (long)tempi;
+         else if ((*c == 'h') || (*c == 'H')) *((short*)vptr) = (short)tempi;
+         else if ((*c == 'b') || (*c == 'B')) *((unsigned char *)vptr) = (unsigned char)tempi;
+         break;
+       case 'f': case 'F':
+       case 'd': case 'D':
+         if (Tcl_GetDoubleFromObj(interp,obj,&tempd) != TCL_OK) goto argerror;
+         if ((*c == 'f') || (*c == 'F')) *((float *) vptr) = (float)tempd;
+         else if ((*c == 'd') || (*c == 'D')) *((double*) vptr) = tempd;
+         break;
+       case 's': case 'S':
+         if (*(c+1) == '#') {
+           int *vlptr = (int *) va_arg(ap, void *);
+           *((char **) vptr) = Tcl_GetStringFromObj(obj, vlptr);
+           c++;
+         } else {
+           *((char **)vptr) = Tcl_GetStringFromObj(obj,NULL);
+         }
+         break;
+       case 'c': case 'C':
+         *((char *)vptr) = *(Tcl_GetStringFromObj(obj,NULL));
+         break;
+       case 'p': case 'P':
+         ty = (swig_type_info *) va_arg(ap, void *);
+         if (SWIG_Tcl_ConvertPtr(interp, obj, (void **) vptr, ty, 0) != SWIG_OK) goto argerror;
+         break;
+       case 'o': case 'O':
+         *((Tcl_Obj **)vptr) = objv[argno+1];
+         break;
+       default:
+         break;
+       }
+     }
+   }
+ 
+   if ((*c != ';') && ((objc-1) > argno)) {
+     Tcl_SetResult(interp, (char *) "Wrong # args.", TCL_STATIC);
+     goto argerror;
+   }
+   va_end(ap);
+   return TCL_OK;
+ 
+  argerror:
+   {
+     char temp[32];
+     sprintf(temp,"%d", argno+1);
+     c = strchr(fmt,':');
+     if (!c) c = strchr(fmt,';');
+     if (!c) c = (char *)"";
+     Tcl_AppendResult(interp,c," argument ", temp, NULL);
+     va_end(ap);
+     return TCL_ERROR;
+   }
+ }
+ 
+ #ifdef __cplusplus
+ #if 0
+ { /* cc-mode */
+ #endif
+ }
+ #endif
+ 
+ 
+ 
+ #define SWIG_exception_fail(code, msg) do { SWIG_Error(code, msg); SWIG_fail; } while(0) 
+ 
+ #define SWIG_contract_assert(expr, msg) if (!(expr)) { SWIG_Error(SWIG_RuntimeError, msg); SWIG_fail; } else 
+ 
+ 
+ 
+   #define SWIG_exception(code, msg) do { SWIG_Error(code, msg); return TCL_ERROR;; } while(0) 
+ 
+ 
+ /* -------- TYPES TABLE (BEGIN) -------- */
+ 
+ #define SWIGTYPE_p_GIntBig swig_types[0]
+ #define SWIGTYPE_p_OGRDataSourceShadow swig_types[1]
+ #define SWIGTYPE_p_OGRDriverShadow swig_types[2]
+ #define SWIGTYPE_p_OGRFeatureDefnShadow swig_types[3]
+ #define SWIGTYPE_p_OGRFeatureShadow swig_types[4]
+ #define SWIGTYPE_p_OGRFieldDefnShadow swig_types[5]
+ #define SWIGTYPE_p_OGRGeometryShadow swig_types[6]
+ #define SWIGTYPE_p_OGRLayerShadow swig_types[7]
+ #define SWIGTYPE_p_OSRCoordinateTransformationShadow swig_types[8]
+ #define SWIGTYPE_p_OSRSpatialReferenceShadow swig_types[9]
+ #define SWIGTYPE_p_char swig_types[10]
+ #define SWIGTYPE_p_double swig_types[11]
+ #define SWIGTYPE_p_int swig_types[12]
+ #define SWIGTYPE_p_p_char swig_types[13]
+ #define SWIGTYPE_p_p_double swig_types[14]
+ #define SWIGTYPE_p_p_int swig_types[15]
+ #define SWIGTYPE_p_p_p_char swig_types[16]
+ static swig_type_info *swig_types[18];
+ static swig_module_info swig_module = {swig_types, 17, 0, 0, 0, 0};
+ #define SWIG_TypeQuery(name) SWIG_TypeQueryModule(&swig_module, &swig_module, name)
+ #define SWIG_MangledTypeQuery(name) SWIG_MangledTypeQueryModule(&swig_module, &swig_module, name)
+ 
+ /* -------- TYPES TABLE (END) -------- */
+ 
+ #define SWIG_init    Ogr_Init
+ #define SWIG_name    "ogr"
+ #define SWIG_prefix  "osgeo::"
+ #define SWIG_namespace "osgeo"
+ 
+ #define SWIG_version "1.0"
+ 
+ #define SWIGVERSION 0x010336 
+ #define SWIG_VERSION SWIGVERSION
+ 
+ 
+ #define SWIG_as_voidptr(a) const_cast< void * >(static_cast< const void * >(a)) 
+ #define SWIG_as_voidptrptr(a) ((void)SWIG_as_voidptr(*a),reinterpret_cast< void** >(a)) 
+ 
+ 
+ #include <stdexcept>
+ 
+ 
+ 
+ #ifdef __cplusplus
+ extern "C" {
+ #endif
+ #ifdef MAC_TCL
+ #pragma export on
+ #endif
+ SWIGEXPORT int SWIG_init(Tcl_Interp *);
+ #ifdef MAC_TCL
+ #pragma export off
+ #endif
+ #ifdef __cplusplus
+ }
+ #endif
+ 
+ 
+ 
+ #include <iostream>
+ using namespace std;
+ 
+ #include "ogr_api.h"
+ #include "ogr_core.h"
+ #include "cpl_port.h"
+ #include "cpl_string.h"
+ #include "ogr_srs_api.h"
+ 
+ #ifdef DEBUG 
+ typedef struct OGRSpatialReferenceHS OSRSpatialReferenceShadow;
+ typedef struct OGRDriverHS OGRDriverShadow;
+ typedef struct OGRDataSourceHS OGRDataSourceShadow;
+ typedef struct OGRLayerHS OGRLayerShadow;
+ typedef struct OGRFeatureHS OGRFeatureShadow;
+ typedef struct OGRFeatureDefnHS OGRFeatureDefnShadow;
+ typedef struct OGRGeometryHS OGRGeometryShadow;
+ typedef struct OGRCoordinateTransformationHS OSRCoordinateTransformationShadow;
+ typedef struct OGRCoordinateTransformationHS OGRCoordinateTransformationShadow;
+ typedef struct OGRFieldDefnHS OGRFieldDefnShadow;
+ #else
+ typedef void OSRSpatialReferenceShadow;
+ typedef void OGRDriverShadow;
+ typedef void OGRDataSourceShadow;
+ typedef void OGRLayerShadow;
+ typedef void OGRFeatureShadow;
+ typedef void OGRFeatureDefnShadow;
+ typedef void OGRGeometryShadow;
+ typedef void OSRCoordinateTransformationShadow;
+ typedef void OGRFieldDefnShadow;
+ #endif
+ 
+ 
+ 
+ #include <limits.h>
+ #if !defined(SWIG_NO_LLONG_MAX)
+ # if !defined(LLONG_MAX) && defined(__GNUC__) && defined (__LONG_LONG_MAX__)
+ #   define LLONG_MAX __LONG_LONG_MAX__
+ #   define LLONG_MIN (-LLONG_MAX - 1LL)
+ #   define ULLONG_MAX (LLONG_MAX * 2ULL + 1ULL)
+ # endif
+ #endif
+ 
+ 
+ SWIGINTERNINLINE Tcl_Obj* 
+ SWIG_From_long  (long value)
+ {
+   if (((long) INT_MIN <= value) && (value <= (long) INT_MAX)) {
+     return Tcl_NewIntObj(static_cast< int >(value));
+   } else {
+     return Tcl_NewLongObj(value);
+   }
+ }
+ 
+ 
+ SWIGINTERNINLINE Tcl_Obj *
+ SWIG_From_int  (int value)
+ {    
+   return SWIG_From_long  (value);
+ }
+ 
+ 
+ SWIGINTERNINLINE Tcl_Obj *
+ SWIG_FromCharPtrAndSize(const char* carray, size_t size)
+ {
+   return (size < INT_MAX) ? Tcl_NewStringObj(carray, static_cast< int >(size)) : NULL;
+ }
+ 
+ 
+ SWIGINTERNINLINE Tcl_Obj * 
+ SWIG_FromCharPtr(const char *cptr)
+ { 
+   return SWIG_FromCharPtrAndSize(cptr, (cptr ? strlen(cptr) : 0));
+ }
+ 
+ 
+ void VeryQuiteErrorHandler(CPLErr eclass, int code, const char *msg ) {
+   /* If the error class is CE_Fatal, we want to have a message issued
+      because the CPL support code does an abort() before any exception
+      can be generated */
+   if (eclass == CE_Fatal ) {
+     CPLDefaultErrorHandler(eclass, code, msg );
+   }
+ }
+ 
+ 
+ void UseExceptions() {
+   CPLSetErrorHandler( (CPLErrorHandler) VeryQuiteErrorHandler );
+ }
+ 
+ void DontUseExceptions() {
+   CPLSetErrorHandler( CPLDefaultErrorHandler );
+ }
+ 
+ 
+ SWIGINTERN int
+ SWIG_AsCharPtrAndSize(Tcl_Obj *obj, char** cptr, size_t* psize, int *alloc)
+ { 
+   int len = 0;
+   char *cstr = Tcl_GetStringFromObj(obj, &len);
+   if (cstr) {
+     if (cptr)  *cptr = cstr;
+     if (psize) *psize = len + 1;
+     if (alloc) *alloc = SWIG_OLDOBJ;
+     return SWIG_OK;
+   }
+   return SWIG_TypeError;
+ }
+ 
+ 
+ 
+ 
+ SWIGINTERN OGRDataSourceShadow *OGRDriverShadow_CreateDataSource(OGRDriverShadow *self,char const *name,char **options=0){
+     OGRDataSourceShadow *ds = (OGRDataSourceShadow*) OGR_Dr_CreateDataSource( self, name, options);
+     return ds;
+   }
+ SWIGINTERN OGRDataSourceShadow *OGRDriverShadow_CopyDataSource(OGRDriverShadow *self,OGRDataSourceShadow *copy_ds,char const *name,char **options=0){
+     OGRDataSourceShadow *ds = (OGRDataSourceShadow*) OGR_Dr_CopyDataSource(self, copy_ds, name, options);
+     return ds;
+   }
+ 
+ SWIGINTERN int
+ SWIG_AsVal_long SWIG_TCL_DECL_ARGS_2(Tcl_Obj *obj, long* val)
+ {
+   long v;
+   if (Tcl_GetLongFromObj(0,obj, &v) == TCL_OK) {
+     if (val) *val = (long) v;
+     return SWIG_OK;
+   }
+   return SWIG_TypeError;
+ }
+ 
+ 
+ SWIGINTERN int
+ SWIG_AsVal_int SWIG_TCL_DECL_ARGS_2(Tcl_Obj * obj, int *val)
+ {
+   long v;
+   int res = SWIG_AsVal_long SWIG_TCL_CALL_ARGS_2(obj, &v);
+   if (SWIG_IsOK(res)) {
+     if ((v < INT_MIN || v > INT_MAX)) {
+       return SWIG_OverflowError;
+     } else {
+       if (val) *val = static_cast< int >(v);
+     }
+   }  
+   return res;
+ }
+ 
+ SWIGINTERN OGRDataSourceShadow *OGRDriverShadow_Open(OGRDriverShadow *self,char const *name,int update=0){
+     OGRDataSourceShadow* ds = (OGRDataSourceShadow*) OGR_Dr_Open(self, name, update);
+     return ds;
+   }
+ SWIGINTERN int OGRDriverShadow_DeleteDataSource(OGRDriverShadow *self,char const *name){
+     return OGR_Dr_DeleteDataSource( self, name );
+   }
+ SWIGINTERN bool OGRDriverShadow_TestCapability(OGRDriverShadow *self,char const *cap){
+     return (OGR_Dr_TestCapability(self, cap) > 0);
+   }
+ 
+   #define SWIG_From_bool   Tcl_NewBooleanObj 
+ 
+ SWIGINTERN char const *OGRDriverShadow_GetName(OGRDriverShadow *self){
+     return OGR_Dr_GetName( self );
+   }
+ SWIGINTERN void delete_OGRDataSourceShadow(OGRDataSourceShadow *self){
+     OGRReleaseDataSource(self);
+   }
+ SWIGINTERN int OGRDataSourceShadow_GetRefCount(OGRDataSourceShadow *self){
+     return OGR_DS_GetRefCount(self);
+   }
+ SWIGINTERN int OGRDataSourceShadow_GetSummaryRefCount(OGRDataSourceShadow *self){
+     return OGR_DS_GetSummaryRefCount(self);
+   }
+ SWIGINTERN int OGRDataSourceShadow_GetLayerCount(OGRDataSourceShadow *self){
+     return OGR_DS_GetLayerCount(self);
+   }
+ SWIGINTERN OGRDriverShadow *OGRDataSourceShadow_GetDriver(OGRDataSourceShadow *self){
+     return (OGRDriverShadow *) OGR_DS_GetDriver( self );
+   }
+ SWIGINTERN char const *OGRDataSourceShadow_GetName(OGRDataSourceShadow *self){
+     return OGR_DS_GetName(self);
+   }
+ SWIGINTERN OGRErr OGRDataSourceShadow_DeleteLayer(OGRDataSourceShadow *self,int index){
+     return OGR_DS_DeleteLayer(self, index);
+   }
+ 
+ 
+ #include "ogr_core.h"
+ static char const *
+ OGRErrMessages( int rc ) {
+   switch( rc ) {
+   case OGRERR_NONE:
+     return "OGR Error: None";
+   case OGRERR_NOT_ENOUGH_DATA:
+     return "OGR Error: Not enough data to deserialize";
+   case OGRERR_NOT_ENOUGH_MEMORY:
+     return "OGR Error: Not enough memory";
+   case OGRERR_UNSUPPORTED_GEOMETRY_TYPE:
+     return "OGR Error: Unsupported geometry type";
+   case OGRERR_UNSUPPORTED_OPERATION:
+     return "OGR Error: Unsupported operation";
+   case OGRERR_CORRUPT_DATA:
+     return "OGR Error: Corrupt data";
+   case OGRERR_FAILURE:
+     return "OGR Error: General Error";
+   case OGRERR_UNSUPPORTED_SRS:
+     return "OGR Error: Unsupported SRS";
+   case OGRERR_INVALID_HANDLE:
+     return "OGR Error: Invalid handle";
+   default:
+     return "OGR Error: Unknown";
+   }
+ }
+ 
+ SWIGINTERN OGRLayerShadow *OGRDataSourceShadow_CreateLayer(OGRDataSourceShadow *self,char const *name,OSRSpatialReferenceShadow *srs=NULL,OGRwkbGeometryType geom_type=wkbUnknown,char **options=0){
+     OGRLayerShadow* layer = (OGRLayerShadow*) OGR_DS_CreateLayer( self,
+ 								  name,
+ 								  srs,
+ 								  geom_type,
+ 								  options);
+     return layer;
+   }
+ SWIGINTERN OGRLayerShadow *OGRDataSourceShadow_CopyLayer(OGRDataSourceShadow *self,OGRLayerShadow *src_layer,char const *new_name,char **options=0){
+     OGRLayerShadow* layer = (OGRLayerShadow*) OGR_DS_CopyLayer( self,
+                                                       src_layer,
+                                                       new_name,
+                                                       options);
+     return layer;
+   }
+ SWIGINTERN OGRLayerShadow *OGRDataSourceShadow_GetLayerByIndex(OGRDataSourceShadow *self,int index=0){
+     OGRLayerShadow* layer = (OGRLayerShadow*) OGR_DS_GetLayer(self, index);
+     return layer;
+   }
+ SWIGINTERN OGRLayerShadow *OGRDataSourceShadow_GetLayerByName(OGRDataSourceShadow *self,char const *layer_name){
+     OGRLayerShadow* layer = (OGRLayerShadow*) OGR_DS_GetLayerByName(self, layer_name);
+     return layer;
+   }
+ SWIGINTERN bool OGRDataSourceShadow_TestCapability(OGRDataSourceShadow *self,char const *cap){
+     return (OGR_DS_TestCapability(self, cap) > 0);
+   }
+ SWIGINTERN OGRLayerShadow *OGRDataSourceShadow_ExecuteSQL(OGRDataSourceShadow *self,char const *statement,OGRGeometryShadow *spatialFilter=NULL,char const *dialect=""){
+     OGRLayerShadow* layer = (OGRLayerShadow*) OGR_DS_ExecuteSQL((OGRDataSourceShadow*)self,
+                                                       statement,
+                                                       spatialFilter,
+                                                       dialect);
+     return layer;
+   }
+ SWIGINTERN void OGRDataSourceShadow_ReleaseResultSet(OGRDataSourceShadow *self,OGRLayerShadow *layer){
+     OGR_DS_ReleaseResultSet(self, layer);
+   }
+ SWIGINTERN int OGRLayerShadow_GetRefCount(OGRLayerShadow *self){
+     return OGR_L_GetRefCount(self);
+   }
+ SWIGINTERN void OGRLayerShadow_SetSpatialFilter(OGRLayerShadow *self,OGRGeometryShadow *filter){
+     OGR_L_SetSpatialFilter (self, filter);
+   }
+ 
+ SWIGINTERN int
+ SWIG_AsVal_double SWIG_TCL_DECL_ARGS_2(Tcl_Obj *obj, double *val)
+ {
+   double v;
+   if (Tcl_GetDoubleFromObj(0, obj, &v) == TCL_OK) {
+     if (val) *val = v;
+     return SWIG_OK;
+   }
+   return SWIG_TypeError;
+ }
+ 
+ SWIGINTERN void OGRLayerShadow_SetSpatialFilterRect(OGRLayerShadow *self,double minx,double miny,double maxx,double maxy){
+     OGR_L_SetSpatialFilterRect(self, minx, miny, maxx, maxy);                          
+   }
+ SWIGINTERN OGRGeometryShadow *OGRLayerShadow_GetSpatialFilter(OGRLayerShadow *self){
+     return (OGRGeometryShadow *) OGR_L_GetSpatialFilter(self);
+   }
+ SWIGINTERN OGRErr OGRLayerShadow_SetAttributeFilter(OGRLayerShadow *self,char *filter_string){
+     return OGR_L_SetAttributeFilter((OGRLayerShadow*)self, filter_string);
+   }
+ SWIGINTERN void OGRLayerShadow_ResetReading(OGRLayerShadow *self){
+     OGR_L_ResetReading(self);
+   }
+ SWIGINTERN char const *OGRLayerShadow_GetName(OGRLayerShadow *self){
+     return OGR_FD_GetName(OGR_L_GetLayerDefn(self));
+   }
+ SWIGINTERN char const *OGRLayerShadow_GetGeometryColumn(OGRLayerShadow *self){
+     return OGR_L_GetGeometryColumn(self);
+   }
+ SWIGINTERN char const *OGRLayerShadow_GetFIDColumn(OGRLayerShadow *self){
+     return OGR_L_GetFIDColumn(self);
+   }
+ SWIGINTERN OGRFeatureShadow *OGRLayerShadow_GetFeature(OGRLayerShadow *self,long fid){
+     return (OGRFeatureShadow*) OGR_L_GetFeature(self, fid);
+   }
+ SWIGINTERN OGRFeatureShadow *OGRLayerShadow_GetNextFeature(OGRLayerShadow *self){
+     return (OGRFeatureShadow*) OGR_L_GetNextFeature(self);
+   }
+ SWIGINTERN OGRErr OGRLayerShadow_SetNextByIndex(OGRLayerShadow *self,long new_index){
+     return OGR_L_SetNextByIndex(self, new_index);
+   }
+ SWIGINTERN OGRErr OGRLayerShadow_SetFeature(OGRLayerShadow *self,OGRFeatureShadow *feature){
+     return OGR_L_SetFeature(self, feature);
+   }
+ SWIGINTERN OGRErr OGRLayerShadow_CreateFeature(OGRLayerShadow *self,OGRFeatureShadow *feature){
+     return OGR_L_CreateFeature(self, feature);
+   }
+ SWIGINTERN OGRErr OGRLayerShadow_DeleteFeature(OGRLayerShadow *self,long fid){
+     return OGR_L_DeleteFeature(self, fid);
+   }
+ SWIGINTERN OGRErr OGRLayerShadow_SyncToDisk(OGRLayerShadow *self){
+     return OGR_L_SyncToDisk(self);
+   }
+ SWIGINTERN OGRFeatureDefnShadow *OGRLayerShadow_GetLayerDefn(OGRLayerShadow *self){
+     return (OGRFeatureDefnShadow*) OGR_L_GetLayerDefn(self);
+   }
+ SWIGINTERN int OGRLayerShadow_GetFeatureCount(OGRLayerShadow *self,int force=1){
+     return OGR_L_GetFeatureCount(self, force);
+   }
+ 
+ static Tcl_Obj*
+ CreateListFromDoubleArray(Tcl_Interp *interp, double *first, unsigned int size ) {
+   Tcl_Obj *out = Tcl_NewListObj(0, NULL);
+   for( unsigned int i=0; i<size; i++ ) {
+     Tcl_Obj *val = Tcl_NewDoubleObj( *first );
+     ++first;
+     if (Tcl_ListObjAppendElement(interp, out, val) != TCL_OK) {
+         Tcl_DecrRefCount(val);
+         Tcl_DecrRefCount(out);
+         /* Error msg in interp result */
+         return NULL; /* signifies error */
+     }
+   }
+   return out;
+ }
+ 
+ SWIGINTERN OGRErr OGRLayerShadow_GetExtent(OGRLayerShadow *self,double argout[4],int force=1){
+     return OGR_L_GetExtent(self, (OGREnvelope*)argout, force);
+   }
+ SWIGINTERN bool OGRLayerShadow_TestCapability(OGRLayerShadow *self,char const *cap){
+     return (OGR_L_TestCapability(self, cap) > 0);
+   }
+ SWIGINTERN OGRErr OGRLayerShadow_CreateField(OGRLayerShadow *self,OGRFieldDefnShadow *field_def,int approx_ok=1){
+     return OGR_L_CreateField(self, field_def, approx_ok);
+   }
+ SWIGINTERN OGRErr OGRLayerShadow_StartTransaction(OGRLayerShadow *self){
+     return OGR_L_StartTransaction(self);
+   }
+ SWIGINTERN OGRErr OGRLayerShadow_CommitTransaction(OGRLayerShadow *self){
+     return OGR_L_CommitTransaction(self);
+   }
+ SWIGINTERN OGRErr OGRLayerShadow_RollbackTransaction(OGRLayerShadow *self){
+     return OGR_L_RollbackTransaction(self);
+   }
+ SWIGINTERN OSRSpatialReferenceShadow *OGRLayerShadow_GetSpatialRef(OGRLayerShadow *self){
+     OGRSpatialReferenceH ref =  OGR_L_GetSpatialRef(self);
+     if( ref )
+         OSRReference(ref);
+     return (OSRSpatialReferenceShadow*) ref;
+   }
+ SWIGINTERN GIntBig OGRLayerShadow_GetFeaturesRead(OGRLayerShadow *self){
+     return OGR_L_GetFeaturesRead(self);
+   }
+ SWIGINTERN void delete_OGRFeatureShadow(OGRFeatureShadow *self){
+     OGR_F_Destroy(self);
+   }
+ SWIGINTERN OGRFeatureShadow *new_OGRFeatureShadow(OGRFeatureDefnShadow *feature_def=0){
+       return (OGRFeatureShadow*) OGR_F_Create( feature_def );
+   }
+ SWIGINTERN OGRFeatureDefnShadow *OGRFeatureShadow_GetDefnRef(OGRFeatureShadow *self){
+     return (OGRFeatureDefnShadow*) OGR_F_GetDefnRef(self);
+   }
+ SWIGINTERN OGRErr OGRFeatureShadow_SetGeometry(OGRFeatureShadow *self,OGRGeometryShadow *geom){
+     return OGR_F_SetGeometry(self, geom);
+   }
+ SWIGINTERN OGRErr OGRFeatureShadow_SetGeometryDirectly(OGRFeatureShadow *self,OGRGeometryShadow *geom){
+     return OGR_F_SetGeometryDirectly(self, geom);
+   }
+ SWIGINTERN OGRGeometryShadow *OGRFeatureShadow_GetGeometryRef(OGRFeatureShadow *self){
+     return (OGRGeometryShadow*) OGR_F_GetGeometryRef(self);
+   }
+ SWIGINTERN OGRFeatureShadow *OGRFeatureShadow_Clone(OGRFeatureShadow *self){
+     return (OGRFeatureShadow*) OGR_F_Clone(self);
+   }
+ SWIGINTERN bool OGRFeatureShadow_Equal(OGRFeatureShadow *self,OGRFeatureShadow *feature){
+     return (OGR_F_Equal(self, feature) > 0);
+   }
+ SWIGINTERN int OGRFeatureShadow_GetFieldCount(OGRFeatureShadow *self){
+     return OGR_F_GetFieldCount(self);
+   }
+ SWIGINTERN OGRFieldDefnShadow *OGRFeatureShadow_GetFieldDefnRef__SWIG_0(OGRFeatureShadow *self,int id){
+     return (OGRFieldDefnShadow *) OGR_F_GetFieldDefnRef(self, id);
+   }
+ SWIGINTERN OGRFieldDefnShadow *OGRFeatureShadow_GetFieldDefnRef__SWIG_1(OGRFeatureShadow *self,char const *name){
+       int i = OGR_F_GetFieldIndex(self, name);
+       if (i == -1)
+ 	  CPLError(CE_Failure, 1, "No such field: '%s'", name);
+       else
+ 	  return (OGRFieldDefnShadow *) OGR_F_GetFieldDefnRef(self, i);
+       return NULL;
+   }
+ SWIGINTERN char const *OGRFeatureShadow_GetFieldAsString__SWIG_0(OGRFeatureShadow *self,int id){
+     return (const char *) OGR_F_GetFieldAsString(self, id);
+   }
+ SWIGINTERN char const *OGRFeatureShadow_GetFieldAsString__SWIG_1(OGRFeatureShadow *self,char const *name){
+       int i = OGR_F_GetFieldIndex(self, name);
+       if (i == -1)
+ 	  CPLError(CE_Failure, 1, "No such field: '%s'", name);
+       else
+ 	  return (const char *) OGR_F_GetFieldAsString(self, i);
+       return NULL;
+   }
+ SWIGINTERN int OGRFeatureShadow_GetFieldAsInteger__SWIG_0(OGRFeatureShadow *self,int id){
+     return OGR_F_GetFieldAsInteger(self, id);
+   }
+ SWIGINTERN int OGRFeatureShadow_GetFieldAsInteger__SWIG_1(OGRFeatureShadow *self,char const *name){
+       int i = OGR_F_GetFieldIndex(self, name);
+       if (i == -1)
+ 	  CPLError(CE_Failure, 1, "No such field: '%s'", name);
+       else
+ 	  return OGR_F_GetFieldAsInteger(self, i);
+       return 0;
+   }
+ SWIGINTERN double OGRFeatureShadow_GetFieldAsDouble__SWIG_0(OGRFeatureShadow *self,int id){
+     return OGR_F_GetFieldAsDouble(self, id);
+   }
+ 
+   #define SWIG_From_double   Tcl_NewDoubleObj 
+ 
+ SWIGINTERN double OGRFeatureShadow_GetFieldAsDouble__SWIG_1(OGRFeatureShadow *self,char const *name){
+       int i = OGR_F_GetFieldIndex(self, name);
+       if (i == -1)
+ 	  CPLError(CE_Failure, 1, "No such field: '%s'", name);
+       else
+ 	  return OGR_F_GetFieldAsDouble(self, i);
+       return 0;
+   }
+ SWIGINTERN void OGRFeatureShadow_GetFieldAsDateTime(OGRFeatureShadow *self,int id,int *pnYear,int *pnMonth,int *pnDay,int *pnHour,int *pnMinute,int *pnSecond,int *pnTZFlag){
+       OGR_F_GetFieldAsDateTime(self, id, pnYear, pnMonth, pnDay,
+ 			       pnHour, pnMinute, pnSecond,
+ 			       pnTZFlag);
+   }
+ SWIGINTERN void OGRFeatureShadow_GetFieldAsIntegerList(OGRFeatureShadow *self,int id,int *nLen,int const **pList){
+       *pList = OGR_F_GetFieldAsIntegerList(self, id, nLen);
+   }
+ SWIGINTERN void OGRFeatureShadow_GetFieldAsDoubleList(OGRFeatureShadow *self,int id,int *nLen,double const **pList){
+       *pList = OGR_F_GetFieldAsDoubleList(self, id, nLen);
+   }
+ SWIGINTERN void OGRFeatureShadow_GetFieldAsStringList(OGRFeatureShadow *self,int id,char ***pList){
+       *pList = OGR_F_GetFieldAsStringList(self, id);
+   }
+ SWIGINTERN bool OGRFeatureShadow_IsFieldSet__SWIG_0(OGRFeatureShadow *self,int id){
+     return (OGR_F_IsFieldSet(self, id) > 0);
+   }
+ SWIGINTERN bool OGRFeatureShadow_IsFieldSet__SWIG_1(OGRFeatureShadow *self,char const *name){
+       int i = OGR_F_GetFieldIndex(self, name);
+       if (i == -1)
+ 	  CPLError(CE_Failure, 1, "No such field: '%s'", name);
+       else
+ 	  return (OGR_F_IsFieldSet(self, i) > 0);
+       return false;
+   }
+ SWIGINTERN int OGRFeatureShadow_GetFieldIndex(OGRFeatureShadow *self,char const *name){
+       return OGR_F_GetFieldIndex(self, name);
+   }
+ SWIGINTERN int OGRFeatureShadow_GetFID(OGRFeatureShadow *self){
+     return OGR_F_GetFID(self);
+   }
+ SWIGINTERN OGRErr OGRFeatureShadow_SetFID(OGRFeatureShadow *self,int fid){
+     return OGR_F_SetFID(self, fid);
+   }
+ SWIGINTERN void OGRFeatureShadow_DumpReadable(OGRFeatureShadow *self){
+     OGR_F_DumpReadable(self, NULL);
+   }
+ SWIGINTERN void OGRFeatureShadow_UnsetField__SWIG_0(OGRFeatureShadow *self,int id){
+     OGR_F_UnsetField(self, id);
+   }
+ SWIGINTERN void OGRFeatureShadow_UnsetField__SWIG_1(OGRFeatureShadow *self,char const *name){
+       int i = OGR_F_GetFieldIndex(self, name);
+       if (i == -1)
+ 	  CPLError(CE_Failure, 1, "No such field: '%s'", name);
+       else
+ 	  OGR_F_UnsetField(self, i);
+   }
+ SWIGINTERN void OGRFeatureShadow_SetField__SWIG_0(OGRFeatureShadow *self,int id,char const *value){
+     OGR_F_SetFieldString(self, id, value);
+   }
+ SWIGINTERN void OGRFeatureShadow_SetField__SWIG_1(OGRFeatureShadow *self,char const *name,char const *value){
+       int i = OGR_F_GetFieldIndex(self, name);
+       if (i == -1)
+ 	  CPLError(CE_Failure, 1, "No such field: '%s'", name);
+       else
+ 	  OGR_F_SetFieldString(self, i, value);
+   }
+ SWIGINTERN void OGRFeatureShadow_SetField__SWIG_2(OGRFeatureShadow *self,int id,int value){
+     OGR_F_SetFieldInteger(self, id, value);
+   }
+ SWIGINTERN void OGRFeatureShadow_SetField__SWIG_3(OGRFeatureShadow *self,char const *name,int value){
+       int i = OGR_F_GetFieldIndex(self, name);
+       if (i == -1)
+ 	  CPLError(CE_Failure, 1, "No such field: '%s'", name);
+       else
+ 	  OGR_F_SetFieldInteger(self, i, value);
+   }
+ SWIGINTERN void OGRFeatureShadow_SetField__SWIG_4(OGRFeatureShadow *self,int id,double value){
+     OGR_F_SetFieldDouble(self, id, value);
+   }
+ SWIGINTERN void OGRFeatureShadow_SetField__SWIG_5(OGRFeatureShadow *self,char const *name,double value){
+       int i = OGR_F_GetFieldIndex(self, name);
+       if (i == -1)
+ 	  CPLError(CE_Failure, 1, "No such field: '%s'", name);
+       else
+ 	  OGR_F_SetFieldDouble(self, i, value);
+   }
+ SWIGINTERN void OGRFeatureShadow_SetField__SWIG_6(OGRFeatureShadow *self,int id,int year,int month,int day,int hour,int minute,int second,int tzflag){
+     OGR_F_SetFieldDateTime(self, id, year, month, day,
+                              hour, minute, second, 
+                              tzflag);
+   }
+ SWIGINTERN void OGRFeatureShadow_SetField__SWIG_7(OGRFeatureShadow *self,char const *name,int year,int month,int day,int hour,int minute,int second,int tzflag){
+       int i = OGR_F_GetFieldIndex(self, name);
+       if (i == -1)
+ 	  CPLError(CE_Failure, 1, "No such field: '%s'", name);
+       else
+ 	  OGR_F_SetFieldDateTime(self, i, year, month, day,
+ 				 hour, minute, second, 
+ 				 tzflag);
+   }
+ SWIGINTERN void OGRFeatureShadow_SetFieldIntegerList(OGRFeatureShadow *self,int id,int nList,int *pList){
+       OGR_F_SetFieldIntegerList(self, id, nList, pList);
+   }
+ SWIGINTERN void OGRFeatureShadow_SetFieldDoubleList(OGRFeatureShadow *self,int id,int nList,double *pList){
+       OGR_F_SetFieldDoubleList(self, id, nList, pList);
+   }
+ SWIGINTERN void OGRFeatureShadow_SetFieldStringList(OGRFeatureShadow *self,int id,char **pList){
+       OGR_F_SetFieldStringList(self, id, pList);
+   }
+ SWIGINTERN OGRErr OGRFeatureShadow_SetFrom(OGRFeatureShadow *self,OGRFeatureShadow *other,int forgiving=1){
+     return OGR_F_SetFrom(self, other, forgiving);
+   }
+ SWIGINTERN char const *OGRFeatureShadow_GetStyleString(OGRFeatureShadow *self){
+     return (const char*) OGR_F_GetStyleString(self);
+   }
+ SWIGINTERN void OGRFeatureShadow_SetStyleString(OGRFeatureShadow *self,char const *the_string){
+     OGR_F_SetStyleString(self, the_string);
+   }
+ SWIGINTERN OGRFieldType OGRFeatureShadow_GetFieldType__SWIG_0(OGRFeatureShadow *self,int id){
+     return (OGRFieldType) OGR_Fld_GetType( OGR_F_GetFieldDefnRef( self, id));
+   }
+ SWIGINTERN OGRFieldType OGRFeatureShadow_GetFieldType__SWIG_1(OGRFeatureShadow *self,char const *name){
+       int i = OGR_F_GetFieldIndex(self, name);
+       if (i == -1) {
+ 	  CPLError(CE_Failure, 1, "No such field: '%s'", name);
+ 	  return (OGRFieldType)0;
+       } else
+ 	  return (OGRFieldType) OGR_Fld_GetType( 
+ 	      OGR_F_GetFieldDefnRef( self,  i )
+ 	      );
+   }
+ SWIGINTERN void delete_OGRFeatureDefnShadow(OGRFeatureDefnShadow *self){
+     /*OGR_FD_Destroy(self);*/
+     OGR_FD_Release( OGRFeatureDefnH(self) );
+   }
+ SWIGINTERN OGRFeatureDefnShadow *new_OGRFeatureDefnShadow(char const *name_null_ok=NULL){
+     OGRFeatureDefnH h = OGR_FD_Create(name_null_ok);
+     OGR_FD_Reference(h);
+     return (OGRFeatureDefnShadow* )h;
+   }
+ SWIGINTERN char const *OGRFeatureDefnShadow_GetName(OGRFeatureDefnShadow *self){
+     return OGR_FD_GetName(self);
+   }
+ SWIGINTERN int OGRFeatureDefnShadow_GetFieldCount(OGRFeatureDefnShadow *self){
+     return OGR_FD_GetFieldCount(self);
+   }
+ SWIGINTERN OGRFieldDefnShadow *OGRFeatureDefnShadow_GetFieldDefn(OGRFeatureDefnShadow *self,int i){
+     return (OGRFieldDefnShadow*) OGR_FD_GetFieldDefn(self, i);
+   }
+ SWIGINTERN int OGRFeatureDefnShadow_GetFieldIndex(OGRFeatureDefnShadow *self,char const *name){
+       return OGR_FD_GetFieldIndex(self, name);
+   }
+ SWIGINTERN void OGRFeatureDefnShadow_AddFieldDefn(OGRFeatureDefnShadow *self,OGRFieldDefnShadow *defn){
+     OGR_FD_AddFieldDefn(self, defn);
+   }
+ SWIGINTERN OGRwkbGeometryType OGRFeatureDefnShadow_GetGeomType(OGRFeatureDefnShadow *self){
+     return (OGRwkbGeometryType) OGR_FD_GetGeomType(self);
+   }
+ SWIGINTERN void OGRFeatureDefnShadow_SetGeomType(OGRFeatureDefnShadow *self,OGRwkbGeometryType geom_type){
+     OGR_FD_SetGeomType(self, geom_type);
+   }
+ SWIGINTERN int OGRFeatureDefnShadow_GetReferenceCount(OGRFeatureDefnShadow *self){
+     return OGR_FD_GetReferenceCount(self);
+   }
+ SWIGINTERN void delete_OGRFieldDefnShadow(OGRFieldDefnShadow *self){
+     OGR_Fld_Destroy(self);
+   }
+ SWIGINTERN OGRFieldDefnShadow *new_OGRFieldDefnShadow(char const *name_null_ok="unnamed",OGRFieldType field_type=OFTString){
+     return (OGRFieldDefnShadow*) OGR_Fld_Create(name_null_ok, field_type);
+   }
+ SWIGINTERN char const *OGRFieldDefnShadow_GetName(OGRFieldDefnShadow *self){
+     return (const char *) OGR_Fld_GetNameRef(self);
+   }
+ SWIGINTERN char const *OGRFieldDefnShadow_GetNameRef(OGRFieldDefnShadow *self){
+     return (const char *) OGR_Fld_GetNameRef(self);
+   }
+ SWIGINTERN void OGRFieldDefnShadow_SetName(OGRFieldDefnShadow *self,char const *name){
+     OGR_Fld_SetName(self, name);
+   }
+ SWIGINTERN OGRFieldType OGRFieldDefnShadow_GetType(OGRFieldDefnShadow *self){
+     return OGR_Fld_GetType(self);
+   }
+ SWIGINTERN void OGRFieldDefnShadow_SetType(OGRFieldDefnShadow *self,OGRFieldType type){
+     OGR_Fld_SetType(self, type);
+   }
+ SWIGINTERN OGRJustification OGRFieldDefnShadow_GetJustify(OGRFieldDefnShadow *self){
+     return OGR_Fld_GetJustify(self);
+   }
+ SWIGINTERN void OGRFieldDefnShadow_SetJustify(OGRFieldDefnShadow *self,OGRJustification justify){
+     OGR_Fld_SetJustify(self, justify);
+   }
+ SWIGINTERN int OGRFieldDefnShadow_GetWidth(OGRFieldDefnShadow *self){
+     return OGR_Fld_GetWidth(self);
+   }
+ SWIGINTERN void OGRFieldDefnShadow_SetWidth(OGRFieldDefnShadow *self,int width){
+     OGR_Fld_SetWidth(self, width);
+   }
+ SWIGINTERN int OGRFieldDefnShadow_GetPrecision(OGRFieldDefnShadow *self){
+     return OGR_Fld_GetPrecision(self);
+   }
+ SWIGINTERN void OGRFieldDefnShadow_SetPrecision(OGRFieldDefnShadow *self,int precision){
+     OGR_Fld_SetPrecision(self, precision);
+   }
+ SWIGINTERN char const *OGRFieldDefnShadow_GetFieldTypeName(OGRFieldDefnShadow *self,OGRFieldType type){
+     return OGR_GetFieldTypeName(type);
+   }
+ 
+   OGRGeometryShadow* CreateGeometryFromWkb( int len, char *bin_string, 
+                                             OSRSpatialReferenceShadow *reference=NULL ) {
+     OGRGeometryShadow *geom;
+     OGRErr err = OGR_G_CreateFromWkb( (unsigned char *) bin_string,
+                                       reference,
+                                       &geom,
+                                       len );
+     if (err != 0 ) {
+        CPLError(CE_Failure, err, "%s", OGRErrMessages(err));
+        return NULL;
+     }
+     return (OGRGeometryShadow*) geom;
+   }
+  
+ 
+ 
+   OGRGeometryShadow* CreateGeometryFromWkt( char **val, 
+                                       OSRSpatialReferenceShadow *reference=NULL ) {
+     OGRGeometryShadow *geom;
+     OGRErr err = OGR_G_CreateFromWkt(val,
+                                       reference,
+                                       &geom);
+     if (err != 0 ) {
+        CPLError(CE_Failure, err, "%s", OGRErrMessages(err));
+        return NULL;
+     }
+     return (OGRGeometryShadow*) geom;
+   }
+  
+ 
+ 
+   OGRGeometryShadow *CreateGeometryFromGML( const char * input_string ) {
+     OGRGeometryShadow* geom = (OGRGeometryShadow*)OGR_G_CreateFromGML(input_string);
+     return geom;
+   }
+  
+ 
+ 
+   OGRGeometryShadow *CreateGeometryFromJson( const char * input_string ) {
+     OGRGeometryShadow* geom = (OGRGeometryShadow*)OGR_G_CreateGeometryFromJson(input_string);
+     return geom;
+   }
+  
+ 
+ 
+   OGRGeometryShadow* BuildPolygonFromEdges( OGRGeometryShadow*  hLineCollection,  
+                                             int bBestEffort = 0, 
+                                             int bAutoClose = 0, 
+                                             double dfTolerance=0) {
+   
+   OGRGeometryH hPolygon = NULL;
+   
+   OGRErr eErr;
+ 
+   hPolygon = OGRBuildPolygonFromEdges( hLineCollection, bBestEffort, 
+                                        bAutoClose, dfTolerance, &eErr );
+ 
+   if (eErr != OGRERR_NONE ) {
+     CPLError(CE_Failure, eErr, "%s", OGRErrMessages(eErr));
+     return NULL;
+   }
+ 
+   return hPolygon;
+   }
+ 
+ SWIGINTERN void delete_OGRGeometryShadow(OGRGeometryShadow *self){
+     OGR_G_DestroyGeometry( self );
+   }
+ SWIGINTERN OGRGeometryShadow *new_OGRGeometryShadow(OGRwkbGeometryType type=wkbUnknown,char *wkt=0,int wkb=0,char *wkb_buf=0,char *gml=0){
+     if (type != wkbUnknown ) {
+       return (OGRGeometryShadow*) OGR_G_CreateGeometry( type );
+     }
+     else if ( wkt != 0 ) {
+       return CreateGeometryFromWkt( &wkt );
+     }
+     else if ( wkb != 0 ) {
+       return CreateGeometryFromWkb( wkb, wkb_buf );
+     }
+     else if ( gml != 0 ) {
+       return CreateGeometryFromGML( gml );
+     }
+     // throw?
+     else return 0;
+   }
+ SWIGINTERN OGRErr OGRGeometryShadow_ExportToWkt(OGRGeometryShadow *self,char **argout){
+     return OGR_G_ExportToWkt(self, argout);
+   }
+ SWIGINTERN OGRErr OGRGeometryShadow_ExportToWkb(OGRGeometryShadow *self,int *nLen,char **pBuf,OGRwkbByteOrder byte_order=wkbXDR){
+     *nLen = OGR_G_WkbSize( self );
+     *pBuf = (char *) malloc( *nLen * sizeof(unsigned char) );
+     return OGR_G_ExportToWkb(self, byte_order, (unsigned char*) *pBuf );
+   }
+ SWIGINTERN char const *OGRGeometryShadow_ExportToGML(OGRGeometryShadow *self){
+     return (const char *) OGR_G_ExportToGML(self);
+   }
+ SWIGINTERN char const *OGRGeometryShadow_ExportToKML(OGRGeometryShadow *self,char const *altitude_mode=NULL){
+     return (const char *) OGR_G_ExportToKML(self, altitude_mode);
+   }
+ SWIGINTERN char const *OGRGeometryShadow_ExportToJson(OGRGeometryShadow *self){
+     return (const char *) OGR_G_ExportToJson(self);
+   }
+ SWIGINTERN void OGRGeometryShadow_AddPoint(OGRGeometryShadow *self,double x,double y,double z=0){
+     OGR_G_AddPoint( self, x, y, z );
+   }
+ SWIGINTERN void OGRGeometryShadow_AddPoint_2D(OGRGeometryShadow *self,double x,double y){
+     OGR_G_AddPoint_2D( self, x, y );
+   }
+ SWIGINTERN OGRErr OGRGeometryShadow_AddGeometryDirectly(OGRGeometryShadow *self,OGRGeometryShadow *other_disown){
+     return OGR_G_AddGeometryDirectly( self, other_disown );
+   }
+ SWIGINTERN OGRErr OGRGeometryShadow_AddGeometry(OGRGeometryShadow *self,OGRGeometryShadow *other){
+     return OGR_G_AddGeometry( self, other );
+   }
+ SWIGINTERN OGRGeometryShadow *OGRGeometryShadow_Clone(OGRGeometryShadow *self){
+     return (OGRGeometryShadow*) OGR_G_Clone(self);
+   }
+ SWIGINTERN OGRwkbGeometryType OGRGeometryShadow_GetGeometryType(OGRGeometryShadow *self){
+     return (OGRwkbGeometryType) OGR_G_GetGeometryType(self);
+   }
+ SWIGINTERN char const *OGRGeometryShadow_GetGeometryName(OGRGeometryShadow *self){
+     return (const char *) OGR_G_GetGeometryName(self);
+   }
+ SWIGINTERN double OGRGeometryShadow_GetArea(OGRGeometryShadow *self){
+     return OGR_G_GetArea(self);
+   }
+ SWIGINTERN int OGRGeometryShadow_GetPointCount(OGRGeometryShadow *self){
+     return OGR_G_GetPointCount(self);
+   }
+ SWIGINTERN double OGRGeometryShadow_GetX(OGRGeometryShadow *self,int point=0){
+     return OGR_G_GetX(self, point);
+   }
+ SWIGINTERN double OGRGeometryShadow_GetY(OGRGeometryShadow *self,int point=0){
+     return OGR_G_GetY(self, point);
+   }
+ SWIGINTERN double OGRGeometryShadow_GetZ(OGRGeometryShadow *self,int point=0){
+     return OGR_G_GetZ(self, point);
+   }
+ SWIGINTERN void OGRGeometryShadow_GetPoint(OGRGeometryShadow *self,int iPoint=0,double argout[3]=NULL){
+     OGR_G_GetPoint( self, iPoint, argout+0, argout+1, argout+2 );
+   }
+ SWIGINTERN void OGRGeometryShadow_GetPoint_2D(OGRGeometryShadow *self,int iPoint=0,double argout[2]=NULL){
+     OGR_G_GetPoint( self, iPoint, argout+0, argout+1, NULL );
+   }
+ SWIGINTERN int OGRGeometryShadow_GetGeometryCount(OGRGeometryShadow *self){
+     return OGR_G_GetGeometryCount(self);
+   }
+ SWIGINTERN void OGRGeometryShadow_SetPoint(OGRGeometryShadow *self,int point,double x,double y,double z=0){
+     OGR_G_SetPoint(self, point, x, y, z);
+   }
+ SWIGINTERN void OGRGeometryShadow_SetPoint_2D(OGRGeometryShadow *self,int point,double x,double y){
+     OGR_G_SetPoint_2D(self, point, x, y);
+   }
+ SWIGINTERN OGRGeometryShadow *OGRGeometryShadow_GetGeometryRef(OGRGeometryShadow *self,int geom){
+     return (OGRGeometryShadow*) OGR_G_GetGeometryRef(self, geom);
+   }
+ SWIGINTERN OGRGeometryShadow *OGRGeometryShadow_GetBoundary(OGRGeometryShadow *self){
+     return (OGRGeometryShadow*) OGR_G_GetBoundary(self);
+   }
+ SWIGINTERN OGRGeometryShadow *OGRGeometryShadow_ConvexHull(OGRGeometryShadow *self){
+     return (OGRGeometryShadow*) OGR_G_ConvexHull(self);
+   }
+ SWIGINTERN OGRGeometryShadow *OGRGeometryShadow_Buffer(OGRGeometryShadow *self,double distance,int quadsecs=30){
+     return (OGRGeometryShadow*) OGR_G_Buffer( self, distance, quadsecs );
+   }
+ SWIGINTERN OGRGeometryShadow *OGRGeometryShadow_Intersection(OGRGeometryShadow *self,OGRGeometryShadow *other){
+     return (OGRGeometryShadow*) OGR_G_Intersection( self, other );
+   }
+ SWIGINTERN OGRGeometryShadow *OGRGeometryShadow_Union(OGRGeometryShadow *self,OGRGeometryShadow *other){
+     return (OGRGeometryShadow*) OGR_G_Union( self, other );
+   }
+ SWIGINTERN OGRGeometryShadow *OGRGeometryShadow_Difference(OGRGeometryShadow *self,OGRGeometryShadow *other){
+     return (OGRGeometryShadow*) OGR_G_Difference( self, other );
+   }
+ SWIGINTERN OGRGeometryShadow *OGRGeometryShadow_SymmetricDifference(OGRGeometryShadow *self,OGRGeometryShadow *other){
+     return (OGRGeometryShadow*) OGR_G_SymmetricDifference( self, other );
+   }
+ SWIGINTERN double OGRGeometryShadow_Distance(OGRGeometryShadow *self,OGRGeometryShadow *other){
+     return OGR_G_Distance(self, other);
+   }
+ SWIGINTERN void OGRGeometryShadow_Empty(OGRGeometryShadow *self){
+     OGR_G_Empty(self);
+   }
+ SWIGINTERN bool OGRGeometryShadow_IsEmpty(OGRGeometryShadow *self){
+     return (OGR_G_IsEmpty(self) > 0);
+   }
+ SWIGINTERN bool OGRGeometryShadow_IsValid(OGRGeometryShadow *self){
+     return (OGR_G_IsValid(self) > 0);
+   }
+ SWIGINTERN bool OGRGeometryShadow_IsSimple(OGRGeometryShadow *self){
+     return (OGR_G_IsSimple(self) > 0);
+   }
+ SWIGINTERN bool OGRGeometryShadow_IsRing(OGRGeometryShadow *self){
+     return (OGR_G_IsRing(self) > 0);
+   }
+ SWIGINTERN bool OGRGeometryShadow_Intersect(OGRGeometryShadow *self,OGRGeometryShadow *other){
+     return (OGR_G_Intersect(self, other) > 0);
+   }
+ SWIGINTERN bool OGRGeometryShadow_Equal(OGRGeometryShadow *self,OGRGeometryShadow *other){
+     return (OGR_G_Equal(self, other) > 0);
+   }
+ SWIGINTERN bool OGRGeometryShadow_Disjoint(OGRGeometryShadow *self,OGRGeometryShadow *other){
+     return (OGR_G_Disjoint(self, other) > 0);
+   }
+ SWIGINTERN bool OGRGeometryShadow_Touches(OGRGeometryShadow *self,OGRGeometryShadow *other){
+     return (OGR_G_Touches(self, other) > 0);
+   }
+ SWIGINTERN bool OGRGeometryShadow_Crosses(OGRGeometryShadow *self,OGRGeometryShadow *other){
+     return (OGR_G_Crosses(self, other) > 0);
+   }
+ SWIGINTERN bool OGRGeometryShadow_Within(OGRGeometryShadow *self,OGRGeometryShadow *other){
+     return (OGR_G_Within(self, other) > 0);
+   }
+ SWIGINTERN bool OGRGeometryShadow_Contains(OGRGeometryShadow *self,OGRGeometryShadow *other){
+     return (OGR_G_Contains(self, other) > 0);
+   }
+ SWIGINTERN bool OGRGeometryShadow_Overlaps(OGRGeometryShadow *self,OGRGeometryShadow *other){
+     return (OGR_G_Overlaps(self, other) > 0);
+   }
+ SWIGINTERN OGRErr OGRGeometryShadow_TransformTo(OGRGeometryShadow *self,OSRSpatialReferenceShadow *reference){
+     return OGR_G_TransformTo(self, reference);
+   }
+ SWIGINTERN OGRErr OGRGeometryShadow_Transform(OGRGeometryShadow *self,OSRCoordinateTransformationShadow *trans){
+     return OGR_G_Transform(self, trans);
+   }
+ SWIGINTERN OSRSpatialReferenceShadow *OGRGeometryShadow_GetSpatialReference(OGRGeometryShadow *self){
+     OGRSpatialReferenceH ref =  OGR_G_GetSpatialReference(self);
+     if( ref )
+         OSRReference(ref);
+     return (OSRSpatialReferenceShadow*) ref;
+   }
+ SWIGINTERN void OGRGeometryShadow_AssignSpatialReference(OGRGeometryShadow *self,OSRSpatialReferenceShadow *reference){
+     OGR_G_AssignSpatialReference(self, reference);
+   }
+ SWIGINTERN void OGRGeometryShadow_CloseRings(OGRGeometryShadow *self){
+     OGR_G_CloseRings(self);
+   }
+ SWIGINTERN void OGRGeometryShadow_FlattenTo2D(OGRGeometryShadow *self){
+     OGR_G_FlattenTo2D(self);
+   }
+ SWIGINTERN void OGRGeometryShadow_GetEnvelope(OGRGeometryShadow *self,double argout[4]){
+     OGR_G_GetEnvelope(self, (OGREnvelope*)argout);
+   }
+ SWIGINTERN OGRGeometryShadow *OGRGeometryShadow_Centroid(OGRGeometryShadow *self){
+     OGRGeometryShadow *pt = new_OGRGeometryShadow( wkbPoint );
+     OGR_G_Centroid( self, pt );
+     return pt;
+   }
+ SWIGINTERN int OGRGeometryShadow_WkbSize(OGRGeometryShadow *self){
+     return OGR_G_WkbSize(self);
+   }
+ SWIGINTERN int OGRGeometryShadow_GetCoordinateDimension(OGRGeometryShadow *self){
+     return OGR_G_GetCoordinateDimension(self);
+   }
+ SWIGINTERN void OGRGeometryShadow_SetCoordinateDimension(OGRGeometryShadow *self,int dimension){
+     OGR_G_SetCoordinateDimension(self, dimension);
+   }
+ SWIGINTERN int OGRGeometryShadow_GetDimension(OGRGeometryShadow *self){
+     return OGR_G_GetDimension(self);
+   }
+ 
+ char const *OGRDriverShadow_get_name( OGRDriverShadow *h ) {
+   return OGR_Dr_GetName( h );
+ }
+ 
+ char const *OGRDataSourceShadow_get_name( OGRDataSourceShadow *h ) {
+   return OGR_DS_GetName( h );
+ }
+ 
+ char const *OGRDriverShadow_name_get( OGRDriverShadow *h ) {
+   return OGR_Dr_GetName( h );
+ }
+ 
+ char const *OGRDataSourceShadow_name_get( OGRDataSourceShadow *h ) {
+   return OGR_DS_GetName( h );
+ }
+ 
+ 
+   OGRDataSourceShadow* GetOpenDS(int ds_number) {
+     OGRDataSourceShadow* layer = (OGRDataSourceShadow*) OGRGetOpenDS(ds_number);
+     return layer;
+   }
+ 
+ 
+   OGRDataSourceShadow* Open( const char *filename, int update =0 ) {
+     CPLErrorReset();
+     OGRDataSourceShadow* ds = (OGRDataSourceShadow*)OGROpen(filename,update,NULL);
+     if( CPLGetLastErrorType() == CE_Failure && ds != NULL )
+     {
+         CPLDebug( "SWIG", 
+ 		  "OGROpen() succeeded, but an error is posted, so we destroy"
+ 		  " the datasource and fail at swig level." );
+         OGRReleaseDataSource(ds);
+         ds = NULL;
+     }
+ 	
+     return ds;
+   }
+ 
+ 
+   OGRDataSourceShadow* OpenShared( const char *filename, int update =0 ) {
+     CPLErrorReset();
+     OGRDataSourceShadow* ds = (OGRDataSourceShadow*)OGROpenShared(filename,update,NULL);
+     if( CPLGetLastErrorType() == CE_Failure && ds != NULL )
+     {
+         OGRReleaseDataSource(ds);
+         ds = NULL;
+     }
+ 	
+     return ds;
+   }
+ 
+ 
+ OGRDriverShadow* GetDriverByName( char const *name ) {
+   return (OGRDriverShadow*) OGRGetDriverByName( name );
+ }
+ 
+ OGRDriverShadow* GetDriver(int driver_number) {
+   return (OGRDriverShadow*) OGRGetDriver(driver_number);
+ }
+ 
+ #ifdef __cplusplus
+ extern "C" {
+ #endif
+ SWIGINTERN int
+ _wrap_UseExceptions(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
+   if (SWIG_GetArgs(interp, objc, objv,":osgeo::UseExceptions ") == TCL_ERROR) SWIG_fail;
+   UseExceptions();
+   
+   return TCL_OK;
+ fail:
+   return TCL_ERROR;
+ }
+ 
+ 
+ SWIGINTERN int
+ _wrap_DontUseExceptions(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
+   if (SWIG_GetArgs(interp, objc, objv,":osgeo::DontUseExceptions ") == TCL_ERROR) SWIG_fail;
+   DontUseExceptions();
+   
+   return TCL_OK;
+ fail:
+   return TCL_ERROR;
+ }
+ 
+ 
+ SWIGINTERN int
+ _wrap_Driver_name_get(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
+   OGRDriverShadow *arg1 = (OGRDriverShadow *) 0 ;
+   void *argp1 = 0 ;
+   int res1 = 0 ;
+   char *result = 0 ;
+   
+   if (SWIG_GetArgs(interp, objc, objv,"o:osgeo::Driver_name_get self ",(void *)0) == TCL_ERROR) SWIG_fail;
+   res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_OGRDriverShadow, 0 |  0 );
+   if (!SWIG_IsOK(res1)) {
+     SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Driver_name_get" "', argument " "1"" of type '" "OGRDriverShadow *""'"); 
+   }
+   arg1 = reinterpret_cast< OGRDriverShadow * >(argp1);
+   {
+     CPLErrorReset();
+     result = (char *)OGRDriverShadow_name_get(arg1);
+     CPLErr eclass = CPLGetLastErrorType();
+     if ( eclass == CE_Failure || eclass == CE_Fatal ) {
+       SWIG_exception( SWIG_RuntimeError, CPLGetLastErrorMsg() );
+       
+     }
+     
+     
+     
+     
+     
+     
+     
+     
+     
+     
+     
+   }
+   Tcl_SetObjResult(interp,SWIG_FromCharPtr((const char *)result));
+   return TCL_OK;
+ fail:
+   return TCL_ERROR;
+ }
+ 
+ 
+ SWIGINTERN int
+ _wrap_Driver_CreateDataSource(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
+   OGRDriverShadow *arg1 = (OGRDriverShadow *) 0 ;
+   char *arg2 = (char *) 0 ;
+   char **arg3 = (char **) 0 ;
+   void *argp1 = 0 ;
+   int res1 = 0 ;
+   int res2 ;
+   char *buf2 = 0 ;
+   int alloc2 = 0 ;
+   OGRDataSourceShadow *result = 0 ;
+   
+   if (SWIG_GetArgs(interp, objc, objv,"oo|o:osgeo::Driver_CreateDataSource self name ?options? ",(void *)0,(void *)0,(void *)0) == TCL_ERROR) SWIG_fail;
+   res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_OGRDriverShadow, 0 |  0 );
+   if (!SWIG_IsOK(res1)) {
+     SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Driver_CreateDataSource" "', argument " "1"" of type '" "OGRDriverShadow *""'"); 
+   }
+   arg1 = reinterpret_cast< OGRDriverShadow * >(argp1);
+   res2 = SWIG_AsCharPtrAndSize(objv[2], &buf2, NULL, &alloc2);
+   if (!SWIG_IsOK(res2)) {
+     SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "Driver_CreateDataSource" "', argument " "2"" of type '" "char const *""'");
+   }
+   arg2 = reinterpret_cast< char * >(buf2);
+   if (objc > 3) {
+     {
+       /* %typemap(in) char **options */
+       int size;
+       if (Tcl_ListObjLength(interp, objv[3], &size) != TCL_OK) {
+         /* Error msg in interp result */
+         SWIG_fail;
+       }
+       if ( !size ) {
+         Tcl_SetResult(interp, (char*) "Input list mustn't be empty", TCL_STATIC);
+         SWIG_fail;
+       }
+       
+       for (int i = 0; i < size; i++) {
+         Tcl_Obj **o = NULL;
+         /* The reference count for the list element is not incremented with the following */
+         if (Tcl_ListObjIndex(interp, objv[3], i, o) != TCL_OK) {
+           /* Error msg in interp result */
+           SWIG_fail;
+         }
+         char *pszItem = Tcl_GetString(*o);
+         arg3 = CSLAddString( arg3, pszItem );
+       }
+     }
+   }
+   {
+     CPLErrorReset();
+     result = (OGRDataSourceShadow *)OGRDriverShadow_CreateDataSource(arg1,(char const *)arg2,arg3);
+     CPLErr eclass = CPLGetLastErrorType();
+     if ( eclass == CE_Failure || eclass == CE_Fatal ) {
+       SWIG_exception( SWIG_RuntimeError, CPLGetLastErrorMsg() );
+       
+     }
+     
+     
+     
+     
+     
+     
+     
+     
+     
+     
+     
+   }
+   Tcl_SetObjResult(interp, SWIG_NewInstanceObj( SWIG_as_voidptr(result), SWIGTYPE_p_OGRDataSourceShadow,0));
+   if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
+   {
+     /* %typemap(freearg) char **options */
+     CSLDestroy( arg3 );
+   }
+   return TCL_OK;
+ fail:
+   if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
+   {
+     /* %typemap(freearg) char **options */
+     CSLDestroy( arg3 );
+   }
+   return TCL_ERROR;
+ }
+ 
+ 
+ SWIGINTERN int
+ _wrap_Driver_CopyDataSource(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
+   OGRDriverShadow *arg1 = (OGRDriverShadow *) 0 ;
+   OGRDataSourceShadow *arg2 = (OGRDataSourceShadow *) 0 ;
+   char *arg3 = (char *) 0 ;
+   char **arg4 = (char **) 0 ;
+   void *argp1 = 0 ;
+   int res1 = 0 ;
+   void *argp2 = 0 ;
+   int res2 = 0 ;
+   int res3 ;
+   char *buf3 = 0 ;
+   int alloc3 = 0 ;
+   OGRDataSourceShadow *result = 0 ;
+   
+   if (SWIG_GetArgs(interp, objc, objv,"ooo|o:osgeo::Driver_CopyDataSource self copy_ds name ?options? ",(void *)0,(void *)0,(void *)0,(void *)0) == TCL_ERROR) SWIG_fail;
+   res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_OGRDriverShadow, 0 |  0 );
+   if (!SWIG_IsOK(res1)) {
+     SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Driver_CopyDataSource" "', argument " "1"" of type '" "OGRDriverShadow *""'"); 
+   }
+   arg1 = reinterpret_cast< OGRDriverShadow * >(argp1);
+   res2 = SWIG_ConvertPtr(objv[2], &argp2,SWIGTYPE_p_OGRDataSourceShadow, 0 |  0 );
+   if (!SWIG_IsOK(res2)) {
+     SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "Driver_CopyDataSource" "', argument " "2"" of type '" "OGRDataSourceShadow *""'"); 
+   }
+   arg2 = reinterpret_cast< OGRDataSourceShadow * >(argp2);
+   res3 = SWIG_AsCharPtrAndSize(objv[3], &buf3, NULL, &alloc3);
+   if (!SWIG_IsOK(res3)) {
+     SWIG_exception_fail(SWIG_ArgError(res3), "in method '" "Driver_CopyDataSource" "', argument " "3"" of type '" "char const *""'");
+   }
+   arg3 = reinterpret_cast< char * >(buf3);
+   if (objc > 4) {
+     {
+       /* %typemap(in) char **options */
+       int size;
+       if (Tcl_ListObjLength(interp, objv[4], &size) != TCL_OK) {
+         /* Error msg in interp result */
+         SWIG_fail;
+       }
+       if ( !size ) {
+         Tcl_SetResult(interp, (char*) "Input list mustn't be empty", TCL_STATIC);
+         SWIG_fail;
+       }
+       
+       for (int i = 0; i < size; i++) {
+         Tcl_Obj **o = NULL;
+         /* The reference count for the list element is not incremented with the following */
+         if (Tcl_ListObjIndex(interp, objv[4], i, o) != TCL_OK) {
+           /* Error msg in interp result */
+           SWIG_fail;
+         }
+         char *pszItem = Tcl_GetString(*o);
+         arg4 = CSLAddString( arg4, pszItem );
+       }
+     }
+   }
+   {
+     CPLErrorReset();
+     result = (OGRDataSourceShadow *)OGRDriverShadow_CopyDataSource(arg1,arg2,(char const *)arg3,arg4);
+     CPLErr eclass = CPLGetLastErrorType();
+     if ( eclass == CE_Failure || eclass == CE_Fatal ) {
+       SWIG_exception( SWIG_RuntimeError, CPLGetLastErrorMsg() );
+       
+     }
+     
+     
+     
+     
+     
+     
+     
+     
+     
+     
+     
+   }
+   Tcl_SetObjResult(interp, SWIG_NewInstanceObj( SWIG_as_voidptr(result), SWIGTYPE_p_OGRDataSourceShadow,0));
+   if (alloc3 == SWIG_NEWOBJ) delete[] buf3;
+   {
+     /* %typemap(freearg) char **options */
+     CSLDestroy( arg4 );
+   }
+   return TCL_OK;
+ fail:
+   if (alloc3 == SWIG_NEWOBJ) delete[] buf3;
+   {
+     /* %typemap(freearg) char **options */
+     CSLDestroy( arg4 );
+   }
+   return TCL_ERROR;
+ }
+ 
+ 
+ SWIGINTERN int
+ _wrap_Driver_Open(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
+   OGRDriverShadow *arg1 = (OGRDriverShadow *) 0 ;
+   char *arg2 = (char *) 0 ;
+   int arg3 = (int) 0 ;
+   void *argp1 = 0 ;
+   int res1 = 0 ;
+   int res2 ;
+   char *buf2 = 0 ;
+   int alloc2 = 0 ;
+   int val3 ;
+   int ecode3 = 0 ;
+   OGRDataSourceShadow *result = 0 ;
+   
+   if (SWIG_GetArgs(interp, objc, objv,"oo|o:osgeo::Driver_Open self name ?update? ",(void *)0,(void *)0,(void *)0) == TCL_ERROR) SWIG_fail;
+   res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_OGRDriverShadow, 0 |  0 );
+   if (!SWIG_IsOK(res1)) {
+     SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Driver_Open" "', argument " "1"" of type '" "OGRDriverShadow *""'"); 
+   }
+   arg1 = reinterpret_cast< OGRDriverShadow * >(argp1);
+   res2 = SWIG_AsCharPtrAndSize(objv[2], &buf2, NULL, &alloc2);
+   if (!SWIG_IsOK(res2)) {
+     SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "Driver_Open" "', argument " "2"" of type '" "char const *""'");
+   }
+   arg2 = reinterpret_cast< char * >(buf2);
+   if (objc > 3) {
+     ecode3 = SWIG_AsVal_int SWIG_TCL_CALL_ARGS_2(objv[3], &val3);
+     if (!SWIG_IsOK(ecode3)) {
+       SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "Driver_Open" "', argument " "3"" of type '" "int""'");
+     } 
+     arg3 = static_cast< int >(val3);
+   }
+   {
+     CPLErrorReset();
+     result = (OGRDataSourceShadow *)OGRDriverShadow_Open(arg1,(char const *)arg2,arg3);
+     CPLErr eclass = CPLGetLastErrorType();
+     if ( eclass == CE_Failure || eclass == CE_Fatal ) {
+       SWIG_exception( SWIG_RuntimeError, CPLGetLastErrorMsg() );
+       
+     }
+     
+     
+     
+     
+     
+     
+     
+     
+     
+     
+     
+   }
+   Tcl_SetObjResult(interp, SWIG_NewInstanceObj( SWIG_as_voidptr(result), SWIGTYPE_p_OGRDataSourceShadow,0));
+   if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
+   return TCL_OK;
+ fail:
+   if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
+   return TCL_ERROR;
+ }
+ 
+ 
+ SWIGINTERN int
+ _wrap_Driver_DeleteDataSource(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
+   OGRDriverShadow *arg1 = (OGRDriverShadow *) 0 ;
+   char *arg2 = (char *) 0 ;
+   void *argp1 = 0 ;
+   int res1 = 0 ;
+   int res2 ;
+   char *buf2 = 0 ;
+   int alloc2 = 0 ;
+   int result;
+   
+   if (SWIG_GetArgs(interp, objc, objv,"oo:osgeo::Driver_DeleteDataSource self name ",(void *)0,(void *)0) == TCL_ERROR) SWIG_fail;
+   res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_OGRDriverShadow, 0 |  0 );
+   if (!SWIG_IsOK(res1)) {
+     SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Driver_DeleteDataSource" "', argument " "1"" of type '" "OGRDriverShadow *""'"); 
+   }
+   arg1 = reinterpret_cast< OGRDriverShadow * >(argp1);
+   res2 = SWIG_AsCharPtrAndSize(objv[2], &buf2, NULL, &alloc2);
+   if (!SWIG_IsOK(res2)) {
+     SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "Driver_DeleteDataSource" "', argument " "2"" of type '" "char const *""'");
+   }
+   arg2 = reinterpret_cast< char * >(buf2);
+   {
+     CPLErrorReset();
+     result = (int)OGRDriverShadow_DeleteDataSource(arg1,(char const *)arg2);
+     CPLErr eclass = CPLGetLastErrorType();
+     if ( eclass == CE_Failure || eclass == CE_Fatal ) {
+       SWIG_exception( SWIG_RuntimeError, CPLGetLastErrorMsg() );
+       
+     }
+     
+     
+     
+     
+     
+     
+     
+     
+     
+     
+     
+   }
+   Tcl_SetObjResult(interp,SWIG_From_int(static_cast< int >(result)));
+   if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
+   return TCL_OK;
+ fail:
+   if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
+   return TCL_ERROR;
+ }
+ 
+ 
+ SWIGINTERN int
+ _wrap_Driver_TestCapability(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
+   OGRDriverShadow *arg1 = (OGRDriverShadow *) 0 ;
+   char *arg2 = (char *) 0 ;
+   void *argp1 = 0 ;
+   int res1 = 0 ;
+   int res2 ;
+   char *buf2 = 0 ;
+   int alloc2 = 0 ;
+   bool result;
+   
+   if (SWIG_GetArgs(interp, objc, objv,"oo:osgeo::Driver_TestCapability self cap ",(void *)0,(void *)0) == TCL_ERROR) SWIG_fail;
+   res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_OGRDriverShadow, 0 |  0 );
+   if (!SWIG_IsOK(res1)) {
+     SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Driver_TestCapability" "', argument " "1"" of type '" "OGRDriverShadow *""'"); 
+   }
+   arg1 = reinterpret_cast< OGRDriverShadow * >(argp1);
+   res2 = SWIG_AsCharPtrAndSize(objv[2], &buf2, NULL, &alloc2);
+   if (!SWIG_IsOK(res2)) {
+     SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "Driver_TestCapability" "', argument " "2"" of type '" "char const *""'");
+   }
+   arg2 = reinterpret_cast< char * >(buf2);
+   {
+     CPLErrorReset();
+     result = (bool)OGRDriverShadow_TestCapability(arg1,(char const *)arg2);
+     CPLErr eclass = CPLGetLastErrorType();
+     if ( eclass == CE_Failure || eclass == CE_Fatal ) {
+       SWIG_exception( SWIG_RuntimeError, CPLGetLastErrorMsg() );
+       
+     }
+     
+     
+     
+     
+     
+     
+     
+     
+     
+     
+     
+   }
+   Tcl_SetObjResult(interp,SWIG_From_bool(static_cast< bool >(result)));
+   if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
+   return TCL_OK;
+ fail:
+   if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
+   return TCL_ERROR;
+ }
+ 
+ 
+ SWIGINTERN int
+ _wrap_Driver_GetName(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
+   OGRDriverShadow *arg1 = (OGRDriverShadow *) 0 ;
+   void *argp1 = 0 ;
+   int res1 = 0 ;
+   char *result = 0 ;
+   
+   if (SWIG_GetArgs(interp, objc, objv,"o:osgeo::Driver_GetName self ",(void *)0) == TCL_ERROR) SWIG_fail;
+   res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_OGRDriverShadow, 0 |  0 );
+   if (!SWIG_IsOK(res1)) {
+     SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Driver_GetName" "', argument " "1"" of type '" "OGRDriverShadow *""'"); 
+   }
+   arg1 = reinterpret_cast< OGRDriverShadow * >(argp1);
+   {
+     CPLErrorReset();
+     result = (char *)OGRDriverShadow_GetName(arg1);
+     CPLErr eclass = CPLGetLastErrorType();
+     if ( eclass == CE_Failure || eclass == CE_Fatal ) {
+       SWIG_exception( SWIG_RuntimeError, CPLGetLastErrorMsg() );
+       
+     }
+     
+     
+     
+     
+     
+     
+     
+     
+     
+     
+     
+   }
+   Tcl_SetObjResult(interp,SWIG_FromCharPtr((const char *)result));
+   return TCL_OK;
+ fail:
+   return TCL_ERROR;
+ }
+ 
+ 
+ static swig_method swig_OGRDriverShadow_methods[] = {
+     {"CreateDataSource", _wrap_Driver_CreateDataSource}, 
+     {"CopyDataSource", _wrap_Driver_CopyDataSource}, 
+     {"Open", _wrap_Driver_Open}, 
+     {"DeleteDataSource", _wrap_Driver_DeleteDataSource}, 
+     {"TestCapability", _wrap_Driver_TestCapability}, 
+     {"GetName", _wrap_Driver_GetName}, 
+     {0,0}
+ };
+ static swig_attribute swig_OGRDriverShadow_attributes[] = {
+     { "-name",_wrap_Driver_name_get, 0 },
+     {0,0,0}
+ };
+ static swig_class *swig_OGRDriverShadow_bases[] = {0};
+ static const char * swig_OGRDriverShadow_base_names[] = {0};
+ static swig_class _wrap_class_OGRDriverShadow = { "Driver", &SWIGTYPE_p_OGRDriverShadow,0,0, swig_OGRDriverShadow_methods, swig_OGRDriverShadow_attributes, swig_OGRDriverShadow_bases,swig_OGRDriverShadow_base_names, &swig_module };
+ SWIGINTERN int
+ _wrap_DataSource_name_get(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
+   OGRDataSourceShadow *arg1 = (OGRDataSourceShadow *) 0 ;
+   void *argp1 = 0 ;
+   int res1 = 0 ;
+   char *result = 0 ;
+   
+   if (SWIG_GetArgs(interp, objc, objv,"o:osgeo::DataSource_name_get self ",(void *)0) == TCL_ERROR) SWIG_fail;
+   res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_OGRDataSourceShadow, 0 |  0 );
+   if (!SWIG_IsOK(res1)) {
+     SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "DataSource_name_get" "', argument " "1"" of type '" "OGRDataSourceShadow *""'"); 
+   }
+   arg1 = reinterpret_cast< OGRDataSourceShadow * >(argp1);
+   {
+     CPLErrorReset();
+     result = (char *)OGRDataSourceShadow_name_get(arg1);
+     CPLErr eclass = CPLGetLastErrorType();
+     if ( eclass == CE_Failure || eclass == CE_Fatal ) {
+       SWIG_exception( SWIG_RuntimeError, CPLGetLastErrorMsg() );
+       
+     }
+     
+     
+     
+     
+     
+     
+     
+     
+     
+     
+     
+   }
+   Tcl_SetObjResult(interp,SWIG_FromCharPtr((const char *)result));
+   return TCL_OK;
+ fail:
+   return TCL_ERROR;
+ }
+ 
+ 
+ SWIGINTERN int
+ _wrap_delete_DataSource(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
+   OGRDataSourceShadow *arg1 = (OGRDataSourceShadow *) 0 ;
+   void *argp1 = 0 ;
+   int res1 = 0 ;
+   
+   if (SWIG_GetArgs(interp, objc, objv,"o:osgeo::delete_DataSource self ",(void *)0) == TCL_ERROR) SWIG_fail;
+   res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_OGRDataSourceShadow, SWIG_POINTER_DISOWN |  0 );
+   if (!SWIG_IsOK(res1)) {
+     SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "delete_DataSource" "', argument " "1"" of type '" "OGRDataSourceShadow *""'"); 
+   }
+   arg1 = reinterpret_cast< OGRDataSourceShadow * >(argp1);
+   {
+     CPLErrorReset();
+     delete_OGRDataSourceShadow(arg1);
+     CPLErr eclass = CPLGetLastErrorType();
+     if ( eclass == CE_Failure || eclass == CE_Fatal ) {
+       SWIG_exception( SWIG_RuntimeError, CPLGetLastErrorMsg() );
+       
+     }
+     
+     
+     
+     
+     
+     
+     
+     
+     
+     
+     
+   }
+   
+   return TCL_OK;
+ fail:
+   return TCL_ERROR;
+ }
+ 
+ 
+ SWIGINTERN int
+ _wrap_DataSource_GetRefCount(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
+   OGRDataSourceShadow *arg1 = (OGRDataSourceShadow *) 0 ;
+   void *argp1 = 0 ;
+   int res1 = 0 ;
+   int result;
+   
+   if (SWIG_GetArgs(interp, objc, objv,"o:osgeo::DataSource_GetRefCount self ",(void *)0) == TCL_ERROR) SWIG_fail;
+   res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_OGRDataSourceShadow, 0 |  0 );
+   if (!SWIG_IsOK(res1)) {
+     SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "DataSource_GetRefCount" "', argument " "1"" of type '" "OGRDataSourceShadow *""'"); 
+   }
+   arg1 = reinterpret_cast< OGRDataSourceShadow * >(argp1);
+   {
+     CPLErrorReset();
+     result = (int)OGRDataSourceShadow_GetRefCount(arg1);
+     CPLErr eclass = CPLGetLastErrorType();
+     if ( eclass == CE_Failure || eclass == CE_Fatal ) {
+       SWIG_exception( SWIG_RuntimeError, CPLGetLastErrorMsg() );
+       
+     }
+     
+     
+     
+     
+     
+     
+     
+     
+     
+     
+     
+   }
+   Tcl_SetObjResult(interp,SWIG_From_int(static_cast< int >(result)));
+   return TCL_OK;
+ fail:
+   return TCL_ERROR;
+ }
+ 
+ 
+ SWIGINTERN int
+ _wrap_DataSource_GetSummaryRefCount(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
+   OGRDataSourceShadow *arg1 = (OGRDataSourceShadow *) 0 ;
+   void *argp1 = 0 ;
+   int res1 = 0 ;
+   int result;
+   
+   if (SWIG_GetArgs(interp, objc, objv,"o:osgeo::DataSource_GetSummaryRefCount self ",(void *)0) == TCL_ERROR) SWIG_fail;
+   res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_OGRDataSourceShadow, 0 |  0 );
+   if (!SWIG_IsOK(res1)) {
+     SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "DataSource_GetSummaryRefCount" "', argument " "1"" of type '" "OGRDataSourceShadow *""'"); 
+   }
+   arg1 = reinterpret_cast< OGRDataSourceShadow * >(argp1);
+   {
+     CPLErrorReset();
+     result = (int)OGRDataSourceShadow_GetSummaryRefCount(arg1);
+     CPLErr eclass = CPLGetLastErrorType();
+     if ( eclass == CE_Failure || eclass == CE_Fatal ) {
+       SWIG_exception( SWIG_RuntimeError, CPLGetLastErrorMsg() );
+       
+     }
+     
+     
+     
+     
+     
+     
+     
+     
+     
+     
+     
+   }
+   Tcl_SetObjResult(interp,SWIG_From_int(static_cast< int >(result)));
+   return TCL_OK;
+ fail:
+   return TCL_ERROR;
+ }
+ 
+ 
+ SWIGINTERN int
+ _wrap_DataSource_GetLayerCount(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
+   OGRDataSourceShadow *arg1 = (OGRDataSourceShadow *) 0 ;
+   void *argp1 = 0 ;
+   int res1 = 0 ;
+   int result;
+   
+   if (SWIG_GetArgs(interp, objc, objv,"o:osgeo::DataSource_GetLayerCount self ",(void *)0) == TCL_ERROR) SWIG_fail;
+   res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_OGRDataSourceShadow, 0 |  0 );
+   if (!SWIG_IsOK(res1)) {
+     SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "DataSource_GetLayerCount" "', argument " "1"" of type '" "OGRDataSourceShadow *""'"); 
+   }
+   arg1 = reinterpret_cast< OGRDataSourceShadow * >(argp1);
+   {
+     CPLErrorReset();
+     result = (int)OGRDataSourceShadow_GetLayerCount(arg1);
+     CPLErr eclass = CPLGetLastErrorType();
+     if ( eclass == CE_Failure || eclass == CE_Fatal ) {
+       SWIG_exception( SWIG_RuntimeError, CPLGetLastErrorMsg() );
+       
+     }
+     
+     
+     
+     
+     
+     
+     
+     
+     
+     
+     
+   }
+   Tcl_SetObjResult(interp,SWIG_From_int(static_cast< int >(result)));
+   return TCL_OK;
+ fail:
+   return TCL_ERROR;
+ }
+ 
+ 
+ SWIGINTERN int
+ _wrap_DataSource_GetDriver(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
+   OGRDataSourceShadow *arg1 = (OGRDataSourceShadow *) 0 ;
+   void *argp1 = 0 ;
+   int res1 = 0 ;
+   OGRDriverShadow *result = 0 ;
+   
+   if (SWIG_GetArgs(interp, objc, objv,"o:osgeo::DataSource_GetDriver self ",(void *)0) == TCL_ERROR) SWIG_fail;
+   res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_OGRDataSourceShadow, 0 |  0 );
+   if (!SWIG_IsOK(res1)) {
+     SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "DataSource_GetDriver" "', argument " "1"" of type '" "OGRDataSourceShadow *""'"); 
+   }
+   arg1 = reinterpret_cast< OGRDataSourceShadow * >(argp1);
+   {
+     CPLErrorReset();
+     result = (OGRDriverShadow *)OGRDataSourceShadow_GetDriver(arg1);
+     CPLErr eclass = CPLGetLastErrorType();
+     if ( eclass == CE_Failure || eclass == CE_Fatal ) {
+       SWIG_exception( SWIG_RuntimeError, CPLGetLastErrorMsg() );
+       
+     }
+     
+     
+     
+     
+     
+     
+     
+     
+     
+     
+     
+   }
+   Tcl_SetObjResult(interp, SWIG_NewInstanceObj( SWIG_as_voidptr(result), SWIGTYPE_p_OGRDriverShadow,0));
+   return TCL_OK;
+ fail:
+   return TCL_ERROR;
+ }
+ 
+ 
+ SWIGINTERN int
+ _wrap_DataSource_GetName(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
+   OGRDataSourceShadow *arg1 = (OGRDataSourceShadow *) 0 ;
+   void *argp1 = 0 ;
+   int res1 = 0 ;
+   char *result = 0 ;
+   
+   if (SWIG_GetArgs(interp, objc, objv,"o:osgeo::DataSource_GetName self ",(void *)0) == TCL_ERROR) SWIG_fail;
+   res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_OGRDataSourceShadow, 0 |  0 );
+   if (!SWIG_IsOK(res1)) {
+     SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "DataSource_GetName" "', argument " "1"" of type '" "OGRDataSourceShadow *""'"); 
+   }
+   arg1 = reinterpret_cast< OGRDataSourceShadow * >(argp1);
+   {
+     CPLErrorReset();
+     result = (char *)OGRDataSourceShadow_GetName(arg1);
+     CPLErr eclass = CPLGetLastErrorType();
+     if ( eclass == CE_Failure || eclass == CE_Fatal ) {
+       SWIG_exception( SWIG_RuntimeError, CPLGetLastErrorMsg() );
+       
+     }
+     
+     
+     
+     
+     
+     
+     
+     
+     
+     
+     
+   }
+   Tcl_SetObjResult(interp,SWIG_FromCharPtr((const char *)result));
+   return TCL_OK;
+ fail:
+   return TCL_ERROR;
+ }
+ 
+ 
+ SWIGINTERN int
+ _wrap_DataSource_DeleteLayer(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
+   OGRDataSourceShadow *arg1 = (OGRDataSourceShadow *) 0 ;
+   int arg2 ;
+   void *argp1 = 0 ;
+   int res1 = 0 ;
+   int val2 ;
+   int ecode2 = 0 ;
+   OGRErr result;
+   
+   if (SWIG_GetArgs(interp, objc, objv,"oo:osgeo::DataSource_DeleteLayer self index ",(void *)0,(void *)0) == TCL_ERROR) SWIG_fail;
+   res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_OGRDataSourceShadow, 0 |  0 );
+   if (!SWIG_IsOK(res1)) {
+     SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "DataSource_DeleteLayer" "', argument " "1"" of type '" "OGRDataSourceShadow *""'"); 
+   }
+   arg1 = reinterpret_cast< OGRDataSourceShadow * >(argp1);
+   ecode2 = SWIG_AsVal_int SWIG_TCL_CALL_ARGS_2(objv[2], &val2);
+   if (!SWIG_IsOK(ecode2)) {
+     SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "DataSource_DeleteLayer" "', argument " "2"" of type '" "int""'");
+   } 
+   arg2 = static_cast< int >(val2);
+   {
+     CPLErrorReset();
+     result = (OGRErr)OGRDataSourceShadow_DeleteLayer(arg1,arg2);
+     CPLErr eclass = CPLGetLastErrorType();
+     if ( eclass == CE_Failure || eclass == CE_Fatal ) {
+       SWIG_exception( SWIG_RuntimeError, CPLGetLastErrorMsg() );
+       
+     }
+     
+     
+     
+     
+     
+     
+     
+     
+     
+     
+     
+   }
+   {
+     /* %typemap(out) OGRErr */
+     if (result != 0) {
+       Tcl_SetResult(interp, (char*) OGRErrMessages(result), TCL_STATIC);
+       SWIG_fail;
+     }
+   }
+   {
+     /* %typemap(ret) OGRErr */
+     if (!strcmp(Tcl_GetStringResult(interp), "{}") || !strcmp(Tcl_GetStringResult(interp), "")) {
+       Tcl_SetObjResult(interp, Tcl_NewLongObj( result ));
+     }
+   }
+   return TCL_OK;
+ fail:
+   return TCL_ERROR;
+ }
+ 
+ 
+ SWIGINTERN int
+ _wrap_DataSource_CreateLayer(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
+   OGRDataSourceShadow *arg1 = (OGRDataSourceShadow *) 0 ;
+   char *arg2 = (char *) 0 ;
+   OSRSpatialReferenceShadow *arg3 = (OSRSpatialReferenceShadow *) NULL ;
+   OGRwkbGeometryType arg4 = (OGRwkbGeometryType) wkbUnknown ;
+   char **arg5 = (char **) 0 ;
+   void *argp1 = 0 ;
+   int res1 = 0 ;
+   int res2 ;
+   char *buf2 = 0 ;
+   int alloc2 = 0 ;
+   void *argp3 = 0 ;
+   int res3 = 0 ;
+   int val4 ;
+   int ecode4 = 0 ;
+   OGRLayerShadow *result = 0 ;
+   
+   if (SWIG_GetArgs(interp, objc, objv,"oo|ooo:osgeo::DataSource_CreateLayer self name ?srs? ?geom_type? ?options? ",(void *)0,(void *)0,(void *)0,(void *)0,(void *)0) == TCL_ERROR) SWIG_fail;
+   res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_OGRDataSourceShadow, 0 |  0 );
+   if (!SWIG_IsOK(res1)) {
+     SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "DataSource_CreateLayer" "', argument " "1"" of type '" "OGRDataSourceShadow *""'"); 
+   }
+   arg1 = reinterpret_cast< OGRDataSourceShadow * >(argp1);
+   res2 = SWIG_AsCharPtrAndSize(objv[2], &buf2, NULL, &alloc2);
+   if (!SWIG_IsOK(res2)) {
+     SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "DataSource_CreateLayer" "', argument " "2"" of type '" "char const *""'");
+   }
+   arg2 = reinterpret_cast< char * >(buf2);
+   if (objc > 3) {
+     res3 = SWIG_ConvertPtr(objv[3], &argp3,SWIGTYPE_p_OSRSpatialReferenceShadow, 0 |  0 );
+     if (!SWIG_IsOK(res3)) {
+       SWIG_exception_fail(SWIG_ArgError(res3), "in method '" "DataSource_CreateLayer" "', argument " "3"" of type '" "OSRSpatialReferenceShadow *""'"); 
+     }
+     arg3 = reinterpret_cast< OSRSpatialReferenceShadow * >(argp3);
+   }
+   if (objc > 4) {
+     ecode4 = SWIG_AsVal_int SWIG_TCL_CALL_ARGS_2(objv[4], &val4);
+     if (!SWIG_IsOK(ecode4)) {
+       SWIG_exception_fail(SWIG_ArgError(ecode4), "in method '" "DataSource_CreateLayer" "', argument " "4"" of type '" "OGRwkbGeometryType""'");
+     } 
+     arg4 = static_cast< OGRwkbGeometryType >(val4);
+   }
+   if (objc > 5) {
+     {
+       /* %typemap(in) char **options */
+       int size;
+       if (Tcl_ListObjLength(interp, objv[5], &size) != TCL_OK) {
+         /* Error msg in interp result */
+         SWIG_fail;
+       }
+       if ( !size ) {
+         Tcl_SetResult(interp, (char*) "Input list mustn't be empty", TCL_STATIC);
+         SWIG_fail;
+       }
+       
+       for (int i = 0; i < size; i++) {
+         Tcl_Obj **o = NULL;
+         /* The reference count for the list element is not incremented with the following */
+         if (Tcl_ListObjIndex(interp, objv[5], i, o) != TCL_OK) {
+           /* Error msg in interp result */
+           SWIG_fail;
+         }
+         char *pszItem = Tcl_GetString(*o);
+         arg5 = CSLAddString( arg5, pszItem );
+       }
+     }
+   }
+   {
+     CPLErrorReset();
+     result = (OGRLayerShadow *)OGRDataSourceShadow_CreateLayer(arg1,(char const *)arg2,arg3,arg4,arg5);
+     CPLErr eclass = CPLGetLastErrorType();
+     if ( eclass == CE_Failure || eclass == CE_Fatal ) {
+       SWIG_exception( SWIG_RuntimeError, CPLGetLastErrorMsg() );
+       
+     }
+     
+     
+     
+     
+     
+     
+     
+     
+     
+     
+     
+   }
+   Tcl_SetObjResult(interp, SWIG_NewInstanceObj( SWIG_as_voidptr(result), SWIGTYPE_p_OGRLayerShadow,0));
+   if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
+   {
+     /* %typemap(freearg) char **options */
+     CSLDestroy( arg5 );
+   }
+   return TCL_OK;
+ fail:
+   if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
+   {
+     /* %typemap(freearg) char **options */
+     CSLDestroy( arg5 );
+   }
+   return TCL_ERROR;
+ }
+ 
+ 
+ SWIGINTERN int
+ _wrap_DataSource_CopyLayer(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
+   OGRDataSourceShadow *arg1 = (OGRDataSourceShadow *) 0 ;
+   OGRLayerShadow *arg2 = (OGRLayerShadow *) 0 ;
+   char *arg3 = (char *) 0 ;
+   char **arg4 = (char **) 0 ;
+   void *argp1 = 0 ;
+   int res1 = 0 ;
+   void *argp2 = 0 ;
+   int res2 = 0 ;
+   int res3 ;
+   char *buf3 = 0 ;
+   int alloc3 = 0 ;
+   OGRLayerShadow *result = 0 ;
+   
+   if (SWIG_GetArgs(interp, objc, objv,"ooo|o:osgeo::DataSource_CopyLayer self src_layer new_name ?options? ",(void *)0,(void *)0,(void *)0,(void *)0) == TCL_ERROR) SWIG_fail;
+   res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_OGRDataSourceShadow, 0 |  0 );
+   if (!SWIG_IsOK(res1)) {
+     SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "DataSource_CopyLayer" "', argument " "1"" of type '" "OGRDataSourceShadow *""'"); 
+   }
+   arg1 = reinterpret_cast< OGRDataSourceShadow * >(argp1);
+   res2 = SWIG_ConvertPtr(objv[2], &argp2,SWIGTYPE_p_OGRLayerShadow, 0 |  0 );
+   if (!SWIG_IsOK(res2)) {
+     SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "DataSource_CopyLayer" "', argument " "2"" of type '" "OGRLayerShadow *""'"); 
+   }
+   arg2 = reinterpret_cast< OGRLayerShadow * >(argp2);
+   res3 = SWIG_AsCharPtrAndSize(objv[3], &buf3, NULL, &alloc3);
+   if (!SWIG_IsOK(res3)) {
+     SWIG_exception_fail(SWIG_ArgError(res3), "in method '" "DataSource_CopyLayer" "', argument " "3"" of type '" "char const *""'");
+   }
+   arg3 = reinterpret_cast< char * >(buf3);
+   if (objc > 4) {
+     {
+       /* %typemap(in) char **options */
+       int size;
+       if (Tcl_ListObjLength(interp, objv[4], &size) != TCL_OK) {
+         /* Error msg in interp result */
+         SWIG_fail;
+       }
+       if ( !size ) {
+         Tcl_SetResult(interp, (char*) "Input list mustn't be empty", TCL_STATIC);
+         SWIG_fail;
+       }
+       
+       for (int i = 0; i < size; i++) {
+         Tcl_Obj **o = NULL;
+         /* The reference count for the list element is not incremented with the following */
+         if (Tcl_ListObjIndex(interp, objv[4], i, o) != TCL_OK) {
+           /* Error msg in interp result */
+           SWIG_fail;
+         }
+         char *pszItem = Tcl_GetString(*o);
+         arg4 = CSLAddString( arg4, pszItem );
+       }
+     }
+   }
+   {
+     CPLErrorReset();
+     result = (OGRLayerShadow *)OGRDataSourceShadow_CopyLayer(arg1,arg2,(char const *)arg3,arg4);
+     CPLErr eclass = CPLGetLastErrorType();
+     if ( eclass == CE_Failure || eclass == CE_Fatal ) {
+       SWIG_exception( SWIG_RuntimeError, CPLGetLastErrorMsg() );
+       
+     }
+     
+     
+     
+     
+     
+     
+     
+     
+     
+     
+     
+   }
+   Tcl_SetObjResult(interp, SWIG_NewInstanceObj( SWIG_as_voidptr(result), SWIGTYPE_p_OGRLayerShadow,0));
+   if (alloc3 == SWIG_NEWOBJ) delete[] buf3;
+   {
+     /* %typemap(freearg) char **options */
+     CSLDestroy( arg4 );
+   }
+   return TCL_OK;
+ fail:
+   if (alloc3 == SWIG_NEWOBJ) delete[] buf3;
+   {
+     /* %typemap(freearg) char **options */
+     CSLDestroy( arg4 );
+   }
+   return TCL_ERROR;
+ }
+ 
+ 
+ SWIGINTERN int
+ _wrap_DataSource_GetLayerByIndex(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
+   OGRDataSourceShadow *arg1 = (OGRDataSourceShadow *) 0 ;
+   int arg2 = (int) 0 ;
+   void *argp1 = 0 ;
+   int res1 = 0 ;
+   int val2 ;
+   int ecode2 = 0 ;
+   OGRLayerShadow *result = 0 ;
+   
+   if (SWIG_GetArgs(interp, objc, objv,"o|o:osgeo::DataSource_GetLayerByIndex self ?index? ",(void *)0,(void *)0) == TCL_ERROR) SWIG_fail;
+   res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_OGRDataSourceShadow, 0 |  0 );
+   if (!SWIG_IsOK(res1)) {
+     SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "DataSource_GetLayerByIndex" "', argument " "1"" of type '" "OGRDataSourceShadow *""'"); 
+   }
+   arg1 = reinterpret_cast< OGRDataSourceShadow * >(argp1);
+   if (objc > 2) {
+     ecode2 = SWIG_AsVal_int SWIG_TCL_CALL_ARGS_2(objv[2], &val2);
+     if (!SWIG_IsOK(ecode2)) {
+       SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "DataSource_GetLayerByIndex" "', argument " "2"" of type '" "int""'");
+     } 
+     arg2 = static_cast< int >(val2);
+   }
+   {
+     CPLErrorReset();
+     result = (OGRLayerShadow *)OGRDataSourceShadow_GetLayerByIndex(arg1,arg2);
+     CPLErr eclass = CPLGetLastErrorType();
+     if ( eclass == CE_Failure || eclass == CE_Fatal ) {
+       SWIG_exception( SWIG_RuntimeError, CPLGetLastErrorMsg() );
+       
+     }
+     
+     
+     
+     
+     
+     
+     
+     
+     
+     
+     
+   }
+   Tcl_SetObjResult(interp, SWIG_NewInstanceObj( SWIG_as_voidptr(result), SWIGTYPE_p_OGRLayerShadow,0));
+   return TCL_OK;
+ fail:
+   return TCL_ERROR;
+ }
+ 
+ 
+ SWIGINTERN int
+ _wrap_DataSource_GetLayerByName(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
+   OGRDataSourceShadow *arg1 = (OGRDataSourceShadow *) 0 ;
+   char *arg2 = (char *) 0 ;
+   void *argp1 = 0 ;
+   int res1 = 0 ;
+   int res2 ;
+   char *buf2 = 0 ;
+   int alloc2 = 0 ;
+   OGRLayerShadow *result = 0 ;
+   
+   if (SWIG_GetArgs(interp, objc, objv,"oo:osgeo::DataSource_GetLayerByName self layer_name ",(void *)0,(void *)0) == TCL_ERROR) SWIG_fail;
+   res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_OGRDataSourceShadow, 0 |  0 );
+   if (!SWIG_IsOK(res1)) {
+     SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "DataSource_GetLayerByName" "', argument " "1"" of type '" "OGRDataSourceShadow *""'"); 
+   }
+   arg1 = reinterpret_cast< OGRDataSourceShadow * >(argp1);
+   res2 = SWIG_AsCharPtrAndSize(objv[2], &buf2, NULL, &alloc2);
+   if (!SWIG_IsOK(res2)) {
+     SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "DataSource_GetLayerByName" "', argument " "2"" of type '" "char const *""'");
+   }
+   arg2 = reinterpret_cast< char * >(buf2);
+   {
+     CPLErrorReset();
+     result = (OGRLayerShadow *)OGRDataSourceShadow_GetLayerByName(arg1,(char const *)arg2);
+     CPLErr eclass = CPLGetLastErrorType();
+     if ( eclass == CE_Failure || eclass == CE_Fatal ) {
+       SWIG_exception( SWIG_RuntimeError, CPLGetLastErrorMsg() );
+       
+     }
+     
+     
+     
+     
+     
+     
+     
+     
+     
+     
+     
+   }
+   Tcl_SetObjResult(interp, SWIG_NewInstanceObj( SWIG_as_voidptr(result), SWIGTYPE_p_OGRLayerShadow,0));
+   if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
+   return TCL_OK;
+ fail:
+   if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
+   return TCL_ERROR;
+ }
+ 
+ 
+ SWIGINTERN int
+ _wrap_DataSource_TestCapability(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
+   OGRDataSourceShadow *arg1 = (OGRDataSourceShadow *) 0 ;
+   char *arg2 = (char *) 0 ;
+   void *argp1 = 0 ;
+   int res1 = 0 ;
+   int res2 ;
+   char *buf2 = 0 ;
+   int alloc2 = 0 ;
+   bool result;
+   
+   if (SWIG_GetArgs(interp, objc, objv,"oo:osgeo::DataSource_TestCapability self cap ",(void *)0,(void *)0) == TCL_ERROR) SWIG_fail;
+   res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_OGRDataSourceShadow, 0 |  0 );
+   if (!SWIG_IsOK(res1)) {
+     SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "DataSource_TestCapability" "', argument " "1"" of type '" "OGRDataSourceShadow *""'"); 
+   }
+   arg1 = reinterpret_cast< OGRDataSourceShadow * >(argp1);
+   res2 = SWIG_AsCharPtrAndSize(objv[2], &buf2, NULL, &alloc2);
+   if (!SWIG_IsOK(res2)) {
+     SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "DataSource_TestCapability" "', argument " "2"" of type '" "char const *""'");
+   }
+   arg2 = reinterpret_cast< char * >(buf2);
+   {
+     CPLErrorReset();
+     result = (bool)OGRDataSourceShadow_TestCapability(arg1,(char const *)arg2);
+     CPLErr eclass = CPLGetLastErrorType();
+     if ( eclass == CE_Failure || eclass == CE_Fatal ) {
+       SWIG_exception( SWIG_RuntimeError, CPLGetLastErrorMsg() );
+       
+     }
+     
+     
+     
+     
+     
+     
+     
+     
+     
+     
+     
+   }
+   Tcl_SetObjResult(interp,SWIG_From_bool(static_cast< bool >(result)));
+   if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
+   return TCL_OK;
+ fail:
+   if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
+   return TCL_ERROR;
+ }
+ 
+ 
+ SWIGINTERN int
+ _wrap_DataSource_ExecuteSQL(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
+   OGRDataSourceShadow *arg1 = (OGRDataSourceShadow *) 0 ;
+   char *arg2 = (char *) 0 ;
+   OGRGeometryShadow *arg3 = (OGRGeometryShadow *) NULL ;
+   char *arg4 = (char *) "" ;
+   void *argp1 = 0 ;
+   int res1 = 0 ;
+   int res2 ;
+   char *buf2 = 0 ;
+   int alloc2 = 0 ;
+   void *argp3 = 0 ;
+   int res3 = 0 ;
+   int res4 ;
+   char *buf4 = 0 ;
+   int alloc4 = 0 ;
+   OGRLayerShadow *result = 0 ;
+   
+   if (SWIG_GetArgs(interp, objc, objv,"oo|oo:osgeo::DataSource_ExecuteSQL self statement ?spatialFilter? ?dialect? ",(void *)0,(void *)0,(void *)0,(void *)0) == TCL_ERROR) SWIG_fail;
+   res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_OGRDataSourceShadow, 0 |  0 );
+   if (!SWIG_IsOK(res1)) {
+     SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "DataSource_ExecuteSQL" "', argument " "1"" of type '" "OGRDataSourceShadow *""'"); 
+   }
+   arg1 = reinterpret_cast< OGRDataSourceShadow * >(argp1);
+   res2 = SWIG_AsCharPtrAndSize(objv[2], &buf2, NULL, &alloc2);
+   if (!SWIG_IsOK(res2)) {
+     SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "DataSource_ExecuteSQL" "', argument " "2"" of type '" "char const *""'");
+   }
+   arg2 = reinterpret_cast< char * >(buf2);
+   if (objc > 3) {
+     res3 = SWIG_ConvertPtr(objv[3], &argp3,SWIGTYPE_p_OGRGeometryShadow, 0 |  0 );
+     if (!SWIG_IsOK(res3)) {
+       SWIG_exception_fail(SWIG_ArgError(res3), "in method '" "DataSource_ExecuteSQL" "', argument " "3"" of type '" "OGRGeometryShadow *""'"); 
+     }
+     arg3 = reinterpret_cast< OGRGeometryShadow * >(argp3);
+   }
+   if (objc > 4) {
+     res4 = SWIG_AsCharPtrAndSize(objv[4], &buf4, NULL, &alloc4);
+     if (!SWIG_IsOK(res4)) {
+       SWIG_exception_fail(SWIG_ArgError(res4), "in method '" "DataSource_ExecuteSQL" "', argument " "4"" of type '" "char const *""'");
+     }
+     arg4 = reinterpret_cast< char * >(buf4);
+   }
+   {
+     CPLErrorReset();
+     result = (OGRLayerShadow *)OGRDataSourceShadow_ExecuteSQL(arg1,(char const *)arg2,arg3,(char const *)arg4);
+     CPLErr eclass = CPLGetLastErrorType();
+     if ( eclass == CE_Failure || eclass == CE_Fatal ) {
+       SWIG_exception( SWIG_RuntimeError, CPLGetLastErrorMsg() );
+       
+     }
+     
+     
+     
+     
+     
+     
+     
+     
+     
+     
+     
+   }
+   Tcl_SetObjResult(interp, SWIG_NewInstanceObj( SWIG_as_voidptr(result), SWIGTYPE_p_OGRLayerShadow,0));
+   if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
+   if (alloc4 == SWIG_NEWOBJ) delete[] buf4;
+   return TCL_OK;
+ fail:
+   if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
+   if (alloc4 == SWIG_NEWOBJ) delete[] buf4;
+   return TCL_ERROR;
+ }
+ 
+ 
+ SWIGINTERN int
+ _wrap_DataSource_ReleaseResultSet(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
+   OGRDataSourceShadow *arg1 = (OGRDataSourceShadow *) 0 ;
+   OGRLayerShadow *arg2 = (OGRLayerShadow *) 0 ;
+   void *argp1 = 0 ;
+   int res1 = 0 ;
+   int res2 = 0 ;
+   
+   if (SWIG_GetArgs(interp, objc, objv,"oo:osgeo::DataSource_ReleaseResultSet self layer ",(void *)0,(void *)0) == TCL_ERROR) SWIG_fail;
+   res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_OGRDataSourceShadow, 0 |  0 );
+   if (!SWIG_IsOK(res1)) {
+     SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "DataSource_ReleaseResultSet" "', argument " "1"" of type '" "OGRDataSourceShadow *""'"); 
+   }
+   arg1 = reinterpret_cast< OGRDataSourceShadow * >(argp1);
+   res2 = SWIG_ConvertPtr(objv[2], SWIG_as_voidptrptr(&arg2), SWIGTYPE_p_OGRLayerShadow, SWIG_POINTER_DISOWN |  0 );
+   if (!SWIG_IsOK(res2)) {
+     SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "DataSource_ReleaseResultSet" "', argument " "2"" of type '" "OGRLayerShadow *""'");
+   }
+   {
+     CPLErrorReset();
+     OGRDataSourceShadow_ReleaseResultSet(arg1,arg2);
+     CPLErr eclass = CPLGetLastErrorType();
+     if ( eclass == CE_Failure || eclass == CE_Fatal ) {
+       SWIG_exception( SWIG_RuntimeError, CPLGetLastErrorMsg() );
+       
+     }
+     
+     
+     
+     
+     
+     
+     
+     
+     
+     
+     
+   }
+   
+   return TCL_OK;
+ fail:
+   return TCL_ERROR;
+ }
+ 
+ 
+ SWIGINTERN void swig_delete_DataSource(void *obj) {
+ OGRDataSourceShadow *arg1 = (OGRDataSourceShadow *) obj;
+ delete_OGRDataSourceShadow(arg1);
+ }
+ static swig_method swig_OGRDataSourceShadow_methods[] = {
+     {"GetRefCount", _wrap_DataSource_GetRefCount}, 
+     {"GetSummaryRefCount", _wrap_DataSource_GetSummaryRefCount}, 
+     {"GetLayerCount", _wrap_DataSource_GetLayerCount}, 
+     {"GetDriver", _wrap_DataSource_GetDriver}, 
+     {"GetName", _wrap_DataSource_GetName}, 
+     {"DeleteLayer", _wrap_DataSource_DeleteLayer}, 
+     {"CreateLayer", _wrap_DataSource_CreateLayer}, 
+     {"CopyLayer", _wrap_DataSource_CopyLayer}, 
+     {"GetLayerByIndex", _wrap_DataSource_GetLayerByIndex}, 
+     {"GetLayerByName", _wrap_DataSource_GetLayerByName}, 
+     {"TestCapability", _wrap_DataSource_TestCapability}, 
+     {"ExecuteSQL", _wrap_DataSource_ExecuteSQL}, 
+     {"ReleaseResultSet", _wrap_DataSource_ReleaseResultSet}, 
+     {0,0}
+ };
+ static swig_attribute swig_OGRDataSourceShadow_attributes[] = {
+     { "-name",_wrap_DataSource_name_get, 0 },
+     {0,0,0}
+ };
+ static swig_class *swig_OGRDataSourceShadow_bases[] = {0};
+ static const char * swig_OGRDataSourceShadow_base_names[] = {0};
+ static swig_class _wrap_class_OGRDataSourceShadow = { "DataSource", &SWIGTYPE_p_OGRDataSourceShadow,0, swig_delete_DataSource, swig_OGRDataSourceShadow_methods, swig_OGRDataSourceShadow_attributes, swig_OGRDataSourceShadow_bases,swig_OGRDataSourceShadow_base_names, &swig_module };
+ SWIGINTERN int
+ _wrap_Layer_GetRefCount(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
+   OGRLayerShadow *arg1 = (OGRLayerShadow *) 0 ;
+   void *argp1 = 0 ;
+   int res1 = 0 ;
+   int result;
+   
+   if (SWIG_GetArgs(interp, objc, objv,"o:osgeo::Layer_GetRefCount self ",(void *)0) == TCL_ERROR) SWIG_fail;
+   res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_OGRLayerShadow, 0 |  0 );
+   if (!SWIG_IsOK(res1)) {
+     SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Layer_GetRefCount" "', argument " "1"" of type '" "OGRLayerShadow *""'"); 
+   }
+   arg1 = reinterpret_cast< OGRLayerShadow * >(argp1);
+   {
+     CPLErrorReset();
+     result = (int)OGRLayerShadow_GetRefCount(arg1);
+     CPLErr eclass = CPLGetLastErrorType();
+     if ( eclass == CE_Failure || eclass == CE_Fatal ) {
+       SWIG_exception( SWIG_RuntimeError, CPLGetLastErrorMsg() );
+       
+     }
+     
+     
+     
+     
+     
+     
+     
+     
+     
+     
+     
+   }
+   Tcl_SetObjResult(interp,SWIG_From_int(static_cast< int >(result)));
+   return TCL_OK;
+ fail:
+   return TCL_ERROR;
+ }
+ 
+ 
+ SWIGINTERN int
+ _wrap_Layer_SetSpatialFilter(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
+   OGRLayerShadow *arg1 = (OGRLayerShadow *) 0 ;
+   OGRGeometryShadow *arg2 = (OGRGeometryShadow *) 0 ;
+   void *argp1 = 0 ;
+   int res1 = 0 ;
+   void *argp2 = 0 ;
+   int res2 = 0 ;
+   
+   if (SWIG_GetArgs(interp, objc, objv,"oo:osgeo::Layer_SetSpatialFilter self filter ",(void *)0,(void *)0) == TCL_ERROR) SWIG_fail;
+   res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_OGRLayerShadow, 0 |  0 );
+   if (!SWIG_IsOK(res1)) {
+     SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Layer_SetSpatialFilter" "', argument " "1"" of type '" "OGRLayerShadow *""'"); 
+   }
+   arg1 = reinterpret_cast< OGRLayerShadow * >(argp1);
+   res2 = SWIG_ConvertPtr(objv[2], &argp2,SWIGTYPE_p_OGRGeometryShadow, 0 |  0 );
+   if (!SWIG_IsOK(res2)) {
+     SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "Layer_SetSpatialFilter" "', argument " "2"" of type '" "OGRGeometryShadow *""'"); 
+   }
+   arg2 = reinterpret_cast< OGRGeometryShadow * >(argp2);
+   {
+     CPLErrorReset();
+     OGRLayerShadow_SetSpatialFilter(arg1,arg2);
+     CPLErr eclass = CPLGetLastErrorType();
+     if ( eclass == CE_Failure || eclass == CE_Fatal ) {
+       SWIG_exception( SWIG_RuntimeError, CPLGetLastErrorMsg() );
+       
+     }
+     
+     
+     
+     
+     
+     
+     
+     
+     
+     
+     
+   }
+   
+   return TCL_OK;
+ fail:
+   return TCL_ERROR;
+ }
+ 
+ 
+ SWIGINTERN int
+ _wrap_Layer_SetSpatialFilterRect(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
+   OGRLayerShadow *arg1 = (OGRLayerShadow *) 0 ;
+   double arg2 ;
+   double arg3 ;
+   double arg4 ;
+   double arg5 ;
+   void *argp1 = 0 ;
+   int res1 = 0 ;
+   double val2 ;
+   int ecode2 = 0 ;
+   double val3 ;
+   int ecode3 = 0 ;
+   double val4 ;
+   int ecode4 = 0 ;
+   double val5 ;
+   int ecode5 = 0 ;
+   
+   if (SWIG_GetArgs(interp, objc, objv,"ooooo:osgeo::Layer_SetSpatialFilterRect self minx miny maxx maxy ",(void *)0,(void *)0,(void *)0,(void *)0,(void *)0) == TCL_ERROR) SWIG_fail;
+   res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_OGRLayerShadow, 0 |  0 );
+   if (!SWIG_IsOK(res1)) {
+     SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Layer_SetSpatialFilterRect" "', argument " "1"" of type '" "OGRLayerShadow *""'"); 
+   }
+   arg1 = reinterpret_cast< OGRLayerShadow * >(argp1);
+   ecode2 = SWIG_AsVal_double SWIG_TCL_CALL_ARGS_2(objv[2], &val2);
+   if (!SWIG_IsOK(ecode2)) {
+     SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "Layer_SetSpatialFilterRect" "', argument " "2"" of type '" "double""'");
+   } 
+   arg2 = static_cast< double >(val2);
+   ecode3 = SWIG_AsVal_double SWIG_TCL_CALL_ARGS_2(objv[3], &val3);
+   if (!SWIG_IsOK(ecode3)) {
+     SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "Layer_SetSpatialFilterRect" "', argument " "3"" of type '" "double""'");
+   } 
+   arg3 = static_cast< double >(val3);
+   ecode4 = SWIG_AsVal_double SWIG_TCL_CALL_ARGS_2(objv[4], &val4);
+   if (!SWIG_IsOK(ecode4)) {
+     SWIG_exception_fail(SWIG_ArgError(ecode4), "in method '" "Layer_SetSpatialFilterRect" "', argument " "4"" of type '" "double""'");
+   } 
+   arg4 = static_cast< double >(val4);
+   ecode5 = SWIG_AsVal_double SWIG_TCL_CALL_ARGS_2(objv[5], &val5);
+   if (!SWIG_IsOK(ecode5)) {
+     SWIG_exception_fail(SWIG_ArgError(ecode5), "in method '" "Layer_SetSpatialFilterRect" "', argument " "5"" of type '" "double""'");
+   } 
+   arg5 = static_cast< double >(val5);
+   {
+     CPLErrorReset();
+     OGRLayerShadow_SetSpatialFilterRect(arg1,arg2,arg3,arg4,arg5);
+     CPLErr eclass = CPLGetLastErrorType();
+     if ( eclass == CE_Failure || eclass == CE_Fatal ) {
+       SWIG_exception( SWIG_RuntimeError, CPLGetLastErrorMsg() );
+       
+     }
+     
+     
+     
+     
+     
+     
+     
+     
+     
+     
+     
+   }
+   
+   return TCL_OK;
+ fail:
+   return TCL_ERROR;
+ }
+ 
+ 
+ SWIGINTERN int
+ _wrap_Layer_GetSpatialFilter(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
+   OGRLayerShadow *arg1 = (OGRLayerShadow *) 0 ;
+   void *argp1 = 0 ;
+   int res1 = 0 ;
+   OGRGeometryShadow *result = 0 ;
+   
+   if (SWIG_GetArgs(interp, objc, objv,"o:osgeo::Layer_GetSpatialFilter self ",(void *)0) == TCL_ERROR) SWIG_fail;
+   res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_OGRLayerShadow, 0 |  0 );
+   if (!SWIG_IsOK(res1)) {
+     SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Layer_GetSpatialFilter" "', argument " "1"" of type '" "OGRLayerShadow *""'"); 
+   }
+   arg1 = reinterpret_cast< OGRLayerShadow * >(argp1);
+   {
+     CPLErrorReset();
+     result = (OGRGeometryShadow *)OGRLayerShadow_GetSpatialFilter(arg1);
+     CPLErr eclass = CPLGetLastErrorType();
+     if ( eclass == CE_Failure || eclass == CE_Fatal ) {
+       SWIG_exception( SWIG_RuntimeError, CPLGetLastErrorMsg() );
+       
+     }
+     
+     
+     
+     
+     
+     
+     
+     
+     
+     
+     
+   }
+   Tcl_SetObjResult(interp, SWIG_NewInstanceObj( SWIG_as_voidptr(result), SWIGTYPE_p_OGRGeometryShadow,0));
+   return TCL_OK;
+ fail:
+   return TCL_ERROR;
+ }
+ 
+ 
+ SWIGINTERN int
+ _wrap_Layer_SetAttributeFilter(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
+   OGRLayerShadow *arg1 = (OGRLayerShadow *) 0 ;
+   char *arg2 = (char *) 0 ;
+   void *argp1 = 0 ;
+   int res1 = 0 ;
+   int res2 ;
+   char *buf2 = 0 ;
+   int alloc2 = 0 ;
+   OGRErr result;
+   
+   if (SWIG_GetArgs(interp, objc, objv,"oo:osgeo::Layer_SetAttributeFilter self filter_string ",(void *)0,(void *)0) == TCL_ERROR) SWIG_fail;
+   res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_OGRLayerShadow, 0 |  0 );
+   if (!SWIG_IsOK(res1)) {
+     SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Layer_SetAttributeFilter" "', argument " "1"" of type '" "OGRLayerShadow *""'"); 
+   }
+   arg1 = reinterpret_cast< OGRLayerShadow * >(argp1);
+   res2 = SWIG_AsCharPtrAndSize(objv[2], &buf2, NULL, &alloc2);
+   if (!SWIG_IsOK(res2)) {
+     SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "Layer_SetAttributeFilter" "', argument " "2"" of type '" "char *""'");
+   }
+   arg2 = reinterpret_cast< char * >(buf2);
+   {
+     CPLErrorReset();
+     result = (OGRErr)OGRLayerShadow_SetAttributeFilter(arg1,arg2);
+     CPLErr eclass = CPLGetLastErrorType();
+     if ( eclass == CE_Failure || eclass == CE_Fatal ) {
+       SWIG_exception( SWIG_RuntimeError, CPLGetLastErrorMsg() );
+       
+     }
+     
+     
+     
+     
+     
+     
+     
+     
+     
+     
+     
+   }
+   {
+     /* %typemap(out) OGRErr */
+     if (result != 0) {
+       Tcl_SetResult(interp, (char*) OGRErrMessages(result), TCL_STATIC);
+       SWIG_fail;
+     }
+   }
+   if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
+   {
+     /* %typemap(ret) OGRErr */
+     if (!strcmp(Tcl_GetStringResult(interp), "{}") || !strcmp(Tcl_GetStringResult(interp), "")) {
+       Tcl_SetObjResult(interp, Tcl_NewLongObj( result ));
+     }
+   }
+   return TCL_OK;
+ fail:
+   if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
+   return TCL_ERROR;
+ }
+ 
+ 
+ SWIGINTERN int
+ _wrap_Layer_ResetReading(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
+   OGRLayerShadow *arg1 = (OGRLayerShadow *) 0 ;
+   void *argp1 = 0 ;
+   int res1 = 0 ;
+   
+   if (SWIG_GetArgs(interp, objc, objv,"o:osgeo::Layer_ResetReading self ",(void *)0) == TCL_ERROR) SWIG_fail;
+   res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_OGRLayerShadow, 0 |  0 );
+   if (!SWIG_IsOK(res1)) {
+     SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Layer_ResetReading" "', argument " "1"" of type '" "OGRLayerShadow *""'"); 
+   }
+   arg1 = reinterpret_cast< OGRLayerShadow * >(argp1);
+   {
+     CPLErrorReset();
+     OGRLayerShadow_ResetReading(arg1);
+     CPLErr eclass = CPLGetLastErrorType();
+     if ( eclass == CE_Failure || eclass == CE_Fatal ) {
+       SWIG_exception( SWIG_RuntimeError, CPLGetLastErrorMsg() );
+       
+     }
+     
+     
+     
+     
+     
+     
+     
+     
+     
+     
+     
+   }
+   
+   return TCL_OK;
+ fail:
+   return TCL_ERROR;
+ }
+ 
+ 
+ SWIGINTERN int
+ _wrap_Layer_GetName(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
+   OGRLayerShadow *arg1 = (OGRLayerShadow *) 0 ;
+   void *argp1 = 0 ;
+   int res1 = 0 ;
+   char *result = 0 ;
+   
+   if (SWIG_GetArgs(interp, objc, objv,"o:osgeo::Layer_GetName self ",(void *)0) == TCL_ERROR) SWIG_fail;
+   res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_OGRLayerShadow, 0 |  0 );
+   if (!SWIG_IsOK(res1)) {
+     SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Layer_GetName" "', argument " "1"" of type '" "OGRLayerShadow *""'"); 
+   }
+   arg1 = reinterpret_cast< OGRLayerShadow * >(argp1);
+   {
+     CPLErrorReset();
+     result = (char *)OGRLayerShadow_GetName(arg1);
+     CPLErr eclass = CPLGetLastErrorType();
+     if ( eclass == CE_Failure || eclass == CE_Fatal ) {
+       SWIG_exception( SWIG_RuntimeError, CPLGetLastErrorMsg() );
+       
+     }
+     
+     
+     
+     
+     
+     
+     
+     
+     
+     
+     
+   }
+   Tcl_SetObjResult(interp,SWIG_FromCharPtr((const char *)result));
+   return TCL_OK;
+ fail:
+   return TCL_ERROR;
+ }
+ 
+ 
+ SWIGINTERN int
+ _wrap_Layer_GetGeometryColumn(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
+   OGRLayerShadow *arg1 = (OGRLayerShadow *) 0 ;
+   void *argp1 = 0 ;
+   int res1 = 0 ;
+   char *result = 0 ;
+   
+   if (SWIG_GetArgs(interp, objc, objv,"o:osgeo::Layer_GetGeometryColumn self ",(void *)0) == TCL_ERROR) SWIG_fail;
+   res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_OGRLayerShadow, 0 |  0 );
+   if (!SWIG_IsOK(res1)) {
+     SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Layer_GetGeometryColumn" "', argument " "1"" of type '" "OGRLayerShadow *""'"); 
+   }
+   arg1 = reinterpret_cast< OGRLayerShadow * >(argp1);
+   {
+     CPLErrorReset();
+     result = (char *)OGRLayerShadow_GetGeometryColumn(arg1);
+     CPLErr eclass = CPLGetLastErrorType();
+     if ( eclass == CE_Failure || eclass == CE_Fatal ) {
+       SWIG_exception( SWIG_RuntimeError, CPLGetLastErrorMsg() );
+       
+     }
+     
+     
+     
+     
+     
+     
+     
+     
+     
+     
+     
+   }
+   Tcl_SetObjResult(interp,SWIG_FromCharPtr((const char *)result));
+   return TCL_OK;
+ fail:
+   return TCL_ERROR;
+ }
+ 
+ 
+ SWIGINTERN int
+ _wrap_Layer_GetFIDColumn(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
+   OGRLayerShadow *arg1 = (OGRLayerShadow *) 0 ;
+   void *argp1 = 0 ;
+   int res1 = 0 ;
+   char *result = 0 ;
+   
+   if (SWIG_GetArgs(interp, objc, objv,"o:osgeo::Layer_GetFIDColumn self ",(void *)0) == TCL_ERROR) SWIG_fail;
+   res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_OGRLayerShadow, 0 |  0 );
+   if (!SWIG_IsOK(res1)) {
+     SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Layer_GetFIDColumn" "', argument " "1"" of type '" "OGRLayerShadow *""'"); 
+   }
+   arg1 = reinterpret_cast< OGRLayerShadow * >(argp1);
+   {
+     CPLErrorReset();
+     result = (char *)OGRLayerShadow_GetFIDColumn(arg1);
+     CPLErr eclass = CPLGetLastErrorType();
+     if ( eclass == CE_Failure || eclass == CE_Fatal ) {
+       SWIG_exception( SWIG_RuntimeError, CPLGetLastErrorMsg() );
+       
+     }
+     
+     
+     
+     
+     
+     
+     
+     
+     
+     
+     
+   }
+   Tcl_SetObjResult(interp,SWIG_FromCharPtr((const char *)result));
+   return TCL_OK;
+ fail:
+   return TCL_ERROR;
+ }
+ 
+ 
+ SWIGINTERN int
+ _wrap_Layer_GetFeature(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
+   OGRLayerShadow *arg1 = (OGRLayerShadow *) 0 ;
+   long arg2 ;
+   void *argp1 = 0 ;
+   int res1 = 0 ;
+   long val2 ;
+   int ecode2 = 0 ;
+   OGRFeatureShadow *result = 0 ;
+   
+   if (SWIG_GetArgs(interp, objc, objv,"oo:osgeo::Layer_GetFeature self fid ",(void *)0,(void *)0) == TCL_ERROR) SWIG_fail;
+   res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_OGRLayerShadow, 0 |  0 );
+   if (!SWIG_IsOK(res1)) {
+     SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Layer_GetFeature" "', argument " "1"" of type '" "OGRLayerShadow *""'"); 
+   }
+   arg1 = reinterpret_cast< OGRLayerShadow * >(argp1);
+   ecode2 = SWIG_AsVal_long SWIG_TCL_CALL_ARGS_2(objv[2], &val2);
+   if (!SWIG_IsOK(ecode2)) {
+     SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "Layer_GetFeature" "', argument " "2"" of type '" "long""'");
+   } 
+   arg2 = static_cast< long >(val2);
+   {
+     CPLErrorReset();
+     result = (OGRFeatureShadow *)OGRLayerShadow_GetFeature(arg1,arg2);
+     CPLErr eclass = CPLGetLastErrorType();
+     if ( eclass == CE_Failure || eclass == CE_Fatal ) {
+       SWIG_exception( SWIG_RuntimeError, CPLGetLastErrorMsg() );
+       
+     }
+     
+     
+     
+     
+     
+     
+     
+     
+     
+     
+     
+   }
+   Tcl_SetObjResult(interp, SWIG_NewInstanceObj( SWIG_as_voidptr(result), SWIGTYPE_p_OGRFeatureShadow,0));
+   return TCL_OK;
+ fail:
+   return TCL_ERROR;
+ }
+ 
+ 
+ SWIGINTERN int
+ _wrap_Layer_GetNextFeature(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
+   OGRLayerShadow *arg1 = (OGRLayerShadow *) 0 ;
+   void *argp1 = 0 ;
+   int res1 = 0 ;
+   OGRFeatureShadow *result = 0 ;
+   
+   if (SWIG_GetArgs(interp, objc, objv,"o:osgeo::Layer_GetNextFeature self ",(void *)0) == TCL_ERROR) SWIG_fail;
+   res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_OGRLayerShadow, 0 |  0 );
+   if (!SWIG_IsOK(res1)) {
+     SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Layer_GetNextFeature" "', argument " "1"" of type '" "OGRLayerShadow *""'"); 
+   }
+   arg1 = reinterpret_cast< OGRLayerShadow * >(argp1);
+   {
+     CPLErrorReset();
+     result = (OGRFeatureShadow *)OGRLayerShadow_GetNextFeature(arg1);
+     CPLErr eclass = CPLGetLastErrorType();
+     if ( eclass == CE_Failure || eclass == CE_Fatal ) {
+       SWIG_exception( SWIG_RuntimeError, CPLGetLastErrorMsg() );
+       
+     }
+     
+     
+     
+     
+     
+     
+     
+     
+     
+     
+     
+   }
+   Tcl_SetObjResult(interp, SWIG_NewInstanceObj( SWIG_as_voidptr(result), SWIGTYPE_p_OGRFeatureShadow,0));
+   return TCL_OK;
+ fail:
+   return TCL_ERROR;
+ }
+ 
+ 
+ SWIGINTERN int
+ _wrap_Layer_SetNextByIndex(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
+   OGRLayerShadow *arg1 = (OGRLayerShadow *) 0 ;
+   long arg2 ;
+   void *argp1 = 0 ;
+   int res1 = 0 ;
+   long val2 ;
+   int ecode2 = 0 ;
+   OGRErr result;
+   
+   if (SWIG_GetArgs(interp, objc, objv,"oo:osgeo::Layer_SetNextByIndex self new_index ",(void *)0,(void *)0) == TCL_ERROR) SWIG_fail;
+   res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_OGRLayerShadow, 0 |  0 );
+   if (!SWIG_IsOK(res1)) {
+     SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Layer_SetNextByIndex" "', argument " "1"" of type '" "OGRLayerShadow *""'"); 
+   }
+   arg1 = reinterpret_cast< OGRLayerShadow * >(argp1);
+   ecode2 = SWIG_AsVal_long SWIG_TCL_CALL_ARGS_2(objv[2], &val2);
+   if (!SWIG_IsOK(ecode2)) {
+     SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "Layer_SetNextByIndex" "', argument " "2"" of type '" "long""'");
+   } 
+   arg2 = static_cast< long >(val2);
+   {
+     CPLErrorReset();
+     result = (OGRErr)OGRLayerShadow_SetNextByIndex(arg1,arg2);
+     CPLErr eclass = CPLGetLastErrorType();
+     if ( eclass == CE_Failure || eclass == CE_Fatal ) {
+       SWIG_exception( SWIG_RuntimeError, CPLGetLastErrorMsg() );
+       
+     }
+     
+     
+     
+     
+     
+     
+     
+     
+     
+     
+     
+   }
+   {
+     /* %typemap(out) OGRErr */
+     if (result != 0) {
+       Tcl_SetResult(interp, (char*) OGRErrMessages(result), TCL_STATIC);
+       SWIG_fail;
+     }
+   }
+   {
+     /* %typemap(ret) OGRErr */
+     if (!strcmp(Tcl_GetStringResult(interp), "{}") || !strcmp(Tcl_GetStringResult(interp), "")) {
+       Tcl_SetObjResult(interp, Tcl_NewLongObj( result ));
+     }
+   }
+   return TCL_OK;
+ fail:
+   return TCL_ERROR;
+ }
+ 
+ 
+ SWIGINTERN int
+ _wrap_Layer_SetFeature(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
+   OGRLayerShadow *arg1 = (OGRLayerShadow *) 0 ;
+   OGRFeatureShadow *arg2 = (OGRFeatureShadow *) 0 ;
+   void *argp1 = 0 ;
+   int res1 = 0 ;
+   void *argp2 = 0 ;
+   int res2 = 0 ;
+   OGRErr result;
+   
+   if (SWIG_GetArgs(interp, objc, objv,"oo:osgeo::Layer_SetFeature self feature ",(void *)0,(void *)0) == TCL_ERROR) SWIG_fail;
+   res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_OGRLayerShadow, 0 |  0 );
+   if (!SWIG_IsOK(res1)) {
+     SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Layer_SetFeature" "', argument " "1"" of type '" "OGRLayerShadow *""'"); 
+   }
+   arg1 = reinterpret_cast< OGRLayerShadow * >(argp1);
+   res2 = SWIG_ConvertPtr(objv[2], &argp2,SWIGTYPE_p_OGRFeatureShadow, 0 |  0 );
+   if (!SWIG_IsOK(res2)) {
+     SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "Layer_SetFeature" "', argument " "2"" of type '" "OGRFeatureShadow *""'"); 
+   }
+   arg2 = reinterpret_cast< OGRFeatureShadow * >(argp2);
+   {
+     CPLErrorReset();
+     result = (OGRErr)OGRLayerShadow_SetFeature(arg1,arg2);
+     CPLErr eclass = CPLGetLastErrorType();
+     if ( eclass == CE_Failure || eclass == CE_Fatal ) {
+       SWIG_exception( SWIG_RuntimeError, CPLGetLastErrorMsg() );
+       
+     }
+     
+     
+     
+     
+     
+     
+     
+     
+     
+     
+     
+   }
+   {
+     /* %typemap(out) OGRErr */
+     if (result != 0) {
+       Tcl_SetResult(interp, (char*) OGRErrMessages(result), TCL_STATIC);
+       SWIG_fail;
+     }
+   }
+   {
+     /* %typemap(ret) OGRErr */
+     if (!strcmp(Tcl_GetStringResult(interp), "{}") || !strcmp(Tcl_GetStringResult(interp), "")) {
+       Tcl_SetObjResult(interp, Tcl_NewLongObj( result ));
+     }
+   }
+   return TCL_OK;
+ fail:
+   return TCL_ERROR;
+ }
+ 
+ 
+ SWIGINTERN int
+ _wrap_Layer_CreateFeature(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
+   OGRLayerShadow *arg1 = (OGRLayerShadow *) 0 ;
+   OGRFeatureShadow *arg2 = (OGRFeatureShadow *) 0 ;
+   void *argp1 = 0 ;
+   int res1 = 0 ;
+   void *argp2 = 0 ;
+   int res2 = 0 ;
+   OGRErr result;
+   
+   if (SWIG_GetArgs(interp, objc, objv,"oo:osgeo::Layer_CreateFeature self feature ",(void *)0,(void *)0) == TCL_ERROR) SWIG_fail;
+   res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_OGRLayerShadow, 0 |  0 );
+   if (!SWIG_IsOK(res1)) {
+     SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Layer_CreateFeature" "', argument " "1"" of type '" "OGRLayerShadow *""'"); 
+   }
+   arg1 = reinterpret_cast< OGRLayerShadow * >(argp1);
+   res2 = SWIG_ConvertPtr(objv[2], &argp2,SWIGTYPE_p_OGRFeatureShadow, 0 |  0 );
+   if (!SWIG_IsOK(res2)) {
+     SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "Layer_CreateFeature" "', argument " "2"" of type '" "OGRFeatureShadow *""'"); 
+   }
+   arg2 = reinterpret_cast< OGRFeatureShadow * >(argp2);
+   {
+     CPLErrorReset();
+     result = (OGRErr)OGRLayerShadow_CreateFeature(arg1,arg2);
+     CPLErr eclass = CPLGetLastErrorType();
+     if ( eclass == CE_Failure || eclass == CE_Fatal ) {
+       SWIG_exception( SWIG_RuntimeError, CPLGetLastErrorMsg() );
+       
+     }
+     
+     
+     
+     
+     
+     
+     
+     
+     
+     
+     
+   }
+   {
+     /* %typemap(out) OGRErr */
+     if (result != 0) {
+       Tcl_SetResult(interp, (char*) OGRErrMessages(result), TCL_STATIC);
+       SWIG_fail;
+     }
+   }
+   {
+     /* %typemap(ret) OGRErr */
+     if (!strcmp(Tcl_GetStringResult(interp), "{}") || !strcmp(Tcl_GetStringResult(interp), "")) {
+       Tcl_SetObjResult(interp, Tcl_NewLongObj( result ));
+     }
+   }
+   return TCL_OK;
+ fail:
+   return TCL_ERROR;
+ }
+ 
+ 
+ SWIGINTERN int
+ _wrap_Layer_DeleteFeature(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
+   OGRLayerShadow *arg1 = (OGRLayerShadow *) 0 ;
+   long arg2 ;
+   void *argp1 = 0 ;
+   int res1 = 0 ;
+   long val2 ;
+   int ecode2 = 0 ;
+   OGRErr result;
+   
+   if (SWIG_GetArgs(interp, objc, objv,"oo:osgeo::Layer_DeleteFeature self fid ",(void *)0,(void *)0) == TCL_ERROR) SWIG_fail;
+   res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_OGRLayerShadow, 0 |  0 );
+   if (!SWIG_IsOK(res1)) {
+     SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Layer_DeleteFeature" "', argument " "1"" of type '" "OGRLayerShadow *""'"); 
+   }
+   arg1 = reinterpret_cast< OGRLayerShadow * >(argp1);
+   ecode2 = SWIG_AsVal_long SWIG_TCL_CALL_ARGS_2(objv[2], &val2);
+   if (!SWIG_IsOK(ecode2)) {
+     SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "Layer_DeleteFeature" "', argument " "2"" of type '" "long""'");
+   } 
+   arg2 = static_cast< long >(val2);
+   {
+     CPLErrorReset();
+     result = (OGRErr)OGRLayerShadow_DeleteFeature(arg1,arg2);
+     CPLErr eclass = CPLGetLastErrorType();
+     if ( eclass == CE_Failure || eclass == CE_Fatal ) {
+       SWIG_exception( SWIG_RuntimeError, CPLGetLastErrorMsg() );
+       
+     }
+     
+     
+     
+     
+     
+     
+     
+     
+     
+     
+     
+   }
+   {
+     /* %typemap(out) OGRErr */
+     if (result != 0) {
+       Tcl_SetResult(interp, (char*) OGRErrMessages(result), TCL_STATIC);
+       SWIG_fail;
+     }
+   }
+   {
+     /* %typemap(ret) OGRErr */
+     if (!strcmp(Tcl_GetStringResult(interp), "{}") || !strcmp(Tcl_GetStringResult(interp), "")) {
+       Tcl_SetObjResult(interp, Tcl_NewLongObj( result ));
+     }
+   }
+   return TCL_OK;
+ fail:
+   return TCL_ERROR;
+ }
+ 
+ 
+ SWIGINTERN int
+ _wrap_Layer_SyncToDisk(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
+   OGRLayerShadow *arg1 = (OGRLayerShadow *) 0 ;
+   void *argp1 = 0 ;
+   int res1 = 0 ;
+   OGRErr result;
+   
+   if (SWIG_GetArgs(interp, objc, objv,"o:osgeo::Layer_SyncToDisk self ",(void *)0) == TCL_ERROR) SWIG_fail;
+   res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_OGRLayerShadow, 0 |  0 );
+   if (!SWIG_IsOK(res1)) {
+     SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Layer_SyncToDisk" "', argument " "1"" of type '" "OGRLayerShadow *""'"); 
+   }
+   arg1 = reinterpret_cast< OGRLayerShadow * >(argp1);
+   {
+     CPLErrorReset();
+     result = (OGRErr)OGRLayerShadow_SyncToDisk(arg1);
+     CPLErr eclass = CPLGetLastErrorType();
+     if ( eclass == CE_Failure || eclass == CE_Fatal ) {
+       SWIG_exception( SWIG_RuntimeError, CPLGetLastErrorMsg() );
+       
+     }
+     
+     
+     
+     
+     
+     
+     
+     
+     
+     
+     
+   }
+   {
+     /* %typemap(out) OGRErr */
+     if (result != 0) {
+       Tcl_SetResult(interp, (char*) OGRErrMessages(result), TCL_STATIC);
+       SWIG_fail;
+     }
+   }
+   {
+     /* %typemap(ret) OGRErr */
+     if (!strcmp(Tcl_GetStringResult(interp), "{}") || !strcmp(Tcl_GetStringResult(interp), "")) {
+       Tcl_SetObjResult(interp, Tcl_NewLongObj( result ));
+     }
+   }
+   return TCL_OK;
+ fail:
+   return TCL_ERROR;
+ }
+ 
+ 
+ SWIGINTERN int
+ _wrap_Layer_GetLayerDefn(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
+   OGRLayerShadow *arg1 = (OGRLayerShadow *) 0 ;
+   void *argp1 = 0 ;
+   int res1 = 0 ;
+   OGRFeatureDefnShadow *result = 0 ;
+   
+   if (SWIG_GetArgs(interp, objc, objv,"o:osgeo::Layer_GetLayerDefn self ",(void *)0) == TCL_ERROR) SWIG_fail;
+   res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_OGRLayerShadow, 0 |  0 );
+   if (!SWIG_IsOK(res1)) {
+     SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Layer_GetLayerDefn" "', argument " "1"" of type '" "OGRLayerShadow *""'"); 
+   }
+   arg1 = reinterpret_cast< OGRLayerShadow * >(argp1);
+   {
+     CPLErrorReset();
+     result = (OGRFeatureDefnShadow *)OGRLayerShadow_GetLayerDefn(arg1);
+     CPLErr eclass = CPLGetLastErrorType();
+     if ( eclass == CE_Failure || eclass == CE_Fatal ) {
+       SWIG_exception( SWIG_RuntimeError, CPLGetLastErrorMsg() );
+       
+     }
+     
+     
+     
+     
+     
+     
+     
+     
+     
+     
+     
+   }
+   Tcl_SetObjResult(interp, SWIG_NewInstanceObj( SWIG_as_voidptr(result), SWIGTYPE_p_OGRFeatureDefnShadow,0));
+   return TCL_OK;
+ fail:
+   return TCL_ERROR;
+ }
+ 
+ 
+ SWIGINTERN int
+ _wrap_Layer_GetFeatureCount(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
+   OGRLayerShadow *arg1 = (OGRLayerShadow *) 0 ;
+   int arg2 = (int) 1 ;
+   void *argp1 = 0 ;
+   int res1 = 0 ;
+   int val2 ;
+   int ecode2 = 0 ;
+   int result;
+   
+   if (SWIG_GetArgs(interp, objc, objv,"o|o:osgeo::Layer_GetFeatureCount self ?force? ",(void *)0,(void *)0) == TCL_ERROR) SWIG_fail;
+   res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_OGRLayerShadow, 0 |  0 );
+   if (!SWIG_IsOK(res1)) {
+     SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Layer_GetFeatureCount" "', argument " "1"" of type '" "OGRLayerShadow *""'"); 
+   }
+   arg1 = reinterpret_cast< OGRLayerShadow * >(argp1);
+   if (objc > 2) {
+     ecode2 = SWIG_AsVal_int SWIG_TCL_CALL_ARGS_2(objv[2], &val2);
+     if (!SWIG_IsOK(ecode2)) {
+       SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "Layer_GetFeatureCount" "', argument " "2"" of type '" "int""'");
+     } 
+     arg2 = static_cast< int >(val2);
+   }
+   {
+     CPLErrorReset();
+     result = (int)OGRLayerShadow_GetFeatureCount(arg1,arg2);
+     CPLErr eclass = CPLGetLastErrorType();
+     if ( eclass == CE_Failure || eclass == CE_Fatal ) {
+       SWIG_exception( SWIG_RuntimeError, CPLGetLastErrorMsg() );
+       
+     }
+     
+     
+     
+     
+     
+     
+     
+     
+     
+     
+     
+   }
+   Tcl_SetObjResult(interp,SWIG_From_int(static_cast< int >(result)));
+   return TCL_OK;
+ fail:
+   return TCL_ERROR;
+ }
+ 
+ 
+ SWIGINTERN int
+ _wrap_Layer_GetExtent(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
+   OGRLayerShadow *arg1 = (OGRLayerShadow *) 0 ;
+   double *arg2 ;
+   int arg3 = (int) 1 ;
+   void *argp1 = 0 ;
+   int res1 = 0 ;
+   double argout2[4] ;
+   int val3 ;
+   int ecode3 = 0 ;
+   OGRErr result;
+   
+   {
+     /* %typemap(in,numinputs=0) (double argout2[ANY]) */
+     arg2 = argout2;
+   }
+   if (SWIG_GetArgs(interp, objc, objv,"o|o:osgeo::Layer_GetExtent self ?force? ",(void *)0,(void *)0) == TCL_ERROR) SWIG_fail;
+   res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_OGRLayerShadow, 0 |  0 );
+   if (!SWIG_IsOK(res1)) {
+     SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Layer_GetExtent" "', argument " "1"" of type '" "OGRLayerShadow *""'"); 
+   }
+   arg1 = reinterpret_cast< OGRLayerShadow * >(argp1);
+   if (objc > 2) {
+     ecode3 = SWIG_AsVal_int SWIG_TCL_CALL_ARGS_2(objv[2], &val3);
+     if (!SWIG_IsOK(ecode3)) {
+       SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "Layer_GetExtent" "', argument " "3"" of type '" "int""'");
+     } 
+     arg3 = static_cast< int >(val3);
+   }
+   {
+     CPLErrorReset();
+     result = (OGRErr)OGRLayerShadow_GetExtent(arg1,arg2,arg3);
+     CPLErr eclass = CPLGetLastErrorType();
+     if ( eclass == CE_Failure || eclass == CE_Fatal ) {
+       SWIG_exception( SWIG_RuntimeError, CPLGetLastErrorMsg() );
+       
+     }
+     
+     
+     
+     
+     
+     
+     
+     
+     
+     
+     
+   }
+   {
+     /* %typemap(out) OGRErr */
+     if (result != 0) {
+       Tcl_SetResult(interp, (char*) OGRErrMessages(result), TCL_STATIC);
+       SWIG_fail;
+     }
+   }
+   {
+     /* %typemap(argout) (double argout[ANY]) */
+     Tcl_Obj *out = CreateListFromDoubleArray( interp, arg2, 4 );
+     if (out == NULL) SWIG_fail;
+     Tcl_ListObjAppendElement(interp,Tcl_GetObjResult(interp),out);
+   }
+   {
+     /* %typemap(ret) OGRErr */
+     if (!strcmp(Tcl_GetStringResult(interp), "{}") || !strcmp(Tcl_GetStringResult(interp), "")) {
+       Tcl_SetObjResult(interp, Tcl_NewLongObj( result ));
+     }
+   }
+   return TCL_OK;
+ fail:
+   return TCL_ERROR;
+ }
+ 
+ 
+ SWIGINTERN int
+ _wrap_Layer_TestCapability(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
+   OGRLayerShadow *arg1 = (OGRLayerShadow *) 0 ;
+   char *arg2 = (char *) 0 ;
+   void *argp1 = 0 ;
+   int res1 = 0 ;
+   int res2 ;
+   char *buf2 = 0 ;
+   int alloc2 = 0 ;
+   bool result;
+   
+   if (SWIG_GetArgs(interp, objc, objv,"oo:osgeo::Layer_TestCapability self cap ",(void *)0,(void *)0) == TCL_ERROR) SWIG_fail;
+   res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_OGRLayerShadow, 0 |  0 );
+   if (!SWIG_IsOK(res1)) {
+     SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Layer_TestCapability" "', argument " "1"" of type '" "OGRLayerShadow *""'"); 
+   }
+   arg1 = reinterpret_cast< OGRLayerShadow * >(argp1);
+   res2 = SWIG_AsCharPtrAndSize(objv[2], &buf2, NULL, &alloc2);
+   if (!SWIG_IsOK(res2)) {
+     SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "Layer_TestCapability" "', argument " "2"" of type '" "char const *""'");
+   }
+   arg2 = reinterpret_cast< char * >(buf2);
+   {
+     CPLErrorReset();
+     result = (bool)OGRLayerShadow_TestCapability(arg1,(char const *)arg2);
+     CPLErr eclass = CPLGetLastErrorType();
+     if ( eclass == CE_Failure || eclass == CE_Fatal ) {
+       SWIG_exception( SWIG_RuntimeError, CPLGetLastErrorMsg() );
+       
+     }
+     
+     
+     
+     
+     
+     
+     
+     
+     
+     
+     
+   }
+   Tcl_SetObjResult(interp,SWIG_From_bool(static_cast< bool >(result)));
+   if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
+   return TCL_OK;
+ fail:
+   if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
+   return TCL_ERROR;
+ }
+ 
+ 
+ SWIGINTERN int
+ _wrap_Layer_CreateField(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
+   OGRLayerShadow *arg1 = (OGRLayerShadow *) 0 ;
+   OGRFieldDefnShadow *arg2 = (OGRFieldDefnShadow *) 0 ;
+   int arg3 = (int) 1 ;
+   void *argp1 = 0 ;
+   int res1 = 0 ;
+   void *argp2 = 0 ;
+   int res2 = 0 ;
+   int val3 ;
+   int ecode3 = 0 ;
+   OGRErr result;
+   
+   if (SWIG_GetArgs(interp, objc, objv,"oo|o:osgeo::Layer_CreateField self field_def ?approx_ok? ",(void *)0,(void *)0,(void *)0) == TCL_ERROR) SWIG_fail;
+   res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_OGRLayerShadow, 0 |  0 );
+   if (!SWIG_IsOK(res1)) {
+     SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Layer_CreateField" "', argument " "1"" of type '" "OGRLayerShadow *""'"); 
+   }
+   arg1 = reinterpret_cast< OGRLayerShadow * >(argp1);
+   res2 = SWIG_ConvertPtr(objv[2], &argp2,SWIGTYPE_p_OGRFieldDefnShadow, 0 |  0 );
+   if (!SWIG_IsOK(res2)) {
+     SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "Layer_CreateField" "', argument " "2"" of type '" "OGRFieldDefnShadow *""'"); 
+   }
+   arg2 = reinterpret_cast< OGRFieldDefnShadow * >(argp2);
+   if (objc > 3) {
+     ecode3 = SWIG_AsVal_int SWIG_TCL_CALL_ARGS_2(objv[3], &val3);
+     if (!SWIG_IsOK(ecode3)) {
+       SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "Layer_CreateField" "', argument " "3"" of type '" "int""'");
+     } 
+     arg3 = static_cast< int >(val3);
+   }
+   {
+     CPLErrorReset();
+     result = (OGRErr)OGRLayerShadow_CreateField(arg1,arg2,arg3);
+     CPLErr eclass = CPLGetLastErrorType();
+     if ( eclass == CE_Failure || eclass == CE_Fatal ) {
+       SWIG_exception( SWIG_RuntimeError, CPLGetLastErrorMsg() );
+       
+     }
+     
+     
+     
+     
+     
+     
+     
+     
+     
+     
+     
+   }
+   {
+     /* %typemap(out) OGRErr */
+     if (result != 0) {
+       Tcl_SetResult(interp, (char*) OGRErrMessages(result), TCL_STATIC);
+       SWIG_fail;
+     }
+   }
+   {
+     /* %typemap(ret) OGRErr */
+     if (!strcmp(Tcl_GetStringResult(interp), "{}") || !strcmp(Tcl_GetStringResult(interp), "")) {
+       Tcl_SetObjResult(interp, Tcl_NewLongObj( result ));
+     }
+   }
+   return TCL_OK;
+ fail:
+   return TCL_ERROR;
+ }
+ 
+ 
+ SWIGINTERN int
+ _wrap_Layer_StartTransaction(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
+   OGRLayerShadow *arg1 = (OGRLayerShadow *) 0 ;
+   void *argp1 = 0 ;
+   int res1 = 0 ;
+   OGRErr result;
+   
+   if (SWIG_GetArgs(interp, objc, objv,"o:osgeo::Layer_StartTransaction self ",(void *)0) == TCL_ERROR) SWIG_fail;
+   res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_OGRLayerShadow, 0 |  0 );
+   if (!SWIG_IsOK(res1)) {
+     SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Layer_StartTransaction" "', argument " "1"" of type '" "OGRLayerShadow *""'"); 
+   }
+   arg1 = reinterpret_cast< OGRLayerShadow * >(argp1);
+   {
+     CPLErrorReset();
+     result = (OGRErr)OGRLayerShadow_StartTransaction(arg1);
+     CPLErr eclass = CPLGetLastErrorType();
+     if ( eclass == CE_Failure || eclass == CE_Fatal ) {
+       SWIG_exception( SWIG_RuntimeError, CPLGetLastErrorMsg() );
+       
+     }
+     
+     
+     
+     
+     
+     
+     
+     
+     
+     
+     
+   }
+   {
+     /* %typemap(out) OGRErr */
+     if (result != 0) {
+       Tcl_SetResult(interp, (char*) OGRErrMessages(result), TCL_STATIC);
+       SWIG_fail;
+     }
+   }
+   {
+     /* %typemap(ret) OGRErr */
+     if (!strcmp(Tcl_GetStringResult(interp), "{}") || !strcmp(Tcl_GetStringResult(interp), "")) {
+       Tcl_SetObjResult(interp, Tcl_NewLongObj( result ));
+     }
+   }
+   return TCL_OK;
+ fail:
+   return TCL_ERROR;
+ }
+ 
+ 
+ SWIGINTERN int
+ _wrap_Layer_CommitTransaction(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
+   OGRLayerShadow *arg1 = (OGRLayerShadow *) 0 ;
+   void *argp1 = 0 ;
+   int res1 = 0 ;
+   OGRErr result;
+   
+   if (SWIG_GetArgs(interp, objc, objv,"o:osgeo::Layer_CommitTransaction self ",(void *)0) == TCL_ERROR) SWIG_fail;
+   res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_OGRLayerShadow, 0 |  0 );
+   if (!SWIG_IsOK(res1)) {
+     SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Layer_CommitTransaction" "', argument " "1"" of type '" "OGRLayerShadow *""'"); 
+   }
+   arg1 = reinterpret_cast< OGRLayerShadow * >(argp1);
+   {
+     CPLErrorReset();
+     result = (OGRErr)OGRLayerShadow_CommitTransaction(arg1);
+     CPLErr eclass = CPLGetLastErrorType();
+     if ( eclass == CE_Failure || eclass == CE_Fatal ) {
+       SWIG_exception( SWIG_RuntimeError, CPLGetLastErrorMsg() );
+       
+     }
+     
+     
+     
+     
+     
+     
+     
+     
+     
+     
+     
+   }
+   {
+     /* %typemap(out) OGRErr */
+     if (result != 0) {
+       Tcl_SetResult(interp, (char*) OGRErrMessages(result), TCL_STATIC);
+       SWIG_fail;
+     }
+   }
+   {
+     /* %typemap(ret) OGRErr */
+     if (!strcmp(Tcl_GetStringResult(interp), "{}") || !strcmp(Tcl_GetStringResult(interp), "")) {
+       Tcl_SetObjResult(interp, Tcl_NewLongObj( result ));
+     }
+   }
+   return TCL_OK;
+ fail:
+   return TCL_ERROR;
+ }
+ 
+ 
+ SWIGINTERN int
+ _wrap_Layer_RollbackTransaction(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
+   OGRLayerShadow *arg1 = (OGRLayerShadow *) 0 ;
+   void *argp1 = 0 ;
+   int res1 = 0 ;
+   OGRErr result;
+   
+   if (SWIG_GetArgs(interp, objc, objv,"o:osgeo::Layer_RollbackTransaction self ",(void *)0) == TCL_ERROR) SWIG_fail;
+   res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_OGRLayerShadow, 0 |  0 );
+   if (!SWIG_IsOK(res1)) {
+     SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Layer_RollbackTransaction" "', argument " "1"" of type '" "OGRLayerShadow *""'"); 
+   }
+   arg1 = reinterpret_cast< OGRLayerShadow * >(argp1);
+   {
+     CPLErrorReset();
+     result = (OGRErr)OGRLayerShadow_RollbackTransaction(arg1);
+     CPLErr eclass = CPLGetLastErrorType();
+     if ( eclass == CE_Failure || eclass == CE_Fatal ) {
+       SWIG_exception( SWIG_RuntimeError, CPLGetLastErrorMsg() );
+       
+     }
+     
+     
+     
+     
+     
+     
+     
+     
+     
+     
+     
+   }
+   {
+     /* %typemap(out) OGRErr */
+     if (result != 0) {
+       Tcl_SetResult(interp, (char*) OGRErrMessages(result), TCL_STATIC);
+       SWIG_fail;
+     }
+   }
+   {
+     /* %typemap(ret) OGRErr */
+     if (!strcmp(Tcl_GetStringResult(interp), "{}") || !strcmp(Tcl_GetStringResult(interp), "")) {
+       Tcl_SetObjResult(interp, Tcl_NewLongObj( result ));
+     }
+   }
+   return TCL_OK;
+ fail:
+   return TCL_ERROR;
+ }
+ 
+ 
+ SWIGINTERN int
+ _wrap_Layer_GetSpatialRef(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
+   OGRLayerShadow *arg1 = (OGRLayerShadow *) 0 ;
+   void *argp1 = 0 ;
+   int res1 = 0 ;
+   OSRSpatialReferenceShadow *result = 0 ;
+   
+   if (SWIG_GetArgs(interp, objc, objv,"o:osgeo::Layer_GetSpatialRef self ",(void *)0) == TCL_ERROR) SWIG_fail;
+   res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_OGRLayerShadow, 0 |  0 );
+   if (!SWIG_IsOK(res1)) {
+     SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Layer_GetSpatialRef" "', argument " "1"" of type '" "OGRLayerShadow *""'"); 
+   }
+   arg1 = reinterpret_cast< OGRLayerShadow * >(argp1);
+   {
+     CPLErrorReset();
+     result = (OSRSpatialReferenceShadow *)OGRLayerShadow_GetSpatialRef(arg1);
+     CPLErr eclass = CPLGetLastErrorType();
+     if ( eclass == CE_Failure || eclass == CE_Fatal ) {
+       SWIG_exception( SWIG_RuntimeError, CPLGetLastErrorMsg() );
+       
+     }
+     
+     
+     
+     
+     
+     
+     
+     
+     
+     
+     
+   }
+   Tcl_SetObjResult(interp, SWIG_NewInstanceObj( SWIG_as_voidptr(result), SWIGTYPE_p_OSRSpatialReferenceShadow,0));
+   return TCL_OK;
+ fail:
+   return TCL_ERROR;
+ }
+ 
+ 
+ SWIGINTERN int
+ _wrap_Layer_GetFeaturesRead(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
+   OGRLayerShadow *arg1 = (OGRLayerShadow *) 0 ;
+   void *argp1 = 0 ;
+   int res1 = 0 ;
+   GIntBig result;
+   
+   if (SWIG_GetArgs(interp, objc, objv,"o:osgeo::Layer_GetFeaturesRead self ",(void *)0) == TCL_ERROR) SWIG_fail;
+   res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_OGRLayerShadow, 0 |  0 );
+   if (!SWIG_IsOK(res1)) {
+     SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Layer_GetFeaturesRead" "', argument " "1"" of type '" "OGRLayerShadow *""'"); 
+   }
+   arg1 = reinterpret_cast< OGRLayerShadow * >(argp1);
+   {
+     CPLErrorReset();
+     result = OGRLayerShadow_GetFeaturesRead(arg1);
+     CPLErr eclass = CPLGetLastErrorType();
+     if ( eclass == CE_Failure || eclass == CE_Fatal ) {
+       SWIG_exception( SWIG_RuntimeError, CPLGetLastErrorMsg() );
+       
+     }
+     
+     
+     
+     
+     
+     
+     
+     
+     
+     
+     
+   }
+   Tcl_SetObjResult(interp,SWIG_NewInstanceObj((new GIntBig(static_cast< const GIntBig& >(result))), SWIGTYPE_p_GIntBig, SWIG_POINTER_OWN | 0 ));
+   return TCL_OK;
+ fail:
+   return TCL_ERROR;
+ }
+ 
+ 
+ static swig_method swig_OGRLayerShadow_methods[] = {
+     {"GetRefCount", _wrap_Layer_GetRefCount}, 
+     {"SetSpatialFilter", _wrap_Layer_SetSpatialFilter}, 
+     {"SetSpatialFilterRect", _wrap_Layer_SetSpatialFilterRect}, 
+     {"GetSpatialFilter", _wrap_Layer_GetSpatialFilter}, 
+     {"SetAttributeFilter", _wrap_Layer_SetAttributeFilter}, 
+     {"ResetReading", _wrap_Layer_ResetReading}, 
+     {"GetName", _wrap_Layer_GetName}, 
+     {"GetGeometryColumn", _wrap_Layer_GetGeometryColumn}, 
+     {"GetFIDColumn", _wrap_Layer_GetFIDColumn}, 
+     {"GetFeature", _wrap_Layer_GetFeature}, 
+     {"GetNextFeature", _wrap_Layer_GetNextFeature}, 
+     {"SetNextByIndex", _wrap_Layer_SetNextByIndex}, 
+     {"SetFeature", _wrap_Layer_SetFeature}, 
+     {"CreateFeature", _wrap_Layer_CreateFeature}, 
+     {"DeleteFeature", _wrap_Layer_DeleteFeature}, 
+     {"SyncToDisk", _wrap_Layer_SyncToDisk}, 
+     {"GetLayerDefn", _wrap_Layer_GetLayerDefn}, 
+     {"GetFeatureCount", _wrap_Layer_GetFeatureCount}, 
+     {"GetExtent", _wrap_Layer_GetExtent}, 
+     {"TestCapability", _wrap_Layer_TestCapability}, 
+     {"CreateField", _wrap_Layer_CreateField}, 
+     {"StartTransaction", _wrap_Layer_StartTransaction}, 
+     {"CommitTransaction", _wrap_Layer_CommitTransaction}, 
+     {"RollbackTransaction", _wrap_Layer_RollbackTransaction}, 
+     {"GetSpatialRef", _wrap_Layer_GetSpatialRef}, 
+     {"GetFeaturesRead", _wrap_Layer_GetFeaturesRead}, 
+     {0,0}
+ };
+ static swig_attribute swig_OGRLayerShadow_attributes[] = {
+     {0,0,0}
+ };
+ static swig_class *swig_OGRLayerShadow_bases[] = {0};
+ static const char * swig_OGRLayerShadow_base_names[] = {0};
+ static swig_class _wrap_class_OGRLayerShadow = { "Layer", &SWIGTYPE_p_OGRLayerShadow,0,0, swig_OGRLayerShadow_methods, swig_OGRLayerShadow_attributes, swig_OGRLayerShadow_bases,swig_OGRLayerShadow_base_names, &swig_module };
+ SWIGINTERN int
+ _wrap_delete_Feature(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
+   OGRFeatureShadow *arg1 = (OGRFeatureShadow *) 0 ;
+   void *argp1 = 0 ;
+   int res1 = 0 ;
+   
+   if (SWIG_GetArgs(interp, objc, objv,"o:osgeo::delete_Feature self ",(void *)0) == TCL_ERROR) SWIG_fail;
+   res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_OGRFeatureShadow, SWIG_POINTER_DISOWN |  0 );
+   if (!SWIG_IsOK(res1)) {
+     SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "delete_Feature" "', argument " "1"" of type '" "OGRFeatureShadow *""'"); 
+   }
+   arg1 = reinterpret_cast< OGRFeatureShadow * >(argp1);
+   {
+     CPLErrorReset();
+     delete_OGRFeatureShadow(arg1);
+     CPLErr eclass = CPLGetLastErrorType();
+     if ( eclass == CE_Failure || eclass == CE_Fatal ) {
+       SWIG_exception( SWIG_RuntimeError, CPLGetLastErrorMsg() );
+       
+     }
+     
+     
+     
+     
+     
+     
+     
+     
+     
+     
+     
+   }
+   
+   return TCL_OK;
+ fail:
+   return TCL_ERROR;
+ }
+ 
+ 
+ SWIGINTERN int
+ _wrap_new_Feature(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
+   OGRFeatureDefnShadow *arg1 = (OGRFeatureDefnShadow *) 0 ;
+   void *argp1 = 0 ;
+   int res1 = 0 ;
+   OGRFeatureShadow *result = 0 ;
+   
+   if (SWIG_GetArgs(interp, objc, objv,"|o:osgeo::new_Feature ?feature_def? ",(void *)0) == TCL_ERROR) SWIG_fail;
+   if (objc > 1) {
+     res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_OGRFeatureDefnShadow, 0 |  0 );
+     if (!SWIG_IsOK(res1)) {
+       SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "new_Feature" "', argument " "1"" of type '" "OGRFeatureDefnShadow *""'"); 
+     }
+     arg1 = reinterpret_cast< OGRFeatureDefnShadow * >(argp1);
+   }
+   {
+     CPLErrorReset();
+     result = (OGRFeatureShadow *)new_OGRFeatureShadow(arg1);
+     CPLErr eclass = CPLGetLastErrorType();
+     if ( eclass == CE_Failure || eclass == CE_Fatal ) {
+       SWIG_exception( SWIG_RuntimeError, CPLGetLastErrorMsg() );
+       
+     }
+     
+     
+     
+     
+     
+     
+     
+     
+     
+     
+     
+   }
+   Tcl_SetObjResult(interp, SWIG_NewInstanceObj( SWIG_as_voidptr(result), SWIGTYPE_p_OGRFeatureShadow,0));
+   return TCL_OK;
+ fail:
+   return TCL_ERROR;
+ }
+ 
+ 
+ SWIGINTERN int
+ _wrap_Feature_GetDefnRef(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
+   OGRFeatureShadow *arg1 = (OGRFeatureShadow *) 0 ;
+   void *argp1 = 0 ;
+   int res1 = 0 ;
+   OGRFeatureDefnShadow *result = 0 ;
+   
+   if (SWIG_GetArgs(interp, objc, objv,"o:osgeo::Feature_GetDefnRef self ",(void *)0) == TCL_ERROR) SWIG_fail;
+   res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_OGRFeatureShadow, 0 |  0 );
+   if (!SWIG_IsOK(res1)) {
+     SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Feature_GetDefnRef" "', argument " "1"" of type '" "OGRFeatureShadow *""'"); 
+   }
+   arg1 = reinterpret_cast< OGRFeatureShadow * >(argp1);
+   {
+     CPLErrorReset();
+     result = (OGRFeatureDefnShadow *)OGRFeatureShadow_GetDefnRef(arg1);
+     CPLErr eclass = CPLGetLastErrorType();
+     if ( eclass == CE_Failure || eclass == CE_Fatal ) {
+       SWIG_exception( SWIG_RuntimeError, CPLGetLastErrorMsg() );
+       
+     }
+     
+     
+     
+     
+     
+     
+     
+     
+     
+     
+     
+   }
+   Tcl_SetObjResult(interp, SWIG_NewInstanceObj( SWIG_as_voidptr(result), SWIGTYPE_p_OGRFeatureDefnShadow,0));
+   return TCL_OK;
+ fail:
+   return TCL_ERROR;
+ }
+ 
+ 
+ SWIGINTERN int
+ _wrap_Feature_SetGeometry(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
+   OGRFeatureShadow *arg1 = (OGRFeatureShadow *) 0 ;
+   OGRGeometryShadow *arg2 = (OGRGeometryShadow *) 0 ;
+   void *argp1 = 0 ;
+   int res1 = 0 ;
+   void *argp2 = 0 ;
+   int res2 = 0 ;
+   OGRErr result;
+   
+   if (SWIG_GetArgs(interp, objc, objv,"oo:osgeo::Feature_SetGeometry self geom ",(void *)0,(void *)0) == TCL_ERROR) SWIG_fail;
+   res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_OGRFeatureShadow, 0 |  0 );
+   if (!SWIG_IsOK(res1)) {
+     SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Feature_SetGeometry" "', argument " "1"" of type '" "OGRFeatureShadow *""'"); 
+   }
+   arg1 = reinterpret_cast< OGRFeatureShadow * >(argp1);
+   res2 = SWIG_ConvertPtr(objv[2], &argp2,SWIGTYPE_p_OGRGeometryShadow, 0 |  0 );
+   if (!SWIG_IsOK(res2)) {
+     SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "Feature_SetGeometry" "', argument " "2"" of type '" "OGRGeometryShadow *""'"); 
+   }
+   arg2 = reinterpret_cast< OGRGeometryShadow * >(argp2);
+   {
+     CPLErrorReset();
+     result = (OGRErr)OGRFeatureShadow_SetGeometry(arg1,arg2);
+     CPLErr eclass = CPLGetLastErrorType();
+     if ( eclass == CE_Failure || eclass == CE_Fatal ) {
+       SWIG_exception( SWIG_RuntimeError, CPLGetLastErrorMsg() );
+       
+     }
+     
+     
+     
+     
+     
+     
+     
+     
+     
+     
+     
+   }
+   {
+     /* %typemap(out) OGRErr */
+     if (result != 0) {
+       Tcl_SetResult(interp, (char*) OGRErrMessages(result), TCL_STATIC);
+       SWIG_fail;
+     }
+   }
+   {
+     /* %typemap(ret) OGRErr */
+     if (!strcmp(Tcl_GetStringResult(interp), "{}") || !strcmp(Tcl_GetStringResult(interp), "")) {
+       Tcl_SetObjResult(interp, Tcl_NewLongObj( result ));
+     }
+   }
+   return TCL_OK;
+ fail:
+   return TCL_ERROR;
+ }
+ 
+ 
+ SWIGINTERN int
+ _wrap_Feature_SetGeometryDirectly(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
+   OGRFeatureShadow *arg1 = (OGRFeatureShadow *) 0 ;
+   OGRGeometryShadow *arg2 = (OGRGeometryShadow *) 0 ;
+   void *argp1 = 0 ;
+   int res1 = 0 ;
+   int res2 = 0 ;
+   OGRErr result;
+   
+   if (SWIG_GetArgs(interp, objc, objv,"oo:osgeo::Feature_SetGeometryDirectly self geom ",(void *)0,(void *)0) == TCL_ERROR) SWIG_fail;
+   res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_OGRFeatureShadow, 0 |  0 );
+   if (!SWIG_IsOK(res1)) {
+     SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Feature_SetGeometryDirectly" "', argument " "1"" of type '" "OGRFeatureShadow *""'"); 
+   }
+   arg1 = reinterpret_cast< OGRFeatureShadow * >(argp1);
+   res2 = SWIG_ConvertPtr(objv[2], SWIG_as_voidptrptr(&arg2), SWIGTYPE_p_OGRGeometryShadow, SWIG_POINTER_DISOWN |  0 );
+   if (!SWIG_IsOK(res2)) {
+     SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "Feature_SetGeometryDirectly" "', argument " "2"" of type '" "OGRGeometryShadow *""'");
+   }
+   {
+     CPLErrorReset();
+     result = (OGRErr)OGRFeatureShadow_SetGeometryDirectly(arg1,arg2);
+     CPLErr eclass = CPLGetLastErrorType();
+     if ( eclass == CE_Failure || eclass == CE_Fatal ) {
+       SWIG_exception( SWIG_RuntimeError, CPLGetLastErrorMsg() );
+       
+     }
+     
+     
+     
+     
+     
+     
+     
+     
+     
+     
+     
+   }
+   {
+     /* %typemap(out) OGRErr */
+     if (result != 0) {
+       Tcl_SetResult(interp, (char*) OGRErrMessages(result), TCL_STATIC);
+       SWIG_fail;
+     }
+   }
+   {
+     /* %typemap(ret) OGRErr */
+     if (!strcmp(Tcl_GetStringResult(interp), "{}") || !strcmp(Tcl_GetStringResult(interp), "")) {
+       Tcl_SetObjResult(interp, Tcl_NewLongObj( result ));
+     }
+   }
+   return TCL_OK;
+ fail:
+   return TCL_ERROR;
+ }
+ 
+ 
+ SWIGINTERN int
+ _wrap_Feature_GetGeometryRef(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
+   OGRFeatureShadow *arg1 = (OGRFeatureShadow *) 0 ;
+   void *argp1 = 0 ;
+   int res1 = 0 ;
+   OGRGeometryShadow *result = 0 ;
+   
+   if (SWIG_GetArgs(interp, objc, objv,"o:osgeo::Feature_GetGeometryRef self ",(void *)0) == TCL_ERROR) SWIG_fail;
+   res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_OGRFeatureShadow, 0 |  0 );
+   if (!SWIG_IsOK(res1)) {
+     SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Feature_GetGeometryRef" "', argument " "1"" of type '" "OGRFeatureShadow *""'"); 
+   }
+   arg1 = reinterpret_cast< OGRFeatureShadow * >(argp1);
+   {
+     CPLErrorReset();
+     result = (OGRGeometryShadow *)OGRFeatureShadow_GetGeometryRef(arg1);
+     CPLErr eclass = CPLGetLastErrorType();
+     if ( eclass == CE_Failure || eclass == CE_Fatal ) {
+       SWIG_exception( SWIG_RuntimeError, CPLGetLastErrorMsg() );
+       
+     }
+     
+     
+     
+     
+     
+     
+     
+     
+     
+     
+     
+   }
+   Tcl_SetObjResult(interp, SWIG_NewInstanceObj( SWIG_as_voidptr(result), SWIGTYPE_p_OGRGeometryShadow,0));
+   return TCL_OK;
+ fail:
+   return TCL_ERROR;
+ }
+ 
+ 
+ SWIGINTERN int
+ _wrap_Feature_Clone(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
+   OGRFeatureShadow *arg1 = (OGRFeatureShadow *) 0 ;
+   void *argp1 = 0 ;
+   int res1 = 0 ;
+   OGRFeatureShadow *result = 0 ;
+   
+   if (SWIG_GetArgs(interp, objc, objv,"o:osgeo::Feature_Clone self ",(void *)0) == TCL_ERROR) SWIG_fail;
+   res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_OGRFeatureShadow, 0 |  0 );
+   if (!SWIG_IsOK(res1)) {
+     SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Feature_Clone" "', argument " "1"" of type '" "OGRFeatureShadow *""'"); 
+   }
+   arg1 = reinterpret_cast< OGRFeatureShadow * >(argp1);
+   {
+     CPLErrorReset();
+     result = (OGRFeatureShadow *)OGRFeatureShadow_Clone(arg1);
+     CPLErr eclass = CPLGetLastErrorType();
+     if ( eclass == CE_Failure || eclass == CE_Fatal ) {
+       SWIG_exception( SWIG_RuntimeError, CPLGetLastErrorMsg() );
+       
+     }
+     
+     
+     
+     
+     
+     
+     
+     
+     
+     
+     
+   }
+   Tcl_SetObjResult(interp, SWIG_NewInstanceObj( SWIG_as_voidptr(result), SWIGTYPE_p_OGRFeatureShadow,0));
+   return TCL_OK;
+ fail:
+   return TCL_ERROR;
+ }
+ 
+ 
+ SWIGINTERN int
+ _wrap_Feature_Equal(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
+   OGRFeatureShadow *arg1 = (OGRFeatureShadow *) 0 ;
+   OGRFeatureShadow *arg2 = (OGRFeatureShadow *) 0 ;
+   void *argp1 = 0 ;
+   int res1 = 0 ;
+   void *argp2 = 0 ;
+   int res2 = 0 ;
+   bool result;
+   
+   if (SWIG_GetArgs(interp, objc, objv,"oo:osgeo::Feature_Equal self feature ",(void *)0,(void *)0) == TCL_ERROR) SWIG_fail;
+   res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_OGRFeatureShadow, 0 |  0 );
+   if (!SWIG_IsOK(res1)) {
+     SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Feature_Equal" "', argument " "1"" of type '" "OGRFeatureShadow *""'"); 
+   }
+   arg1 = reinterpret_cast< OGRFeatureShadow * >(argp1);
+   res2 = SWIG_ConvertPtr(objv[2], &argp2,SWIGTYPE_p_OGRFeatureShadow, 0 |  0 );
+   if (!SWIG_IsOK(res2)) {
+     SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "Feature_Equal" "', argument " "2"" of type '" "OGRFeatureShadow *""'"); 
+   }
+   arg2 = reinterpret_cast< OGRFeatureShadow * >(argp2);
+   {
+     CPLErrorReset();
+     result = (bool)OGRFeatureShadow_Equal(arg1,arg2);
+     CPLErr eclass = CPLGetLastErrorType();
+     if ( eclass == CE_Failure || eclass == CE_Fatal ) {
+       SWIG_exception( SWIG_RuntimeError, CPLGetLastErrorMsg() );
+       
+     }
+     
+     
+     
+     
+     
+     
+     
+     
+     
+     
+     
+   }
+   Tcl_SetObjResult(interp,SWIG_From_bool(static_cast< bool >(result)));
+   return TCL_OK;
+ fail:
+   return TCL_ERROR;
+ }
+ 
+ 
+ SWIGINTERN int
+ _wrap_Feature_GetFieldCount(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
+   OGRFeatureShadow *arg1 = (OGRFeatureShadow *) 0 ;
+   void *argp1 = 0 ;
+   int res1 = 0 ;
+   int result;
+   
+   if (SWIG_GetArgs(interp, objc, objv,"o:osgeo::Feature_GetFieldCount self ",(void *)0) == TCL_ERROR) SWIG_fail;
+   res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_OGRFeatureShadow, 0 |  0 );
+   if (!SWIG_IsOK(res1)) {
+     SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Feature_GetFieldCount" "', argument " "1"" of type '" "OGRFeatureShadow *""'"); 
+   }
+   arg1 = reinterpret_cast< OGRFeatureShadow * >(argp1);
+   {
+     CPLErrorReset();
+     result = (int)OGRFeatureShadow_GetFieldCount(arg1);
+     CPLErr eclass = CPLGetLastErrorType();
+     if ( eclass == CE_Failure || eclass == CE_Fatal ) {
+       SWIG_exception( SWIG_RuntimeError, CPLGetLastErrorMsg() );
+       
+     }
+     
+     
+     
+     
+     
+     
+     
+     
+     
+     
+     
+   }
+   Tcl_SetObjResult(interp,SWIG_From_int(static_cast< int >(result)));
+   return TCL_OK;
+ fail:
+   return TCL_ERROR;
+ }
+ 
+ 
+ SWIGINTERN int
+ _wrap_Feature_GetFieldDefnRef__SWIG_0(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
+   OGRFeatureShadow *arg1 = (OGRFeatureShadow *) 0 ;
+   int arg2 ;
+   void *argp1 = 0 ;
+   int res1 = 0 ;
+   int val2 ;
+   int ecode2 = 0 ;
+   OGRFieldDefnShadow *result = 0 ;
+   
+   if (SWIG_GetArgs(interp, objc, objv,"oo:osgeo::Feature_GetFieldDefnRef self id ",(void *)0,(void *)0) == TCL_ERROR) SWIG_fail;
+   res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_OGRFeatureShadow, 0 |  0 );
+   if (!SWIG_IsOK(res1)) {
+     SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Feature_GetFieldDefnRef" "', argument " "1"" of type '" "OGRFeatureShadow *""'"); 
+   }
+   arg1 = reinterpret_cast< OGRFeatureShadow * >(argp1);
+   ecode2 = SWIG_AsVal_int SWIG_TCL_CALL_ARGS_2(objv[2], &val2);
+   if (!SWIG_IsOK(ecode2)) {
+     SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "Feature_GetFieldDefnRef" "', argument " "2"" of type '" "int""'");
+   } 
+   arg2 = static_cast< int >(val2);
+   {
+     CPLErrorReset();
+     result = (OGRFieldDefnShadow *)OGRFeatureShadow_GetFieldDefnRef__SWIG_0(arg1,arg2);
+     CPLErr eclass = CPLGetLastErrorType();
+     if ( eclass == CE_Failure || eclass == CE_Fatal ) {
+       SWIG_exception( SWIG_RuntimeError, CPLGetLastErrorMsg() );
+       
+     }
+     
+     
+     
+     
+     
+     
+     
+     
+     
+     
+     
+   }
+   Tcl_SetObjResult(interp, SWIG_NewInstanceObj( SWIG_as_voidptr(result), SWIGTYPE_p_OGRFieldDefnShadow,0));
+   return TCL_OK;
+ fail:
+   return TCL_ERROR;
+ }
+ 
+ 
+ SWIGINTERN int
+ _wrap_Feature_GetFieldDefnRef__SWIG_1(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
+   OGRFeatureShadow *arg1 = (OGRFeatureShadow *) 0 ;
+   char *arg2 = (char *) 0 ;
+   void *argp1 = 0 ;
+   int res1 = 0 ;
+   int res2 ;
+   char *buf2 = 0 ;
+   int alloc2 = 0 ;
+   OGRFieldDefnShadow *result = 0 ;
+   
+   if (SWIG_GetArgs(interp, objc, objv,"oo:osgeo::Feature_GetFieldDefnRef self name ",(void *)0,(void *)0) == TCL_ERROR) SWIG_fail;
+   res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_OGRFeatureShadow, 0 |  0 );
+   if (!SWIG_IsOK(res1)) {
+     SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Feature_GetFieldDefnRef" "', argument " "1"" of type '" "OGRFeatureShadow *""'"); 
+   }
+   arg1 = reinterpret_cast< OGRFeatureShadow * >(argp1);
+   res2 = SWIG_AsCharPtrAndSize(objv[2], &buf2, NULL, &alloc2);
+   if (!SWIG_IsOK(res2)) {
+     SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "Feature_GetFieldDefnRef" "', argument " "2"" of type '" "char const *""'");
+   }
+   arg2 = reinterpret_cast< char * >(buf2);
+   {
+     CPLErrorReset();
+     result = (OGRFieldDefnShadow *)OGRFeatureShadow_GetFieldDefnRef__SWIG_1(arg1,(char const *)arg2);
+     CPLErr eclass = CPLGetLastErrorType();
+     if ( eclass == CE_Failure || eclass == CE_Fatal ) {
+       SWIG_exception( SWIG_RuntimeError, CPLGetLastErrorMsg() );
+       
+     }
+     
+     
+     
+     
+     
+     
+     
+     
+     
+     
+     
+   }
+   Tcl_SetObjResult(interp, SWIG_NewInstanceObj( SWIG_as_voidptr(result), SWIGTYPE_p_OGRFieldDefnShadow,0));
+   if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
+   return TCL_OK;
+ fail:
+   if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
+   return TCL_ERROR;
+ }
+ 
+ 
+ SWIGINTERN int
+ _wrap_Feature_GetFieldDefnRef(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
+   Tcl_Obj *CONST *argv = objv+1;
+   int argc = objc-1;
+   if (argc == 2) {
+     int _v;
+     void *vptr = 0;
+     int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_OGRFeatureShadow, 0);
+     _v = SWIG_CheckState(res);
+     if (_v) {
+       {
+         int res = SWIG_AsVal_int SWIG_TCL_CALL_ARGS_2(argv[1], NULL);
+         _v = SWIG_CheckState(res);
+       }
+       if (_v) {
+         return _wrap_Feature_GetFieldDefnRef__SWIG_0(clientData, interp, objc, argv - 1);
+       }
+     }
+   }
+   if (argc == 2) {
+     int _v;
+     void *vptr = 0;
+     int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_OGRFeatureShadow, 0);
+     _v = SWIG_CheckState(res);
+     if (_v) {
+       int res = SWIG_AsCharPtrAndSize(argv[1], 0, NULL, 0);
+       _v = SWIG_CheckState(res);
+       if (_v) {
+         return _wrap_Feature_GetFieldDefnRef__SWIG_1(clientData, interp, objc, argv - 1);
+       }
+     }
+   }
+   
+   Tcl_SetResult(interp,(char *) "No matching function for overloaded 'Feature_GetFieldDefnRef'", TCL_STATIC);
+   return TCL_ERROR;
+ }
+ 
+ 
+ SWIGINTERN int
+ _wrap_Feature_GetFieldAsString__SWIG_0(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
+   OGRFeatureShadow *arg1 = (OGRFeatureShadow *) 0 ;
+   int arg2 ;
+   void *argp1 = 0 ;
+   int res1 = 0 ;
+   int val2 ;
+   int ecode2 = 0 ;
+   char *result = 0 ;
+   
+   if (SWIG_GetArgs(interp, objc, objv,"oo:osgeo::Feature_GetFieldAsString self id ",(void *)0,(void *)0) == TCL_ERROR) SWIG_fail;
+   res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_OGRFeatureShadow, 0 |  0 );
+   if (!SWIG_IsOK(res1)) {
+     SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Feature_GetFieldAsString" "', argument " "1"" of type '" "OGRFeatureShadow *""'"); 
+   }
+   arg1 = reinterpret_cast< OGRFeatureShadow * >(argp1);
+   ecode2 = SWIG_AsVal_int SWIG_TCL_CALL_ARGS_2(objv[2], &val2);
+   if (!SWIG_IsOK(ecode2)) {
+     SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "Feature_GetFieldAsString" "', argument " "2"" of type '" "int""'");
+   } 
+   arg2 = static_cast< int >(val2);
+   {
+     CPLErrorReset();
+     result = (char *)OGRFeatureShadow_GetFieldAsString__SWIG_0(arg1,arg2);
+     CPLErr eclass = CPLGetLastErrorType();
+     if ( eclass == CE_Failure || eclass == CE_Fatal ) {
+       SWIG_exception( SWIG_RuntimeError, CPLGetLastErrorMsg() );
+       
+     }
+     
+     
+     
+     
+     
+     
+     
+     
+     
+     
+     
+   }
+   Tcl_SetObjResult(interp,SWIG_FromCharPtr((const char *)result));
+   return TCL_OK;
+ fail:
+   return TCL_ERROR;
+ }
+ 
+ 
+ SWIGINTERN int
+ _wrap_Feature_GetFieldAsString__SWIG_1(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
+   OGRFeatureShadow *arg1 = (OGRFeatureShadow *) 0 ;
+   char *arg2 = (char *) 0 ;
+   void *argp1 = 0 ;
+   int res1 = 0 ;
+   int res2 ;
+   char *buf2 = 0 ;
+   int alloc2 = 0 ;
+   char *result = 0 ;
+   
+   if (SWIG_GetArgs(interp, objc, objv,"oo:osgeo::Feature_GetFieldAsString self name ",(void *)0,(void *)0) == TCL_ERROR) SWIG_fail;
+   res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_OGRFeatureShadow, 0 |  0 );
+   if (!SWIG_IsOK(res1)) {
+     SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Feature_GetFieldAsString" "', argument " "1"" of type '" "OGRFeatureShadow *""'"); 
+   }
+   arg1 = reinterpret_cast< OGRFeatureShadow * >(argp1);
+   res2 = SWIG_AsCharPtrAndSize(objv[2], &buf2, NULL, &alloc2);
+   if (!SWIG_IsOK(res2)) {
+     SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "Feature_GetFieldAsString" "', argument " "2"" of type '" "char const *""'");
+   }
+   arg2 = reinterpret_cast< char * >(buf2);
+   {
+     CPLErrorReset();
+     result = (char *)OGRFeatureShadow_GetFieldAsString__SWIG_1(arg1,(char const *)arg2);
+     CPLErr eclass = CPLGetLastErrorType();
+     if ( eclass == CE_Failure || eclass == CE_Fatal ) {
+       SWIG_exception( SWIG_RuntimeError, CPLGetLastErrorMsg() );
+       
+     }
+     
+     
+     
+     
+     
+     
+     
+     
+     
+     
+     
+   }
+   Tcl_SetObjResult(interp,SWIG_FromCharPtr((const char *)result));
+   if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
+   return TCL_OK;
+ fail:
+   if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
+   return TCL_ERROR;
+ }
+ 
+ 
+ SWIGINTERN int
+ _wrap_Feature_GetFieldAsString(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
+   Tcl_Obj *CONST *argv = objv+1;
+   int argc = objc-1;
+   if (argc == 2) {
+     int _v;
+     void *vptr = 0;
+     int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_OGRFeatureShadow, 0);
+     _v = SWIG_CheckState(res);
+     if (_v) {
+       {
+         int res = SWIG_AsVal_int SWIG_TCL_CALL_ARGS_2(argv[1], NULL);
+         _v = SWIG_CheckState(res);
+       }
+       if (_v) {
+         return _wrap_Feature_GetFieldAsString__SWIG_0(clientData, interp, objc, argv - 1);
+       }
+     }
+   }
+   if (argc == 2) {
+     int _v;
+     void *vptr = 0;
+     int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_OGRFeatureShadow, 0);
+     _v = SWIG_CheckState(res);
+     if (_v) {
+       int res = SWIG_AsCharPtrAndSize(argv[1], 0, NULL, 0);
+       _v = SWIG_CheckState(res);
+       if (_v) {
+         return _wrap_Feature_GetFieldAsString__SWIG_1(clientData, interp, objc, argv - 1);
+       }
+     }
+   }
+   
+   Tcl_SetResult(interp,(char *) "No matching function for overloaded 'Feature_GetFieldAsString'", TCL_STATIC);
+   return TCL_ERROR;
+ }
+ 
+ 
+ SWIGINTERN int
+ _wrap_Feature_GetFieldAsInteger__SWIG_0(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
+   OGRFeatureShadow *arg1 = (OGRFeatureShadow *) 0 ;
+   int arg2 ;
+   void *argp1 = 0 ;
+   int res1 = 0 ;
+   int val2 ;
+   int ecode2 = 0 ;
+   int result;
+   
+   if (SWIG_GetArgs(interp, objc, objv,"oo:osgeo::Feature_GetFieldAsInteger self id ",(void *)0,(void *)0) == TCL_ERROR) SWIG_fail;
+   res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_OGRFeatureShadow, 0 |  0 );
+   if (!SWIG_IsOK(res1)) {
+     SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Feature_GetFieldAsInteger" "', argument " "1"" of type '" "OGRFeatureShadow *""'"); 
+   }
+   arg1 = reinterpret_cast< OGRFeatureShadow * >(argp1);
+   ecode2 = SWIG_AsVal_int SWIG_TCL_CALL_ARGS_2(objv[2], &val2);
+   if (!SWIG_IsOK(ecode2)) {
+     SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "Feature_GetFieldAsInteger" "', argument " "2"" of type '" "int""'");
+   } 
+   arg2 = static_cast< int >(val2);
+   {
+     CPLErrorReset();
+     result = (int)OGRFeatureShadow_GetFieldAsInteger__SWIG_0(arg1,arg2);
+     CPLErr eclass = CPLGetLastErrorType();
+     if ( eclass == CE_Failure || eclass == CE_Fatal ) {
+       SWIG_exception( SWIG_RuntimeError, CPLGetLastErrorMsg() );
+       
+     }
+     
+     
+     
+     
+     
+     
+     
+     
+     
+     
+     
+   }
+   Tcl_SetObjResult(interp,SWIG_From_int(static_cast< int >(result)));
+   return TCL_OK;
+ fail:
+   return TCL_ERROR;
+ }
+ 
+ 
+ SWIGINTERN int
+ _wrap_Feature_GetFieldAsInteger__SWIG_1(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
+   OGRFeatureShadow *arg1 = (OGRFeatureShadow *) 0 ;
+   char *arg2 = (char *) 0 ;
+   void *argp1 = 0 ;
+   int res1 = 0 ;
+   int res2 ;
+   char *buf2 = 0 ;
+   int alloc2 = 0 ;
+   int result;
+   
+   if (SWIG_GetArgs(interp, objc, objv,"oo:osgeo::Feature_GetFieldAsInteger self name ",(void *)0,(void *)0) == TCL_ERROR) SWIG_fail;
+   res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_OGRFeatureShadow, 0 |  0 );
+   if (!SWIG_IsOK(res1)) {
+     SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Feature_GetFieldAsInteger" "', argument " "1"" of type '" "OGRFeatureShadow *""'"); 
+   }
+   arg1 = reinterpret_cast< OGRFeatureShadow * >(argp1);
+   res2 = SWIG_AsCharPtrAndSize(objv[2], &buf2, NULL, &alloc2);
+   if (!SWIG_IsOK(res2)) {
+     SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "Feature_GetFieldAsInteger" "', argument " "2"" of type '" "char const *""'");
+   }
+   arg2 = reinterpret_cast< char * >(buf2);
+   {
+     CPLErrorReset();
+     result = (int)OGRFeatureShadow_GetFieldAsInteger__SWIG_1(arg1,(char const *)arg2);
+     CPLErr eclass = CPLGetLastErrorType();
+     if ( eclass == CE_Failure || eclass == CE_Fatal ) {
+       SWIG_exception( SWIG_RuntimeError, CPLGetLastErrorMsg() );
+       
+     }
+     
+     
+     
+     
+     
+     
+     
+     
+     
+     
+     
+   }
+   Tcl_SetObjResult(interp,SWIG_From_int(static_cast< int >(result)));
+   if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
+   return TCL_OK;
+ fail:
+   if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
+   return TCL_ERROR;
+ }
+ 
+ 
+ SWIGINTERN int
+ _wrap_Feature_GetFieldAsInteger(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
+   Tcl_Obj *CONST *argv = objv+1;
+   int argc = objc-1;
+   if (argc == 2) {
+     int _v;
+     void *vptr = 0;
+     int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_OGRFeatureShadow, 0);
+     _v = SWIG_CheckState(res);
+     if (_v) {
+       {
+         int res = SWIG_AsVal_int SWIG_TCL_CALL_ARGS_2(argv[1], NULL);
+         _v = SWIG_CheckState(res);
+       }
+       if (_v) {
+         return _wrap_Feature_GetFieldAsInteger__SWIG_0(clientData, interp, objc, argv - 1);
+       }
+     }
+   }
+   if (argc == 2) {
+     int _v;
+     void *vptr = 0;
+     int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_OGRFeatureShadow, 0);
+     _v = SWIG_CheckState(res);
+     if (_v) {
+       int res = SWIG_AsCharPtrAndSize(argv[1], 0, NULL, 0);
+       _v = SWIG_CheckState(res);
+       if (_v) {
+         return _wrap_Feature_GetFieldAsInteger__SWIG_1(clientData, interp, objc, argv - 1);
+       }
+     }
+   }
+   
+   Tcl_SetResult(interp,(char *) "No matching function for overloaded 'Feature_GetFieldAsInteger'", TCL_STATIC);
+   return TCL_ERROR;
+ }
+ 
+ 
+ SWIGINTERN int
+ _wrap_Feature_GetFieldAsDouble__SWIG_0(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
+   OGRFeatureShadow *arg1 = (OGRFeatureShadow *) 0 ;
+   int arg2 ;
+   void *argp1 = 0 ;
+   int res1 = 0 ;
+   int val2 ;
+   int ecode2 = 0 ;
+   double result;
+   
+   if (SWIG_GetArgs(interp, objc, objv,"oo:osgeo::Feature_GetFieldAsDouble self id ",(void *)0,(void *)0) == TCL_ERROR) SWIG_fail;
+   res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_OGRFeatureShadow, 0 |  0 );
+   if (!SWIG_IsOK(res1)) {
+     SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Feature_GetFieldAsDouble" "', argument " "1"" of type '" "OGRFeatureShadow *""'"); 
+   }
+   arg1 = reinterpret_cast< OGRFeatureShadow * >(argp1);
+   ecode2 = SWIG_AsVal_int SWIG_TCL_CALL_ARGS_2(objv[2], &val2);
+   if (!SWIG_IsOK(ecode2)) {
+     SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "Feature_GetFieldAsDouble" "', argument " "2"" of type '" "int""'");
+   } 
+   arg2 = static_cast< int >(val2);
+   {
+     CPLErrorReset();
+     result = (double)OGRFeatureShadow_GetFieldAsDouble__SWIG_0(arg1,arg2);
+     CPLErr eclass = CPLGetLastErrorType();
+     if ( eclass == CE_Failure || eclass == CE_Fatal ) {
+       SWIG_exception( SWIG_RuntimeError, CPLGetLastErrorMsg() );
+       
+     }
+     
+     
+     
+     
+     
+     
+     
+     
+     
+     
+     
+   }
+   Tcl_SetObjResult(interp,SWIG_From_double(static_cast< double >(result)));
+   return TCL_OK;
+ fail:
+   return TCL_ERROR;
+ }
+ 
+ 
+ SWIGINTERN int
+ _wrap_Feature_GetFieldAsDouble__SWIG_1(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
+   OGRFeatureShadow *arg1 = (OGRFeatureShadow *) 0 ;
+   char *arg2 = (char *) 0 ;
+   void *argp1 = 0 ;
+   int res1 = 0 ;
+   int res2 ;
+   char *buf2 = 0 ;
+   int alloc2 = 0 ;
+   double result;
+   
+   if (SWIG_GetArgs(interp, objc, objv,"oo:osgeo::Feature_GetFieldAsDouble self name ",(void *)0,(void *)0) == TCL_ERROR) SWIG_fail;
+   res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_OGRFeatureShadow, 0 |  0 );
+   if (!SWIG_IsOK(res1)) {
+     SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Feature_GetFieldAsDouble" "', argument " "1"" of type '" "OGRFeatureShadow *""'"); 
+   }
+   arg1 = reinterpret_cast< OGRFeatureShadow * >(argp1);
+   res2 = SWIG_AsCharPtrAndSize(objv[2], &buf2, NULL, &alloc2);
+   if (!SWIG_IsOK(res2)) {
+     SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "Feature_GetFieldAsDouble" "', argument " "2"" of type '" "char const *""'");
+   }
+   arg2 = reinterpret_cast< char * >(buf2);
+   {
+     CPLErrorReset();
+     result = (double)OGRFeatureShadow_GetFieldAsDouble__SWIG_1(arg1,(char const *)arg2);
+     CPLErr eclass = CPLGetLastErrorType();
+     if ( eclass == CE_Failure || eclass == CE_Fatal ) {
+       SWIG_exception( SWIG_RuntimeError, CPLGetLastErrorMsg() );
+       
+     }
+     
+     
+     
+     
+     
+     
+     
+     
+     
+     
+     
+   }
+   Tcl_SetObjResult(interp,SWIG_From_double(static_cast< double >(result)));
+   if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
+   return TCL_OK;
+ fail:
+   if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
+   return TCL_ERROR;
+ }
+ 
+ 
+ SWIGINTERN int
+ _wrap_Feature_GetFieldAsDouble(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
+   Tcl_Obj *CONST *argv = objv+1;
+   int argc = objc-1;
+   if (argc == 2) {
+     int _v;
+     void *vptr = 0;
+     int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_OGRFeatureShadow, 0);
+     _v = SWIG_CheckState(res);
+     if (_v) {
+       {
+         int res = SWIG_AsVal_int SWIG_TCL_CALL_ARGS_2(argv[1], NULL);
+         _v = SWIG_CheckState(res);
+       }
+       if (_v) {
+         return _wrap_Feature_GetFieldAsDouble__SWIG_0(clientData, interp, objc, argv - 1);
+       }
+     }
+   }
+   if (argc == 2) {
+     int _v;
+     void *vptr = 0;
+     int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_OGRFeatureShadow, 0);
+     _v = SWIG_CheckState(res);
+     if (_v) {
+       int res = SWIG_AsCharPtrAndSize(argv[1], 0, NULL, 0);
+       _v = SWIG_CheckState(res);
+       if (_v) {
+         return _wrap_Feature_GetFieldAsDouble__SWIG_1(clientData, interp, objc, argv - 1);
+       }
+     }
+   }
+   
+   Tcl_SetResult(interp,(char *) "No matching function for overloaded 'Feature_GetFieldAsDouble'", TCL_STATIC);
+   return TCL_ERROR;
+ }
+ 
+ 
+ SWIGINTERN int
+ _wrap_Feature_GetFieldAsDateTime(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
+   OGRFeatureShadow *arg1 = (OGRFeatureShadow *) 0 ;
+   int arg2 ;
+   int *arg3 = (int *) 0 ;
+   int *arg4 = (int *) 0 ;
+   int *arg5 = (int *) 0 ;
+   int *arg6 = (int *) 0 ;
+   int *arg7 = (int *) 0 ;
+   int *arg8 = (int *) 0 ;
+   int *arg9 = (int *) 0 ;
+   void *argp1 = 0 ;
+   int res1 = 0 ;
+   int val2 ;
+   int ecode2 = 0 ;
+   int temp3 ;
+   int res3 = SWIG_TMPOBJ ;
+   int temp4 ;
+   int res4 = SWIG_TMPOBJ ;
+   int temp5 ;
+   int res5 = SWIG_TMPOBJ ;
+   int temp6 ;
+   int res6 = SWIG_TMPOBJ ;
+   int temp7 ;
+   int res7 = SWIG_TMPOBJ ;
+   int temp8 ;
+   int res8 = SWIG_TMPOBJ ;
+   int temp9 ;
+   int res9 = SWIG_TMPOBJ ;
+   
+   arg3 = &temp3;
+   arg4 = &temp4;
+   arg5 = &temp5;
+   arg6 = &temp6;
+   arg7 = &temp7;
+   arg8 = &temp8;
+   arg9 = &temp9;
+   if (SWIG_GetArgs(interp, objc, objv,"oo:osgeo::Feature_GetFieldAsDateTime self id ",(void *)0,(void *)0) == TCL_ERROR) SWIG_fail;
+   res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_OGRFeatureShadow, 0 |  0 );
+   if (!SWIG_IsOK(res1)) {
+     SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Feature_GetFieldAsDateTime" "', argument " "1"" of type '" "OGRFeatureShadow *""'"); 
+   }
+   arg1 = reinterpret_cast< OGRFeatureShadow * >(argp1);
+   ecode2 = SWIG_AsVal_int SWIG_TCL_CALL_ARGS_2(objv[2], &val2);
+   if (!SWIG_IsOK(ecode2)) {
+     SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "Feature_GetFieldAsDateTime" "', argument " "2"" of type '" "int""'");
+   } 
+   arg2 = static_cast< int >(val2);
+   {
+     CPLErrorReset();
+     OGRFeatureShadow_GetFieldAsDateTime(arg1,arg2,arg3,arg4,arg5,arg6,arg7,arg8,arg9);
+     CPLErr eclass = CPLGetLastErrorType();
+     if ( eclass == CE_Failure || eclass == CE_Fatal ) {
+       SWIG_exception( SWIG_RuntimeError, CPLGetLastErrorMsg() );
+       
+     }
+     
+     
+     
+     
+     
+     
+     
+     
+     
+     
+     
+   }
+   
+   if (SWIG_IsTmpObj(res3)) {
+     Tcl_ListObjAppendElement(interp,Tcl_GetObjResult(interp),SWIG_From_int((*arg3)));
+   } else {
+     int new_flags = SWIG_IsNewObj(res3) ? (SWIG_POINTER_OWN |  0 ) :  0 ;
+     Tcl_ListObjAppendElement(interp,Tcl_GetObjResult(interp),SWIG_NewPointerObj((void*)(arg3), SWIGTYPE_p_int, new_flags));
+   }
+   if (SWIG_IsTmpObj(res4)) {
+     Tcl_ListObjAppendElement(interp,Tcl_GetObjResult(interp),SWIG_From_int((*arg4)));
+   } else {
+     int new_flags = SWIG_IsNewObj(res4) ? (SWIG_POINTER_OWN |  0 ) :  0 ;
+     Tcl_ListObjAppendElement(interp,Tcl_GetObjResult(interp),SWIG_NewPointerObj((void*)(arg4), SWIGTYPE_p_int, new_flags));
+   }
+   if (SWIG_IsTmpObj(res5)) {
+     Tcl_ListObjAppendElement(interp,Tcl_GetObjResult(interp),SWIG_From_int((*arg5)));
+   } else {
+     int new_flags = SWIG_IsNewObj(res5) ? (SWIG_POINTER_OWN |  0 ) :  0 ;
+     Tcl_ListObjAppendElement(interp,Tcl_GetObjResult(interp),SWIG_NewPointerObj((void*)(arg5), SWIGTYPE_p_int, new_flags));
+   }
+   if (SWIG_IsTmpObj(res6)) {
+     Tcl_ListObjAppendElement(interp,Tcl_GetObjResult(interp),SWIG_From_int((*arg6)));
+   } else {
+     int new_flags = SWIG_IsNewObj(res6) ? (SWIG_POINTER_OWN |  0 ) :  0 ;
+     Tcl_ListObjAppendElement(interp,Tcl_GetObjResult(interp),SWIG_NewPointerObj((void*)(arg6), SWIGTYPE_p_int, new_flags));
+   }
+   if (SWIG_IsTmpObj(res7)) {
+     Tcl_ListObjAppendElement(interp,Tcl_GetObjResult(interp),SWIG_From_int((*arg7)));
+   } else {
+     int new_flags = SWIG_IsNewObj(res7) ? (SWIG_POINTER_OWN |  0 ) :  0 ;
+     Tcl_ListObjAppendElement(interp,Tcl_GetObjResult(interp),SWIG_NewPointerObj((void*)(arg7), SWIGTYPE_p_int, new_flags));
+   }
+   if (SWIG_IsTmpObj(res8)) {
+     Tcl_ListObjAppendElement(interp,Tcl_GetObjResult(interp),SWIG_From_int((*arg8)));
+   } else {
+     int new_flags = SWIG_IsNewObj(res8) ? (SWIG_POINTER_OWN |  0 ) :  0 ;
+     Tcl_ListObjAppendElement(interp,Tcl_GetObjResult(interp),SWIG_NewPointerObj((void*)(arg8), SWIGTYPE_p_int, new_flags));
+   }
+   if (SWIG_IsTmpObj(res9)) {
+     Tcl_ListObjAppendElement(interp,Tcl_GetObjResult(interp),SWIG_From_int((*arg9)));
+   } else {
+     int new_flags = SWIG_IsNewObj(res9) ? (SWIG_POINTER_OWN |  0 ) :  0 ;
+     Tcl_ListObjAppendElement(interp,Tcl_GetObjResult(interp),SWIG_NewPointerObj((void*)(arg9), SWIGTYPE_p_int, new_flags));
+   }
+   return TCL_OK;
+ fail:
+   return TCL_ERROR;
+ }
+ 
+ 
+ SWIGINTERN int
+ _wrap_Feature_GetFieldAsIntegerList(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
+   OGRFeatureShadow *arg1 = (OGRFeatureShadow *) 0 ;
+   int arg2 ;
+   int *arg3 = (int *) 0 ;
+   int **arg4 = (int **) 0 ;
+   void *argp1 = 0 ;
+   int res1 = 0 ;
+   int val2 ;
+   int ecode2 = 0 ;
+   int nLen3 ;
+   int *pList3 ;
+   
+   {
+     /* %typemap(in,numinputs=0) (int *nLen3, const int **pList3) (int nLen3, int *pList3) */
+     arg3 = &nLen3;
+     arg4 = &pList3;
+   }
+   if (SWIG_GetArgs(interp, objc, objv,"oo:osgeo::Feature_GetFieldAsIntegerList self id ?pList? ",(void *)0,(void *)0) == TCL_ERROR) SWIG_fail;
+   res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_OGRFeatureShadow, 0 |  0 );
+   if (!SWIG_IsOK(res1)) {
+     SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Feature_GetFieldAsIntegerList" "', argument " "1"" of type '" "OGRFeatureShadow *""'"); 
+   }
+   arg1 = reinterpret_cast< OGRFeatureShadow * >(argp1);
+   ecode2 = SWIG_AsVal_int SWIG_TCL_CALL_ARGS_2(objv[2], &val2);
+   if (!SWIG_IsOK(ecode2)) {
+     SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "Feature_GetFieldAsIntegerList" "', argument " "2"" of type '" "int""'");
+   } 
+   arg2 = static_cast< int >(val2);
+   {
+     CPLErrorReset();
+     OGRFeatureShadow_GetFieldAsIntegerList(arg1,arg2,arg3,(int const **)arg4);
+     CPLErr eclass = CPLGetLastErrorType();
+     if ( eclass == CE_Failure || eclass == CE_Fatal ) {
+       SWIG_exception( SWIG_RuntimeError, CPLGetLastErrorMsg() );
+       
+     }
+     
+     
+     
+     
+     
+     
+     
+     
+     
+     
+     
+   }
+   
+   {
+     /* %typemap(argout) (int *nLen, const int **pList ) */
+     Tcl_Obj *out = Tcl_NewListObj(0, NULL);
+     for( int i=0; i<*arg3; i++ ) {
+       Tcl_Obj *val = Tcl_NewLongObj( (*arg4)[i] );
+       if (Tcl_ListObjAppendElement(interp, out, val) != TCL_OK) {
+         Tcl_DecrRefCount(val);
+         Tcl_DecrRefCount(out);
+         /* Error msg in interp result */
+         SWIG_fail;
+       }
+     }
+     Tcl_SetObjResult(interp, out);
+   }
+   return TCL_OK;
+ fail:
+   return TCL_ERROR;
+ }
+ 
+ 
+ SWIGINTERN int
+ _wrap_Feature_GetFieldAsDoubleList(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
+   OGRFeatureShadow *arg1 = (OGRFeatureShadow *) 0 ;
+   int arg2 ;
+   int *arg3 = (int *) 0 ;
+   double **arg4 = (double **) 0 ;
+   void *argp1 = 0 ;
+   int res1 = 0 ;
+   int val2 ;
+   int ecode2 = 0 ;
+   int nLen3 ;
+   double *pList3 ;
+   
+   {
+     /* %typemap(in,numinputs=0) (int *nLen3, const double **pList3) (int nLen3, double *pList3) */
+     arg3 = &nLen3;
+     arg4 = &pList3;
+   }
+   if (SWIG_GetArgs(interp, objc, objv,"oo:osgeo::Feature_GetFieldAsDoubleList self id ?pList? ",(void *)0,(void *)0) == TCL_ERROR) SWIG_fail;
+   res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_OGRFeatureShadow, 0 |  0 );
+   if (!SWIG_IsOK(res1)) {
+     SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Feature_GetFieldAsDoubleList" "', argument " "1"" of type '" "OGRFeatureShadow *""'"); 
+   }
+   arg1 = reinterpret_cast< OGRFeatureShadow * >(argp1);
+   ecode2 = SWIG_AsVal_int SWIG_TCL_CALL_ARGS_2(objv[2], &val2);
+   if (!SWIG_IsOK(ecode2)) {
+     SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "Feature_GetFieldAsDoubleList" "', argument " "2"" of type '" "int""'");
+   } 
+   arg2 = static_cast< int >(val2);
+   {
+     CPLErrorReset();
+     OGRFeatureShadow_GetFieldAsDoubleList(arg1,arg2,arg3,(double const **)arg4);
+     CPLErr eclass = CPLGetLastErrorType();
+     if ( eclass == CE_Failure || eclass == CE_Fatal ) {
+       SWIG_exception( SWIG_RuntimeError, CPLGetLastErrorMsg() );
+       
+     }
+     
+     
+     
+     
+     
+     
+     
+     
+     
+     
+     
+   }
+   
+   {
+     /* %typemap(argout) (int *nLen, const double **pList ) */
+     Tcl_Obj *out = Tcl_NewListObj(0, NULL);
+     for( int i=0; i<*arg3; i++ ) {
+       Tcl_Obj *val = Tcl_NewDoubleObj( (*arg4)[i] );
+       if (Tcl_ListObjAppendElement(interp, out, val) != TCL_OK) {
+         Tcl_DecrRefCount(val);
+         Tcl_DecrRefCount(out);
+         /* Error msg in interp result */
+         SWIG_fail;
+       }
+     }
+     Tcl_SetObjResult(interp, out);
+   }
+   return TCL_OK;
+ fail:
+   return TCL_ERROR;
+ }
+ 
+ 
+ SWIGINTERN int
+ _wrap_Feature_GetFieldAsStringList(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
+   OGRFeatureShadow *arg1 = (OGRFeatureShadow *) 0 ;
+   int arg2 ;
+   char ***arg3 = (char ***) 0 ;
+   void *argp1 = 0 ;
+   int res1 = 0 ;
+   int val2 ;
+   int ecode2 = 0 ;
+   void *argp3 = 0 ;
+   int res3 = 0 ;
+   
+   if (SWIG_GetArgs(interp, objc, objv,"ooo:osgeo::Feature_GetFieldAsStringList self id pList ",(void *)0,(void *)0,(void *)0) == TCL_ERROR) SWIG_fail;
+   res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_OGRFeatureShadow, 0 |  0 );
+   if (!SWIG_IsOK(res1)) {
+     SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Feature_GetFieldAsStringList" "', argument " "1"" of type '" "OGRFeatureShadow *""'"); 
+   }
+   arg1 = reinterpret_cast< OGRFeatureShadow * >(argp1);
+   ecode2 = SWIG_AsVal_int SWIG_TCL_CALL_ARGS_2(objv[2], &val2);
+   if (!SWIG_IsOK(ecode2)) {
+     SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "Feature_GetFieldAsStringList" "', argument " "2"" of type '" "int""'");
+   } 
+   arg2 = static_cast< int >(val2);
+   res3 = SWIG_ConvertPtr(objv[3], &argp3,SWIGTYPE_p_p_p_char, 0 |  0 );
+   if (!SWIG_IsOK(res3)) {
+     SWIG_exception_fail(SWIG_ArgError(res3), "in method '" "Feature_GetFieldAsStringList" "', argument " "3"" of type '" "char ***""'"); 
+   }
+   arg3 = reinterpret_cast< char *** >(argp3);
+   {
+     CPLErrorReset();
+     OGRFeatureShadow_GetFieldAsStringList(arg1,arg2,arg3);
+     CPLErr eclass = CPLGetLastErrorType();
+     if ( eclass == CE_Failure || eclass == CE_Fatal ) {
+       SWIG_exception( SWIG_RuntimeError, CPLGetLastErrorMsg() );
+       
+     }
+     
+     
+     
+     
+     
+     
+     
+     
+     
+     
+     
+   }
+   
+   return TCL_OK;
+ fail:
+   return TCL_ERROR;
+ }
+ 
+ 
+ SWIGINTERN int
+ _wrap_Feature_IsFieldSet__SWIG_0(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
+   OGRFeatureShadow *arg1 = (OGRFeatureShadow *) 0 ;
+   int arg2 ;
+   void *argp1 = 0 ;
+   int res1 = 0 ;
+   int val2 ;
+   int ecode2 = 0 ;
+   bool result;
+   
+   if (SWIG_GetArgs(interp, objc, objv,"oo:osgeo::Feature_IsFieldSet self id ",(void *)0,(void *)0) == TCL_ERROR) SWIG_fail;
+   res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_OGRFeatureShadow, 0 |  0 );
+   if (!SWIG_IsOK(res1)) {
+     SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Feature_IsFieldSet" "', argument " "1"" of type '" "OGRFeatureShadow *""'"); 
+   }
+   arg1 = reinterpret_cast< OGRFeatureShadow * >(argp1);
+   ecode2 = SWIG_AsVal_int SWIG_TCL_CALL_ARGS_2(objv[2], &val2);
+   if (!SWIG_IsOK(ecode2)) {
+     SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "Feature_IsFieldSet" "', argument " "2"" of type '" "int""'");
+   } 
+   arg2 = static_cast< int >(val2);
+   {
+     CPLErrorReset();
+     result = (bool)OGRFeatureShadow_IsFieldSet__SWIG_0(arg1,arg2);
+     CPLErr eclass = CPLGetLastErrorType();
+     if ( eclass == CE_Failure || eclass == CE_Fatal ) {
+       SWIG_exception( SWIG_RuntimeError, CPLGetLastErrorMsg() );
+       
+     }
+     
+     
+     
+     
+     
+     
+     
+     
+     
+     
+     
+   }
+   Tcl_SetObjResult(interp,SWIG_From_bool(static_cast< bool >(result)));
+   return TCL_OK;
+ fail:
+   return TCL_ERROR;
+ }
+ 
+ 
+ SWIGINTERN int
+ _wrap_Feature_IsFieldSet__SWIG_1(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
+   OGRFeatureShadow *arg1 = (OGRFeatureShadow *) 0 ;
+   char *arg2 = (char *) 0 ;
+   void *argp1 = 0 ;
+   int res1 = 0 ;
+   int res2 ;
+   char *buf2 = 0 ;
+   int alloc2 = 0 ;
+   bool result;
+   
+   if (SWIG_GetArgs(interp, objc, objv,"oo:osgeo::Feature_IsFieldSet self name ",(void *)0,(void *)0) == TCL_ERROR) SWIG_fail;
+   res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_OGRFeatureShadow, 0 |  0 );
+   if (!SWIG_IsOK(res1)) {
+     SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Feature_IsFieldSet" "', argument " "1"" of type '" "OGRFeatureShadow *""'"); 
+   }
+   arg1 = reinterpret_cast< OGRFeatureShadow * >(argp1);
+   res2 = SWIG_AsCharPtrAndSize(objv[2], &buf2, NULL, &alloc2);
+   if (!SWIG_IsOK(res2)) {
+     SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "Feature_IsFieldSet" "', argument " "2"" of type '" "char const *""'");
+   }
+   arg2 = reinterpret_cast< char * >(buf2);
+   {
+     CPLErrorReset();
+     result = (bool)OGRFeatureShadow_IsFieldSet__SWIG_1(arg1,(char const *)arg2);
+     CPLErr eclass = CPLGetLastErrorType();
+     if ( eclass == CE_Failure || eclass == CE_Fatal ) {
+       SWIG_exception( SWIG_RuntimeError, CPLGetLastErrorMsg() );
+       
+     }
+     
+     
+     
+     
+     
+     
+     
+     
+     
+     
+     
+   }
+   Tcl_SetObjResult(interp,SWIG_From_bool(static_cast< bool >(result)));
+   if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
+   return TCL_OK;
+ fail:
+   if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
+   return TCL_ERROR;
+ }
+ 
+ 
+ SWIGINTERN int
+ _wrap_Feature_IsFieldSet(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
+   Tcl_Obj *CONST *argv = objv+1;
+   int argc = objc-1;
+   if (argc == 2) {
+     int _v;
+     void *vptr = 0;
+     int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_OGRFeatureShadow, 0);
+     _v = SWIG_CheckState(res);
+     if (_v) {
+       {
+         int res = SWIG_AsVal_int SWIG_TCL_CALL_ARGS_2(argv[1], NULL);
+         _v = SWIG_CheckState(res);
+       }
+       if (_v) {
+         return _wrap_Feature_IsFieldSet__SWIG_0(clientData, interp, objc, argv - 1);
+       }
+     }
+   }
+   if (argc == 2) {
+     int _v;
+     void *vptr = 0;
+     int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_OGRFeatureShadow, 0);
+     _v = SWIG_CheckState(res);
+     if (_v) {
+       int res = SWIG_AsCharPtrAndSize(argv[1], 0, NULL, 0);
+       _v = SWIG_CheckState(res);
+       if (_v) {
+         return _wrap_Feature_IsFieldSet__SWIG_1(clientData, interp, objc, argv - 1);
+       }
+     }
+   }
+   
+   Tcl_SetResult(interp,(char *) "No matching function for overloaded 'Feature_IsFieldSet'", TCL_STATIC);
+   return TCL_ERROR;
+ }
+ 
+ 
+ SWIGINTERN int
+ _wrap_Feature_GetFieldIndex(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
+   OGRFeatureShadow *arg1 = (OGRFeatureShadow *) 0 ;
+   char *arg2 = (char *) 0 ;
+   void *argp1 = 0 ;
+   int res1 = 0 ;
+   int res2 ;
+   char *buf2 = 0 ;
+   int alloc2 = 0 ;
+   int result;
+   
+   if (SWIG_GetArgs(interp, objc, objv,"oo:osgeo::Feature_GetFieldIndex self name ",(void *)0,(void *)0) == TCL_ERROR) SWIG_fail;
+   res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_OGRFeatureShadow, 0 |  0 );
+   if (!SWIG_IsOK(res1)) {
+     SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Feature_GetFieldIndex" "', argument " "1"" of type '" "OGRFeatureShadow *""'"); 
+   }
+   arg1 = reinterpret_cast< OGRFeatureShadow * >(argp1);
+   res2 = SWIG_AsCharPtrAndSize(objv[2], &buf2, NULL, &alloc2);
+   if (!SWIG_IsOK(res2)) {
+     SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "Feature_GetFieldIndex" "', argument " "2"" of type '" "char const *""'");
+   }
+   arg2 = reinterpret_cast< char * >(buf2);
+   {
+     CPLErrorReset();
+     result = (int)OGRFeatureShadow_GetFieldIndex(arg1,(char const *)arg2);
+     CPLErr eclass = CPLGetLastErrorType();
+     if ( eclass == CE_Failure || eclass == CE_Fatal ) {
+       SWIG_exception( SWIG_RuntimeError, CPLGetLastErrorMsg() );
+       
+     }
+     
+     
+     
+     
+     
+     
+     
+     
+     
+     
+     
+   }
+   Tcl_SetObjResult(interp,SWIG_From_int(static_cast< int >(result)));
+   if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
+   return TCL_OK;
+ fail:
+   if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
+   return TCL_ERROR;
+ }
+ 
+ 
+ SWIGINTERN int
+ _wrap_Feature_GetFID(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
+   OGRFeatureShadow *arg1 = (OGRFeatureShadow *) 0 ;
+   void *argp1 = 0 ;
+   int res1 = 0 ;
+   int result;
+   
+   if (SWIG_GetArgs(interp, objc, objv,"o:osgeo::Feature_GetFID self ",(void *)0) == TCL_ERROR) SWIG_fail;
+   res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_OGRFeatureShadow, 0 |  0 );
+   if (!SWIG_IsOK(res1)) {
+     SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Feature_GetFID" "', argument " "1"" of type '" "OGRFeatureShadow *""'"); 
+   }
+   arg1 = reinterpret_cast< OGRFeatureShadow * >(argp1);
+   {
+     CPLErrorReset();
+     result = (int)OGRFeatureShadow_GetFID(arg1);
+     CPLErr eclass = CPLGetLastErrorType();
+     if ( eclass == CE_Failure || eclass == CE_Fatal ) {
+       SWIG_exception( SWIG_RuntimeError, CPLGetLastErrorMsg() );
+       
+     }
+     
+     
+     
+     
+     
+     
+     
+     
+     
+     
+     
+   }
+   Tcl_SetObjResult(interp,SWIG_From_int(static_cast< int >(result)));
+   return TCL_OK;
+ fail:
+   return TCL_ERROR;
+ }
+ 
+ 
+ SWIGINTERN int
+ _wrap_Feature_SetFID(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
+   OGRFeatureShadow *arg1 = (OGRFeatureShadow *) 0 ;
+   int arg2 ;
+   void *argp1 = 0 ;
+   int res1 = 0 ;
+   int val2 ;
+   int ecode2 = 0 ;
+   OGRErr result;
+   
+   if (SWIG_GetArgs(interp, objc, objv,"oo:osgeo::Feature_SetFID self fid ",(void *)0,(void *)0) == TCL_ERROR) SWIG_fail;
+   res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_OGRFeatureShadow, 0 |  0 );
+   if (!SWIG_IsOK(res1)) {
+     SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Feature_SetFID" "', argument " "1"" of type '" "OGRFeatureShadow *""'"); 
+   }
+   arg1 = reinterpret_cast< OGRFeatureShadow * >(argp1);
+   ecode2 = SWIG_AsVal_int SWIG_TCL_CALL_ARGS_2(objv[2], &val2);
+   if (!SWIG_IsOK(ecode2)) {
+     SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "Feature_SetFID" "', argument " "2"" of type '" "int""'");
+   } 
+   arg2 = static_cast< int >(val2);
+   {
+     CPLErrorReset();
+     result = (OGRErr)OGRFeatureShadow_SetFID(arg1,arg2);
+     CPLErr eclass = CPLGetLastErrorType();
+     if ( eclass == CE_Failure || eclass == CE_Fatal ) {
+       SWIG_exception( SWIG_RuntimeError, CPLGetLastErrorMsg() );
+       
+     }
+     
+     
+     
+     
+     
+     
+     
+     
+     
+     
+     
+   }
+   {
+     /* %typemap(out) OGRErr */
+     if (result != 0) {
+       Tcl_SetResult(interp, (char*) OGRErrMessages(result), TCL_STATIC);
+       SWIG_fail;
+     }
+   }
+   {
+     /* %typemap(ret) OGRErr */
+     if (!strcmp(Tcl_GetStringResult(interp), "{}") || !strcmp(Tcl_GetStringResult(interp), "")) {
+       Tcl_SetObjResult(interp, Tcl_NewLongObj( result ));
+     }
+   }
+   return TCL_OK;
+ fail:
+   return TCL_ERROR;
+ }
+ 
+ 
+ SWIGINTERN int
+ _wrap_Feature_DumpReadable(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
+   OGRFeatureShadow *arg1 = (OGRFeatureShadow *) 0 ;
+   void *argp1 = 0 ;
+   int res1 = 0 ;
+   
+   if (SWIG_GetArgs(interp, objc, objv,"o:osgeo::Feature_DumpReadable self ",(void *)0) == TCL_ERROR) SWIG_fail;
+   res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_OGRFeatureShadow, 0 |  0 );
+   if (!SWIG_IsOK(res1)) {
+     SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Feature_DumpReadable" "', argument " "1"" of type '" "OGRFeatureShadow *""'"); 
+   }
+   arg1 = reinterpret_cast< OGRFeatureShadow * >(argp1);
+   {
+     CPLErrorReset();
+     OGRFeatureShadow_DumpReadable(arg1);
+     CPLErr eclass = CPLGetLastErrorType();
+     if ( eclass == CE_Failure || eclass == CE_Fatal ) {
+       SWIG_exception( SWIG_RuntimeError, CPLGetLastErrorMsg() );
+       
+     }
+     
+     
+     
+     
+     
+     
+     
+     
+     
+     
+     
+   }
+   
+   return TCL_OK;
+ fail:
+   return TCL_ERROR;
+ }
+ 
+ 
+ SWIGINTERN int
+ _wrap_Feature_UnsetField__SWIG_0(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
+   OGRFeatureShadow *arg1 = (OGRFeatureShadow *) 0 ;
+   int arg2 ;
+   void *argp1 = 0 ;
+   int res1 = 0 ;
+   int val2 ;
+   int ecode2 = 0 ;
+   
+   if (SWIG_GetArgs(interp, objc, objv,"oo:osgeo::Feature_UnsetField self id ",(void *)0,(void *)0) == TCL_ERROR) SWIG_fail;
+   res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_OGRFeatureShadow, 0 |  0 );
+   if (!SWIG_IsOK(res1)) {
+     SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Feature_UnsetField" "', argument " "1"" of type '" "OGRFeatureShadow *""'"); 
+   }
+   arg1 = reinterpret_cast< OGRFeatureShadow * >(argp1);
+   ecode2 = SWIG_AsVal_int SWIG_TCL_CALL_ARGS_2(objv[2], &val2);
+   if (!SWIG_IsOK(ecode2)) {
+     SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "Feature_UnsetField" "', argument " "2"" of type '" "int""'");
+   } 
+   arg2 = static_cast< int >(val2);
+   {
+     CPLErrorReset();
+     OGRFeatureShadow_UnsetField__SWIG_0(arg1,arg2);
+     CPLErr eclass = CPLGetLastErrorType();
+     if ( eclass == CE_Failure || eclass == CE_Fatal ) {
+       SWIG_exception( SWIG_RuntimeError, CPLGetLastErrorMsg() );
+       
+     }
+     
+     
+     
+     
+     
+     
+     
+     
+     
+     
+     
+   }
+   
+   return TCL_OK;
+ fail:
+   return TCL_ERROR;
+ }
+ 
+ 
+ SWIGINTERN int
+ _wrap_Feature_UnsetField__SWIG_1(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
+   OGRFeatureShadow *arg1 = (OGRFeatureShadow *) 0 ;
+   char *arg2 = (char *) 0 ;
+   void *argp1 = 0 ;
+   int res1 = 0 ;
+   int res2 ;
+   char *buf2 = 0 ;
+   int alloc2 = 0 ;
+   
+   if (SWIG_GetArgs(interp, objc, objv,"oo:osgeo::Feature_UnsetField self name ",(void *)0,(void *)0) == TCL_ERROR) SWIG_fail;
+   res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_OGRFeatureShadow, 0 |  0 );
+   if (!SWIG_IsOK(res1)) {
+     SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Feature_UnsetField" "', argument " "1"" of type '" "OGRFeatureShadow *""'"); 
+   }
+   arg1 = reinterpret_cast< OGRFeatureShadow * >(argp1);
+   res2 = SWIG_AsCharPtrAndSize(objv[2], &buf2, NULL, &alloc2);
+   if (!SWIG_IsOK(res2)) {
+     SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "Feature_UnsetField" "', argument " "2"" of type '" "char const *""'");
+   }
+   arg2 = reinterpret_cast< char * >(buf2);
+   {
+     CPLErrorReset();
+     OGRFeatureShadow_UnsetField__SWIG_1(arg1,(char const *)arg2);
+     CPLErr eclass = CPLGetLastErrorType();
+     if ( eclass == CE_Failure || eclass == CE_Fatal ) {
+       SWIG_exception( SWIG_RuntimeError, CPLGetLastErrorMsg() );
+       
+     }
+     
+     
+     
+     
+     
+     
+     
+     
+     
+     
+     
+   }
+   
+   if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
+   return TCL_OK;
+ fail:
+   if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
+   return TCL_ERROR;
+ }
+ 
+ 
+ SWIGINTERN int
+ _wrap_Feature_UnsetField(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
+   Tcl_Obj *CONST *argv = objv+1;
+   int argc = objc-1;
+   if (argc == 2) {
+     int _v;
+     void *vptr = 0;
+     int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_OGRFeatureShadow, 0);
+     _v = SWIG_CheckState(res);
+     if (_v) {
+       {
+         int res = SWIG_AsVal_int SWIG_TCL_CALL_ARGS_2(argv[1], NULL);
+         _v = SWIG_CheckState(res);
+       }
+       if (_v) {
+         return _wrap_Feature_UnsetField__SWIG_0(clientData, interp, objc, argv - 1);
+       }
+     }
+   }
+   if (argc == 2) {
+     int _v;
+     void *vptr = 0;
+     int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_OGRFeatureShadow, 0);
+     _v = SWIG_CheckState(res);
+     if (_v) {
+       int res = SWIG_AsCharPtrAndSize(argv[1], 0, NULL, 0);
+       _v = SWIG_CheckState(res);
+       if (_v) {
+         return _wrap_Feature_UnsetField__SWIG_1(clientData, interp, objc, argv - 1);
+       }
+     }
+   }
+   
+   Tcl_SetResult(interp,(char *) "No matching function for overloaded 'Feature_UnsetField'", TCL_STATIC);
+   return TCL_ERROR;
+ }
+ 
+ 
+ SWIGINTERN int
+ _wrap_Feature_SetField__SWIG_0(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
+   OGRFeatureShadow *arg1 = (OGRFeatureShadow *) 0 ;
+   int arg2 ;
+   char *arg3 = (char *) 0 ;
+   void *argp1 = 0 ;
+   int res1 = 0 ;
+   int val2 ;
+   int ecode2 = 0 ;
+   
+   if (SWIG_GetArgs(interp, objc, objv,"ooo:osgeo::Feature_SetField self id value ",(void *)0,(void *)0,(void *)0) == TCL_ERROR) SWIG_fail;
+   res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_OGRFeatureShadow, 0 |  0 );
+   if (!SWIG_IsOK(res1)) {
+     SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Feature_SetField" "', argument " "1"" of type '" "OGRFeatureShadow *""'"); 
+   }
+   arg1 = reinterpret_cast< OGRFeatureShadow * >(argp1);
+   ecode2 = SWIG_AsVal_int SWIG_TCL_CALL_ARGS_2(objv[2], &val2);
+   if (!SWIG_IsOK(ecode2)) {
+     SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "Feature_SetField" "', argument " "2"" of type '" "int""'");
+   } 
+   arg2 = static_cast< int >(val2);
+   {
+     /* %typemap(in) (tostring argin) */
+     arg3 = Tcl_GetString( objv[3] ); 
+   }
+   {
+     CPLErrorReset();
+     OGRFeatureShadow_SetField__SWIG_0(arg1,arg2,(char const *)arg3);
+     CPLErr eclass = CPLGetLastErrorType();
+     if ( eclass == CE_Failure || eclass == CE_Fatal ) {
+       SWIG_exception( SWIG_RuntimeError, CPLGetLastErrorMsg() );
+       
+     }
+     
+     
+     
+     
+     
+     
+     
+     
+     
+     
+     
+   }
+   
+   return TCL_OK;
+ fail:
+   return TCL_ERROR;
+ }
+ 
+ 
+ SWIGINTERN int
+ _wrap_Feature_SetField__SWIG_1(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
+   OGRFeatureShadow *arg1 = (OGRFeatureShadow *) 0 ;
+   char *arg2 = (char *) 0 ;
+   char *arg3 = (char *) 0 ;
+   void *argp1 = 0 ;
+   int res1 = 0 ;
+   int res2 ;
+   char *buf2 = 0 ;
+   int alloc2 = 0 ;
+   
+   if (SWIG_GetArgs(interp, objc, objv,"ooo:osgeo::Feature_SetField self name value ",(void *)0,(void *)0,(void *)0) == TCL_ERROR) SWIG_fail;
+   res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_OGRFeatureShadow, 0 |  0 );
+   if (!SWIG_IsOK(res1)) {
+     SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Feature_SetField" "', argument " "1"" of type '" "OGRFeatureShadow *""'"); 
+   }
+   arg1 = reinterpret_cast< OGRFeatureShadow * >(argp1);
+   res2 = SWIG_AsCharPtrAndSize(objv[2], &buf2, NULL, &alloc2);
+   if (!SWIG_IsOK(res2)) {
+     SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "Feature_SetField" "', argument " "2"" of type '" "char const *""'");
+   }
+   arg2 = reinterpret_cast< char * >(buf2);
+   {
+     /* %typemap(in) (tostring argin) */
+     arg3 = Tcl_GetString( objv[3] ); 
+   }
+   {
+     CPLErrorReset();
+     OGRFeatureShadow_SetField__SWIG_1(arg1,(char const *)arg2,(char const *)arg3);
+     CPLErr eclass = CPLGetLastErrorType();
+     if ( eclass == CE_Failure || eclass == CE_Fatal ) {
+       SWIG_exception( SWIG_RuntimeError, CPLGetLastErrorMsg() );
+       
+     }
+     
+     
+     
+     
+     
+     
+     
+     
+     
+     
+     
+   }
+   
+   if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
+   return TCL_OK;
+ fail:
+   if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
+   return TCL_ERROR;
+ }
+ 
+ 
+ SWIGINTERN int
+ _wrap_Feature_SetField__SWIG_2(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
+   OGRFeatureShadow *arg1 = (OGRFeatureShadow *) 0 ;
+   int arg2 ;
+   int arg3 ;
+   void *argp1 = 0 ;
+   int res1 = 0 ;
+   int val2 ;
+   int ecode2 = 0 ;
+   int val3 ;
+   int ecode3 = 0 ;
+   
+   if (SWIG_GetArgs(interp, objc, objv,"ooo:osgeo::Feature_SetField self id value ",(void *)0,(void *)0,(void *)0) == TCL_ERROR) SWIG_fail;
+   res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_OGRFeatureShadow, 0 |  0 );
+   if (!SWIG_IsOK(res1)) {
+     SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Feature_SetField" "', argument " "1"" of type '" "OGRFeatureShadow *""'"); 
+   }
+   arg1 = reinterpret_cast< OGRFeatureShadow * >(argp1);
+   ecode2 = SWIG_AsVal_int SWIG_TCL_CALL_ARGS_2(objv[2], &val2);
+   if (!SWIG_IsOK(ecode2)) {
+     SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "Feature_SetField" "', argument " "2"" of type '" "int""'");
+   } 
+   arg2 = static_cast< int >(val2);
+   ecode3 = SWIG_AsVal_int SWIG_TCL_CALL_ARGS_2(objv[3], &val3);
+   if (!SWIG_IsOK(ecode3)) {
+     SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "Feature_SetField" "', argument " "3"" of type '" "int""'");
+   } 
+   arg3 = static_cast< int >(val3);
+   {
+     CPLErrorReset();
+     OGRFeatureShadow_SetField__SWIG_2(arg1,arg2,arg3);
+     CPLErr eclass = CPLGetLastErrorType();
+     if ( eclass == CE_Failure || eclass == CE_Fatal ) {
+       SWIG_exception( SWIG_RuntimeError, CPLGetLastErrorMsg() );
+       
+     }
+     
+     
+     
+     
+     
+     
+     
+     
+     
+     
+     
+   }
+   
+   return TCL_OK;
+ fail:
+   return TCL_ERROR;
+ }
+ 
+ 
+ SWIGINTERN int
+ _wrap_Feature_SetField__SWIG_3(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
+   OGRFeatureShadow *arg1 = (OGRFeatureShadow *) 0 ;
+   char *arg2 = (char *) 0 ;
+   int arg3 ;
+   void *argp1 = 0 ;
+   int res1 = 0 ;
+   int res2 ;
+   char *buf2 = 0 ;
+   int alloc2 = 0 ;
+   int val3 ;
+   int ecode3 = 0 ;
+   
+   if (SWIG_GetArgs(interp, objc, objv,"ooo:osgeo::Feature_SetField self name value ",(void *)0,(void *)0,(void *)0) == TCL_ERROR) SWIG_fail;
+   res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_OGRFeatureShadow, 0 |  0 );
+   if (!SWIG_IsOK(res1)) {
+     SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Feature_SetField" "', argument " "1"" of type '" "OGRFeatureShadow *""'"); 
+   }
+   arg1 = reinterpret_cast< OGRFeatureShadow * >(argp1);
+   res2 = SWIG_AsCharPtrAndSize(objv[2], &buf2, NULL, &alloc2);
+   if (!SWIG_IsOK(res2)) {
+     SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "Feature_SetField" "', argument " "2"" of type '" "char const *""'");
+   }
+   arg2 = reinterpret_cast< char * >(buf2);
+   ecode3 = SWIG_AsVal_int SWIG_TCL_CALL_ARGS_2(objv[3], &val3);
+   if (!SWIG_IsOK(ecode3)) {
+     SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "Feature_SetField" "', argument " "3"" of type '" "int""'");
+   } 
+   arg3 = static_cast< int >(val3);
+   {
+     CPLErrorReset();
+     OGRFeatureShadow_SetField__SWIG_3(arg1,(char const *)arg2,arg3);
+     CPLErr eclass = CPLGetLastErrorType();
+     if ( eclass == CE_Failure || eclass == CE_Fatal ) {
+       SWIG_exception( SWIG_RuntimeError, CPLGetLastErrorMsg() );
+       
+     }
+     
+     
+     
+     
+     
+     
+     
+     
+     
+     
+     
+   }
+   
+   if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
+   return TCL_OK;
+ fail:
+   if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
+   return TCL_ERROR;
+ }
+ 
+ 
+ SWIGINTERN int
+ _wrap_Feature_SetField__SWIG_4(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
+   OGRFeatureShadow *arg1 = (OGRFeatureShadow *) 0 ;
+   int arg2 ;
+   double arg3 ;
+   void *argp1 = 0 ;
+   int res1 = 0 ;
+   int val2 ;
+   int ecode2 = 0 ;
+   double val3 ;
+   int ecode3 = 0 ;
+   
+   if (SWIG_GetArgs(interp, objc, objv,"ooo:osgeo::Feature_SetField self id value ",(void *)0,(void *)0,(void *)0) == TCL_ERROR) SWIG_fail;
+   res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_OGRFeatureShadow, 0 |  0 );
+   if (!SWIG_IsOK(res1)) {
+     SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Feature_SetField" "', argument " "1"" of type '" "OGRFeatureShadow *""'"); 
+   }
+   arg1 = reinterpret_cast< OGRFeatureShadow * >(argp1);
+   ecode2 = SWIG_AsVal_int SWIG_TCL_CALL_ARGS_2(objv[2], &val2);
+   if (!SWIG_IsOK(ecode2)) {
+     SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "Feature_SetField" "', argument " "2"" of type '" "int""'");
+   } 
+   arg2 = static_cast< int >(val2);
+   ecode3 = SWIG_AsVal_double SWIG_TCL_CALL_ARGS_2(objv[3], &val3);
+   if (!SWIG_IsOK(ecode3)) {
+     SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "Feature_SetField" "', argument " "3"" of type '" "double""'");
+   } 
+   arg3 = static_cast< double >(val3);
+   {
+     CPLErrorReset();
+     OGRFeatureShadow_SetField__SWIG_4(arg1,arg2,arg3);
+     CPLErr eclass = CPLGetLastErrorType();
+     if ( eclass == CE_Failure || eclass == CE_Fatal ) {
+       SWIG_exception( SWIG_RuntimeError, CPLGetLastErrorMsg() );
+       
+     }
+     
+     
+     
+     
+     
+     
+     
+     
+     
+     
+     
+   }
+   
+   return TCL_OK;
+ fail:
+   return TCL_ERROR;
+ }
+ 
+ 
+ SWIGINTERN int
+ _wrap_Feature_SetField__SWIG_5(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
+   OGRFeatureShadow *arg1 = (OGRFeatureShadow *) 0 ;
+   char *arg2 = (char *) 0 ;
+   double arg3 ;
+   void *argp1 = 0 ;
+   int res1 = 0 ;
+   int res2 ;
+   char *buf2 = 0 ;
+   int alloc2 = 0 ;
+   double val3 ;
+   int ecode3 = 0 ;
+   
+   if (SWIG_GetArgs(interp, objc, objv,"ooo:osgeo::Feature_SetField self name value ",(void *)0,(void *)0,(void *)0) == TCL_ERROR) SWIG_fail;
+   res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_OGRFeatureShadow, 0 |  0 );
+   if (!SWIG_IsOK(res1)) {
+     SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Feature_SetField" "', argument " "1"" of type '" "OGRFeatureShadow *""'"); 
+   }
+   arg1 = reinterpret_cast< OGRFeatureShadow * >(argp1);
+   res2 = SWIG_AsCharPtrAndSize(objv[2], &buf2, NULL, &alloc2);
+   if (!SWIG_IsOK(res2)) {
+     SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "Feature_SetField" "', argument " "2"" of type '" "char const *""'");
+   }
+   arg2 = reinterpret_cast< char * >(buf2);
+   ecode3 = SWIG_AsVal_double SWIG_TCL_CALL_ARGS_2(objv[3], &val3);
+   if (!SWIG_IsOK(ecode3)) {
+     SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "Feature_SetField" "', argument " "3"" of type '" "double""'");
+   } 
+   arg3 = static_cast< double >(val3);
+   {
+     CPLErrorReset();
+     OGRFeatureShadow_SetField__SWIG_5(arg1,(char const *)arg2,arg3);
+     CPLErr eclass = CPLGetLastErrorType();
+     if ( eclass == CE_Failure || eclass == CE_Fatal ) {
+       SWIG_exception( SWIG_RuntimeError, CPLGetLastErrorMsg() );
+       
+     }
+     
+     
+     
+     
+     
+     
+     
+     
+     
+     
+     
+   }
+   
+   if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
+   return TCL_OK;
+ fail:
+   if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
+   return TCL_ERROR;
+ }
+ 
+ 
+ SWIGINTERN int
+ _wrap_Feature_SetField__SWIG_6(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
+   OGRFeatureShadow *arg1 = (OGRFeatureShadow *) 0 ;
+   int arg2 ;
+   int arg3 ;
+   int arg4 ;
+   int arg5 ;
+   int arg6 ;
+   int arg7 ;
+   int arg8 ;
+   int arg9 ;
+   void *argp1 = 0 ;
+   int res1 = 0 ;
+   int val2 ;
+   int ecode2 = 0 ;
+   int val3 ;
+   int ecode3 = 0 ;
+   int val4 ;
+   int ecode4 = 0 ;
+   int val5 ;
+   int ecode5 = 0 ;
+   int val6 ;
+   int ecode6 = 0 ;
+   int val7 ;
+   int ecode7 = 0 ;
+   int val8 ;
+   int ecode8 = 0 ;
+   int val9 ;
+   int ecode9 = 0 ;
+   
+   if (SWIG_GetArgs(interp, objc, objv,"ooooooooo:osgeo::Feature_SetField self id year month day hour minute second tzflag ",(void *)0,(void *)0,(void *)0,(void *)0,(void *)0,(void *)0,(void *)0,(void *)0,(void *)0) == TCL_ERROR) SWIG_fail;
+   res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_OGRFeatureShadow, 0 |  0 );
+   if (!SWIG_IsOK(res1)) {
+     SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Feature_SetField" "', argument " "1"" of type '" "OGRFeatureShadow *""'"); 
+   }
+   arg1 = reinterpret_cast< OGRFeatureShadow * >(argp1);
+   ecode2 = SWIG_AsVal_int SWIG_TCL_CALL_ARGS_2(objv[2], &val2);
+   if (!SWIG_IsOK(ecode2)) {
+     SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "Feature_SetField" "', argument " "2"" of type '" "int""'");
+   } 
+   arg2 = static_cast< int >(val2);
+   ecode3 = SWIG_AsVal_int SWIG_TCL_CALL_ARGS_2(objv[3], &val3);
+   if (!SWIG_IsOK(ecode3)) {
+     SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "Feature_SetField" "', argument " "3"" of type '" "int""'");
+   } 
+   arg3 = static_cast< int >(val3);
+   ecode4 = SWIG_AsVal_int SWIG_TCL_CALL_ARGS_2(objv[4], &val4);
+   if (!SWIG_IsOK(ecode4)) {
+     SWIG_exception_fail(SWIG_ArgError(ecode4), "in method '" "Feature_SetField" "', argument " "4"" of type '" "int""'");
+   } 
+   arg4 = static_cast< int >(val4);
+   ecode5 = SWIG_AsVal_int SWIG_TCL_CALL_ARGS_2(objv[5], &val5);
+   if (!SWIG_IsOK(ecode5)) {
+     SWIG_exception_fail(SWIG_ArgError(ecode5), "in method '" "Feature_SetField" "', argument " "5"" of type '" "int""'");
+   } 
+   arg5 = static_cast< int >(val5);
+   ecode6 = SWIG_AsVal_int SWIG_TCL_CALL_ARGS_2(objv[6], &val6);
+   if (!SWIG_IsOK(ecode6)) {
+     SWIG_exception_fail(SWIG_ArgError(ecode6), "in method '" "Feature_SetField" "', argument " "6"" of type '" "int""'");
+   } 
+   arg6 = static_cast< int >(val6);
+   ecode7 = SWIG_AsVal_int SWIG_TCL_CALL_ARGS_2(objv[7], &val7);
+   if (!SWIG_IsOK(ecode7)) {
+     SWIG_exception_fail(SWIG_ArgError(ecode7), "in method '" "Feature_SetField" "', argument " "7"" of type '" "int""'");
+   } 
+   arg7 = static_cast< int >(val7);
+   ecode8 = SWIG_AsVal_int SWIG_TCL_CALL_ARGS_2(objv[8], &val8);
+   if (!SWIG_IsOK(ecode8)) {
+     SWIG_exception_fail(SWIG_ArgError(ecode8), "in method '" "Feature_SetField" "', argument " "8"" of type '" "int""'");
+   } 
+   arg8 = static_cast< int >(val8);
+   ecode9 = SWIG_AsVal_int SWIG_TCL_CALL_ARGS_2(objv[9], &val9);
+   if (!SWIG_IsOK(ecode9)) {
+     SWIG_exception_fail(SWIG_ArgError(ecode9), "in method '" "Feature_SetField" "', argument " "9"" of type '" "int""'");
+   } 
+   arg9 = static_cast< int >(val9);
+   {
+     CPLErrorReset();
+     OGRFeatureShadow_SetField__SWIG_6(arg1,arg2,arg3,arg4,arg5,arg6,arg7,arg8,arg9);
+     CPLErr eclass = CPLGetLastErrorType();
+     if ( eclass == CE_Failure || eclass == CE_Fatal ) {
+       SWIG_exception( SWIG_RuntimeError, CPLGetLastErrorMsg() );
+       
+     }
+     
+     
+     
+     
+     
+     
+     
+     
+     
+     
+     
+   }
+   
+   return TCL_OK;
+ fail:
+   return TCL_ERROR;
+ }
+ 
+ 
+ SWIGINTERN int
+ _wrap_Feature_SetField__SWIG_7(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
+   OGRFeatureShadow *arg1 = (OGRFeatureShadow *) 0 ;
+   char *arg2 = (char *) 0 ;
+   int arg3 ;
+   int arg4 ;
+   int arg5 ;
+   int arg6 ;
+   int arg7 ;
+   int arg8 ;
+   int arg9 ;
+   void *argp1 = 0 ;
+   int res1 = 0 ;
+   int res2 ;
+   char *buf2 = 0 ;
+   int alloc2 = 0 ;
+   int val3 ;
+   int ecode3 = 0 ;
+   int val4 ;
+   int ecode4 = 0 ;
+   int val5 ;
+   int ecode5 = 0 ;
+   int val6 ;
+   int ecode6 = 0 ;
+   int val7 ;
+   int ecode7 = 0 ;
+   int val8 ;
+   int ecode8 = 0 ;
+   int val9 ;
+   int ecode9 = 0 ;
+   
+   if (SWIG_GetArgs(interp, objc, objv,"ooooooooo:osgeo::Feature_SetField self name year month day hour minute second tzflag ",(void *)0,(void *)0,(void *)0,(void *)0,(void *)0,(void *)0,(void *)0,(void *)0,(void *)0) == TCL_ERROR) SWIG_fail;
+   res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_OGRFeatureShadow, 0 |  0 );
+   if (!SWIG_IsOK(res1)) {
+     SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Feature_SetField" "', argument " "1"" of type '" "OGRFeatureShadow *""'"); 
+   }
+   arg1 = reinterpret_cast< OGRFeatureShadow * >(argp1);
+   res2 = SWIG_AsCharPtrAndSize(objv[2], &buf2, NULL, &alloc2);
+   if (!SWIG_IsOK(res2)) {
+     SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "Feature_SetField" "', argument " "2"" of type '" "char const *""'");
+   }
+   arg2 = reinterpret_cast< char * >(buf2);
+   ecode3 = SWIG_AsVal_int SWIG_TCL_CALL_ARGS_2(objv[3], &val3);
+   if (!SWIG_IsOK(ecode3)) {
+     SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "Feature_SetField" "', argument " "3"" of type '" "int""'");
+   } 
+   arg3 = static_cast< int >(val3);
+   ecode4 = SWIG_AsVal_int SWIG_TCL_CALL_ARGS_2(objv[4], &val4);
+   if (!SWIG_IsOK(ecode4)) {
+     SWIG_exception_fail(SWIG_ArgError(ecode4), "in method '" "Feature_SetField" "', argument " "4"" of type '" "int""'");
+   } 
+   arg4 = static_cast< int >(val4);
+   ecode5 = SWIG_AsVal_int SWIG_TCL_CALL_ARGS_2(objv[5], &val5);
+   if (!SWIG_IsOK(ecode5)) {
+     SWIG_exception_fail(SWIG_ArgError(ecode5), "in method '" "Feature_SetField" "', argument " "5"" of type '" "int""'");
+   } 
+   arg5 = static_cast< int >(val5);
+   ecode6 = SWIG_AsVal_int SWIG_TCL_CALL_ARGS_2(objv[6], &val6);
+   if (!SWIG_IsOK(ecode6)) {
+     SWIG_exception_fail(SWIG_ArgError(ecode6), "in method '" "Feature_SetField" "', argument " "6"" of type '" "int""'");
+   } 
+   arg6 = static_cast< int >(val6);
+   ecode7 = SWIG_AsVal_int SWIG_TCL_CALL_ARGS_2(objv[7], &val7);
+   if (!SWIG_IsOK(ecode7)) {
+     SWIG_exception_fail(SWIG_ArgError(ecode7), "in method '" "Feature_SetField" "', argument " "7"" of type '" "int""'");
+   } 
+   arg7 = static_cast< int >(val7);
+   ecode8 = SWIG_AsVal_int SWIG_TCL_CALL_ARGS_2(objv[8], &val8);
+   if (!SWIG_IsOK(ecode8)) {
+     SWIG_exception_fail(SWIG_ArgError(ecode8), "in method '" "Feature_SetField" "', argument " "8"" of type '" "int""'");
+   } 
+   arg8 = static_cast< int >(val8);
+   ecode9 = SWIG_AsVal_int SWIG_TCL_CALL_ARGS_2(objv[9], &val9);
+   if (!SWIG_IsOK(ecode9)) {
+     SWIG_exception_fail(SWIG_ArgError(ecode9), "in method '" "Feature_SetField" "', argument " "9"" of type '" "int""'");
+   } 
+   arg9 = static_cast< int >(val9);
+   {
+     CPLErrorReset();
+     OGRFeatureShadow_SetField__SWIG_7(arg1,(char const *)arg2,arg3,arg4,arg5,arg6,arg7,arg8,arg9);
+     CPLErr eclass = CPLGetLastErrorType();
+     if ( eclass == CE_Failure || eclass == CE_Fatal ) {
+       SWIG_exception( SWIG_RuntimeError, CPLGetLastErrorMsg() );
+       
+     }
+     
+     
+     
+     
+     
+     
+     
+     
+     
+     
+     
+   }
+   
+   if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
+   return TCL_OK;
+ fail:
+   if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
+   return TCL_ERROR;
+ }
+ 
+ 
+ SWIGINTERN int
+ _wrap_Feature_SetField(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
+   Tcl_Obj *CONST *argv = objv+1;
+   int argc = objc-1;
+   if (argc == 3) {
+     int _v;
+     void *vptr = 0;
+     int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_OGRFeatureShadow, 0);
+     _v = SWIG_CheckState(res);
+     if (_v) {
+       {
+         int res = SWIG_AsVal_int SWIG_TCL_CALL_ARGS_2(argv[1], NULL);
+         _v = SWIG_CheckState(res);
+       }
+       if (_v) {
+         {
+           /* %typemap(typecheck,precedence=SWIG_TYPECHECK_POINTER) (tostring argin) */
+           _v = 1;
+         }
+         if (_v) {
+           return _wrap_Feature_SetField__SWIG_0(clientData, interp, objc, argv - 1);
+         }
+       }
+     }
+   }
+   if (argc == 3) {
+     int _v;
+     void *vptr = 0;
+     int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_OGRFeatureShadow, 0);
+     _v = SWIG_CheckState(res);
+     if (_v) {
+       {
+         int res = SWIG_AsVal_int SWIG_TCL_CALL_ARGS_2(argv[1], NULL);
+         _v = SWIG_CheckState(res);
+       }
+       if (_v) {
+         {
+           int res = SWIG_AsVal_int SWIG_TCL_CALL_ARGS_2(argv[2], NULL);
+           _v = SWIG_CheckState(res);
+         }
+         if (_v) {
+           return _wrap_Feature_SetField__SWIG_2(clientData, interp, objc, argv - 1);
+         }
+       }
+     }
+   }
+   if (argc == 3) {
+     int _v;
+     void *vptr = 0;
+     int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_OGRFeatureShadow, 0);
+     _v = SWIG_CheckState(res);
+     if (_v) {
+       {
+         int res = SWIG_AsVal_int SWIG_TCL_CALL_ARGS_2(argv[1], NULL);
+         _v = SWIG_CheckState(res);
+       }
+       if (_v) {
+         {
+           int res = SWIG_AsVal_double SWIG_TCL_CALL_ARGS_2(argv[2], NULL);
+           _v = SWIG_CheckState(res);
+         }
+         if (_v) {
+           return _wrap_Feature_SetField__SWIG_4(clientData, interp, objc, argv - 1);
+         }
+       }
+     }
+   }
+   if (argc == 3) {
+     int _v;
+     void *vptr = 0;
+     int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_OGRFeatureShadow, 0);
+     _v = SWIG_CheckState(res);
+     if (_v) {
+       int res = SWIG_AsCharPtrAndSize(argv[1], 0, NULL, 0);
+       _v = SWIG_CheckState(res);
+       if (_v) {
+         {
+           /* %typemap(typecheck,precedence=SWIG_TYPECHECK_POINTER) (tostring argin) */
+           _v = 1;
+         }
+         if (_v) {
+           return _wrap_Feature_SetField__SWIG_1(clientData, interp, objc, argv - 1);
+         }
+       }
+     }
+   }
+   if (argc == 3) {
+     int _v;
+     void *vptr = 0;
+     int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_OGRFeatureShadow, 0);
+     _v = SWIG_CheckState(res);
+     if (_v) {
+       int res = SWIG_AsCharPtrAndSize(argv[1], 0, NULL, 0);
+       _v = SWIG_CheckState(res);
+       if (_v) {
+         {
+           int res = SWIG_AsVal_int SWIG_TCL_CALL_ARGS_2(argv[2], NULL);
+           _v = SWIG_CheckState(res);
+         }
+         if (_v) {
+           return _wrap_Feature_SetField__SWIG_3(clientData, interp, objc, argv - 1);
+         }
+       }
+     }
+   }
+   if (argc == 3) {
+     int _v;
+     void *vptr = 0;
+     int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_OGRFeatureShadow, 0);
+     _v = SWIG_CheckState(res);
+     if (_v) {
+       int res = SWIG_AsCharPtrAndSize(argv[1], 0, NULL, 0);
+       _v = SWIG_CheckState(res);
+       if (_v) {
+         {
+           int res = SWIG_AsVal_double SWIG_TCL_CALL_ARGS_2(argv[2], NULL);
+           _v = SWIG_CheckState(res);
+         }
+         if (_v) {
+           return _wrap_Feature_SetField__SWIG_5(clientData, interp, objc, argv - 1);
+         }
+       }
+     }
+   }
+   if (argc == 9) {
+     int _v;
+     void *vptr = 0;
+     int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_OGRFeatureShadow, 0);
+     _v = SWIG_CheckState(res);
+     if (_v) {
+       {
+         int res = SWIG_AsVal_int SWIG_TCL_CALL_ARGS_2(argv[1], NULL);
+         _v = SWIG_CheckState(res);
+       }
+       if (_v) {
+         {
+           int res = SWIG_AsVal_int SWIG_TCL_CALL_ARGS_2(argv[2], NULL);
+           _v = SWIG_CheckState(res);
+         }
+         if (_v) {
+           {
+             int res = SWIG_AsVal_int SWIG_TCL_CALL_ARGS_2(argv[3], NULL);
+             _v = SWIG_CheckState(res);
+           }
+           if (_v) {
+             {
+               int res = SWIG_AsVal_int SWIG_TCL_CALL_ARGS_2(argv[4], NULL);
+               _v = SWIG_CheckState(res);
+             }
+             if (_v) {
+               {
+                 int res = SWIG_AsVal_int SWIG_TCL_CALL_ARGS_2(argv[5], NULL);
+                 _v = SWIG_CheckState(res);
+               }
+               if (_v) {
+                 {
+                   int res = SWIG_AsVal_int SWIG_TCL_CALL_ARGS_2(argv[6], NULL);
+                   _v = SWIG_CheckState(res);
+                 }
+                 if (_v) {
+                   {
+                     int res = SWIG_AsVal_int SWIG_TCL_CALL_ARGS_2(argv[7], NULL);
+                     _v = SWIG_CheckState(res);
+                   }
+                   if (_v) {
+                     {
+                       int res = SWIG_AsVal_int SWIG_TCL_CALL_ARGS_2(argv[8], NULL);
+                       _v = SWIG_CheckState(res);
+                     }
+                     if (_v) {
+                       return _wrap_Feature_SetField__SWIG_6(clientData, interp, objc, argv - 1);
+                     }
+                   }
+                 }
+               }
+             }
+           }
+         }
+       }
+     }
+   }
+   if (argc == 9) {
+     int _v;
+     void *vptr = 0;
+     int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_OGRFeatureShadow, 0);
+     _v = SWIG_CheckState(res);
+     if (_v) {
+       int res = SWIG_AsCharPtrAndSize(argv[1], 0, NULL, 0);
+       _v = SWIG_CheckState(res);
+       if (_v) {
+         {
+           int res = SWIG_AsVal_int SWIG_TCL_CALL_ARGS_2(argv[2], NULL);
+           _v = SWIG_CheckState(res);
+         }
+         if (_v) {
+           {
+             int res = SWIG_AsVal_int SWIG_TCL_CALL_ARGS_2(argv[3], NULL);
+             _v = SWIG_CheckState(res);
+           }
+           if (_v) {
+             {
+               int res = SWIG_AsVal_int SWIG_TCL_CALL_ARGS_2(argv[4], NULL);
+               _v = SWIG_CheckState(res);
+             }
+             if (_v) {
+               {
+                 int res = SWIG_AsVal_int SWIG_TCL_CALL_ARGS_2(argv[5], NULL);
+                 _v = SWIG_CheckState(res);
+               }
+               if (_v) {
+                 {
+                   int res = SWIG_AsVal_int SWIG_TCL_CALL_ARGS_2(argv[6], NULL);
+                   _v = SWIG_CheckState(res);
+                 }
+                 if (_v) {
+                   {
+                     int res = SWIG_AsVal_int SWIG_TCL_CALL_ARGS_2(argv[7], NULL);
+                     _v = SWIG_CheckState(res);
+                   }
+                   if (_v) {
+                     {
+                       int res = SWIG_AsVal_int SWIG_TCL_CALL_ARGS_2(argv[8], NULL);
+                       _v = SWIG_CheckState(res);
+                     }
+                     if (_v) {
+                       return _wrap_Feature_SetField__SWIG_7(clientData, interp, objc, argv - 1);
+                     }
+                   }
+                 }
+               }
+             }
+           }
+         }
+       }
+     }
+   }
+   
+   Tcl_SetResult(interp,(char *) "No matching function for overloaded 'Feature_SetField'", TCL_STATIC);
+   return TCL_ERROR;
+ }
+ 
+ 
+ SWIGINTERN int
+ _wrap_Feature_SetFieldIntegerList(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
+   OGRFeatureShadow *arg1 = (OGRFeatureShadow *) 0 ;
+   int arg2 ;
+   int arg3 ;
+   int *arg4 = (int *) 0 ;
+   void *argp1 = 0 ;
+   int res1 = 0 ;
+   int val2 ;
+   int ecode2 = 0 ;
+   
+   if (SWIG_GetArgs(interp, objc, objv,"ooo:osgeo::Feature_SetFieldIntegerList self id nList ?pList? ",(void *)0,(void *)0,(void *)0) == TCL_ERROR) SWIG_fail;
+   res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_OGRFeatureShadow, 0 |  0 );
+   if (!SWIG_IsOK(res1)) {
+     SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Feature_SetFieldIntegerList" "', argument " "1"" of type '" "OGRFeatureShadow *""'"); 
+   }
+   arg1 = reinterpret_cast< OGRFeatureShadow * >(argp1);
+   ecode2 = SWIG_AsVal_int SWIG_TCL_CALL_ARGS_2(objv[2], &val2);
+   if (!SWIG_IsOK(ecode2)) {
+     SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "Feature_SetFieldIntegerList" "', argument " "2"" of type '" "int""'");
+   } 
+   arg2 = static_cast< int >(val2);
+   {
+     /* %typemap(in,numinputs=1) (int nList, int* pList)*/
+     /* The following also checks if input is a list */
+     if (Tcl_ListObjLength(interp, objv[3], &arg3) != TCL_OK) {
+       /* Error msg in interp result */
+       SWIG_fail;
+     }
+     if ( !arg3 ) {
+       Tcl_SetResult(interp, (char*) "Input list mustn't be empty", TCL_STATIC);
+       SWIG_fail;
+     }
+     
+     arg4 = (int*) CPLMalloc(arg3*sizeof(int));
+     
+     for( int i = 0; i<arg3; i++ ) {
+       Tcl_Obj **o = NULL;
+       if (Tcl_ListObjIndex(interp, objv[3], i, o) != TCL_OK) {
+         /* ref count is not incremented */
+         /* Error msg in interp result */
+         SWIG_fail;
+       }
+       
+       int val;
+       if (Tcl_GetIntFromObj(interp, *o, &val ) != TCL_OK) {
+         /* Error msg in interp result */
+         SWIG_fail;
+       }
+       arg4[i] = val;
+     }
+   }
+   {
+     CPLErrorReset();
+     OGRFeatureShadow_SetFieldIntegerList(arg1,arg2,arg3,arg4);
+     CPLErr eclass = CPLGetLastErrorType();
+     if ( eclass == CE_Failure || eclass == CE_Fatal ) {
+       SWIG_exception( SWIG_RuntimeError, CPLGetLastErrorMsg() );
+       
+     }
+     
+     
+     
+     
+     
+     
+     
+     
+     
+     
+     
+   }
+   
+   {
+     /* %typemap(freearg) (int nList, int* pList) */
+     if (arg4) {
+       CPLFree((void*) arg4);
+     }
+   }
+   return TCL_OK;
+ fail:
+   {
+     /* %typemap(freearg) (int nList, int* pList) */
+     if (arg4) {
+       CPLFree((void*) arg4);
+     }
+   }
+   return TCL_ERROR;
+ }
+ 
+ 
+ SWIGINTERN int
+ _wrap_Feature_SetFieldDoubleList(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
+   OGRFeatureShadow *arg1 = (OGRFeatureShadow *) 0 ;
+   int arg2 ;
+   int arg3 ;
+   double *arg4 = (double *) 0 ;
+   void *argp1 = 0 ;
+   int res1 = 0 ;
+   int val2 ;
+   int ecode2 = 0 ;
+   
+   if (SWIG_GetArgs(interp, objc, objv,"ooo:osgeo::Feature_SetFieldDoubleList self id nList ?pList? ",(void *)0,(void *)0,(void *)0) == TCL_ERROR) SWIG_fail;
+   res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_OGRFeatureShadow, 0 |  0 );
+   if (!SWIG_IsOK(res1)) {
+     SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Feature_SetFieldDoubleList" "', argument " "1"" of type '" "OGRFeatureShadow *""'"); 
+   }
+   arg1 = reinterpret_cast< OGRFeatureShadow * >(argp1);
+   ecode2 = SWIG_AsVal_int SWIG_TCL_CALL_ARGS_2(objv[2], &val2);
+   if (!SWIG_IsOK(ecode2)) {
+     SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "Feature_SetFieldDoubleList" "', argument " "2"" of type '" "int""'");
+   } 
+   arg2 = static_cast< int >(val2);
+   {
+     /* %typemap(in,numinputs=1) (int nList, double* pList)*/
+     /* The following also checks if input is a list */
+     if (Tcl_ListObjLength(interp, objv[3], &arg3) != TCL_OK) {
+       /* Error msg in interp result */
+       SWIG_fail;
+     }
+     if ( !arg3 ) {
+       Tcl_SetResult(interp, (char*) "Input list mustn't be empty", TCL_STATIC);
+       SWIG_fail;
+     }
+     
+     arg4 = (double*) CPLMalloc(arg3*sizeof(double));
+     
+     for( int i = 0; i<arg3; i++ ) {
+       Tcl_Obj **o = NULL;
+       if (Tcl_ListObjIndex(interp, objv[3], i, o) != TCL_OK) {
+         /* ref count is not incremented */
+         /* Error msg in interp result */
+         SWIG_fail;
+       }
+       
+       double val;
+       if (Tcl_GetDoubleFromObj(interp, *o, &val ) != TCL_OK) {
+         /* Error msg in interp result */
+         SWIG_fail;
+       }
+       arg4[i] = val;
+     }
+   }
+   {
+     CPLErrorReset();
+     OGRFeatureShadow_SetFieldDoubleList(arg1,arg2,arg3,arg4);
+     CPLErr eclass = CPLGetLastErrorType();
+     if ( eclass == CE_Failure || eclass == CE_Fatal ) {
+       SWIG_exception( SWIG_RuntimeError, CPLGetLastErrorMsg() );
+       
+     }
+     
+     
+     
+     
+     
+     
+     
+     
+     
+     
+     
+   }
+   
+   {
+     /* %typemap(freearg) (int nList, double* pList) */
+     if (arg4) {
+       CPLFree((void*) arg4);
+     }
+   }
+   return TCL_OK;
+ fail:
+   {
+     /* %typemap(freearg) (int nList, double* pList) */
+     if (arg4) {
+       CPLFree((void*) arg4);
+     }
+   }
+   return TCL_ERROR;
+ }
+ 
+ 
+ SWIGINTERN int
+ _wrap_Feature_SetFieldStringList(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
+   OGRFeatureShadow *arg1 = (OGRFeatureShadow *) 0 ;
+   int arg2 ;
+   char **arg3 = (char **) 0 ;
+   void *argp1 = 0 ;
+   int res1 = 0 ;
+   int val2 ;
+   int ecode2 = 0 ;
+   
+   if (SWIG_GetArgs(interp, objc, objv,"ooo:osgeo::Feature_SetFieldStringList self id pList ",(void *)0,(void *)0,(void *)0) == TCL_ERROR) SWIG_fail;
+   res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_OGRFeatureShadow, 0 |  0 );
+   if (!SWIG_IsOK(res1)) {
+     SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Feature_SetFieldStringList" "', argument " "1"" of type '" "OGRFeatureShadow *""'"); 
+   }
+   arg1 = reinterpret_cast< OGRFeatureShadow * >(argp1);
+   ecode2 = SWIG_AsVal_int SWIG_TCL_CALL_ARGS_2(objv[2], &val2);
+   if (!SWIG_IsOK(ecode2)) {
+     SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "Feature_SetFieldStringList" "', argument " "2"" of type '" "int""'");
+   } 
+   arg2 = static_cast< int >(val2);
+   {
+     /* %typemap(in) char **options */
+     int size;
+     if (Tcl_ListObjLength(interp, objv[3], &size) != TCL_OK) {
+       /* Error msg in interp result */
+       SWIG_fail;
+     }
+     if ( !size ) {
+       Tcl_SetResult(interp, (char*) "Input list mustn't be empty", TCL_STATIC);
+       SWIG_fail;
+     }
+     
+     for (int i = 0; i < size; i++) {
+       Tcl_Obj **o = NULL;
+       /* The reference count for the list element is not incremented with the following */
+       if (Tcl_ListObjIndex(interp, objv[3], i, o) != TCL_OK) {
+         /* Error msg in interp result */
+         SWIG_fail;
+       }
+       char *pszItem = Tcl_GetString(*o);
+       arg3 = CSLAddString( arg3, pszItem );
+     }
+   }
+   {
+     CPLErrorReset();
+     OGRFeatureShadow_SetFieldStringList(arg1,arg2,arg3);
+     CPLErr eclass = CPLGetLastErrorType();
+     if ( eclass == CE_Failure || eclass == CE_Fatal ) {
+       SWIG_exception( SWIG_RuntimeError, CPLGetLastErrorMsg() );
+       
+     }
+     
+     
+     
+     
+     
+     
+     
+     
+     
+     
+     
+   }
+   
+   {
+     /* %typemap(freearg) char **options */
+     CSLDestroy( arg3 );
+   }
+   return TCL_OK;
+ fail:
+   {
+     /* %typemap(freearg) char **options */
+     CSLDestroy( arg3 );
+   }
+   return TCL_ERROR;
+ }
+ 
+ 
+ SWIGINTERN int
+ _wrap_Feature_SetFrom(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
+   OGRFeatureShadow *arg1 = (OGRFeatureShadow *) 0 ;
+   OGRFeatureShadow *arg2 = (OGRFeatureShadow *) 0 ;
+   int arg3 = (int) 1 ;
+   void *argp1 = 0 ;
+   int res1 = 0 ;
+   void *argp2 = 0 ;
+   int res2 = 0 ;
+   int val3 ;
+   int ecode3 = 0 ;
+   OGRErr result;
+   
+   if (SWIG_GetArgs(interp, objc, objv,"oo|o:osgeo::Feature_SetFrom self other ?forgiving? ",(void *)0,(void *)0,(void *)0) == TCL_ERROR) SWIG_fail;
+   res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_OGRFeatureShadow, 0 |  0 );
+   if (!SWIG_IsOK(res1)) {
+     SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Feature_SetFrom" "', argument " "1"" of type '" "OGRFeatureShadow *""'"); 
+   }
+   arg1 = reinterpret_cast< OGRFeatureShadow * >(argp1);
+   res2 = SWIG_ConvertPtr(objv[2], &argp2,SWIGTYPE_p_OGRFeatureShadow, 0 |  0 );
+   if (!SWIG_IsOK(res2)) {
+     SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "Feature_SetFrom" "', argument " "2"" of type '" "OGRFeatureShadow *""'"); 
+   }
+   arg2 = reinterpret_cast< OGRFeatureShadow * >(argp2);
+   if (objc > 3) {
+     ecode3 = SWIG_AsVal_int SWIG_TCL_CALL_ARGS_2(objv[3], &val3);
+     if (!SWIG_IsOK(ecode3)) {
+       SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "Feature_SetFrom" "', argument " "3"" of type '" "int""'");
+     } 
+     arg3 = static_cast< int >(val3);
+   }
+   {
+     CPLErrorReset();
+     result = (OGRErr)OGRFeatureShadow_SetFrom(arg1,arg2,arg3);
+     CPLErr eclass = CPLGetLastErrorType();
+     if ( eclass == CE_Failure || eclass == CE_Fatal ) {
+       SWIG_exception( SWIG_RuntimeError, CPLGetLastErrorMsg() );
+       
+     }
+     
+     
+     
+     
+     
+     
+     
+     
+     
+     
+     
+   }
+   {
+     /* %typemap(out) OGRErr */
+     if (result != 0) {
+       Tcl_SetResult(interp, (char*) OGRErrMessages(result), TCL_STATIC);
+       SWIG_fail;
+     }
+   }
+   {
+     /* %typemap(ret) OGRErr */
+     if (!strcmp(Tcl_GetStringResult(interp), "{}") || !strcmp(Tcl_GetStringResult(interp), "")) {
+       Tcl_SetObjResult(interp, Tcl_NewLongObj( result ));
+     }
+   }
+   return TCL_OK;
+ fail:
+   return TCL_ERROR;
+ }
+ 
+ 
+ SWIGINTERN int
+ _wrap_Feature_GetStyleString(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
+   OGRFeatureShadow *arg1 = (OGRFeatureShadow *) 0 ;
+   void *argp1 = 0 ;
+   int res1 = 0 ;
+   char *result = 0 ;
+   
+   if (SWIG_GetArgs(interp, objc, objv,"o:osgeo::Feature_GetStyleString self ",(void *)0) == TCL_ERROR) SWIG_fail;
+   res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_OGRFeatureShadow, 0 |  0 );
+   if (!SWIG_IsOK(res1)) {
+     SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Feature_GetStyleString" "', argument " "1"" of type '" "OGRFeatureShadow *""'"); 
+   }
+   arg1 = reinterpret_cast< OGRFeatureShadow * >(argp1);
+   {
+     CPLErrorReset();
+     result = (char *)OGRFeatureShadow_GetStyleString(arg1);
+     CPLErr eclass = CPLGetLastErrorType();
+     if ( eclass == CE_Failure || eclass == CE_Fatal ) {
+       SWIG_exception( SWIG_RuntimeError, CPLGetLastErrorMsg() );
+       
+     }
+     
+     
+     
+     
+     
+     
+     
+     
+     
+     
+     
+   }
+   Tcl_SetObjResult(interp,SWIG_FromCharPtr((const char *)result));
+   return TCL_OK;
+ fail:
+   return TCL_ERROR;
+ }
+ 
+ 
+ SWIGINTERN int
+ _wrap_Feature_SetStyleString(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
+   OGRFeatureShadow *arg1 = (OGRFeatureShadow *) 0 ;
+   char *arg2 = (char *) 0 ;
+   void *argp1 = 0 ;
+   int res1 = 0 ;
+   int res2 ;
+   char *buf2 = 0 ;
+   int alloc2 = 0 ;
+   
+   if (SWIG_GetArgs(interp, objc, objv,"oo:osgeo::Feature_SetStyleString self the_string ",(void *)0,(void *)0) == TCL_ERROR) SWIG_fail;
+   res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_OGRFeatureShadow, 0 |  0 );
+   if (!SWIG_IsOK(res1)) {
+     SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Feature_SetStyleString" "', argument " "1"" of type '" "OGRFeatureShadow *""'"); 
+   }
+   arg1 = reinterpret_cast< OGRFeatureShadow * >(argp1);
+   res2 = SWIG_AsCharPtrAndSize(objv[2], &buf2, NULL, &alloc2);
+   if (!SWIG_IsOK(res2)) {
+     SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "Feature_SetStyleString" "', argument " "2"" of type '" "char const *""'");
+   }
+   arg2 = reinterpret_cast< char * >(buf2);
+   {
+     CPLErrorReset();
+     OGRFeatureShadow_SetStyleString(arg1,(char const *)arg2);
+     CPLErr eclass = CPLGetLastErrorType();
+     if ( eclass == CE_Failure || eclass == CE_Fatal ) {
+       SWIG_exception( SWIG_RuntimeError, CPLGetLastErrorMsg() );
+       
+     }
+     
+     
+     
+     
+     
+     
+     
+     
+     
+     
+     
+   }
+   
+   if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
+   return TCL_OK;
+ fail:
+   if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
+   return TCL_ERROR;
+ }
+ 
+ 
+ SWIGINTERN int
+ _wrap_Feature_GetFieldType__SWIG_0(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
+   OGRFeatureShadow *arg1 = (OGRFeatureShadow *) 0 ;
+   int arg2 ;
+   void *argp1 = 0 ;
+   int res1 = 0 ;
+   int val2 ;
+   int ecode2 = 0 ;
+   OGRFieldType result;
+   
+   if (SWIG_GetArgs(interp, objc, objv,"oo:osgeo::Feature_GetFieldType self id ",(void *)0,(void *)0) == TCL_ERROR) SWIG_fail;
+   res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_OGRFeatureShadow, 0 |  0 );
+   if (!SWIG_IsOK(res1)) {
+     SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Feature_GetFieldType" "', argument " "1"" of type '" "OGRFeatureShadow *""'"); 
+   }
+   arg1 = reinterpret_cast< OGRFeatureShadow * >(argp1);
+   ecode2 = SWIG_AsVal_int SWIG_TCL_CALL_ARGS_2(objv[2], &val2);
+   if (!SWIG_IsOK(ecode2)) {
+     SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "Feature_GetFieldType" "', argument " "2"" of type '" "int""'");
+   } 
+   arg2 = static_cast< int >(val2);
+   {
+     CPLErrorReset();
+     result = (OGRFieldType)OGRFeatureShadow_GetFieldType__SWIG_0(arg1,arg2);
+     CPLErr eclass = CPLGetLastErrorType();
+     if ( eclass == CE_Failure || eclass == CE_Fatal ) {
+       SWIG_exception( SWIG_RuntimeError, CPLGetLastErrorMsg() );
+       
+     }
+     
+     
+     
+     
+     
+     
+     
+     
+     
+     
+     
+   }
+   Tcl_SetObjResult(interp,SWIG_From_int(static_cast< int >(result)));
+   return TCL_OK;
+ fail:
+   return TCL_ERROR;
+ }
+ 
+ 
+ SWIGINTERN int
+ _wrap_Feature_GetFieldType__SWIG_1(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
+   OGRFeatureShadow *arg1 = (OGRFeatureShadow *) 0 ;
+   char *arg2 = (char *) 0 ;
+   void *argp1 = 0 ;
+   int res1 = 0 ;
+   int res2 ;
+   char *buf2 = 0 ;
+   int alloc2 = 0 ;
+   OGRFieldType result;
+   
+   if (SWIG_GetArgs(interp, objc, objv,"oo:osgeo::Feature_GetFieldType self name ",(void *)0,(void *)0) == TCL_ERROR) SWIG_fail;
+   res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_OGRFeatureShadow, 0 |  0 );
+   if (!SWIG_IsOK(res1)) {
+     SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Feature_GetFieldType" "', argument " "1"" of type '" "OGRFeatureShadow *""'"); 
+   }
+   arg1 = reinterpret_cast< OGRFeatureShadow * >(argp1);
+   res2 = SWIG_AsCharPtrAndSize(objv[2], &buf2, NULL, &alloc2);
+   if (!SWIG_IsOK(res2)) {
+     SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "Feature_GetFieldType" "', argument " "2"" of type '" "char const *""'");
+   }
+   arg2 = reinterpret_cast< char * >(buf2);
+   {
+     CPLErrorReset();
+     result = (OGRFieldType)OGRFeatureShadow_GetFieldType__SWIG_1(arg1,(char const *)arg2);
+     CPLErr eclass = CPLGetLastErrorType();
+     if ( eclass == CE_Failure || eclass == CE_Fatal ) {
+       SWIG_exception( SWIG_RuntimeError, CPLGetLastErrorMsg() );
+       
+     }
+     
+     
+     
+     
+     
+     
+     
+     
+     
+     
+     
+   }
+   Tcl_SetObjResult(interp,SWIG_From_int(static_cast< int >(result)));
+   if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
+   return TCL_OK;
+ fail:
+   if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
+   return TCL_ERROR;
+ }
+ 
+ 
+ SWIGINTERN int
+ _wrap_Feature_GetFieldType(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
+   Tcl_Obj *CONST *argv = objv+1;
+   int argc = objc-1;
+   if (argc == 2) {
+     int _v;
+     void *vptr = 0;
+     int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_OGRFeatureShadow, 0);
+     _v = SWIG_CheckState(res);
+     if (_v) {
+       {
+         int res = SWIG_AsVal_int SWIG_TCL_CALL_ARGS_2(argv[1], NULL);
+         _v = SWIG_CheckState(res);
+       }
+       if (_v) {
+         return _wrap_Feature_GetFieldType__SWIG_0(clientData, interp, objc, argv - 1);
+       }
+     }
+   }
+   if (argc == 2) {
+     int _v;
+     void *vptr = 0;
+     int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_OGRFeatureShadow, 0);
+     _v = SWIG_CheckState(res);
+     if (_v) {
+       int res = SWIG_AsCharPtrAndSize(argv[1], 0, NULL, 0);
+       _v = SWIG_CheckState(res);
+       if (_v) {
+         return _wrap_Feature_GetFieldType__SWIG_1(clientData, interp, objc, argv - 1);
+       }
+     }
+   }
+   
+   Tcl_SetResult(interp,(char *) "No matching function for overloaded 'Feature_GetFieldType'", TCL_STATIC);
+   return TCL_ERROR;
+ }
+ 
+ 
+ SWIGINTERN void swig_delete_Feature(void *obj) {
+ OGRFeatureShadow *arg1 = (OGRFeatureShadow *) obj;
+ delete_OGRFeatureShadow(arg1);
+ }
+ static swig_method swig_OGRFeatureShadow_methods[] = {
+     {"GetDefnRef", _wrap_Feature_GetDefnRef}, 
+     {"SetGeometry", _wrap_Feature_SetGeometry}, 
+     {"SetGeometryDirectly", _wrap_Feature_SetGeometryDirectly}, 
+     {"GetGeometryRef", _wrap_Feature_GetGeometryRef}, 
+     {"Clone", _wrap_Feature_Clone}, 
+     {"Equal", _wrap_Feature_Equal}, 
+     {"GetFieldCount", _wrap_Feature_GetFieldCount}, 
+     {"GetFieldDefnRef", _wrap_Feature_GetFieldDefnRef}, 
+     {"GetFieldAsString", _wrap_Feature_GetFieldAsString}, 
+     {"GetFieldAsInteger", _wrap_Feature_GetFieldAsInteger}, 
+     {"GetFieldAsDouble", _wrap_Feature_GetFieldAsDouble}, 
+     {"GetFieldAsDateTime", _wrap_Feature_GetFieldAsDateTime}, 
+     {"GetFieldAsIntegerList", _wrap_Feature_GetFieldAsIntegerList}, 
+     {"GetFieldAsDoubleList", _wrap_Feature_GetFieldAsDoubleList}, 
+     {"GetFieldAsStringList", _wrap_Feature_GetFieldAsStringList}, 
+     {"IsFieldSet", _wrap_Feature_IsFieldSet}, 
+     {"GetFieldIndex", _wrap_Feature_GetFieldIndex}, 
+     {"GetFID", _wrap_Feature_GetFID}, 
+     {"SetFID", _wrap_Feature_SetFID}, 
+     {"DumpReadable", _wrap_Feature_DumpReadable}, 
+     {"UnsetField", _wrap_Feature_UnsetField}, 
+     {"SetField", _wrap_Feature_SetField}, 
+     {"SetFieldIntegerList", _wrap_Feature_SetFieldIntegerList}, 
+     {"SetFieldDoubleList", _wrap_Feature_SetFieldDoubleList}, 
+     {"SetFieldStringList", _wrap_Feature_SetFieldStringList}, 
+     {"SetFrom", _wrap_Feature_SetFrom}, 
+     {"GetStyleString", _wrap_Feature_GetStyleString}, 
+     {"SetStyleString", _wrap_Feature_SetStyleString}, 
+     {"GetFieldType", _wrap_Feature_GetFieldType}, 
+     {0,0}
+ };
+ static swig_attribute swig_OGRFeatureShadow_attributes[] = {
+     {0,0,0}
+ };
+ static swig_class *swig_OGRFeatureShadow_bases[] = {0};
+ static const char * swig_OGRFeatureShadow_base_names[] = {0};
+ static swig_class _wrap_class_OGRFeatureShadow = { "Feature", &SWIGTYPE_p_OGRFeatureShadow,_wrap_new_Feature, swig_delete_Feature, swig_OGRFeatureShadow_methods, swig_OGRFeatureShadow_attributes, swig_OGRFeatureShadow_bases,swig_OGRFeatureShadow_base_names, &swig_module };
+ SWIGINTERN int
+ _wrap_delete_FeatureDefn(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
+   OGRFeatureDefnShadow *arg1 = (OGRFeatureDefnShadow *) 0 ;
+   void *argp1 = 0 ;
+   int res1 = 0 ;
+   
+   if (SWIG_GetArgs(interp, objc, objv,"o:osgeo::delete_FeatureDefn self ",(void *)0) == TCL_ERROR) SWIG_fail;
+   res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_OGRFeatureDefnShadow, SWIG_POINTER_DISOWN |  0 );
+   if (!SWIG_IsOK(res1)) {
+     SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "delete_FeatureDefn" "', argument " "1"" of type '" "OGRFeatureDefnShadow *""'"); 
+   }
+   arg1 = reinterpret_cast< OGRFeatureDefnShadow * >(argp1);
+   {
+     CPLErrorReset();
+     delete_OGRFeatureDefnShadow(arg1);
+     CPLErr eclass = CPLGetLastErrorType();
+     if ( eclass == CE_Failure || eclass == CE_Fatal ) {
+       SWIG_exception( SWIG_RuntimeError, CPLGetLastErrorMsg() );
+       
+     }
+     
+     
+     
+     
+     
+     
+     
+     
+     
+     
+     
+   }
+   
+   return TCL_OK;
+ fail:
+   return TCL_ERROR;
+ }
+ 
+ 
+ SWIGINTERN int
+ _wrap_new_FeatureDefn(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
+   char *arg1 = (char *) NULL ;
+   int res1 ;
+   char *buf1 = 0 ;
+   int alloc1 = 0 ;
+   OGRFeatureDefnShadow *result = 0 ;
+   
+   if (SWIG_GetArgs(interp, objc, objv,"|o:osgeo::new_FeatureDefn ?name_null_ok? ",(void *)0) == TCL_ERROR) SWIG_fail;
+   if (objc > 1) {
+     res1 = SWIG_AsCharPtrAndSize(objv[1], &buf1, NULL, &alloc1);
+     if (!SWIG_IsOK(res1)) {
+       SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "new_FeatureDefn" "', argument " "1"" of type '" "char const *""'");
+     }
+     arg1 = reinterpret_cast< char * >(buf1);
+   }
+   {
+     CPLErrorReset();
+     result = (OGRFeatureDefnShadow *)new_OGRFeatureDefnShadow((char const *)arg1);
+     CPLErr eclass = CPLGetLastErrorType();
+     if ( eclass == CE_Failure || eclass == CE_Fatal ) {
+       SWIG_exception( SWIG_RuntimeError, CPLGetLastErrorMsg() );
+       
+     }
+     
+     
+     
+     
+     
+     
+     
+     
+     
+     
+     
+   }
+   Tcl_SetObjResult(interp, SWIG_NewInstanceObj( SWIG_as_voidptr(result), SWIGTYPE_p_OGRFeatureDefnShadow,0));
+   if (alloc1 == SWIG_NEWOBJ) delete[] buf1;
+   return TCL_OK;
+ fail:
+   if (alloc1 == SWIG_NEWOBJ) delete[] buf1;
+   return TCL_ERROR;
+ }
+ 
+ 
+ SWIGINTERN int
+ _wrap_FeatureDefn_GetName(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
+   OGRFeatureDefnShadow *arg1 = (OGRFeatureDefnShadow *) 0 ;
+   void *argp1 = 0 ;
+   int res1 = 0 ;
+   char *result = 0 ;
+   
+   if (SWIG_GetArgs(interp, objc, objv,"o:osgeo::FeatureDefn_GetName self ",(void *)0) == TCL_ERROR) SWIG_fail;
+   res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_OGRFeatureDefnShadow, 0 |  0 );
+   if (!SWIG_IsOK(res1)) {
+     SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "FeatureDefn_GetName" "', argument " "1"" of type '" "OGRFeatureDefnShadow *""'"); 
+   }
+   arg1 = reinterpret_cast< OGRFeatureDefnShadow * >(argp1);
+   {
+     CPLErrorReset();
+     result = (char *)OGRFeatureDefnShadow_GetName(arg1);
+     CPLErr eclass = CPLGetLastErrorType();
+     if ( eclass == CE_Failure || eclass == CE_Fatal ) {
+       SWIG_exception( SWIG_RuntimeError, CPLGetLastErrorMsg() );
+       
+     }
+     
+     
+     
+     
+     
+     
+     
+     
+     
+     
+     
+   }
+   Tcl_SetObjResult(interp,SWIG_FromCharPtr((const char *)result));
+   return TCL_OK;
+ fail:
+   return TCL_ERROR;
+ }
+ 
+ 
+ SWIGINTERN int
+ _wrap_FeatureDefn_GetFieldCount(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
+   OGRFeatureDefnShadow *arg1 = (OGRFeatureDefnShadow *) 0 ;
+   void *argp1 = 0 ;
+   int res1 = 0 ;
+   int result;
+   
+   if (SWIG_GetArgs(interp, objc, objv,"o:osgeo::FeatureDefn_GetFieldCount self ",(void *)0) == TCL_ERROR) SWIG_fail;
+   res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_OGRFeatureDefnShadow, 0 |  0 );
+   if (!SWIG_IsOK(res1)) {
+     SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "FeatureDefn_GetFieldCount" "', argument " "1"" of type '" "OGRFeatureDefnShadow *""'"); 
+   }
+   arg1 = reinterpret_cast< OGRFeatureDefnShadow * >(argp1);
+   {
+     CPLErrorReset();
+     result = (int)OGRFeatureDefnShadow_GetFieldCount(arg1);
+     CPLErr eclass = CPLGetLastErrorType();
+     if ( eclass == CE_Failure || eclass == CE_Fatal ) {
+       SWIG_exception( SWIG_RuntimeError, CPLGetLastErrorMsg() );
+       
+     }
+     
+     
+     
+     
+     
+     
+     
+     
+     
+     
+     
+   }
+   Tcl_SetObjResult(interp,SWIG_From_int(static_cast< int >(result)));
+   return TCL_OK;
+ fail:
+   return TCL_ERROR;
+ }
+ 
+ 
+ SWIGINTERN int
+ _wrap_FeatureDefn_GetFieldDefn(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
+   OGRFeatureDefnShadow *arg1 = (OGRFeatureDefnShadow *) 0 ;
+   int arg2 ;
+   void *argp1 = 0 ;
+   int res1 = 0 ;
+   int val2 ;
+   int ecode2 = 0 ;
+   OGRFieldDefnShadow *result = 0 ;
+   
+   if (SWIG_GetArgs(interp, objc, objv,"oo:osgeo::FeatureDefn_GetFieldDefn self i ",(void *)0,(void *)0) == TCL_ERROR) SWIG_fail;
+   res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_OGRFeatureDefnShadow, 0 |  0 );
+   if (!SWIG_IsOK(res1)) {
+     SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "FeatureDefn_GetFieldDefn" "', argument " "1"" of type '" "OGRFeatureDefnShadow *""'"); 
+   }
+   arg1 = reinterpret_cast< OGRFeatureDefnShadow * >(argp1);
+   ecode2 = SWIG_AsVal_int SWIG_TCL_CALL_ARGS_2(objv[2], &val2);
+   if (!SWIG_IsOK(ecode2)) {
+     SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "FeatureDefn_GetFieldDefn" "', argument " "2"" of type '" "int""'");
+   } 
+   arg2 = static_cast< int >(val2);
+   {
+     CPLErrorReset();
+     result = (OGRFieldDefnShadow *)OGRFeatureDefnShadow_GetFieldDefn(arg1,arg2);
+     CPLErr eclass = CPLGetLastErrorType();
+     if ( eclass == CE_Failure || eclass == CE_Fatal ) {
+       SWIG_exception( SWIG_RuntimeError, CPLGetLastErrorMsg() );
+       
+     }
+     
+     
+     
+     
+     
+     
+     
+     
+     
+     
+     
+   }
+   Tcl_SetObjResult(interp, SWIG_NewInstanceObj( SWIG_as_voidptr(result), SWIGTYPE_p_OGRFieldDefnShadow,0));
+   return TCL_OK;
+ fail:
+   return TCL_ERROR;
+ }
+ 
+ 
+ SWIGINTERN int
+ _wrap_FeatureDefn_GetFieldIndex(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
+   OGRFeatureDefnShadow *arg1 = (OGRFeatureDefnShadow *) 0 ;
+   char *arg2 = (char *) 0 ;
+   void *argp1 = 0 ;
+   int res1 = 0 ;
+   int res2 ;
+   char *buf2 = 0 ;
+   int alloc2 = 0 ;
+   int result;
+   
+   if (SWIG_GetArgs(interp, objc, objv,"oo:osgeo::FeatureDefn_GetFieldIndex self name ",(void *)0,(void *)0) == TCL_ERROR) SWIG_fail;
+   res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_OGRFeatureDefnShadow, 0 |  0 );
+   if (!SWIG_IsOK(res1)) {
+     SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "FeatureDefn_GetFieldIndex" "', argument " "1"" of type '" "OGRFeatureDefnShadow *""'"); 
+   }
+   arg1 = reinterpret_cast< OGRFeatureDefnShadow * >(argp1);
+   res2 = SWIG_AsCharPtrAndSize(objv[2], &buf2, NULL, &alloc2);
+   if (!SWIG_IsOK(res2)) {
+     SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "FeatureDefn_GetFieldIndex" "', argument " "2"" of type '" "char const *""'");
+   }
+   arg2 = reinterpret_cast< char * >(buf2);
+   {
+     CPLErrorReset();
+     result = (int)OGRFeatureDefnShadow_GetFieldIndex(arg1,(char const *)arg2);
+     CPLErr eclass = CPLGetLastErrorType();
+     if ( eclass == CE_Failure || eclass == CE_Fatal ) {
+       SWIG_exception( SWIG_RuntimeError, CPLGetLastErrorMsg() );
+       
+     }
+     
+     
+     
+     
+     
+     
+     
+     
+     
+     
+     
+   }
+   Tcl_SetObjResult(interp,SWIG_From_int(static_cast< int >(result)));
+   if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
+   return TCL_OK;
+ fail:
+   if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
+   return TCL_ERROR;
+ }
+ 
+ 
+ SWIGINTERN int
+ _wrap_FeatureDefn_AddFieldDefn(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
+   OGRFeatureDefnShadow *arg1 = (OGRFeatureDefnShadow *) 0 ;
+   OGRFieldDefnShadow *arg2 = (OGRFieldDefnShadow *) 0 ;
+   void *argp1 = 0 ;
+   int res1 = 0 ;
+   void *argp2 = 0 ;
+   int res2 = 0 ;
+   
+   if (SWIG_GetArgs(interp, objc, objv,"oo:osgeo::FeatureDefn_AddFieldDefn self defn ",(void *)0,(void *)0) == TCL_ERROR) SWIG_fail;
+   res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_OGRFeatureDefnShadow, 0 |  0 );
+   if (!SWIG_IsOK(res1)) {
+     SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "FeatureDefn_AddFieldDefn" "', argument " "1"" of type '" "OGRFeatureDefnShadow *""'"); 
+   }
+   arg1 = reinterpret_cast< OGRFeatureDefnShadow * >(argp1);
+   res2 = SWIG_ConvertPtr(objv[2], &argp2,SWIGTYPE_p_OGRFieldDefnShadow, 0 |  0 );
+   if (!SWIG_IsOK(res2)) {
+     SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "FeatureDefn_AddFieldDefn" "', argument " "2"" of type '" "OGRFieldDefnShadow *""'"); 
+   }
+   arg2 = reinterpret_cast< OGRFieldDefnShadow * >(argp2);
+   {
+     CPLErrorReset();
+     OGRFeatureDefnShadow_AddFieldDefn(arg1,arg2);
+     CPLErr eclass = CPLGetLastErrorType();
+     if ( eclass == CE_Failure || eclass == CE_Fatal ) {
+       SWIG_exception( SWIG_RuntimeError, CPLGetLastErrorMsg() );
+       
+     }
+     
+     
+     
+     
+     
+     
+     
+     
+     
+     
+     
+   }
+   
+   return TCL_OK;
+ fail:
+   return TCL_ERROR;
+ }
+ 
+ 
+ SWIGINTERN int
+ _wrap_FeatureDefn_GetGeomType(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
+   OGRFeatureDefnShadow *arg1 = (OGRFeatureDefnShadow *) 0 ;
+   void *argp1 = 0 ;
+   int res1 = 0 ;
+   OGRwkbGeometryType result;
+   
+   if (SWIG_GetArgs(interp, objc, objv,"o:osgeo::FeatureDefn_GetGeomType self ",(void *)0) == TCL_ERROR) SWIG_fail;
+   res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_OGRFeatureDefnShadow, 0 |  0 );
+   if (!SWIG_IsOK(res1)) {
+     SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "FeatureDefn_GetGeomType" "', argument " "1"" of type '" "OGRFeatureDefnShadow *""'"); 
+   }
+   arg1 = reinterpret_cast< OGRFeatureDefnShadow * >(argp1);
+   {
+     CPLErrorReset();
+     result = (OGRwkbGeometryType)OGRFeatureDefnShadow_GetGeomType(arg1);
+     CPLErr eclass = CPLGetLastErrorType();
+     if ( eclass == CE_Failure || eclass == CE_Fatal ) {
+       SWIG_exception( SWIG_RuntimeError, CPLGetLastErrorMsg() );
+       
+     }
+     
+     
+     
+     
+     
+     
+     
+     
+     
+     
+     
+   }
+   Tcl_SetObjResult(interp,SWIG_From_int(static_cast< int >(result)));
+   return TCL_OK;
+ fail:
+   return TCL_ERROR;
+ }
+ 
+ 
+ SWIGINTERN int
+ _wrap_FeatureDefn_SetGeomType(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
+   OGRFeatureDefnShadow *arg1 = (OGRFeatureDefnShadow *) 0 ;
+   OGRwkbGeometryType arg2 ;
+   void *argp1 = 0 ;
+   int res1 = 0 ;
+   int val2 ;
+   int ecode2 = 0 ;
+   
+   if (SWIG_GetArgs(interp, objc, objv,"oo:osgeo::FeatureDefn_SetGeomType self geom_type ",(void *)0,(void *)0) == TCL_ERROR) SWIG_fail;
+   res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_OGRFeatureDefnShadow, 0 |  0 );
+   if (!SWIG_IsOK(res1)) {
+     SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "FeatureDefn_SetGeomType" "', argument " "1"" of type '" "OGRFeatureDefnShadow *""'"); 
+   }
+   arg1 = reinterpret_cast< OGRFeatureDefnShadow * >(argp1);
+   ecode2 = SWIG_AsVal_int SWIG_TCL_CALL_ARGS_2(objv[2], &val2);
+   if (!SWIG_IsOK(ecode2)) {
+     SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "FeatureDefn_SetGeomType" "', argument " "2"" of type '" "OGRwkbGeometryType""'");
+   } 
+   arg2 = static_cast< OGRwkbGeometryType >(val2);
+   {
+     CPLErrorReset();
+     OGRFeatureDefnShadow_SetGeomType(arg1,arg2);
+     CPLErr eclass = CPLGetLastErrorType();
+     if ( eclass == CE_Failure || eclass == CE_Fatal ) {
+       SWIG_exception( SWIG_RuntimeError, CPLGetLastErrorMsg() );
+       
+     }
+     
+     
+     
+     
+     
+     
+     
+     
+     
+     
+     
+   }
+   
+   return TCL_OK;
+ fail:
+   return TCL_ERROR;
+ }
+ 
+ 
+ SWIGINTERN int
+ _wrap_FeatureDefn_GetReferenceCount(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
+   OGRFeatureDefnShadow *arg1 = (OGRFeatureDefnShadow *) 0 ;
+   void *argp1 = 0 ;
+   int res1 = 0 ;
+   int result;
+   
+   if (SWIG_GetArgs(interp, objc, objv,"o:osgeo::FeatureDefn_GetReferenceCount self ",(void *)0) == TCL_ERROR) SWIG_fail;
+   res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_OGRFeatureDefnShadow, 0 |  0 );
+   if (!SWIG_IsOK(res1)) {
+     SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "FeatureDefn_GetReferenceCount" "', argument " "1"" of type '" "OGRFeatureDefnShadow *""'"); 
+   }
+   arg1 = reinterpret_cast< OGRFeatureDefnShadow * >(argp1);
+   {
+     CPLErrorReset();
+     result = (int)OGRFeatureDefnShadow_GetReferenceCount(arg1);
+     CPLErr eclass = CPLGetLastErrorType();
+     if ( eclass == CE_Failure || eclass == CE_Fatal ) {
+       SWIG_exception( SWIG_RuntimeError, CPLGetLastErrorMsg() );
+       
+     }
+     
+     
+     
+     
+     
+     
+     
+     
+     
+     
+     
+   }
+   Tcl_SetObjResult(interp,SWIG_From_int(static_cast< int >(result)));
+   return TCL_OK;
+ fail:
+   return TCL_ERROR;
+ }
+ 
+ 
+ SWIGINTERN void swig_delete_FeatureDefn(void *obj) {
+ OGRFeatureDefnShadow *arg1 = (OGRFeatureDefnShadow *) obj;
+ delete_OGRFeatureDefnShadow(arg1);
+ }
+ static swig_method swig_OGRFeatureDefnShadow_methods[] = {
+     {"GetName", _wrap_FeatureDefn_GetName}, 
+     {"GetFieldCount", _wrap_FeatureDefn_GetFieldCount}, 
+     {"GetFieldDefn", _wrap_FeatureDefn_GetFieldDefn}, 
+     {"GetFieldIndex", _wrap_FeatureDefn_GetFieldIndex}, 
+     {"AddFieldDefn", _wrap_FeatureDefn_AddFieldDefn}, 
+     {"GetGeomType", _wrap_FeatureDefn_GetGeomType}, 
+     {"SetGeomType", _wrap_FeatureDefn_SetGeomType}, 
+     {"GetReferenceCount", _wrap_FeatureDefn_GetReferenceCount}, 
+     {0,0}
+ };
+ static swig_attribute swig_OGRFeatureDefnShadow_attributes[] = {
+     {0,0,0}
+ };
+ static swig_class *swig_OGRFeatureDefnShadow_bases[] = {0};
+ static const char * swig_OGRFeatureDefnShadow_base_names[] = {0};
+ static swig_class _wrap_class_OGRFeatureDefnShadow = { "FeatureDefn", &SWIGTYPE_p_OGRFeatureDefnShadow,_wrap_new_FeatureDefn, swig_delete_FeatureDefn, swig_OGRFeatureDefnShadow_methods, swig_OGRFeatureDefnShadow_attributes, swig_OGRFeatureDefnShadow_bases,swig_OGRFeatureDefnShadow_base_names, &swig_module };
+ SWIGINTERN int
+ _wrap_delete_FieldDefn(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
+   OGRFieldDefnShadow *arg1 = (OGRFieldDefnShadow *) 0 ;
+   void *argp1 = 0 ;
+   int res1 = 0 ;
+   
+   if (SWIG_GetArgs(interp, objc, objv,"o:osgeo::delete_FieldDefn self ",(void *)0) == TCL_ERROR) SWIG_fail;
+   res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_OGRFieldDefnShadow, SWIG_POINTER_DISOWN |  0 );
+   if (!SWIG_IsOK(res1)) {
+     SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "delete_FieldDefn" "', argument " "1"" of type '" "OGRFieldDefnShadow *""'"); 
+   }
+   arg1 = reinterpret_cast< OGRFieldDefnShadow * >(argp1);
+   {
+     CPLErrorReset();
+     delete_OGRFieldDefnShadow(arg1);
+     CPLErr eclass = CPLGetLastErrorType();
+     if ( eclass == CE_Failure || eclass == CE_Fatal ) {
+       SWIG_exception( SWIG_RuntimeError, CPLGetLastErrorMsg() );
+       
+     }
+     
+     
+     
+     
+     
+     
+     
+     
+     
+     
+     
+   }
+   
+   return TCL_OK;
+ fail:
+   return TCL_ERROR;
+ }
+ 
+ 
+ SWIGINTERN int
+ _wrap_new_FieldDefn(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
+   char *arg1 = (char *) "unnamed" ;
+   OGRFieldType arg2 = (OGRFieldType) OFTString ;
+   int res1 ;
+   char *buf1 = 0 ;
+   int alloc1 = 0 ;
+   int val2 ;
+   int ecode2 = 0 ;
+   OGRFieldDefnShadow *result = 0 ;
+   
+   if (SWIG_GetArgs(interp, objc, objv,"|oo:osgeo::new_FieldDefn ?name_null_ok? ?field_type? ",(void *)0,(void *)0) == TCL_ERROR) SWIG_fail;
+   if (objc > 1) {
+     res1 = SWIG_AsCharPtrAndSize(objv[1], &buf1, NULL, &alloc1);
+     if (!SWIG_IsOK(res1)) {
+       SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "new_FieldDefn" "', argument " "1"" of type '" "char const *""'");
+     }
+     arg1 = reinterpret_cast< char * >(buf1);
+   }
+   if (objc > 2) {
+     ecode2 = SWIG_AsVal_int SWIG_TCL_CALL_ARGS_2(objv[2], &val2);
+     if (!SWIG_IsOK(ecode2)) {
+       SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "new_FieldDefn" "', argument " "2"" of type '" "OGRFieldType""'");
+     } 
+     arg2 = static_cast< OGRFieldType >(val2);
+   }
+   {
+     CPLErrorReset();
+     result = (OGRFieldDefnShadow *)new_OGRFieldDefnShadow((char const *)arg1,arg2);
+     CPLErr eclass = CPLGetLastErrorType();
+     if ( eclass == CE_Failure || eclass == CE_Fatal ) {
+       SWIG_exception( SWIG_RuntimeError, CPLGetLastErrorMsg() );
+       
+     }
+     
+     
+     
+     
+     
+     
+     
+     
+     
+     
+     
+   }
+   Tcl_SetObjResult(interp, SWIG_NewInstanceObj( SWIG_as_voidptr(result), SWIGTYPE_p_OGRFieldDefnShadow,0));
+   if (alloc1 == SWIG_NEWOBJ) delete[] buf1;
+   return TCL_OK;
+ fail:
+   if (alloc1 == SWIG_NEWOBJ) delete[] buf1;
+   return TCL_ERROR;
+ }
+ 
+ 
+ SWIGINTERN int
+ _wrap_FieldDefn_GetName(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
+   OGRFieldDefnShadow *arg1 = (OGRFieldDefnShadow *) 0 ;
+   void *argp1 = 0 ;
+   int res1 = 0 ;
+   char *result = 0 ;
+   
+   if (SWIG_GetArgs(interp, objc, objv,"o:osgeo::FieldDefn_GetName self ",(void *)0) == TCL_ERROR) SWIG_fail;
+   res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_OGRFieldDefnShadow, 0 |  0 );
+   if (!SWIG_IsOK(res1)) {
+     SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "FieldDefn_GetName" "', argument " "1"" of type '" "OGRFieldDefnShadow *""'"); 
+   }
+   arg1 = reinterpret_cast< OGRFieldDefnShadow * >(argp1);
+   {
+     CPLErrorReset();
+     result = (char *)OGRFieldDefnShadow_GetName(arg1);
+     CPLErr eclass = CPLGetLastErrorType();
+     if ( eclass == CE_Failure || eclass == CE_Fatal ) {
+       SWIG_exception( SWIG_RuntimeError, CPLGetLastErrorMsg() );
+       
+     }
+     
+     
+     
+     
+     
+     
+     
+     
+     
+     
+     
+   }
+   Tcl_SetObjResult(interp,SWIG_FromCharPtr((const char *)result));
+   return TCL_OK;
+ fail:
+   return TCL_ERROR;
+ }
+ 
+ 
+ SWIGINTERN int
+ _wrap_FieldDefn_GetNameRef(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
+   OGRFieldDefnShadow *arg1 = (OGRFieldDefnShadow *) 0 ;
+   void *argp1 = 0 ;
+   int res1 = 0 ;
+   char *result = 0 ;
+   
+   if (SWIG_GetArgs(interp, objc, objv,"o:osgeo::FieldDefn_GetNameRef self ",(void *)0) == TCL_ERROR) SWIG_fail;
+   res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_OGRFieldDefnShadow, 0 |  0 );
+   if (!SWIG_IsOK(res1)) {
+     SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "FieldDefn_GetNameRef" "', argument " "1"" of type '" "OGRFieldDefnShadow *""'"); 
+   }
+   arg1 = reinterpret_cast< OGRFieldDefnShadow * >(argp1);
+   {
+     CPLErrorReset();
+     result = (char *)OGRFieldDefnShadow_GetNameRef(arg1);
+     CPLErr eclass = CPLGetLastErrorType();
+     if ( eclass == CE_Failure || eclass == CE_Fatal ) {
+       SWIG_exception( SWIG_RuntimeError, CPLGetLastErrorMsg() );
+       
+     }
+     
+     
+     
+     
+     
+     
+     
+     
+     
+     
+     
+   }
+   Tcl_SetObjResult(interp,SWIG_FromCharPtr((const char *)result));
+   return TCL_OK;
+ fail:
+   return TCL_ERROR;
+ }
+ 
+ 
+ SWIGINTERN int
+ _wrap_FieldDefn_SetName(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
+   OGRFieldDefnShadow *arg1 = (OGRFieldDefnShadow *) 0 ;
+   char *arg2 = (char *) 0 ;
+   void *argp1 = 0 ;
+   int res1 = 0 ;
+   int res2 ;
+   char *buf2 = 0 ;
+   int alloc2 = 0 ;
+   
+   if (SWIG_GetArgs(interp, objc, objv,"oo:osgeo::FieldDefn_SetName self name ",(void *)0,(void *)0) == TCL_ERROR) SWIG_fail;
+   res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_OGRFieldDefnShadow, 0 |  0 );
+   if (!SWIG_IsOK(res1)) {
+     SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "FieldDefn_SetName" "', argument " "1"" of type '" "OGRFieldDefnShadow *""'"); 
+   }
+   arg1 = reinterpret_cast< OGRFieldDefnShadow * >(argp1);
+   res2 = SWIG_AsCharPtrAndSize(objv[2], &buf2, NULL, &alloc2);
+   if (!SWIG_IsOK(res2)) {
+     SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "FieldDefn_SetName" "', argument " "2"" of type '" "char const *""'");
+   }
+   arg2 = reinterpret_cast< char * >(buf2);
+   {
+     CPLErrorReset();
+     OGRFieldDefnShadow_SetName(arg1,(char const *)arg2);
+     CPLErr eclass = CPLGetLastErrorType();
+     if ( eclass == CE_Failure || eclass == CE_Fatal ) {
+       SWIG_exception( SWIG_RuntimeError, CPLGetLastErrorMsg() );
+       
+     }
+     
+     
+     
+     
+     
+     
+     
+     
+     
+     
+     
+   }
+   
+   if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
+   return TCL_OK;
+ fail:
+   if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
+   return TCL_ERROR;
+ }
+ 
+ 
+ SWIGINTERN int
+ _wrap_FieldDefn_GetType(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
+   OGRFieldDefnShadow *arg1 = (OGRFieldDefnShadow *) 0 ;
+   void *argp1 = 0 ;
+   int res1 = 0 ;
+   OGRFieldType result;
+   
+   if (SWIG_GetArgs(interp, objc, objv,"o:osgeo::FieldDefn_GetType self ",(void *)0) == TCL_ERROR) SWIG_fail;
+   res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_OGRFieldDefnShadow, 0 |  0 );
+   if (!SWIG_IsOK(res1)) {
+     SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "FieldDefn_GetType" "', argument " "1"" of type '" "OGRFieldDefnShadow *""'"); 
+   }
+   arg1 = reinterpret_cast< OGRFieldDefnShadow * >(argp1);
+   {
+     CPLErrorReset();
+     result = (OGRFieldType)OGRFieldDefnShadow_GetType(arg1);
+     CPLErr eclass = CPLGetLastErrorType();
+     if ( eclass == CE_Failure || eclass == CE_Fatal ) {
+       SWIG_exception( SWIG_RuntimeError, CPLGetLastErrorMsg() );
+       
+     }
+     
+     
+     
+     
+     
+     
+     
+     
+     
+     
+     
+   }
+   Tcl_SetObjResult(interp,SWIG_From_int(static_cast< int >(result)));
+   return TCL_OK;
+ fail:
+   return TCL_ERROR;
+ }
+ 
+ 
+ SWIGINTERN int
+ _wrap_FieldDefn_SetType(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
+   OGRFieldDefnShadow *arg1 = (OGRFieldDefnShadow *) 0 ;
+   OGRFieldType arg2 ;
+   void *argp1 = 0 ;
+   int res1 = 0 ;
+   int val2 ;
+   int ecode2 = 0 ;
+   
+   if (SWIG_GetArgs(interp, objc, objv,"oo:osgeo::FieldDefn_SetType self type ",(void *)0,(void *)0) == TCL_ERROR) SWIG_fail;
+   res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_OGRFieldDefnShadow, 0 |  0 );
+   if (!SWIG_IsOK(res1)) {
+     SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "FieldDefn_SetType" "', argument " "1"" of type '" "OGRFieldDefnShadow *""'"); 
+   }
+   arg1 = reinterpret_cast< OGRFieldDefnShadow * >(argp1);
+   ecode2 = SWIG_AsVal_int SWIG_TCL_CALL_ARGS_2(objv[2], &val2);
+   if (!SWIG_IsOK(ecode2)) {
+     SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "FieldDefn_SetType" "', argument " "2"" of type '" "OGRFieldType""'");
+   } 
+   arg2 = static_cast< OGRFieldType >(val2);
+   {
+     CPLErrorReset();
+     OGRFieldDefnShadow_SetType(arg1,arg2);
+     CPLErr eclass = CPLGetLastErrorType();
+     if ( eclass == CE_Failure || eclass == CE_Fatal ) {
+       SWIG_exception( SWIG_RuntimeError, CPLGetLastErrorMsg() );
+       
+     }
+     
+     
+     
+     
+     
+     
+     
+     
+     
+     
+     
+   }
+   
+   return TCL_OK;
+ fail:
+   return TCL_ERROR;
+ }
+ 
+ 
+ SWIGINTERN int
+ _wrap_FieldDefn_GetJustify(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
+   OGRFieldDefnShadow *arg1 = (OGRFieldDefnShadow *) 0 ;
+   void *argp1 = 0 ;
+   int res1 = 0 ;
+   OGRJustification result;
+   
+   if (SWIG_GetArgs(interp, objc, objv,"o:osgeo::FieldDefn_GetJustify self ",(void *)0) == TCL_ERROR) SWIG_fail;
+   res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_OGRFieldDefnShadow, 0 |  0 );
+   if (!SWIG_IsOK(res1)) {
+     SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "FieldDefn_GetJustify" "', argument " "1"" of type '" "OGRFieldDefnShadow *""'"); 
+   }
+   arg1 = reinterpret_cast< OGRFieldDefnShadow * >(argp1);
+   {
+     CPLErrorReset();
+     result = (OGRJustification)OGRFieldDefnShadow_GetJustify(arg1);
+     CPLErr eclass = CPLGetLastErrorType();
+     if ( eclass == CE_Failure || eclass == CE_Fatal ) {
+       SWIG_exception( SWIG_RuntimeError, CPLGetLastErrorMsg() );
+       
+     }
+     
+     
+     
+     
+     
+     
+     
+     
+     
+     
+     
+   }
+   Tcl_SetObjResult(interp,SWIG_From_int(static_cast< int >(result)));
+   return TCL_OK;
+ fail:
+   return TCL_ERROR;
+ }
+ 
+ 
+ SWIGINTERN int
+ _wrap_FieldDefn_SetJustify(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
+   OGRFieldDefnShadow *arg1 = (OGRFieldDefnShadow *) 0 ;
+   OGRJustification arg2 ;
+   void *argp1 = 0 ;
+   int res1 = 0 ;
+   int val2 ;
+   int ecode2 = 0 ;
+   
+   if (SWIG_GetArgs(interp, objc, objv,"oo:osgeo::FieldDefn_SetJustify self justify ",(void *)0,(void *)0) == TCL_ERROR) SWIG_fail;
+   res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_OGRFieldDefnShadow, 0 |  0 );
+   if (!SWIG_IsOK(res1)) {
+     SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "FieldDefn_SetJustify" "', argument " "1"" of type '" "OGRFieldDefnShadow *""'"); 
+   }
+   arg1 = reinterpret_cast< OGRFieldDefnShadow * >(argp1);
+   ecode2 = SWIG_AsVal_int SWIG_TCL_CALL_ARGS_2(objv[2], &val2);
+   if (!SWIG_IsOK(ecode2)) {
+     SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "FieldDefn_SetJustify" "', argument " "2"" of type '" "OGRJustification""'");
+   } 
+   arg2 = static_cast< OGRJustification >(val2);
+   {
+     CPLErrorReset();
+     OGRFieldDefnShadow_SetJustify(arg1,arg2);
+     CPLErr eclass = CPLGetLastErrorType();
+     if ( eclass == CE_Failure || eclass == CE_Fatal ) {
+       SWIG_exception( SWIG_RuntimeError, CPLGetLastErrorMsg() );
+       
+     }
+     
+     
+     
+     
+     
+     
+     
+     
+     
+     
+     
+   }
+   
+   return TCL_OK;
+ fail:
+   return TCL_ERROR;
+ }
+ 
+ 
+ SWIGINTERN int
+ _wrap_FieldDefn_GetWidth(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
+   OGRFieldDefnShadow *arg1 = (OGRFieldDefnShadow *) 0 ;
+   void *argp1 = 0 ;
+   int res1 = 0 ;
+   int result;
+   
+   if (SWIG_GetArgs(interp, objc, objv,"o:osgeo::FieldDefn_GetWidth self ",(void *)0) == TCL_ERROR) SWIG_fail;
+   res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_OGRFieldDefnShadow, 0 |  0 );
+   if (!SWIG_IsOK(res1)) {
+     SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "FieldDefn_GetWidth" "', argument " "1"" of type '" "OGRFieldDefnShadow *""'"); 
+   }
+   arg1 = reinterpret_cast< OGRFieldDefnShadow * >(argp1);
+   {
+     CPLErrorReset();
+     result = (int)OGRFieldDefnShadow_GetWidth(arg1);
+     CPLErr eclass = CPLGetLastErrorType();
+     if ( eclass == CE_Failure || eclass == CE_Fatal ) {
+       SWIG_exception( SWIG_RuntimeError, CPLGetLastErrorMsg() );
+       
+     }
+     
+     
+     
+     
+     
+     
+     
+     
+     
+     
+     
+   }
+   Tcl_SetObjResult(interp,SWIG_From_int(static_cast< int >(result)));
+   return TCL_OK;
+ fail:
+   return TCL_ERROR;
+ }
+ 
+ 
+ SWIGINTERN int
+ _wrap_FieldDefn_SetWidth(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
+   OGRFieldDefnShadow *arg1 = (OGRFieldDefnShadow *) 0 ;
+   int arg2 ;
+   void *argp1 = 0 ;
+   int res1 = 0 ;
+   int val2 ;
+   int ecode2 = 0 ;
+   
+   if (SWIG_GetArgs(interp, objc, objv,"oo:osgeo::FieldDefn_SetWidth self width ",(void *)0,(void *)0) == TCL_ERROR) SWIG_fail;
+   res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_OGRFieldDefnShadow, 0 |  0 );
+   if (!SWIG_IsOK(res1)) {
+     SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "FieldDefn_SetWidth" "', argument " "1"" of type '" "OGRFieldDefnShadow *""'"); 
+   }
+   arg1 = reinterpret_cast< OGRFieldDefnShadow * >(argp1);
+   ecode2 = SWIG_AsVal_int SWIG_TCL_CALL_ARGS_2(objv[2], &val2);
+   if (!SWIG_IsOK(ecode2)) {
+     SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "FieldDefn_SetWidth" "', argument " "2"" of type '" "int""'");
+   } 
+   arg2 = static_cast< int >(val2);
+   {
+     CPLErrorReset();
+     OGRFieldDefnShadow_SetWidth(arg1,arg2);
+     CPLErr eclass = CPLGetLastErrorType();
+     if ( eclass == CE_Failure || eclass == CE_Fatal ) {
+       SWIG_exception( SWIG_RuntimeError, CPLGetLastErrorMsg() );
+       
+     }
+     
+     
+     
+     
+     
+     
+     
+     
+     
+     
+     
+   }
+   
+   return TCL_OK;
+ fail:
+   return TCL_ERROR;
+ }
+ 
+ 
+ SWIGINTERN int
+ _wrap_FieldDefn_GetPrecision(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
+   OGRFieldDefnShadow *arg1 = (OGRFieldDefnShadow *) 0 ;
+   void *argp1 = 0 ;
+   int res1 = 0 ;
+   int result;
+   
+   if (SWIG_GetArgs(interp, objc, objv,"o:osgeo::FieldDefn_GetPrecision self ",(void *)0) == TCL_ERROR) SWIG_fail;
+   res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_OGRFieldDefnShadow, 0 |  0 );
+   if (!SWIG_IsOK(res1)) {
+     SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "FieldDefn_GetPrecision" "', argument " "1"" of type '" "OGRFieldDefnShadow *""'"); 
+   }
+   arg1 = reinterpret_cast< OGRFieldDefnShadow * >(argp1);
+   {
+     CPLErrorReset();
+     result = (int)OGRFieldDefnShadow_GetPrecision(arg1);
+     CPLErr eclass = CPLGetLastErrorType();
+     if ( eclass == CE_Failure || eclass == CE_Fatal ) {
+       SWIG_exception( SWIG_RuntimeError, CPLGetLastErrorMsg() );
+       
+     }
+     
+     
+     
+     
+     
+     
+     
+     
+     
+     
+     
+   }
+   Tcl_SetObjResult(interp,SWIG_From_int(static_cast< int >(result)));
+   return TCL_OK;
+ fail:
+   return TCL_ERROR;
+ }
+ 
+ 
+ SWIGINTERN int
+ _wrap_FieldDefn_SetPrecision(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
+   OGRFieldDefnShadow *arg1 = (OGRFieldDefnShadow *) 0 ;
+   int arg2 ;
+   void *argp1 = 0 ;
+   int res1 = 0 ;
+   int val2 ;
+   int ecode2 = 0 ;
+   
+   if (SWIG_GetArgs(interp, objc, objv,"oo:osgeo::FieldDefn_SetPrecision self precision ",(void *)0,(void *)0) == TCL_ERROR) SWIG_fail;
+   res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_OGRFieldDefnShadow, 0 |  0 );
+   if (!SWIG_IsOK(res1)) {
+     SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "FieldDefn_SetPrecision" "', argument " "1"" of type '" "OGRFieldDefnShadow *""'"); 
+   }
+   arg1 = reinterpret_cast< OGRFieldDefnShadow * >(argp1);
+   ecode2 = SWIG_AsVal_int SWIG_TCL_CALL_ARGS_2(objv[2], &val2);
+   if (!SWIG_IsOK(ecode2)) {
+     SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "FieldDefn_SetPrecision" "', argument " "2"" of type '" "int""'");
+   } 
+   arg2 = static_cast< int >(val2);
+   {
+     CPLErrorReset();
+     OGRFieldDefnShadow_SetPrecision(arg1,arg2);
+     CPLErr eclass = CPLGetLastErrorType();
+     if ( eclass == CE_Failure || eclass == CE_Fatal ) {
+       SWIG_exception( SWIG_RuntimeError, CPLGetLastErrorMsg() );
+       
+     }
+     
+     
+     
+     
+     
+     
+     
+     
+     
+     
+     
+   }
+   
+   return TCL_OK;
+ fail:
+   return TCL_ERROR;
+ }
+ 
+ 
+ SWIGINTERN int
+ _wrap_FieldDefn_GetFieldTypeName(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
+   OGRFieldDefnShadow *arg1 = (OGRFieldDefnShadow *) 0 ;
+   OGRFieldType arg2 ;
+   void *argp1 = 0 ;
+   int res1 = 0 ;
+   int val2 ;
+   int ecode2 = 0 ;
+   char *result = 0 ;
+   
+   if (SWIG_GetArgs(interp, objc, objv,"oo:osgeo::FieldDefn_GetFieldTypeName self type ",(void *)0,(void *)0) == TCL_ERROR) SWIG_fail;
+   res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_OGRFieldDefnShadow, 0 |  0 );
+   if (!SWIG_IsOK(res1)) {
+     SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "FieldDefn_GetFieldTypeName" "', argument " "1"" of type '" "OGRFieldDefnShadow *""'"); 
+   }
+   arg1 = reinterpret_cast< OGRFieldDefnShadow * >(argp1);
+   ecode2 = SWIG_AsVal_int SWIG_TCL_CALL_ARGS_2(objv[2], &val2);
+   if (!SWIG_IsOK(ecode2)) {
+     SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "FieldDefn_GetFieldTypeName" "', argument " "2"" of type '" "OGRFieldType""'");
+   } 
+   arg2 = static_cast< OGRFieldType >(val2);
+   {
+     CPLErrorReset();
+     result = (char *)OGRFieldDefnShadow_GetFieldTypeName(arg1,arg2);
+     CPLErr eclass = CPLGetLastErrorType();
+     if ( eclass == CE_Failure || eclass == CE_Fatal ) {
+       SWIG_exception( SWIG_RuntimeError, CPLGetLastErrorMsg() );
+       
+     }
+     
+     
+     
+     
+     
+     
+     
+     
+     
+     
+     
+   }
+   Tcl_SetObjResult(interp,SWIG_FromCharPtr((const char *)result));
+   return TCL_OK;
+ fail:
+   return TCL_ERROR;
+ }
+ 
+ 
+ SWIGINTERN void swig_delete_FieldDefn(void *obj) {
+ OGRFieldDefnShadow *arg1 = (OGRFieldDefnShadow *) obj;
+ delete_OGRFieldDefnShadow(arg1);
+ }
+ static swig_method swig_OGRFieldDefnShadow_methods[] = {
+     {"GetName", _wrap_FieldDefn_GetName}, 
+     {"GetNameRef", _wrap_FieldDefn_GetNameRef}, 
+     {"SetName", _wrap_FieldDefn_SetName}, 
+     {"GetType", _wrap_FieldDefn_GetType}, 
+     {"SetType", _wrap_FieldDefn_SetType}, 
+     {"GetJustify", _wrap_FieldDefn_GetJustify}, 
+     {"SetJustify", _wrap_FieldDefn_SetJustify}, 
+     {"GetWidth", _wrap_FieldDefn_GetWidth}, 
+     {"SetWidth", _wrap_FieldDefn_SetWidth}, 
+     {"GetPrecision", _wrap_FieldDefn_GetPrecision}, 
+     {"SetPrecision", _wrap_FieldDefn_SetPrecision}, 
+     {"GetFieldTypeName", _wrap_FieldDefn_GetFieldTypeName}, 
+     {0,0}
+ };
+ static swig_attribute swig_OGRFieldDefnShadow_attributes[] = {
+     {0,0,0}
+ };
+ static swig_class *swig_OGRFieldDefnShadow_bases[] = {0};
+ static const char * swig_OGRFieldDefnShadow_base_names[] = {0};
+ static swig_class _wrap_class_OGRFieldDefnShadow = { "FieldDefn", &SWIGTYPE_p_OGRFieldDefnShadow,_wrap_new_FieldDefn, swig_delete_FieldDefn, swig_OGRFieldDefnShadow_methods, swig_OGRFieldDefnShadow_attributes, swig_OGRFieldDefnShadow_bases,swig_OGRFieldDefnShadow_base_names, &swig_module };
+ SWIGINTERN int
+ _wrap_CreateGeometryFromWkb(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
+   int arg1 ;
+   char *arg2 = (char *) 0 ;
+   OSRSpatialReferenceShadow *arg3 = (OSRSpatialReferenceShadow *) NULL ;
+   void *argp3 = 0 ;
+   int res3 = 0 ;
+   OGRGeometryShadow *result = 0 ;
+   
+   if (SWIG_GetArgs(interp, objc, objv,"o|o:osgeo::CreateGeometryFromWkb len ?bin_string? ?reference? ",(void *)0,(void *)0) == TCL_ERROR) SWIG_fail;
+   {
+     /* %typemap(in,numinputs=1) (int nLen, char *pBuf ) */
+     /* Storage is handled by the respective Tcl_Obj. It should considered read-only. */
+     arg2 = Tcl_GetStringFromObj(objv[1], &arg1);
+   }
+   if (objc > 2) {
+     res3 = SWIG_ConvertPtr(objv[2], &argp3,SWIGTYPE_p_OSRSpatialReferenceShadow, 0 |  0 );
+     if (!SWIG_IsOK(res3)) {
+       SWIG_exception_fail(SWIG_ArgError(res3), "in method '" "CreateGeometryFromWkb" "', argument " "3"" of type '" "OSRSpatialReferenceShadow *""'"); 
+     }
+     arg3 = reinterpret_cast< OSRSpatialReferenceShadow * >(argp3);
+   }
+   {
+     CPLErrorReset();
+     result = (OGRGeometryShadow *)CreateGeometryFromWkb(arg1,arg2,arg3);
+     CPLErr eclass = CPLGetLastErrorType();
+     if ( eclass == CE_Failure || eclass == CE_Fatal ) {
+       SWIG_exception( SWIG_RuntimeError, CPLGetLastErrorMsg() );
+       
+     }
+     
+     
+     
+     
+     
+     
+     
+     
+     
+     
+     
+   }
+   Tcl_SetObjResult(interp, SWIG_NewInstanceObj( SWIG_as_voidptr(result), SWIGTYPE_p_OGRGeometryShadow,0));
+   return TCL_OK;
+ fail:
+   return TCL_ERROR;
+ }
+ 
+ 
+ SWIGINTERN int
+ _wrap_CreateGeometryFromWkt(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
+   char **arg1 = (char **) 0 ;
+   OSRSpatialReferenceShadow *arg2 = (OSRSpatialReferenceShadow *) NULL ;
+   char *val1 ;
+   void *argp2 = 0 ;
+   int res2 = 0 ;
+   OGRGeometryShadow *result = 0 ;
+   
+   if (SWIG_GetArgs(interp, objc, objv,"o|o:osgeo::CreateGeometryFromWkt val ?reference? ",(void *)0,(void *)0) == TCL_ERROR) SWIG_fail;
+   {
+     /* %typemap(in) (char **ignorechange) */
+     val1 = Tcl_GetString(objv[1]);
+     arg1 = &val1;
+   }
+   if (objc > 2) {
+     res2 = SWIG_ConvertPtr(objv[2], &argp2,SWIGTYPE_p_OSRSpatialReferenceShadow, 0 |  0 );
+     if (!SWIG_IsOK(res2)) {
+       SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "CreateGeometryFromWkt" "', argument " "2"" of type '" "OSRSpatialReferenceShadow *""'"); 
+     }
+     arg2 = reinterpret_cast< OSRSpatialReferenceShadow * >(argp2);
+   }
+   {
+     CPLErrorReset();
+     result = (OGRGeometryShadow *)CreateGeometryFromWkt(arg1,arg2);
+     CPLErr eclass = CPLGetLastErrorType();
+     if ( eclass == CE_Failure || eclass == CE_Fatal ) {
+       SWIG_exception( SWIG_RuntimeError, CPLGetLastErrorMsg() );
+       
+     }
+     
+     
+     
+     
+     
+     
+     
+     
+     
+     
+     
+   }
+   Tcl_SetObjResult(interp, SWIG_NewInstanceObj( SWIG_as_voidptr(result), SWIGTYPE_p_OGRGeometryShadow,0));
+   return TCL_OK;
+ fail:
+   return TCL_ERROR;
+ }
+ 
+ 
+ SWIGINTERN int
+ _wrap_CreateGeometryFromGML(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
+   char *arg1 = (char *) 0 ;
+   int res1 ;
+   char *buf1 = 0 ;
+   int alloc1 = 0 ;
+   OGRGeometryShadow *result = 0 ;
+   
+   if (SWIG_GetArgs(interp, objc, objv,"o:osgeo::CreateGeometryFromGML input_string ",(void *)0) == TCL_ERROR) SWIG_fail;
+   res1 = SWIG_AsCharPtrAndSize(objv[1], &buf1, NULL, &alloc1);
+   if (!SWIG_IsOK(res1)) {
+     SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CreateGeometryFromGML" "', argument " "1"" of type '" "char const *""'");
+   }
+   arg1 = reinterpret_cast< char * >(buf1);
+   {
+     CPLErrorReset();
+     result = (OGRGeometryShadow *)CreateGeometryFromGML((char const *)arg1);
+     CPLErr eclass = CPLGetLastErrorType();
+     if ( eclass == CE_Failure || eclass == CE_Fatal ) {
+       SWIG_exception( SWIG_RuntimeError, CPLGetLastErrorMsg() );
+       
+     }
+     
+     
+     
+     
+     
+     
+     
+     
+     
+     
+     
+   }
+   Tcl_SetObjResult(interp, SWIG_NewInstanceObj( SWIG_as_voidptr(result), SWIGTYPE_p_OGRGeometryShadow,0));
+   if (alloc1 == SWIG_NEWOBJ) delete[] buf1;
+   return TCL_OK;
+ fail:
+   if (alloc1 == SWIG_NEWOBJ) delete[] buf1;
+   return TCL_ERROR;
+ }
+ 
+ 
+ SWIGINTERN int
+ _wrap_CreateGeometryFromJson(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
+   char *arg1 = (char *) 0 ;
+   int res1 ;
+   char *buf1 = 0 ;
+   int alloc1 = 0 ;
+   OGRGeometryShadow *result = 0 ;
+   
+   if (SWIG_GetArgs(interp, objc, objv,"o:osgeo::CreateGeometryFromJson input_string ",(void *)0) == TCL_ERROR) SWIG_fail;
+   res1 = SWIG_AsCharPtrAndSize(objv[1], &buf1, NULL, &alloc1);
+   if (!SWIG_IsOK(res1)) {
+     SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CreateGeometryFromJson" "', argument " "1"" of type '" "char const *""'");
+   }
+   arg1 = reinterpret_cast< char * >(buf1);
+   {
+     CPLErrorReset();
+     result = (OGRGeometryShadow *)CreateGeometryFromJson((char const *)arg1);
+     CPLErr eclass = CPLGetLastErrorType();
+     if ( eclass == CE_Failure || eclass == CE_Fatal ) {
+       SWIG_exception( SWIG_RuntimeError, CPLGetLastErrorMsg() );
+       
+     }
+     
+     
+     
+     
+     
+     
+     
+     
+     
+     
+     
+   }
+   Tcl_SetObjResult(interp, SWIG_NewInstanceObj( SWIG_as_voidptr(result), SWIGTYPE_p_OGRGeometryShadow,0));
+   if (alloc1 == SWIG_NEWOBJ) delete[] buf1;
+   return TCL_OK;
+ fail:
+   if (alloc1 == SWIG_NEWOBJ) delete[] buf1;
+   return TCL_ERROR;
+ }
+ 
+ 
+ SWIGINTERN int
+ _wrap_BuildPolygonFromEdges(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
+   OGRGeometryShadow *arg1 = (OGRGeometryShadow *) 0 ;
+   int arg2 = (int) 0 ;
+   int arg3 = (int) 0 ;
+   double arg4 = (double) 0 ;
+   void *argp1 = 0 ;
+   int res1 = 0 ;
+   int val2 ;
+   int ecode2 = 0 ;
+   int val3 ;
+   int ecode3 = 0 ;
+   double val4 ;
+   int ecode4 = 0 ;
+   OGRGeometryShadow *result = 0 ;
+   
+   if (SWIG_GetArgs(interp, objc, objv,"o|ooo:osgeo::BuildPolygonFromEdges hLineCollection ?bBestEffort? ?bAutoClose? ?dfTolerance? ",(void *)0,(void *)0,(void *)0,(void *)0) == TCL_ERROR) SWIG_fail;
+   res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_OGRGeometryShadow, 0 |  0 );
+   if (!SWIG_IsOK(res1)) {
+     SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "BuildPolygonFromEdges" "', argument " "1"" of type '" "OGRGeometryShadow *""'"); 
+   }
+   arg1 = reinterpret_cast< OGRGeometryShadow * >(argp1);
+   if (objc > 2) {
+     ecode2 = SWIG_AsVal_int SWIG_TCL_CALL_ARGS_2(objv[2], &val2);
+     if (!SWIG_IsOK(ecode2)) {
+       SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "BuildPolygonFromEdges" "', argument " "2"" of type '" "int""'");
+     } 
+     arg2 = static_cast< int >(val2);
+   }
+   if (objc > 3) {
+     ecode3 = SWIG_AsVal_int SWIG_TCL_CALL_ARGS_2(objv[3], &val3);
+     if (!SWIG_IsOK(ecode3)) {
+       SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "BuildPolygonFromEdges" "', argument " "3"" of type '" "int""'");
+     } 
+     arg3 = static_cast< int >(val3);
+   }
+   if (objc > 4) {
+     ecode4 = SWIG_AsVal_double SWIG_TCL_CALL_ARGS_2(objv[4], &val4);
+     if (!SWIG_IsOK(ecode4)) {
+       SWIG_exception_fail(SWIG_ArgError(ecode4), "in method '" "BuildPolygonFromEdges" "', argument " "4"" of type '" "double""'");
+     } 
+     arg4 = static_cast< double >(val4);
+   }
+   {
+     CPLErrorReset();
+     result = (OGRGeometryShadow *)BuildPolygonFromEdges(arg1,arg2,arg3,arg4);
+     CPLErr eclass = CPLGetLastErrorType();
+     if ( eclass == CE_Failure || eclass == CE_Fatal ) {
+       SWIG_exception( SWIG_RuntimeError, CPLGetLastErrorMsg() );
+       
+     }
+     
+     
+     
+     
+     
+     
+     
+     
+     
+     
+     
+   }
+   Tcl_SetObjResult(interp, SWIG_NewInstanceObj( SWIG_as_voidptr(result), SWIGTYPE_p_OGRGeometryShadow,0));
+   return TCL_OK;
+ fail:
+   return TCL_ERROR;
+ }
+ 
+ 
+ SWIGINTERN int
+ _wrap_delete_Geometry(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
+   OGRGeometryShadow *arg1 = (OGRGeometryShadow *) 0 ;
+   void *argp1 = 0 ;
+   int res1 = 0 ;
+   
+   if (SWIG_GetArgs(interp, objc, objv,"o:osgeo::delete_Geometry self ",(void *)0) == TCL_ERROR) SWIG_fail;
+   res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_OGRGeometryShadow, SWIG_POINTER_DISOWN |  0 );
+   if (!SWIG_IsOK(res1)) {
+     SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "delete_Geometry" "', argument " "1"" of type '" "OGRGeometryShadow *""'"); 
+   }
+   arg1 = reinterpret_cast< OGRGeometryShadow * >(argp1);
+   {
+     CPLErrorReset();
+     delete_OGRGeometryShadow(arg1);
+     CPLErr eclass = CPLGetLastErrorType();
+     if ( eclass == CE_Failure || eclass == CE_Fatal ) {
+       SWIG_exception( SWIG_RuntimeError, CPLGetLastErrorMsg() );
+       
+     }
+     
+     
+     
+     
+     
+     
+     
+     
+     
+     
+     
+   }
+   
+   return TCL_OK;
+ fail:
+   return TCL_ERROR;
+ }
+ 
+ 
+ SWIGINTERN int
+ _wrap_new_Geometry(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
+   OGRwkbGeometryType arg1 = (OGRwkbGeometryType) wkbUnknown ;
+   char *arg2 = (char *) 0 ;
+   int arg3 = (int) 0 ;
+   char *arg4 = (char *) 0 ;
+   char *arg5 = (char *) 0 ;
+   int val1 ;
+   int ecode1 = 0 ;
+   int res2 ;
+   char *buf2 = 0 ;
+   int alloc2 = 0 ;
+   int res5 ;
+   char *buf5 = 0 ;
+   int alloc5 = 0 ;
+   OGRGeometryShadow *result = 0 ;
+   
+   if (SWIG_GetArgs(interp, objc, objv,"|oooo:osgeo::new_Geometry ?type? ?wkt? ?wkb? ?wkb_buf? ?gml? ",(void *)0,(void *)0,(void *)0,(void *)0) == TCL_ERROR) SWIG_fail;
+   if (objc > 1) {
+     ecode1 = SWIG_AsVal_int SWIG_TCL_CALL_ARGS_2(objv[1], &val1);
+     if (!SWIG_IsOK(ecode1)) {
+       SWIG_exception_fail(SWIG_ArgError(ecode1), "in method '" "new_Geometry" "', argument " "1"" of type '" "OGRwkbGeometryType""'");
+     } 
+     arg1 = static_cast< OGRwkbGeometryType >(val1);
+   }
+   if (objc > 2) {
+     res2 = SWIG_AsCharPtrAndSize(objv[2], &buf2, NULL, &alloc2);
+     if (!SWIG_IsOK(res2)) {
+       SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "new_Geometry" "', argument " "2"" of type '" "char *""'");
+     }
+     arg2 = reinterpret_cast< char * >(buf2);
+   }
+   if (objc > 3) {
+     {
+       /* %typemap(in,numinputs=1) (int nLen, char *pBuf ) */
+       /* Storage is handled by the respective Tcl_Obj. It should considered read-only. */
+       arg4 = Tcl_GetStringFromObj(objv[3], &arg3);
+     }
+   }
+   if (objc > 4) {
+     res5 = SWIG_AsCharPtrAndSize(objv[4], &buf5, NULL, &alloc5);
+     if (!SWIG_IsOK(res5)) {
+       SWIG_exception_fail(SWIG_ArgError(res5), "in method '" "new_Geometry" "', argument " "5"" of type '" "char *""'");
+     }
+     arg5 = reinterpret_cast< char * >(buf5);
+   }
+   {
+     CPLErrorReset();
+     result = (OGRGeometryShadow *)new_OGRGeometryShadow(arg1,arg2,arg3,arg4,arg5);
+     CPLErr eclass = CPLGetLastErrorType();
+     if ( eclass == CE_Failure || eclass == CE_Fatal ) {
+       SWIG_exception( SWIG_RuntimeError, CPLGetLastErrorMsg() );
+       
+     }
+     
+     
+     
+     
+     
+     
+     
+     
+     
+     
+     
+   }
+   Tcl_SetObjResult(interp, SWIG_NewInstanceObj( SWIG_as_voidptr(result), SWIGTYPE_p_OGRGeometryShadow,0));
+   if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
+   if (alloc5 == SWIG_NEWOBJ) delete[] buf5;
+   return TCL_OK;
+ fail:
+   if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
+   if (alloc5 == SWIG_NEWOBJ) delete[] buf5;
+   return TCL_ERROR;
+ }
+ 
+ 
+ SWIGINTERN int
+ _wrap_Geometry_ExportToWkt(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
+   OGRGeometryShadow *arg1 = (OGRGeometryShadow *) 0 ;
+   char **arg2 = (char **) 0 ;
+   void *argp1 = 0 ;
+   int res1 = 0 ;
+   char *argout2 = 0 ;
+   OGRErr result;
+   
+   {
+     /* %typemap(in,numinputs=0) (char **argout2) */
+     arg2 = &argout2;
+   }
+   if (SWIG_GetArgs(interp, objc, objv,"o:osgeo::Geometry_ExportToWkt self ",(void *)0) == TCL_ERROR) SWIG_fail;
+   res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_OGRGeometryShadow, 0 |  0 );
+   if (!SWIG_IsOK(res1)) {
+     SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Geometry_ExportToWkt" "', argument " "1"" of type '" "OGRGeometryShadow *""'"); 
+   }
+   arg1 = reinterpret_cast< OGRGeometryShadow * >(argp1);
+   {
+     CPLErrorReset();
+     result = (OGRErr)OGRGeometryShadow_ExportToWkt(arg1,arg2);
+     CPLErr eclass = CPLGetLastErrorType();
+     if ( eclass == CE_Failure || eclass == CE_Fatal ) {
+       SWIG_exception( SWIG_RuntimeError, CPLGetLastErrorMsg() );
+       
+     }
+     
+     
+     
+     
+     
+     
+     
+     
+     
+     
+     
+   }
+   {
+     /* %typemap(out) OGRErr */
+     if (result != 0) {
+       Tcl_SetResult(interp, (char*) OGRErrMessages(result), TCL_STATIC);
+       SWIG_fail;
+     }
+   }
+   {
+     /* %typemap(argout) (char **argout) */
+     Tcl_Obj *o;
+     if ( arg2 ) {
+       o = Tcl_NewStringObj( *arg2, -1 );
+     } else {
+       o = Tcl_NewObj();
+     }
+     Tcl_ListObjAppendElement(interp,Tcl_GetObjResult(interp),o);
+   }
+   {
+     /* %typemap(ret) OGRErr */
+     if (!strcmp(Tcl_GetStringResult(interp), "{}") || !strcmp(Tcl_GetStringResult(interp), "")) {
+       Tcl_SetObjResult(interp, Tcl_NewLongObj( result ));
+     }
+   }
+   return TCL_OK;
+ fail:
+   return TCL_ERROR;
+ }
+ 
+ 
+ SWIGINTERN int
+ _wrap_Geometry_ExportToWkb(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
+   OGRGeometryShadow *arg1 = (OGRGeometryShadow *) 0 ;
+   int *arg2 = (int *) 0 ;
+   char **arg3 = (char **) 0 ;
+   OGRwkbByteOrder arg4 = (OGRwkbByteOrder) wkbXDR ;
+   void *argp1 = 0 ;
+   int res1 = 0 ;
+   int nLen2 = 0 ;
+   char *pBuf2 = 0 ;
+   int val4 ;
+   int ecode4 = 0 ;
+   OGRErr result;
+   
+   {
+     /* %typemap(in,numinputs=0) (int *nLen2, char **pBuf2 ) */
+     arg2 = &nLen2;
+     arg3 = &pBuf2;
+   }
+   if (SWIG_GetArgs(interp, objc, objv,"o|o:osgeo::Geometry_ExportToWkb self ?pBuf? ?byte_order? ",(void *)0,(void *)0) == TCL_ERROR) SWIG_fail;
+   res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_OGRGeometryShadow, 0 |  0 );
+   if (!SWIG_IsOK(res1)) {
+     SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Geometry_ExportToWkb" "', argument " "1"" of type '" "OGRGeometryShadow *""'"); 
+   }
+   arg1 = reinterpret_cast< OGRGeometryShadow * >(argp1);
+   if (objc > 2) {
+     ecode4 = SWIG_AsVal_int SWIG_TCL_CALL_ARGS_2(objv[2], &val4);
+     if (!SWIG_IsOK(ecode4)) {
+       SWIG_exception_fail(SWIG_ArgError(ecode4), "in method '" "Geometry_ExportToWkb" "', argument " "4"" of type '" "OGRwkbByteOrder""'");
+     } 
+     arg4 = static_cast< OGRwkbByteOrder >(val4);
+   }
+   {
+     CPLErrorReset();
+     result = (OGRErr)OGRGeometryShadow_ExportToWkb(arg1,arg2,arg3,arg4);
+     CPLErr eclass = CPLGetLastErrorType();
+     if ( eclass == CE_Failure || eclass == CE_Fatal ) {
+       SWIG_exception( SWIG_RuntimeError, CPLGetLastErrorMsg() );
+       
+     }
+     
+     
+     
+     
+     
+     
+     
+     
+     
+     
+     
+   }
+   {
+     /* %typemap(out) OGRErr */
+     if (result != 0) {
+       Tcl_SetResult(interp, (char*) OGRErrMessages(result), TCL_STATIC);
+       SWIG_fail;
+     }
+   }
+   {
+     /* %typemap(argout) (int *nLen, char **pBuf ) */
+     Tcl_SetObjResult(interp, Tcl_NewStringObj( *arg3, *arg2 ));
+   }
+   {
+     /* %typemap(ret) OGRErr */
+     if (!strcmp(Tcl_GetStringResult(interp), "{}") || !strcmp(Tcl_GetStringResult(interp), "")) {
+       Tcl_SetObjResult(interp, Tcl_NewLongObj( result ));
+     }
+   }
+   return TCL_OK;
+ fail:
+   return TCL_ERROR;
+ }
+ 
+ 
+ SWIGINTERN int
+ _wrap_Geometry_ExportToGML(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
+   OGRGeometryShadow *arg1 = (OGRGeometryShadow *) 0 ;
+   void *argp1 = 0 ;
+   int res1 = 0 ;
+   char *result = 0 ;
+   
+   if (SWIG_GetArgs(interp, objc, objv,"o:osgeo::Geometry_ExportToGML self ",(void *)0) == TCL_ERROR) SWIG_fail;
+   res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_OGRGeometryShadow, 0 |  0 );
+   if (!SWIG_IsOK(res1)) {
+     SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Geometry_ExportToGML" "', argument " "1"" of type '" "OGRGeometryShadow *""'"); 
+   }
+   arg1 = reinterpret_cast< OGRGeometryShadow * >(argp1);
+   {
+     CPLErrorReset();
+     result = (char *)OGRGeometryShadow_ExportToGML(arg1);
+     CPLErr eclass = CPLGetLastErrorType();
+     if ( eclass == CE_Failure || eclass == CE_Fatal ) {
+       SWIG_exception( SWIG_RuntimeError, CPLGetLastErrorMsg() );
+       
+     }
+     
+     
+     
+     
+     
+     
+     
+     
+     
+     
+     
+   }
+   Tcl_SetObjResult(interp,SWIG_FromCharPtr((const char *)result));
+   return TCL_OK;
+ fail:
+   return TCL_ERROR;
+ }
+ 
+ 
+ SWIGINTERN int
+ _wrap_Geometry_ExportToKML(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
+   OGRGeometryShadow *arg1 = (OGRGeometryShadow *) 0 ;
+   char *arg2 = (char *) NULL ;
+   void *argp1 = 0 ;
+   int res1 = 0 ;
+   int res2 ;
+   char *buf2 = 0 ;
+   int alloc2 = 0 ;
+   char *result = 0 ;
+   
+   if (SWIG_GetArgs(interp, objc, objv,"o|o:osgeo::Geometry_ExportToKML self ?altitude_mode? ",(void *)0,(void *)0) == TCL_ERROR) SWIG_fail;
+   res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_OGRGeometryShadow, 0 |  0 );
+   if (!SWIG_IsOK(res1)) {
+     SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Geometry_ExportToKML" "', argument " "1"" of type '" "OGRGeometryShadow *""'"); 
+   }
+   arg1 = reinterpret_cast< OGRGeometryShadow * >(argp1);
+   if (objc > 2) {
+     res2 = SWIG_AsCharPtrAndSize(objv[2], &buf2, NULL, &alloc2);
+     if (!SWIG_IsOK(res2)) {
+       SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "Geometry_ExportToKML" "', argument " "2"" of type '" "char const *""'");
+     }
+     arg2 = reinterpret_cast< char * >(buf2);
+   }
+   {
+     CPLErrorReset();
+     result = (char *)OGRGeometryShadow_ExportToKML(arg1,(char const *)arg2);
+     CPLErr eclass = CPLGetLastErrorType();
+     if ( eclass == CE_Failure || eclass == CE_Fatal ) {
+       SWIG_exception( SWIG_RuntimeError, CPLGetLastErrorMsg() );
+       
+     }
+     
+     
+     
+     
+     
+     
+     
+     
+     
+     
+     
+   }
+   Tcl_SetObjResult(interp,SWIG_FromCharPtr((const char *)result));
+   if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
+   return TCL_OK;
+ fail:
+   if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
+   return TCL_ERROR;
+ }
+ 
+ 
+ SWIGINTERN int
+ _wrap_Geometry_ExportToJson(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
+   OGRGeometryShadow *arg1 = (OGRGeometryShadow *) 0 ;
+   void *argp1 = 0 ;
+   int res1 = 0 ;
+   char *result = 0 ;
+   
+   if (SWIG_GetArgs(interp, objc, objv,"o:osgeo::Geometry_ExportToJson self ",(void *)0) == TCL_ERROR) SWIG_fail;
+   res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_OGRGeometryShadow, 0 |  0 );
+   if (!SWIG_IsOK(res1)) {
+     SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Geometry_ExportToJson" "', argument " "1"" of type '" "OGRGeometryShadow *""'"); 
+   }
+   arg1 = reinterpret_cast< OGRGeometryShadow * >(argp1);
+   {
+     CPLErrorReset();
+     result = (char *)OGRGeometryShadow_ExportToJson(arg1);
+     CPLErr eclass = CPLGetLastErrorType();
+     if ( eclass == CE_Failure || eclass == CE_Fatal ) {
+       SWIG_exception( SWIG_RuntimeError, CPLGetLastErrorMsg() );
+       
+     }
+     
+     
+     
+     
+     
+     
+     
+     
+     
+     
+     
+   }
+   Tcl_SetObjResult(interp,SWIG_FromCharPtr((const char *)result));
+   return TCL_OK;
+ fail:
+   return TCL_ERROR;
+ }
+ 
+ 
+ SWIGINTERN int
+ _wrap_Geometry_AddPoint(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
+   OGRGeometryShadow *arg1 = (OGRGeometryShadow *) 0 ;
+   double arg2 ;
+   double arg3 ;
+   double arg4 = (double) 0 ;
+   void *argp1 = 0 ;
+   int res1 = 0 ;
+   double val2 ;
+   int ecode2 = 0 ;
+   double val3 ;
+   int ecode3 = 0 ;
+   double val4 ;
+   int ecode4 = 0 ;
+   
+   if (SWIG_GetArgs(interp, objc, objv,"ooo|o:osgeo::Geometry_AddPoint self x y ?z? ",(void *)0,(void *)0,(void *)0,(void *)0) == TCL_ERROR) SWIG_fail;
+   res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_OGRGeometryShadow, 0 |  0 );
+   if (!SWIG_IsOK(res1)) {
+     SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Geometry_AddPoint" "', argument " "1"" of type '" "OGRGeometryShadow *""'"); 
+   }
+   arg1 = reinterpret_cast< OGRGeometryShadow * >(argp1);
+   ecode2 = SWIG_AsVal_double SWIG_TCL_CALL_ARGS_2(objv[2], &val2);
+   if (!SWIG_IsOK(ecode2)) {
+     SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "Geometry_AddPoint" "', argument " "2"" of type '" "double""'");
+   } 
+   arg2 = static_cast< double >(val2);
+   ecode3 = SWIG_AsVal_double SWIG_TCL_CALL_ARGS_2(objv[3], &val3);
+   if (!SWIG_IsOK(ecode3)) {
+     SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "Geometry_AddPoint" "', argument " "3"" of type '" "double""'");
+   } 
+   arg3 = static_cast< double >(val3);
+   if (objc > 4) {
+     ecode4 = SWIG_AsVal_double SWIG_TCL_CALL_ARGS_2(objv[4], &val4);
+     if (!SWIG_IsOK(ecode4)) {
+       SWIG_exception_fail(SWIG_ArgError(ecode4), "in method '" "Geometry_AddPoint" "', argument " "4"" of type '" "double""'");
+     } 
+     arg4 = static_cast< double >(val4);
+   }
+   {
+     CPLErrorReset();
+     OGRGeometryShadow_AddPoint(arg1,arg2,arg3,arg4);
+     CPLErr eclass = CPLGetLastErrorType();
+     if ( eclass == CE_Failure || eclass == CE_Fatal ) {
+       SWIG_exception( SWIG_RuntimeError, CPLGetLastErrorMsg() );
+       
+     }
+     
+     
+     
+     
+     
+     
+     
+     
+     
+     
+     
+   }
+   
+   return TCL_OK;
+ fail:
+   return TCL_ERROR;
+ }
+ 
+ 
+ SWIGINTERN int
+ _wrap_Geometry_AddPoint_2D(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
+   OGRGeometryShadow *arg1 = (OGRGeometryShadow *) 0 ;
+   double arg2 ;
+   double arg3 ;
+   void *argp1 = 0 ;
+   int res1 = 0 ;
+   double val2 ;
+   int ecode2 = 0 ;
+   double val3 ;
+   int ecode3 = 0 ;
+   
+   if (SWIG_GetArgs(interp, objc, objv,"ooo:osgeo::Geometry_AddPoint_2D self x y ",(void *)0,(void *)0,(void *)0) == TCL_ERROR) SWIG_fail;
+   res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_OGRGeometryShadow, 0 |  0 );
+   if (!SWIG_IsOK(res1)) {
+     SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Geometry_AddPoint_2D" "', argument " "1"" of type '" "OGRGeometryShadow *""'"); 
+   }
+   arg1 = reinterpret_cast< OGRGeometryShadow * >(argp1);
+   ecode2 = SWIG_AsVal_double SWIG_TCL_CALL_ARGS_2(objv[2], &val2);
+   if (!SWIG_IsOK(ecode2)) {
+     SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "Geometry_AddPoint_2D" "', argument " "2"" of type '" "double""'");
+   } 
+   arg2 = static_cast< double >(val2);
+   ecode3 = SWIG_AsVal_double SWIG_TCL_CALL_ARGS_2(objv[3], &val3);
+   if (!SWIG_IsOK(ecode3)) {
+     SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "Geometry_AddPoint_2D" "', argument " "3"" of type '" "double""'");
+   } 
+   arg3 = static_cast< double >(val3);
+   {
+     CPLErrorReset();
+     OGRGeometryShadow_AddPoint_2D(arg1,arg2,arg3);
+     CPLErr eclass = CPLGetLastErrorType();
+     if ( eclass == CE_Failure || eclass == CE_Fatal ) {
+       SWIG_exception( SWIG_RuntimeError, CPLGetLastErrorMsg() );
+       
+     }
+     
+     
+     
+     
+     
+     
+     
+     
+     
+     
+     
+   }
+   
+   return TCL_OK;
+ fail:
+   return TCL_ERROR;
+ }
+ 
+ 
+ SWIGINTERN int
+ _wrap_Geometry_AddGeometryDirectly(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
+   OGRGeometryShadow *arg1 = (OGRGeometryShadow *) 0 ;
+   OGRGeometryShadow *arg2 = (OGRGeometryShadow *) 0 ;
+   void *argp1 = 0 ;
+   int res1 = 0 ;
+   int res2 = 0 ;
+   OGRErr result;
+   
+   if (SWIG_GetArgs(interp, objc, objv,"oo:osgeo::Geometry_AddGeometryDirectly self other_disown ",(void *)0,(void *)0) == TCL_ERROR) SWIG_fail;
+   res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_OGRGeometryShadow, 0 |  0 );
+   if (!SWIG_IsOK(res1)) {
+     SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Geometry_AddGeometryDirectly" "', argument " "1"" of type '" "OGRGeometryShadow *""'"); 
+   }
+   arg1 = reinterpret_cast< OGRGeometryShadow * >(argp1);
+   res2 = SWIG_ConvertPtr(objv[2], SWIG_as_voidptrptr(&arg2), SWIGTYPE_p_OGRGeometryShadow, SWIG_POINTER_DISOWN |  0 );
+   if (!SWIG_IsOK(res2)) {
+     SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "Geometry_AddGeometryDirectly" "', argument " "2"" of type '" "OGRGeometryShadow *""'");
+   }
+   {
+     CPLErrorReset();
+     result = (OGRErr)OGRGeometryShadow_AddGeometryDirectly(arg1,arg2);
+     CPLErr eclass = CPLGetLastErrorType();
+     if ( eclass == CE_Failure || eclass == CE_Fatal ) {
+       SWIG_exception( SWIG_RuntimeError, CPLGetLastErrorMsg() );
+       
+     }
+     
+     
+     
+     
+     
+     
+     
+     
+     
+     
+     
+   }
+   {
+     /* %typemap(out) OGRErr */
+     if (result != 0) {
+       Tcl_SetResult(interp, (char*) OGRErrMessages(result), TCL_STATIC);
+       SWIG_fail;
+     }
+   }
+   {
+     /* %typemap(ret) OGRErr */
+     if (!strcmp(Tcl_GetStringResult(interp), "{}") || !strcmp(Tcl_GetStringResult(interp), "")) {
+       Tcl_SetObjResult(interp, Tcl_NewLongObj( result ));
+     }
+   }
+   return TCL_OK;
+ fail:
+   return TCL_ERROR;
+ }
+ 
+ 
+ SWIGINTERN int
+ _wrap_Geometry_AddGeometry(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
+   OGRGeometryShadow *arg1 = (OGRGeometryShadow *) 0 ;
+   OGRGeometryShadow *arg2 = (OGRGeometryShadow *) 0 ;
+   void *argp1 = 0 ;
+   int res1 = 0 ;
+   void *argp2 = 0 ;
+   int res2 = 0 ;
+   OGRErr result;
+   
+   if (SWIG_GetArgs(interp, objc, objv,"oo:osgeo::Geometry_AddGeometry self other ",(void *)0,(void *)0) == TCL_ERROR) SWIG_fail;
+   res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_OGRGeometryShadow, 0 |  0 );
+   if (!SWIG_IsOK(res1)) {
+     SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Geometry_AddGeometry" "', argument " "1"" of type '" "OGRGeometryShadow *""'"); 
+   }
+   arg1 = reinterpret_cast< OGRGeometryShadow * >(argp1);
+   res2 = SWIG_ConvertPtr(objv[2], &argp2,SWIGTYPE_p_OGRGeometryShadow, 0 |  0 );
+   if (!SWIG_IsOK(res2)) {
+     SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "Geometry_AddGeometry" "', argument " "2"" of type '" "OGRGeometryShadow *""'"); 
+   }
+   arg2 = reinterpret_cast< OGRGeometryShadow * >(argp2);
+   {
+     CPLErrorReset();
+     result = (OGRErr)OGRGeometryShadow_AddGeometry(arg1,arg2);
+     CPLErr eclass = CPLGetLastErrorType();
+     if ( eclass == CE_Failure || eclass == CE_Fatal ) {
+       SWIG_exception( SWIG_RuntimeError, CPLGetLastErrorMsg() );
+       
+     }
+     
+     
+     
+     
+     
+     
+     
+     
+     
+     
+     
+   }
+   {
+     /* %typemap(out) OGRErr */
+     if (result != 0) {
+       Tcl_SetResult(interp, (char*) OGRErrMessages(result), TCL_STATIC);
+       SWIG_fail;
+     }
+   }
+   {
+     /* %typemap(ret) OGRErr */
+     if (!strcmp(Tcl_GetStringResult(interp), "{}") || !strcmp(Tcl_GetStringResult(interp), "")) {
+       Tcl_SetObjResult(interp, Tcl_NewLongObj( result ));
+     }
+   }
+   return TCL_OK;
+ fail:
+   return TCL_ERROR;
+ }
+ 
+ 
+ SWIGINTERN int
+ _wrap_Geometry_Clone(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
+   OGRGeometryShadow *arg1 = (OGRGeometryShadow *) 0 ;
+   void *argp1 = 0 ;
+   int res1 = 0 ;
+   OGRGeometryShadow *result = 0 ;
+   
+   if (SWIG_GetArgs(interp, objc, objv,"o:osgeo::Geometry_Clone self ",(void *)0) == TCL_ERROR) SWIG_fail;
+   res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_OGRGeometryShadow, 0 |  0 );
+   if (!SWIG_IsOK(res1)) {
+     SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Geometry_Clone" "', argument " "1"" of type '" "OGRGeometryShadow *""'"); 
+   }
+   arg1 = reinterpret_cast< OGRGeometryShadow * >(argp1);
+   {
+     CPLErrorReset();
+     result = (OGRGeometryShadow *)OGRGeometryShadow_Clone(arg1);
+     CPLErr eclass = CPLGetLastErrorType();
+     if ( eclass == CE_Failure || eclass == CE_Fatal ) {
+       SWIG_exception( SWIG_RuntimeError, CPLGetLastErrorMsg() );
+       
+     }
+     
+     
+     
+     
+     
+     
+     
+     
+     
+     
+     
+   }
+   Tcl_SetObjResult(interp, SWIG_NewInstanceObj( SWIG_as_voidptr(result), SWIGTYPE_p_OGRGeometryShadow,0));
+   return TCL_OK;
+ fail:
+   return TCL_ERROR;
+ }
+ 
+ 
+ SWIGINTERN int
+ _wrap_Geometry_GetGeometryType(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
+   OGRGeometryShadow *arg1 = (OGRGeometryShadow *) 0 ;
+   void *argp1 = 0 ;
+   int res1 = 0 ;
+   OGRwkbGeometryType result;
+   
+   if (SWIG_GetArgs(interp, objc, objv,"o:osgeo::Geometry_GetGeometryType self ",(void *)0) == TCL_ERROR) SWIG_fail;
+   res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_OGRGeometryShadow, 0 |  0 );
+   if (!SWIG_IsOK(res1)) {
+     SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Geometry_GetGeometryType" "', argument " "1"" of type '" "OGRGeometryShadow *""'"); 
+   }
+   arg1 = reinterpret_cast< OGRGeometryShadow * >(argp1);
+   {
+     CPLErrorReset();
+     result = (OGRwkbGeometryType)OGRGeometryShadow_GetGeometryType(arg1);
+     CPLErr eclass = CPLGetLastErrorType();
+     if ( eclass == CE_Failure || eclass == CE_Fatal ) {
+       SWIG_exception( SWIG_RuntimeError, CPLGetLastErrorMsg() );
+       
+     }
+     
+     
+     
+     
+     
+     
+     
+     
+     
+     
+     
+   }
+   Tcl_SetObjResult(interp,SWIG_From_int(static_cast< int >(result)));
+   return TCL_OK;
+ fail:
+   return TCL_ERROR;
+ }
+ 
+ 
+ SWIGINTERN int
+ _wrap_Geometry_GetGeometryName(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
+   OGRGeometryShadow *arg1 = (OGRGeometryShadow *) 0 ;
+   void *argp1 = 0 ;
+   int res1 = 0 ;
+   char *result = 0 ;
+   
+   if (SWIG_GetArgs(interp, objc, objv,"o:osgeo::Geometry_GetGeometryName self ",(void *)0) == TCL_ERROR) SWIG_fail;
+   res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_OGRGeometryShadow, 0 |  0 );
+   if (!SWIG_IsOK(res1)) {
+     SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Geometry_GetGeometryName" "', argument " "1"" of type '" "OGRGeometryShadow *""'"); 
+   }
+   arg1 = reinterpret_cast< OGRGeometryShadow * >(argp1);
+   {
+     CPLErrorReset();
+     result = (char *)OGRGeometryShadow_GetGeometryName(arg1);
+     CPLErr eclass = CPLGetLastErrorType();
+     if ( eclass == CE_Failure || eclass == CE_Fatal ) {
+       SWIG_exception( SWIG_RuntimeError, CPLGetLastErrorMsg() );
+       
+     }
+     
+     
+     
+     
+     
+     
+     
+     
+     
+     
+     
+   }
+   Tcl_SetObjResult(interp,SWIG_FromCharPtr((const char *)result));
+   return TCL_OK;
+ fail:
+   return TCL_ERROR;
+ }
+ 
+ 
+ SWIGINTERN int
+ _wrap_Geometry_GetArea(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
+   OGRGeometryShadow *arg1 = (OGRGeometryShadow *) 0 ;
+   void *argp1 = 0 ;
+   int res1 = 0 ;
+   double result;
+   
+   if (SWIG_GetArgs(interp, objc, objv,"o:osgeo::Geometry_GetArea self ",(void *)0) == TCL_ERROR) SWIG_fail;
+   res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_OGRGeometryShadow, 0 |  0 );
+   if (!SWIG_IsOK(res1)) {
+     SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Geometry_GetArea" "', argument " "1"" of type '" "OGRGeometryShadow *""'"); 
+   }
+   arg1 = reinterpret_cast< OGRGeometryShadow * >(argp1);
+   {
+     CPLErrorReset();
+     result = (double)OGRGeometryShadow_GetArea(arg1);
+     CPLErr eclass = CPLGetLastErrorType();
+     if ( eclass == CE_Failure || eclass == CE_Fatal ) {
+       SWIG_exception( SWIG_RuntimeError, CPLGetLastErrorMsg() );
+       
+     }
+     
+     
+     
+     
+     
+     
+     
+     
+     
+     
+     
+   }
+   Tcl_SetObjResult(interp,SWIG_From_double(static_cast< double >(result)));
+   return TCL_OK;
+ fail:
+   return TCL_ERROR;
+ }
+ 
+ 
+ SWIGINTERN int
+ _wrap_Geometry_GetPointCount(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
+   OGRGeometryShadow *arg1 = (OGRGeometryShadow *) 0 ;
+   void *argp1 = 0 ;
+   int res1 = 0 ;
+   int result;
+   
+   if (SWIG_GetArgs(interp, objc, objv,"o:osgeo::Geometry_GetPointCount self ",(void *)0) == TCL_ERROR) SWIG_fail;
+   res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_OGRGeometryShadow, 0 |  0 );
+   if (!SWIG_IsOK(res1)) {
+     SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Geometry_GetPointCount" "', argument " "1"" of type '" "OGRGeometryShadow *""'"); 
+   }
+   arg1 = reinterpret_cast< OGRGeometryShadow * >(argp1);
+   {
+     CPLErrorReset();
+     result = (int)OGRGeometryShadow_GetPointCount(arg1);
+     CPLErr eclass = CPLGetLastErrorType();
+     if ( eclass == CE_Failure || eclass == CE_Fatal ) {
+       SWIG_exception( SWIG_RuntimeError, CPLGetLastErrorMsg() );
+       
+     }
+     
+     
+     
+     
+     
+     
+     
+     
+     
+     
+     
+   }
+   Tcl_SetObjResult(interp,SWIG_From_int(static_cast< int >(result)));
+   return TCL_OK;
+ fail:
+   return TCL_ERROR;
+ }
+ 
+ 
+ SWIGINTERN int
+ _wrap_Geometry_GetX(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
+   OGRGeometryShadow *arg1 = (OGRGeometryShadow *) 0 ;
+   int arg2 = (int) 0 ;
+   void *argp1 = 0 ;
+   int res1 = 0 ;
+   int val2 ;
+   int ecode2 = 0 ;
+   double result;
+   
+   if (SWIG_GetArgs(interp, objc, objv,"o|o:osgeo::Geometry_GetX self ?point? ",(void *)0,(void *)0) == TCL_ERROR) SWIG_fail;
+   res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_OGRGeometryShadow, 0 |  0 );
+   if (!SWIG_IsOK(res1)) {
+     SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Geometry_GetX" "', argument " "1"" of type '" "OGRGeometryShadow *""'"); 
+   }
+   arg1 = reinterpret_cast< OGRGeometryShadow * >(argp1);
+   if (objc > 2) {
+     ecode2 = SWIG_AsVal_int SWIG_TCL_CALL_ARGS_2(objv[2], &val2);
+     if (!SWIG_IsOK(ecode2)) {
+       SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "Geometry_GetX" "', argument " "2"" of type '" "int""'");
+     } 
+     arg2 = static_cast< int >(val2);
+   }
+   {
+     CPLErrorReset();
+     result = (double)OGRGeometryShadow_GetX(arg1,arg2);
+     CPLErr eclass = CPLGetLastErrorType();
+     if ( eclass == CE_Failure || eclass == CE_Fatal ) {
+       SWIG_exception( SWIG_RuntimeError, CPLGetLastErrorMsg() );
+       
+     }
+     
+     
+     
+     
+     
+     
+     
+     
+     
+     
+     
+   }
+   Tcl_SetObjResult(interp,SWIG_From_double(static_cast< double >(result)));
+   return TCL_OK;
+ fail:
+   return TCL_ERROR;
+ }
+ 
+ 
+ SWIGINTERN int
+ _wrap_Geometry_GetY(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
+   OGRGeometryShadow *arg1 = (OGRGeometryShadow *) 0 ;
+   int arg2 = (int) 0 ;
+   void *argp1 = 0 ;
+   int res1 = 0 ;
+   int val2 ;
+   int ecode2 = 0 ;
+   double result;
+   
+   if (SWIG_GetArgs(interp, objc, objv,"o|o:osgeo::Geometry_GetY self ?point? ",(void *)0,(void *)0) == TCL_ERROR) SWIG_fail;
+   res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_OGRGeometryShadow, 0 |  0 );
+   if (!SWIG_IsOK(res1)) {
+     SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Geometry_GetY" "', argument " "1"" of type '" "OGRGeometryShadow *""'"); 
+   }
+   arg1 = reinterpret_cast< OGRGeometryShadow * >(argp1);
+   if (objc > 2) {
+     ecode2 = SWIG_AsVal_int SWIG_TCL_CALL_ARGS_2(objv[2], &val2);
+     if (!SWIG_IsOK(ecode2)) {
+       SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "Geometry_GetY" "', argument " "2"" of type '" "int""'");
+     } 
+     arg2 = static_cast< int >(val2);
+   }
+   {
+     CPLErrorReset();
+     result = (double)OGRGeometryShadow_GetY(arg1,arg2);
+     CPLErr eclass = CPLGetLastErrorType();
+     if ( eclass == CE_Failure || eclass == CE_Fatal ) {
+       SWIG_exception( SWIG_RuntimeError, CPLGetLastErrorMsg() );
+       
+     }
+     
+     
+     
+     
+     
+     
+     
+     
+     
+     
+     
+   }
+   Tcl_SetObjResult(interp,SWIG_From_double(static_cast< double >(result)));
+   return TCL_OK;
+ fail:
+   return TCL_ERROR;
+ }
+ 
+ 
+ SWIGINTERN int
+ _wrap_Geometry_GetZ(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
+   OGRGeometryShadow *arg1 = (OGRGeometryShadow *) 0 ;
+   int arg2 = (int) 0 ;
+   void *argp1 = 0 ;
+   int res1 = 0 ;
+   int val2 ;
+   int ecode2 = 0 ;
+   double result;
+   
+   if (SWIG_GetArgs(interp, objc, objv,"o|o:osgeo::Geometry_GetZ self ?point? ",(void *)0,(void *)0) == TCL_ERROR) SWIG_fail;
+   res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_OGRGeometryShadow, 0 |  0 );
+   if (!SWIG_IsOK(res1)) {
+     SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Geometry_GetZ" "', argument " "1"" of type '" "OGRGeometryShadow *""'"); 
+   }
+   arg1 = reinterpret_cast< OGRGeometryShadow * >(argp1);
+   if (objc > 2) {
+     ecode2 = SWIG_AsVal_int SWIG_TCL_CALL_ARGS_2(objv[2], &val2);
+     if (!SWIG_IsOK(ecode2)) {
+       SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "Geometry_GetZ" "', argument " "2"" of type '" "int""'");
+     } 
+     arg2 = static_cast< int >(val2);
+   }
+   {
+     CPLErrorReset();
+     result = (double)OGRGeometryShadow_GetZ(arg1,arg2);
+     CPLErr eclass = CPLGetLastErrorType();
+     if ( eclass == CE_Failure || eclass == CE_Fatal ) {
+       SWIG_exception( SWIG_RuntimeError, CPLGetLastErrorMsg() );
+       
+     }
+     
+     
+     
+     
+     
+     
+     
+     
+     
+     
+     
+   }
+   Tcl_SetObjResult(interp,SWIG_From_double(static_cast< double >(result)));
+   return TCL_OK;
+ fail:
+   return TCL_ERROR;
+ }
+ 
+ 
+ SWIGINTERN int
+ _wrap_Geometry_GetPoint(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
+   OGRGeometryShadow *arg1 = (OGRGeometryShadow *) 0 ;
+   int arg2 = (int) 0 ;
+   double *arg3 = (double *) (double *)NULL ;
+   void *argp1 = 0 ;
+   int res1 = 0 ;
+   int val2 ;
+   int ecode2 = 0 ;
+   double argout3[3] ;
+   
+   {
+     /* %typemap(in,numinputs=0) (double argout3[ANY]) */
+     arg3 = argout3;
+   }
+   if (SWIG_GetArgs(interp, objc, objv,"o|o:osgeo::Geometry_GetPoint self ?iPoint? ",(void *)0,(void *)0) == TCL_ERROR) SWIG_fail;
+   res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_OGRGeometryShadow, 0 |  0 );
+   if (!SWIG_IsOK(res1)) {
+     SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Geometry_GetPoint" "', argument " "1"" of type '" "OGRGeometryShadow *""'"); 
+   }
+   arg1 = reinterpret_cast< OGRGeometryShadow * >(argp1);
+   if (objc > 2) {
+     ecode2 = SWIG_AsVal_int SWIG_TCL_CALL_ARGS_2(objv[2], &val2);
+     if (!SWIG_IsOK(ecode2)) {
+       SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "Geometry_GetPoint" "', argument " "2"" of type '" "int""'");
+     } 
+     arg2 = static_cast< int >(val2);
+   }
+   {
+     CPLErrorReset();
+     OGRGeometryShadow_GetPoint(arg1,arg2,arg3);
+     CPLErr eclass = CPLGetLastErrorType();
+     if ( eclass == CE_Failure || eclass == CE_Fatal ) {
+       SWIG_exception( SWIG_RuntimeError, CPLGetLastErrorMsg() );
+       
+     }
+     
+     
+     
+     
+     
+     
+     
+     
+     
+     
+     
+   }
+   
+   {
+     /* %typemap(argout) (double argout[ANY]) */
+     Tcl_Obj *out = CreateListFromDoubleArray( interp, arg3, 3 );
+     if (out == NULL) SWIG_fail;
+     Tcl_ListObjAppendElement(interp,Tcl_GetObjResult(interp),out);
+   }
+   return TCL_OK;
+ fail:
+   return TCL_ERROR;
+ }
+ 
+ 
+ SWIGINTERN int
+ _wrap_Geometry_GetPoint_2D(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
+   OGRGeometryShadow *arg1 = (OGRGeometryShadow *) 0 ;
+   int arg2 = (int) 0 ;
+   double *arg3 = (double *) (double *)NULL ;
+   void *argp1 = 0 ;
+   int res1 = 0 ;
+   int val2 ;
+   int ecode2 = 0 ;
+   double argout3[2] ;
+   
+   {
+     /* %typemap(in,numinputs=0) (double argout3[ANY]) */
+     arg3 = argout3;
+   }
+   if (SWIG_GetArgs(interp, objc, objv,"o|o:osgeo::Geometry_GetPoint_2D self ?iPoint? ",(void *)0,(void *)0) == TCL_ERROR) SWIG_fail;
+   res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_OGRGeometryShadow, 0 |  0 );
+   if (!SWIG_IsOK(res1)) {
+     SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Geometry_GetPoint_2D" "', argument " "1"" of type '" "OGRGeometryShadow *""'"); 
+   }
+   arg1 = reinterpret_cast< OGRGeometryShadow * >(argp1);
+   if (objc > 2) {
+     ecode2 = SWIG_AsVal_int SWIG_TCL_CALL_ARGS_2(objv[2], &val2);
+     if (!SWIG_IsOK(ecode2)) {
+       SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "Geometry_GetPoint_2D" "', argument " "2"" of type '" "int""'");
+     } 
+     arg2 = static_cast< int >(val2);
+   }
+   {
+     CPLErrorReset();
+     OGRGeometryShadow_GetPoint_2D(arg1,arg2,arg3);
+     CPLErr eclass = CPLGetLastErrorType();
+     if ( eclass == CE_Failure || eclass == CE_Fatal ) {
+       SWIG_exception( SWIG_RuntimeError, CPLGetLastErrorMsg() );
+       
+     }
+     
+     
+     
+     
+     
+     
+     
+     
+     
+     
+     
+   }
+   
+   {
+     /* %typemap(argout) (double argout[ANY]) */
+     Tcl_Obj *out = CreateListFromDoubleArray( interp, arg3, 2 );
+     if (out == NULL) SWIG_fail;
+     Tcl_ListObjAppendElement(interp,Tcl_GetObjResult(interp),out);
+   }
+   return TCL_OK;
+ fail:
+   return TCL_ERROR;
+ }
+ 
+ 
+ SWIGINTERN int
+ _wrap_Geometry_GetGeometryCount(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
+   OGRGeometryShadow *arg1 = (OGRGeometryShadow *) 0 ;
+   void *argp1 = 0 ;
+   int res1 = 0 ;
+   int result;
+   
+   if (SWIG_GetArgs(interp, objc, objv,"o:osgeo::Geometry_GetGeometryCount self ",(void *)0) == TCL_ERROR) SWIG_fail;
+   res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_OGRGeometryShadow, 0 |  0 );
+   if (!SWIG_IsOK(res1)) {
+     SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Geometry_GetGeometryCount" "', argument " "1"" of type '" "OGRGeometryShadow *""'"); 
+   }
+   arg1 = reinterpret_cast< OGRGeometryShadow * >(argp1);
+   {
+     CPLErrorReset();
+     result = (int)OGRGeometryShadow_GetGeometryCount(arg1);
+     CPLErr eclass = CPLGetLastErrorType();
+     if ( eclass == CE_Failure || eclass == CE_Fatal ) {
+       SWIG_exception( SWIG_RuntimeError, CPLGetLastErrorMsg() );
+       
+     }
+     
+     
+     
+     
+     
+     
+     
+     
+     
+     
+     
+   }
+   Tcl_SetObjResult(interp,SWIG_From_int(static_cast< int >(result)));
+   return TCL_OK;
+ fail:
+   return TCL_ERROR;
+ }
+ 
+ 
+ SWIGINTERN int
+ _wrap_Geometry_SetPoint(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
+   OGRGeometryShadow *arg1 = (OGRGeometryShadow *) 0 ;
+   int arg2 ;
+   double arg3 ;
+   double arg4 ;
+   double arg5 = (double) 0 ;
+   void *argp1 = 0 ;
+   int res1 = 0 ;
+   int val2 ;
+   int ecode2 = 0 ;
+   double val3 ;
+   int ecode3 = 0 ;
+   double val4 ;
+   int ecode4 = 0 ;
+   double val5 ;
+   int ecode5 = 0 ;
+   
+   if (SWIG_GetArgs(interp, objc, objv,"oooo|o:osgeo::Geometry_SetPoint self point x y ?z? ",(void *)0,(void *)0,(void *)0,(void *)0,(void *)0) == TCL_ERROR) SWIG_fail;
+   res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_OGRGeometryShadow, 0 |  0 );
+   if (!SWIG_IsOK(res1)) {
+     SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Geometry_SetPoint" "', argument " "1"" of type '" "OGRGeometryShadow *""'"); 
+   }
+   arg1 = reinterpret_cast< OGRGeometryShadow * >(argp1);
+   ecode2 = SWIG_AsVal_int SWIG_TCL_CALL_ARGS_2(objv[2], &val2);
+   if (!SWIG_IsOK(ecode2)) {
+     SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "Geometry_SetPoint" "', argument " "2"" of type '" "int""'");
+   } 
+   arg2 = static_cast< int >(val2);
+   ecode3 = SWIG_AsVal_double SWIG_TCL_CALL_ARGS_2(objv[3], &val3);
+   if (!SWIG_IsOK(ecode3)) {
+     SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "Geometry_SetPoint" "', argument " "3"" of type '" "double""'");
+   } 
+   arg3 = static_cast< double >(val3);
+   ecode4 = SWIG_AsVal_double SWIG_TCL_CALL_ARGS_2(objv[4], &val4);
+   if (!SWIG_IsOK(ecode4)) {
+     SWIG_exception_fail(SWIG_ArgError(ecode4), "in method '" "Geometry_SetPoint" "', argument " "4"" of type '" "double""'");
+   } 
+   arg4 = static_cast< double >(val4);
+   if (objc > 5) {
+     ecode5 = SWIG_AsVal_double SWIG_TCL_CALL_ARGS_2(objv[5], &val5);
+     if (!SWIG_IsOK(ecode5)) {
+       SWIG_exception_fail(SWIG_ArgError(ecode5), "in method '" "Geometry_SetPoint" "', argument " "5"" of type '" "double""'");
+     } 
+     arg5 = static_cast< double >(val5);
+   }
+   {
+     CPLErrorReset();
+     OGRGeometryShadow_SetPoint(arg1,arg2,arg3,arg4,arg5);
+     CPLErr eclass = CPLGetLastErrorType();
+     if ( eclass == CE_Failure || eclass == CE_Fatal ) {
+       SWIG_exception( SWIG_RuntimeError, CPLGetLastErrorMsg() );
+       
+     }
+     
+     
+     
+     
+     
+     
+     
+     
+     
+     
+     
+   }
+   
+   return TCL_OK;
+ fail:
+   return TCL_ERROR;
+ }
+ 
+ 
+ SWIGINTERN int
+ _wrap_Geometry_SetPoint_2D(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
+   OGRGeometryShadow *arg1 = (OGRGeometryShadow *) 0 ;
+   int arg2 ;
+   double arg3 ;
+   double arg4 ;
+   void *argp1 = 0 ;
+   int res1 = 0 ;
+   int val2 ;
+   int ecode2 = 0 ;
+   double val3 ;
+   int ecode3 = 0 ;
+   double val4 ;
+   int ecode4 = 0 ;
+   
+   if (SWIG_GetArgs(interp, objc, objv,"oooo:osgeo::Geometry_SetPoint_2D self point x y ",(void *)0,(void *)0,(void *)0,(void *)0) == TCL_ERROR) SWIG_fail;
+   res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_OGRGeometryShadow, 0 |  0 );
+   if (!SWIG_IsOK(res1)) {
+     SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Geometry_SetPoint_2D" "', argument " "1"" of type '" "OGRGeometryShadow *""'"); 
+   }
+   arg1 = reinterpret_cast< OGRGeometryShadow * >(argp1);
+   ecode2 = SWIG_AsVal_int SWIG_TCL_CALL_ARGS_2(objv[2], &val2);
+   if (!SWIG_IsOK(ecode2)) {
+     SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "Geometry_SetPoint_2D" "', argument " "2"" of type '" "int""'");
+   } 
+   arg2 = static_cast< int >(val2);
+   ecode3 = SWIG_AsVal_double SWIG_TCL_CALL_ARGS_2(objv[3], &val3);
+   if (!SWIG_IsOK(ecode3)) {
+     SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "Geometry_SetPoint_2D" "', argument " "3"" of type '" "double""'");
+   } 
+   arg3 = static_cast< double >(val3);
+   ecode4 = SWIG_AsVal_double SWIG_TCL_CALL_ARGS_2(objv[4], &val4);
+   if (!SWIG_IsOK(ecode4)) {
+     SWIG_exception_fail(SWIG_ArgError(ecode4), "in method '" "Geometry_SetPoint_2D" "', argument " "4"" of type '" "double""'");
+   } 
+   arg4 = static_cast< double >(val4);
+   {
+     CPLErrorReset();
+     OGRGeometryShadow_SetPoint_2D(arg1,arg2,arg3,arg4);
+     CPLErr eclass = CPLGetLastErrorType();
+     if ( eclass == CE_Failure || eclass == CE_Fatal ) {
+       SWIG_exception( SWIG_RuntimeError, CPLGetLastErrorMsg() );
+       
+     }
+     
+     
+     
+     
+     
+     
+     
+     
+     
+     
+     
+   }
+   
+   return TCL_OK;
+ fail:
+   return TCL_ERROR;
+ }
+ 
+ 
+ SWIGINTERN int
+ _wrap_Geometry_GetGeometryRef(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
+   OGRGeometryShadow *arg1 = (OGRGeometryShadow *) 0 ;
+   int arg2 ;
+   void *argp1 = 0 ;
+   int res1 = 0 ;
+   int val2 ;
+   int ecode2 = 0 ;
+   OGRGeometryShadow *result = 0 ;
+   
+   if (SWIG_GetArgs(interp, objc, objv,"oo:osgeo::Geometry_GetGeometryRef self geom ",(void *)0,(void *)0) == TCL_ERROR) SWIG_fail;
+   res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_OGRGeometryShadow, 0 |  0 );
+   if (!SWIG_IsOK(res1)) {
+     SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Geometry_GetGeometryRef" "', argument " "1"" of type '" "OGRGeometryShadow *""'"); 
+   }
+   arg1 = reinterpret_cast< OGRGeometryShadow * >(argp1);
+   ecode2 = SWIG_AsVal_int SWIG_TCL_CALL_ARGS_2(objv[2], &val2);
+   if (!SWIG_IsOK(ecode2)) {
+     SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "Geometry_GetGeometryRef" "', argument " "2"" of type '" "int""'");
+   } 
+   arg2 = static_cast< int >(val2);
+   {
+     CPLErrorReset();
+     result = (OGRGeometryShadow *)OGRGeometryShadow_GetGeometryRef(arg1,arg2);
+     CPLErr eclass = CPLGetLastErrorType();
+     if ( eclass == CE_Failure || eclass == CE_Fatal ) {
+       SWIG_exception( SWIG_RuntimeError, CPLGetLastErrorMsg() );
+       
+     }
+     
+     
+     
+     
+     
+     
+     
+     
+     
+     
+     
+   }
+   Tcl_SetObjResult(interp, SWIG_NewInstanceObj( SWIG_as_voidptr(result), SWIGTYPE_p_OGRGeometryShadow,0));
+   return TCL_OK;
+ fail:
+   return TCL_ERROR;
+ }
+ 
+ 
+ SWIGINTERN int
+ _wrap_Geometry_GetBoundary(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
+   OGRGeometryShadow *arg1 = (OGRGeometryShadow *) 0 ;
+   void *argp1 = 0 ;
+   int res1 = 0 ;
+   OGRGeometryShadow *result = 0 ;
+   
+   if (SWIG_GetArgs(interp, objc, objv,"o:osgeo::Geometry_GetBoundary self ",(void *)0) == TCL_ERROR) SWIG_fail;
+   res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_OGRGeometryShadow, 0 |  0 );
+   if (!SWIG_IsOK(res1)) {
+     SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Geometry_GetBoundary" "', argument " "1"" of type '" "OGRGeometryShadow *""'"); 
+   }
+   arg1 = reinterpret_cast< OGRGeometryShadow * >(argp1);
+   {
+     CPLErrorReset();
+     result = (OGRGeometryShadow *)OGRGeometryShadow_GetBoundary(arg1);
+     CPLErr eclass = CPLGetLastErrorType();
+     if ( eclass == CE_Failure || eclass == CE_Fatal ) {
+       SWIG_exception( SWIG_RuntimeError, CPLGetLastErrorMsg() );
+       
+     }
+     
+     
+     
+     
+     
+     
+     
+     
+     
+     
+     
+   }
+   Tcl_SetObjResult(interp, SWIG_NewInstanceObj( SWIG_as_voidptr(result), SWIGTYPE_p_OGRGeometryShadow,0));
+   return TCL_OK;
+ fail:
+   return TCL_ERROR;
+ }
+ 
+ 
+ SWIGINTERN int
+ _wrap_Geometry_ConvexHull(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
+   OGRGeometryShadow *arg1 = (OGRGeometryShadow *) 0 ;
+   void *argp1 = 0 ;
+   int res1 = 0 ;
+   OGRGeometryShadow *result = 0 ;
+   
+   if (SWIG_GetArgs(interp, objc, objv,"o:osgeo::Geometry_ConvexHull self ",(void *)0) == TCL_ERROR) SWIG_fail;
+   res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_OGRGeometryShadow, 0 |  0 );
+   if (!SWIG_IsOK(res1)) {
+     SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Geometry_ConvexHull" "', argument " "1"" of type '" "OGRGeometryShadow *""'"); 
+   }
+   arg1 = reinterpret_cast< OGRGeometryShadow * >(argp1);
+   {
+     CPLErrorReset();
+     result = (OGRGeometryShadow *)OGRGeometryShadow_ConvexHull(arg1);
+     CPLErr eclass = CPLGetLastErrorType();
+     if ( eclass == CE_Failure || eclass == CE_Fatal ) {
+       SWIG_exception( SWIG_RuntimeError, CPLGetLastErrorMsg() );
+       
+     }
+     
+     
+     
+     
+     
+     
+     
+     
+     
+     
+     
+   }
+   Tcl_SetObjResult(interp, SWIG_NewInstanceObj( SWIG_as_voidptr(result), SWIGTYPE_p_OGRGeometryShadow,0));
+   return TCL_OK;
+ fail:
+   return TCL_ERROR;
+ }
+ 
+ 
+ SWIGINTERN int
+ _wrap_Geometry_Buffer(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
+   OGRGeometryShadow *arg1 = (OGRGeometryShadow *) 0 ;
+   double arg2 ;
+   int arg3 = (int) 30 ;
+   void *argp1 = 0 ;
+   int res1 = 0 ;
+   double val2 ;
+   int ecode2 = 0 ;
+   int val3 ;
+   int ecode3 = 0 ;
+   OGRGeometryShadow *result = 0 ;
+   
+   if (SWIG_GetArgs(interp, objc, objv,"oo|o:osgeo::Geometry_Buffer self distance ?quadsecs? ",(void *)0,(void *)0,(void *)0) == TCL_ERROR) SWIG_fail;
+   res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_OGRGeometryShadow, 0 |  0 );
+   if (!SWIG_IsOK(res1)) {
+     SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Geometry_Buffer" "', argument " "1"" of type '" "OGRGeometryShadow *""'"); 
+   }
+   arg1 = reinterpret_cast< OGRGeometryShadow * >(argp1);
+   ecode2 = SWIG_AsVal_double SWIG_TCL_CALL_ARGS_2(objv[2], &val2);
+   if (!SWIG_IsOK(ecode2)) {
+     SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "Geometry_Buffer" "', argument " "2"" of type '" "double""'");
+   } 
+   arg2 = static_cast< double >(val2);
+   if (objc > 3) {
+     ecode3 = SWIG_AsVal_int SWIG_TCL_CALL_ARGS_2(objv[3], &val3);
+     if (!SWIG_IsOK(ecode3)) {
+       SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "Geometry_Buffer" "', argument " "3"" of type '" "int""'");
+     } 
+     arg3 = static_cast< int >(val3);
+   }
+   {
+     CPLErrorReset();
+     result = (OGRGeometryShadow *)OGRGeometryShadow_Buffer(arg1,arg2,arg3);
+     CPLErr eclass = CPLGetLastErrorType();
+     if ( eclass == CE_Failure || eclass == CE_Fatal ) {
+       SWIG_exception( SWIG_RuntimeError, CPLGetLastErrorMsg() );
+       
+     }
+     
+     
+     
+     
+     
+     
+     
+     
+     
+     
+     
+   }
+   Tcl_SetObjResult(interp, SWIG_NewInstanceObj( SWIG_as_voidptr(result), SWIGTYPE_p_OGRGeometryShadow,0));
+   return TCL_OK;
+ fail:
+   return TCL_ERROR;
+ }
+ 
+ 
+ SWIGINTERN int
+ _wrap_Geometry_Intersection(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
+   OGRGeometryShadow *arg1 = (OGRGeometryShadow *) 0 ;
+   OGRGeometryShadow *arg2 = (OGRGeometryShadow *) 0 ;
+   void *argp1 = 0 ;
+   int res1 = 0 ;
+   void *argp2 = 0 ;
+   int res2 = 0 ;
+   OGRGeometryShadow *result = 0 ;
+   
+   if (SWIG_GetArgs(interp, objc, objv,"oo:osgeo::Geometry_Intersection self other ",(void *)0,(void *)0) == TCL_ERROR) SWIG_fail;
+   res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_OGRGeometryShadow, 0 |  0 );
+   if (!SWIG_IsOK(res1)) {
+     SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Geometry_Intersection" "', argument " "1"" of type '" "OGRGeometryShadow *""'"); 
+   }
+   arg1 = reinterpret_cast< OGRGeometryShadow * >(argp1);
+   res2 = SWIG_ConvertPtr(objv[2], &argp2,SWIGTYPE_p_OGRGeometryShadow, 0 |  0 );
+   if (!SWIG_IsOK(res2)) {
+     SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "Geometry_Intersection" "', argument " "2"" of type '" "OGRGeometryShadow *""'"); 
+   }
+   arg2 = reinterpret_cast< OGRGeometryShadow * >(argp2);
+   {
+     CPLErrorReset();
+     result = (OGRGeometryShadow *)OGRGeometryShadow_Intersection(arg1,arg2);
+     CPLErr eclass = CPLGetLastErrorType();
+     if ( eclass == CE_Failure || eclass == CE_Fatal ) {
+       SWIG_exception( SWIG_RuntimeError, CPLGetLastErrorMsg() );
+       
+     }
+     
+     
+     
+     
+     
+     
+     
+     
+     
+     
+     
+   }
+   Tcl_SetObjResult(interp, SWIG_NewInstanceObj( SWIG_as_voidptr(result), SWIGTYPE_p_OGRGeometryShadow,0));
+   return TCL_OK;
+ fail:
+   return TCL_ERROR;
+ }
+ 
+ 
+ SWIGINTERN int
+ _wrap_Geometry_Union(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
+   OGRGeometryShadow *arg1 = (OGRGeometryShadow *) 0 ;
+   OGRGeometryShadow *arg2 = (OGRGeometryShadow *) 0 ;
+   void *argp1 = 0 ;
+   int res1 = 0 ;
+   void *argp2 = 0 ;
+   int res2 = 0 ;
+   OGRGeometryShadow *result = 0 ;
+   
+   if (SWIG_GetArgs(interp, objc, objv,"oo:osgeo::Geometry_Union self other ",(void *)0,(void *)0) == TCL_ERROR) SWIG_fail;
+   res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_OGRGeometryShadow, 0 |  0 );
+   if (!SWIG_IsOK(res1)) {
+     SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Geometry_Union" "', argument " "1"" of type '" "OGRGeometryShadow *""'"); 
+   }
+   arg1 = reinterpret_cast< OGRGeometryShadow * >(argp1);
+   res2 = SWIG_ConvertPtr(objv[2], &argp2,SWIGTYPE_p_OGRGeometryShadow, 0 |  0 );
+   if (!SWIG_IsOK(res2)) {
+     SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "Geometry_Union" "', argument " "2"" of type '" "OGRGeometryShadow *""'"); 
+   }
+   arg2 = reinterpret_cast< OGRGeometryShadow * >(argp2);
+   {
+     CPLErrorReset();
+     result = (OGRGeometryShadow *)OGRGeometryShadow_Union(arg1,arg2);
+     CPLErr eclass = CPLGetLastErrorType();
+     if ( eclass == CE_Failure || eclass == CE_Fatal ) {
+       SWIG_exception( SWIG_RuntimeError, CPLGetLastErrorMsg() );
+       
+     }
+     
+     
+     
+     
+     
+     
+     
+     
+     
+     
+     
+   }
+   Tcl_SetObjResult(interp, SWIG_NewInstanceObj( SWIG_as_voidptr(result), SWIGTYPE_p_OGRGeometryShadow,0));
+   return TCL_OK;
+ fail:
+   return TCL_ERROR;
+ }
+ 
+ 
+ SWIGINTERN int
+ _wrap_Geometry_Difference(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
+   OGRGeometryShadow *arg1 = (OGRGeometryShadow *) 0 ;
+   OGRGeometryShadow *arg2 = (OGRGeometryShadow *) 0 ;
+   void *argp1 = 0 ;
+   int res1 = 0 ;
+   void *argp2 = 0 ;
+   int res2 = 0 ;
+   OGRGeometryShadow *result = 0 ;
+   
+   if (SWIG_GetArgs(interp, objc, objv,"oo:osgeo::Geometry_Difference self other ",(void *)0,(void *)0) == TCL_ERROR) SWIG_fail;
+   res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_OGRGeometryShadow, 0 |  0 );
+   if (!SWIG_IsOK(res1)) {
+     SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Geometry_Difference" "', argument " "1"" of type '" "OGRGeometryShadow *""'"); 
+   }
+   arg1 = reinterpret_cast< OGRGeometryShadow * >(argp1);
+   res2 = SWIG_ConvertPtr(objv[2], &argp2,SWIGTYPE_p_OGRGeometryShadow, 0 |  0 );
+   if (!SWIG_IsOK(res2)) {
+     SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "Geometry_Difference" "', argument " "2"" of type '" "OGRGeometryShadow *""'"); 
+   }
+   arg2 = reinterpret_cast< OGRGeometryShadow * >(argp2);
+   {
+     CPLErrorReset();
+     result = (OGRGeometryShadow *)OGRGeometryShadow_Difference(arg1,arg2);
+     CPLErr eclass = CPLGetLastErrorType();
+     if ( eclass == CE_Failure || eclass == CE_Fatal ) {
+       SWIG_exception( SWIG_RuntimeError, CPLGetLastErrorMsg() );
+       
+     }
+     
+     
+     
+     
+     
+     
+     
+     
+     
+     
+     
+   }
+   Tcl_SetObjResult(interp, SWIG_NewInstanceObj( SWIG_as_voidptr(result), SWIGTYPE_p_OGRGeometryShadow,0));
+   return TCL_OK;
+ fail:
+   return TCL_ERROR;
+ }
+ 
+ 
+ SWIGINTERN int
+ _wrap_Geometry_SymmetricDifference(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
+   OGRGeometryShadow *arg1 = (OGRGeometryShadow *) 0 ;
+   OGRGeometryShadow *arg2 = (OGRGeometryShadow *) 0 ;
+   void *argp1 = 0 ;
+   int res1 = 0 ;
+   void *argp2 = 0 ;
+   int res2 = 0 ;
+   OGRGeometryShadow *result = 0 ;
+   
+   if (SWIG_GetArgs(interp, objc, objv,"oo:osgeo::Geometry_SymmetricDifference self other ",(void *)0,(void *)0) == TCL_ERROR) SWIG_fail;
+   res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_OGRGeometryShadow, 0 |  0 );
+   if (!SWIG_IsOK(res1)) {
+     SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Geometry_SymmetricDifference" "', argument " "1"" of type '" "OGRGeometryShadow *""'"); 
+   }
+   arg1 = reinterpret_cast< OGRGeometryShadow * >(argp1);
+   res2 = SWIG_ConvertPtr(objv[2], &argp2,SWIGTYPE_p_OGRGeometryShadow, 0 |  0 );
+   if (!SWIG_IsOK(res2)) {
+     SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "Geometry_SymmetricDifference" "', argument " "2"" of type '" "OGRGeometryShadow *""'"); 
+   }
+   arg2 = reinterpret_cast< OGRGeometryShadow * >(argp2);
+   {
+     CPLErrorReset();
+     result = (OGRGeometryShadow *)OGRGeometryShadow_SymmetricDifference(arg1,arg2);
+     CPLErr eclass = CPLGetLastErrorType();
+     if ( eclass == CE_Failure || eclass == CE_Fatal ) {
+       SWIG_exception( SWIG_RuntimeError, CPLGetLastErrorMsg() );
+       
+     }
+     
+     
+     
+     
+     
+     
+     
+     
+     
+     
+     
+   }
+   Tcl_SetObjResult(interp, SWIG_NewInstanceObj( SWIG_as_voidptr(result), SWIGTYPE_p_OGRGeometryShadow,0));
+   return TCL_OK;
+ fail:
+   return TCL_ERROR;
+ }
+ 
+ 
+ SWIGINTERN int
+ _wrap_Geometry_Distance(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
+   OGRGeometryShadow *arg1 = (OGRGeometryShadow *) 0 ;
+   OGRGeometryShadow *arg2 = (OGRGeometryShadow *) 0 ;
+   void *argp1 = 0 ;
+   int res1 = 0 ;
+   void *argp2 = 0 ;
+   int res2 = 0 ;
+   double result;
+   
+   if (SWIG_GetArgs(interp, objc, objv,"oo:osgeo::Geometry_Distance self other ",(void *)0,(void *)0) == TCL_ERROR) SWIG_fail;
+   res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_OGRGeometryShadow, 0 |  0 );
+   if (!SWIG_IsOK(res1)) {
+     SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Geometry_Distance" "', argument " "1"" of type '" "OGRGeometryShadow *""'"); 
+   }
+   arg1 = reinterpret_cast< OGRGeometryShadow * >(argp1);
+   res2 = SWIG_ConvertPtr(objv[2], &argp2,SWIGTYPE_p_OGRGeometryShadow, 0 |  0 );
+   if (!SWIG_IsOK(res2)) {
+     SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "Geometry_Distance" "', argument " "2"" of type '" "OGRGeometryShadow *""'"); 
+   }
+   arg2 = reinterpret_cast< OGRGeometryShadow * >(argp2);
+   {
+     CPLErrorReset();
+     result = (double)OGRGeometryShadow_Distance(arg1,arg2);
+     CPLErr eclass = CPLGetLastErrorType();
+     if ( eclass == CE_Failure || eclass == CE_Fatal ) {
+       SWIG_exception( SWIG_RuntimeError, CPLGetLastErrorMsg() );
+       
+     }
+     
+     
+     
+     
+     
+     
+     
+     
+     
+     
+     
+   }
+   Tcl_SetObjResult(interp,SWIG_From_double(static_cast< double >(result)));
+   return TCL_OK;
+ fail:
+   return TCL_ERROR;
+ }
+ 
+ 
+ SWIGINTERN int
+ _wrap_Geometry_Empty(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
+   OGRGeometryShadow *arg1 = (OGRGeometryShadow *) 0 ;
+   void *argp1 = 0 ;
+   int res1 = 0 ;
+   
+   if (SWIG_GetArgs(interp, objc, objv,"o:osgeo::Geometry_Empty self ",(void *)0) == TCL_ERROR) SWIG_fail;
+   res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_OGRGeometryShadow, 0 |  0 );
+   if (!SWIG_IsOK(res1)) {
+     SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Geometry_Empty" "', argument " "1"" of type '" "OGRGeometryShadow *""'"); 
+   }
+   arg1 = reinterpret_cast< OGRGeometryShadow * >(argp1);
+   {
+     CPLErrorReset();
+     OGRGeometryShadow_Empty(arg1);
+     CPLErr eclass = CPLGetLastErrorType();
+     if ( eclass == CE_Failure || eclass == CE_Fatal ) {
+       SWIG_exception( SWIG_RuntimeError, CPLGetLastErrorMsg() );
+       
+     }
+     
+     
+     
+     
+     
+     
+     
+     
+     
+     
+     
+   }
+   
+   return TCL_OK;
+ fail:
+   return TCL_ERROR;
+ }
+ 
+ 
+ SWIGINTERN int
+ _wrap_Geometry_IsEmpty(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
+   OGRGeometryShadow *arg1 = (OGRGeometryShadow *) 0 ;
+   void *argp1 = 0 ;
+   int res1 = 0 ;
+   bool result;
+   
+   if (SWIG_GetArgs(interp, objc, objv,"o:osgeo::Geometry_IsEmpty self ",(void *)0) == TCL_ERROR) SWIG_fail;
+   res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_OGRGeometryShadow, 0 |  0 );
+   if (!SWIG_IsOK(res1)) {
+     SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Geometry_IsEmpty" "', argument " "1"" of type '" "OGRGeometryShadow *""'"); 
+   }
+   arg1 = reinterpret_cast< OGRGeometryShadow * >(argp1);
+   {
+     CPLErrorReset();
+     result = (bool)OGRGeometryShadow_IsEmpty(arg1);
+     CPLErr eclass = CPLGetLastErrorType();
+     if ( eclass == CE_Failure || eclass == CE_Fatal ) {
+       SWIG_exception( SWIG_RuntimeError, CPLGetLastErrorMsg() );
+       
+     }
+     
+     
+     
+     
+     
+     
+     
+     
+     
+     
+     
+   }
+   Tcl_SetObjResult(interp,SWIG_From_bool(static_cast< bool >(result)));
+   return TCL_OK;
+ fail:
+   return TCL_ERROR;
+ }
+ 
+ 
+ SWIGINTERN int
+ _wrap_Geometry_IsValid(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
+   OGRGeometryShadow *arg1 = (OGRGeometryShadow *) 0 ;
+   void *argp1 = 0 ;
+   int res1 = 0 ;
+   bool result;
+   
+   if (SWIG_GetArgs(interp, objc, objv,"o:osgeo::Geometry_IsValid self ",(void *)0) == TCL_ERROR) SWIG_fail;
+   res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_OGRGeometryShadow, 0 |  0 );
+   if (!SWIG_IsOK(res1)) {
+     SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Geometry_IsValid" "', argument " "1"" of type '" "OGRGeometryShadow *""'"); 
+   }
+   arg1 = reinterpret_cast< OGRGeometryShadow * >(argp1);
+   {
+     CPLErrorReset();
+     result = (bool)OGRGeometryShadow_IsValid(arg1);
+     CPLErr eclass = CPLGetLastErrorType();
+     if ( eclass == CE_Failure || eclass == CE_Fatal ) {
+       SWIG_exception( SWIG_RuntimeError, CPLGetLastErrorMsg() );
+       
+     }
+     
+     
+     
+     
+     
+     
+     
+     
+     
+     
+     
+   }
+   Tcl_SetObjResult(interp,SWIG_From_bool(static_cast< bool >(result)));
+   return TCL_OK;
+ fail:
+   return TCL_ERROR;
+ }
+ 
+ 
+ SWIGINTERN int
+ _wrap_Geometry_IsSimple(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
+   OGRGeometryShadow *arg1 = (OGRGeometryShadow *) 0 ;
+   void *argp1 = 0 ;
+   int res1 = 0 ;
+   bool result;
+   
+   if (SWIG_GetArgs(interp, objc, objv,"o:osgeo::Geometry_IsSimple self ",(void *)0) == TCL_ERROR) SWIG_fail;
+   res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_OGRGeometryShadow, 0 |  0 );
+   if (!SWIG_IsOK(res1)) {
+     SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Geometry_IsSimple" "', argument " "1"" of type '" "OGRGeometryShadow *""'"); 
+   }
+   arg1 = reinterpret_cast< OGRGeometryShadow * >(argp1);
+   {
+     CPLErrorReset();
+     result = (bool)OGRGeometryShadow_IsSimple(arg1);
+     CPLErr eclass = CPLGetLastErrorType();
+     if ( eclass == CE_Failure || eclass == CE_Fatal ) {
+       SWIG_exception( SWIG_RuntimeError, CPLGetLastErrorMsg() );
+       
+     }
+     
+     
+     
+     
+     
+     
+     
+     
+     
+     
+     
+   }
+   Tcl_SetObjResult(interp,SWIG_From_bool(static_cast< bool >(result)));
+   return TCL_OK;
+ fail:
+   return TCL_ERROR;
+ }
+ 
+ 
+ SWIGINTERN int
+ _wrap_Geometry_IsRing(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
+   OGRGeometryShadow *arg1 = (OGRGeometryShadow *) 0 ;
+   void *argp1 = 0 ;
+   int res1 = 0 ;
+   bool result;
+   
+   if (SWIG_GetArgs(interp, objc, objv,"o:osgeo::Geometry_IsRing self ",(void *)0) == TCL_ERROR) SWIG_fail;
+   res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_OGRGeometryShadow, 0 |  0 );
+   if (!SWIG_IsOK(res1)) {
+     SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Geometry_IsRing" "', argument " "1"" of type '" "OGRGeometryShadow *""'"); 
+   }
+   arg1 = reinterpret_cast< OGRGeometryShadow * >(argp1);
+   {
+     CPLErrorReset();
+     result = (bool)OGRGeometryShadow_IsRing(arg1);
+     CPLErr eclass = CPLGetLastErrorType();
+     if ( eclass == CE_Failure || eclass == CE_Fatal ) {
+       SWIG_exception( SWIG_RuntimeError, CPLGetLastErrorMsg() );
+       
+     }
+     
+     
+     
+     
+     
+     
+     
+     
+     
+     
+     
+   }
+   Tcl_SetObjResult(interp,SWIG_From_bool(static_cast< bool >(result)));
+   return TCL_OK;
+ fail:
+   return TCL_ERROR;
+ }
+ 
+ 
+ SWIGINTERN int
+ _wrap_Geometry_Intersect(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
+   OGRGeometryShadow *arg1 = (OGRGeometryShadow *) 0 ;
+   OGRGeometryShadow *arg2 = (OGRGeometryShadow *) 0 ;
+   void *argp1 = 0 ;
+   int res1 = 0 ;
+   void *argp2 = 0 ;
+   int res2 = 0 ;
+   bool result;
+   
+   if (SWIG_GetArgs(interp, objc, objv,"oo:osgeo::Geometry_Intersect self other ",(void *)0,(void *)0) == TCL_ERROR) SWIG_fail;
+   res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_OGRGeometryShadow, 0 |  0 );
+   if (!SWIG_IsOK(res1)) {
+     SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Geometry_Intersect" "', argument " "1"" of type '" "OGRGeometryShadow *""'"); 
+   }
+   arg1 = reinterpret_cast< OGRGeometryShadow * >(argp1);
+   res2 = SWIG_ConvertPtr(objv[2], &argp2,SWIGTYPE_p_OGRGeometryShadow, 0 |  0 );
+   if (!SWIG_IsOK(res2)) {
+     SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "Geometry_Intersect" "', argument " "2"" of type '" "OGRGeometryShadow *""'"); 
+   }
+   arg2 = reinterpret_cast< OGRGeometryShadow * >(argp2);
+   {
+     CPLErrorReset();
+     result = (bool)OGRGeometryShadow_Intersect(arg1,arg2);
+     CPLErr eclass = CPLGetLastErrorType();
+     if ( eclass == CE_Failure || eclass == CE_Fatal ) {
+       SWIG_exception( SWIG_RuntimeError, CPLGetLastErrorMsg() );
+       
+     }
+     
+     
+     
+     
+     
+     
+     
+     
+     
+     
+     
+   }
+   Tcl_SetObjResult(interp,SWIG_From_bool(static_cast< bool >(result)));
+   return TCL_OK;
+ fail:
+   return TCL_ERROR;
+ }
+ 
+ 
+ SWIGINTERN int
+ _wrap_Geometry_Equal(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
+   OGRGeometryShadow *arg1 = (OGRGeometryShadow *) 0 ;
+   OGRGeometryShadow *arg2 = (OGRGeometryShadow *) 0 ;
+   void *argp1 = 0 ;
+   int res1 = 0 ;
+   void *argp2 = 0 ;
+   int res2 = 0 ;
+   bool result;
+   
+   if (SWIG_GetArgs(interp, objc, objv,"oo:osgeo::Geometry_Equal self other ",(void *)0,(void *)0) == TCL_ERROR) SWIG_fail;
+   res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_OGRGeometryShadow, 0 |  0 );
+   if (!SWIG_IsOK(res1)) {
+     SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Geometry_Equal" "', argument " "1"" of type '" "OGRGeometryShadow *""'"); 
+   }
+   arg1 = reinterpret_cast< OGRGeometryShadow * >(argp1);
+   res2 = SWIG_ConvertPtr(objv[2], &argp2,SWIGTYPE_p_OGRGeometryShadow, 0 |  0 );
+   if (!SWIG_IsOK(res2)) {
+     SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "Geometry_Equal" "', argument " "2"" of type '" "OGRGeometryShadow *""'"); 
+   }
+   arg2 = reinterpret_cast< OGRGeometryShadow * >(argp2);
+   {
+     CPLErrorReset();
+     result = (bool)OGRGeometryShadow_Equal(arg1,arg2);
+     CPLErr eclass = CPLGetLastErrorType();
+     if ( eclass == CE_Failure || eclass == CE_Fatal ) {
+       SWIG_exception( SWIG_RuntimeError, CPLGetLastErrorMsg() );
+       
+     }
+     
+     
+     
+     
+     
+     
+     
+     
+     
+     
+     
+   }
+   Tcl_SetObjResult(interp,SWIG_From_bool(static_cast< bool >(result)));
+   return TCL_OK;
+ fail:
+   return TCL_ERROR;
+ }
+ 
+ 
+ SWIGINTERN int
+ _wrap_Geometry_Disjoint(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
+   OGRGeometryShadow *arg1 = (OGRGeometryShadow *) 0 ;
+   OGRGeometryShadow *arg2 = (OGRGeometryShadow *) 0 ;
+   void *argp1 = 0 ;
+   int res1 = 0 ;
+   void *argp2 = 0 ;
+   int res2 = 0 ;
+   bool result;
+   
+   if (SWIG_GetArgs(interp, objc, objv,"oo:osgeo::Geometry_Disjoint self other ",(void *)0,(void *)0) == TCL_ERROR) SWIG_fail;
+   res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_OGRGeometryShadow, 0 |  0 );
+   if (!SWIG_IsOK(res1)) {
+     SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Geometry_Disjoint" "', argument " "1"" of type '" "OGRGeometryShadow *""'"); 
+   }
+   arg1 = reinterpret_cast< OGRGeometryShadow * >(argp1);
+   res2 = SWIG_ConvertPtr(objv[2], &argp2,SWIGTYPE_p_OGRGeometryShadow, 0 |  0 );
+   if (!SWIG_IsOK(res2)) {
+     SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "Geometry_Disjoint" "', argument " "2"" of type '" "OGRGeometryShadow *""'"); 
+   }
+   arg2 = reinterpret_cast< OGRGeometryShadow * >(argp2);
+   {
+     CPLErrorReset();
+     result = (bool)OGRGeometryShadow_Disjoint(arg1,arg2);
+     CPLErr eclass = CPLGetLastErrorType();
+     if ( eclass == CE_Failure || eclass == CE_Fatal ) {
+       SWIG_exception( SWIG_RuntimeError, CPLGetLastErrorMsg() );
+       
+     }
+     
+     
+     
+     
+     
+     
+     
+     
+     
+     
+     
+   }
+   Tcl_SetObjResult(interp,SWIG_From_bool(static_cast< bool >(result)));
+   return TCL_OK;
+ fail:
+   return TCL_ERROR;
+ }
+ 
+ 
+ SWIGINTERN int
+ _wrap_Geometry_Touches(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
+   OGRGeometryShadow *arg1 = (OGRGeometryShadow *) 0 ;
+   OGRGeometryShadow *arg2 = (OGRGeometryShadow *) 0 ;
+   void *argp1 = 0 ;
+   int res1 = 0 ;
+   void *argp2 = 0 ;
+   int res2 = 0 ;
+   bool result;
+   
+   if (SWIG_GetArgs(interp, objc, objv,"oo:osgeo::Geometry_Touches self other ",(void *)0,(void *)0) == TCL_ERROR) SWIG_fail;
+   res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_OGRGeometryShadow, 0 |  0 );
+   if (!SWIG_IsOK(res1)) {
+     SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Geometry_Touches" "', argument " "1"" of type '" "OGRGeometryShadow *""'"); 
+   }
+   arg1 = reinterpret_cast< OGRGeometryShadow * >(argp1);
+   res2 = SWIG_ConvertPtr(objv[2], &argp2,SWIGTYPE_p_OGRGeometryShadow, 0 |  0 );
+   if (!SWIG_IsOK(res2)) {
+     SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "Geometry_Touches" "', argument " "2"" of type '" "OGRGeometryShadow *""'"); 
+   }
+   arg2 = reinterpret_cast< OGRGeometryShadow * >(argp2);
+   {
+     CPLErrorReset();
+     result = (bool)OGRGeometryShadow_Touches(arg1,arg2);
+     CPLErr eclass = CPLGetLastErrorType();
+     if ( eclass == CE_Failure || eclass == CE_Fatal ) {
+       SWIG_exception( SWIG_RuntimeError, CPLGetLastErrorMsg() );
+       
+     }
+     
+     
+     
+     
+     
+     
+     
+     
+     
+     
+     
+   }
+   Tcl_SetObjResult(interp,SWIG_From_bool(static_cast< bool >(result)));
+   return TCL_OK;
+ fail:
+   return TCL_ERROR;
+ }
+ 
+ 
+ SWIGINTERN int
+ _wrap_Geometry_Crosses(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
+   OGRGeometryShadow *arg1 = (OGRGeometryShadow *) 0 ;
+   OGRGeometryShadow *arg2 = (OGRGeometryShadow *) 0 ;
+   void *argp1 = 0 ;
+   int res1 = 0 ;
+   void *argp2 = 0 ;
+   int res2 = 0 ;
+   bool result;
+   
+   if (SWIG_GetArgs(interp, objc, objv,"oo:osgeo::Geometry_Crosses self other ",(void *)0,(void *)0) == TCL_ERROR) SWIG_fail;
+   res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_OGRGeometryShadow, 0 |  0 );
+   if (!SWIG_IsOK(res1)) {
+     SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Geometry_Crosses" "', argument " "1"" of type '" "OGRGeometryShadow *""'"); 
+   }
+   arg1 = reinterpret_cast< OGRGeometryShadow * >(argp1);
+   res2 = SWIG_ConvertPtr(objv[2], &argp2,SWIGTYPE_p_OGRGeometryShadow, 0 |  0 );
+   if (!SWIG_IsOK(res2)) {
+     SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "Geometry_Crosses" "', argument " "2"" of type '" "OGRGeometryShadow *""'"); 
+   }
+   arg2 = reinterpret_cast< OGRGeometryShadow * >(argp2);
+   {
+     CPLErrorReset();
+     result = (bool)OGRGeometryShadow_Crosses(arg1,arg2);
+     CPLErr eclass = CPLGetLastErrorType();
+     if ( eclass == CE_Failure || eclass == CE_Fatal ) {
+       SWIG_exception( SWIG_RuntimeError, CPLGetLastErrorMsg() );
+       
+     }
+     
+     
+     
+     
+     
+     
+     
+     
+     
+     
+     
+   }
+   Tcl_SetObjResult(interp,SWIG_From_bool(static_cast< bool >(result)));
+   return TCL_OK;
+ fail:
+   return TCL_ERROR;
+ }
+ 
+ 
+ SWIGINTERN int
+ _wrap_Geometry_Within(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
+   OGRGeometryShadow *arg1 = (OGRGeometryShadow *) 0 ;
+   OGRGeometryShadow *arg2 = (OGRGeometryShadow *) 0 ;
+   void *argp1 = 0 ;
+   int res1 = 0 ;
+   void *argp2 = 0 ;
+   int res2 = 0 ;
+   bool result;
+   
+   if (SWIG_GetArgs(interp, objc, objv,"oo:osgeo::Geometry_Within self other ",(void *)0,(void *)0) == TCL_ERROR) SWIG_fail;
+   res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_OGRGeometryShadow, 0 |  0 );
+   if (!SWIG_IsOK(res1)) {
+     SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Geometry_Within" "', argument " "1"" of type '" "OGRGeometryShadow *""'"); 
+   }
+   arg1 = reinterpret_cast< OGRGeometryShadow * >(argp1);
+   res2 = SWIG_ConvertPtr(objv[2], &argp2,SWIGTYPE_p_OGRGeometryShadow, 0 |  0 );
+   if (!SWIG_IsOK(res2)) {
+     SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "Geometry_Within" "', argument " "2"" of type '" "OGRGeometryShadow *""'"); 
+   }
+   arg2 = reinterpret_cast< OGRGeometryShadow * >(argp2);
+   {
+     CPLErrorReset();
+     result = (bool)OGRGeometryShadow_Within(arg1,arg2);
+     CPLErr eclass = CPLGetLastErrorType();
+     if ( eclass == CE_Failure || eclass == CE_Fatal ) {
+       SWIG_exception( SWIG_RuntimeError, CPLGetLastErrorMsg() );
+       
+     }
+     
+     
+     
+     
+     
+     
+     
+     
+     
+     
+     
+   }
+   Tcl_SetObjResult(interp,SWIG_From_bool(static_cast< bool >(result)));
+   return TCL_OK;
+ fail:
+   return TCL_ERROR;
+ }
+ 
+ 
+ SWIGINTERN int
+ _wrap_Geometry_Contains(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
+   OGRGeometryShadow *arg1 = (OGRGeometryShadow *) 0 ;
+   OGRGeometryShadow *arg2 = (OGRGeometryShadow *) 0 ;
+   void *argp1 = 0 ;
+   int res1 = 0 ;
+   void *argp2 = 0 ;
+   int res2 = 0 ;
+   bool result;
+   
+   if (SWIG_GetArgs(interp, objc, objv,"oo:osgeo::Geometry_Contains self other ",(void *)0,(void *)0) == TCL_ERROR) SWIG_fail;
+   res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_OGRGeometryShadow, 0 |  0 );
+   if (!SWIG_IsOK(res1)) {
+     SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Geometry_Contains" "', argument " "1"" of type '" "OGRGeometryShadow *""'"); 
+   }
+   arg1 = reinterpret_cast< OGRGeometryShadow * >(argp1);
+   res2 = SWIG_ConvertPtr(objv[2], &argp2,SWIGTYPE_p_OGRGeometryShadow, 0 |  0 );
+   if (!SWIG_IsOK(res2)) {
+     SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "Geometry_Contains" "', argument " "2"" of type '" "OGRGeometryShadow *""'"); 
+   }
+   arg2 = reinterpret_cast< OGRGeometryShadow * >(argp2);
+   {
+     CPLErrorReset();
+     result = (bool)OGRGeometryShadow_Contains(arg1,arg2);
+     CPLErr eclass = CPLGetLastErrorType();
+     if ( eclass == CE_Failure || eclass == CE_Fatal ) {
+       SWIG_exception( SWIG_RuntimeError, CPLGetLastErrorMsg() );
+       
+     }
+     
+     
+     
+     
+     
+     
+     
+     
+     
+     
+     
+   }
+   Tcl_SetObjResult(interp,SWIG_From_bool(static_cast< bool >(result)));
+   return TCL_OK;
+ fail:
+   return TCL_ERROR;
+ }
+ 
+ 
+ SWIGINTERN int
+ _wrap_Geometry_Overlaps(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
+   OGRGeometryShadow *arg1 = (OGRGeometryShadow *) 0 ;
+   OGRGeometryShadow *arg2 = (OGRGeometryShadow *) 0 ;
+   void *argp1 = 0 ;
+   int res1 = 0 ;
+   void *argp2 = 0 ;
+   int res2 = 0 ;
+   bool result;
+   
+   if (SWIG_GetArgs(interp, objc, objv,"oo:osgeo::Geometry_Overlaps self other ",(void *)0,(void *)0) == TCL_ERROR) SWIG_fail;
+   res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_OGRGeometryShadow, 0 |  0 );
+   if (!SWIG_IsOK(res1)) {
+     SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Geometry_Overlaps" "', argument " "1"" of type '" "OGRGeometryShadow *""'"); 
+   }
+   arg1 = reinterpret_cast< OGRGeometryShadow * >(argp1);
+   res2 = SWIG_ConvertPtr(objv[2], &argp2,SWIGTYPE_p_OGRGeometryShadow, 0 |  0 );
+   if (!SWIG_IsOK(res2)) {
+     SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "Geometry_Overlaps" "', argument " "2"" of type '" "OGRGeometryShadow *""'"); 
+   }
+   arg2 = reinterpret_cast< OGRGeometryShadow * >(argp2);
+   {
+     CPLErrorReset();
+     result = (bool)OGRGeometryShadow_Overlaps(arg1,arg2);
+     CPLErr eclass = CPLGetLastErrorType();
+     if ( eclass == CE_Failure || eclass == CE_Fatal ) {
+       SWIG_exception( SWIG_RuntimeError, CPLGetLastErrorMsg() );
+       
+     }
+     
+     
+     
+     
+     
+     
+     
+     
+     
+     
+     
+   }
+   Tcl_SetObjResult(interp,SWIG_From_bool(static_cast< bool >(result)));
+   return TCL_OK;
+ fail:
+   return TCL_ERROR;
+ }
+ 
+ 
+ SWIGINTERN int
+ _wrap_Geometry_TransformTo(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
+   OGRGeometryShadow *arg1 = (OGRGeometryShadow *) 0 ;
+   OSRSpatialReferenceShadow *arg2 = (OSRSpatialReferenceShadow *) 0 ;
+   void *argp1 = 0 ;
+   int res1 = 0 ;
+   void *argp2 = 0 ;
+   int res2 = 0 ;
+   OGRErr result;
+   
+   if (SWIG_GetArgs(interp, objc, objv,"oo:osgeo::Geometry_TransformTo self reference ",(void *)0,(void *)0) == TCL_ERROR) SWIG_fail;
+   res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_OGRGeometryShadow, 0 |  0 );
+   if (!SWIG_IsOK(res1)) {
+     SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Geometry_TransformTo" "', argument " "1"" of type '" "OGRGeometryShadow *""'"); 
+   }
+   arg1 = reinterpret_cast< OGRGeometryShadow * >(argp1);
+   res2 = SWIG_ConvertPtr(objv[2], &argp2,SWIGTYPE_p_OSRSpatialReferenceShadow, 0 |  0 );
+   if (!SWIG_IsOK(res2)) {
+     SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "Geometry_TransformTo" "', argument " "2"" of type '" "OSRSpatialReferenceShadow *""'"); 
+   }
+   arg2 = reinterpret_cast< OSRSpatialReferenceShadow * >(argp2);
+   {
+     CPLErrorReset();
+     result = (OGRErr)OGRGeometryShadow_TransformTo(arg1,arg2);
+     CPLErr eclass = CPLGetLastErrorType();
+     if ( eclass == CE_Failure || eclass == CE_Fatal ) {
+       SWIG_exception( SWIG_RuntimeError, CPLGetLastErrorMsg() );
+       
+     }
+     
+     
+     
+     
+     
+     
+     
+     
+     
+     
+     
+   }
+   {
+     /* %typemap(out) OGRErr */
+     if (result != 0) {
+       Tcl_SetResult(interp, (char*) OGRErrMessages(result), TCL_STATIC);
+       SWIG_fail;
+     }
+   }
+   {
+     /* %typemap(ret) OGRErr */
+     if (!strcmp(Tcl_GetStringResult(interp), "{}") || !strcmp(Tcl_GetStringResult(interp), "")) {
+       Tcl_SetObjResult(interp, Tcl_NewLongObj( result ));
+     }
+   }
+   return TCL_OK;
+ fail:
+   return TCL_ERROR;
+ }
+ 
+ 
+ SWIGINTERN int
+ _wrap_Geometry_Transform(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
+   OGRGeometryShadow *arg1 = (OGRGeometryShadow *) 0 ;
+   OSRCoordinateTransformationShadow *arg2 = (OSRCoordinateTransformationShadow *) 0 ;
+   void *argp1 = 0 ;
+   int res1 = 0 ;
+   void *argp2 = 0 ;
+   int res2 = 0 ;
+   OGRErr result;
+   
+   if (SWIG_GetArgs(interp, objc, objv,"oo:osgeo::Geometry_Transform self trans ",(void *)0,(void *)0) == TCL_ERROR) SWIG_fail;
+   res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_OGRGeometryShadow, 0 |  0 );
+   if (!SWIG_IsOK(res1)) {
+     SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Geometry_Transform" "', argument " "1"" of type '" "OGRGeometryShadow *""'"); 
+   }
+   arg1 = reinterpret_cast< OGRGeometryShadow * >(argp1);
+   res2 = SWIG_ConvertPtr(objv[2], &argp2,SWIGTYPE_p_OSRCoordinateTransformationShadow, 0 |  0 );
+   if (!SWIG_IsOK(res2)) {
+     SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "Geometry_Transform" "', argument " "2"" of type '" "OSRCoordinateTransformationShadow *""'"); 
+   }
+   arg2 = reinterpret_cast< OSRCoordinateTransformationShadow * >(argp2);
+   {
+     CPLErrorReset();
+     result = (OGRErr)OGRGeometryShadow_Transform(arg1,arg2);
+     CPLErr eclass = CPLGetLastErrorType();
+     if ( eclass == CE_Failure || eclass == CE_Fatal ) {
+       SWIG_exception( SWIG_RuntimeError, CPLGetLastErrorMsg() );
+       
+     }
+     
+     
+     
+     
+     
+     
+     
+     
+     
+     
+     
+   }
+   {
+     /* %typemap(out) OGRErr */
+     if (result != 0) {
+       Tcl_SetResult(interp, (char*) OGRErrMessages(result), TCL_STATIC);
+       SWIG_fail;
+     }
+   }
+   {
+     /* %typemap(ret) OGRErr */
+     if (!strcmp(Tcl_GetStringResult(interp), "{}") || !strcmp(Tcl_GetStringResult(interp), "")) {
+       Tcl_SetObjResult(interp, Tcl_NewLongObj( result ));
+     }
+   }
+   return TCL_OK;
+ fail:
+   return TCL_ERROR;
+ }
+ 
+ 
+ SWIGINTERN int
+ _wrap_Geometry_GetSpatialReference(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
+   OGRGeometryShadow *arg1 = (OGRGeometryShadow *) 0 ;
+   void *argp1 = 0 ;
+   int res1 = 0 ;
+   OSRSpatialReferenceShadow *result = 0 ;
+   
+   if (SWIG_GetArgs(interp, objc, objv,"o:osgeo::Geometry_GetSpatialReference self ",(void *)0) == TCL_ERROR) SWIG_fail;
+   res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_OGRGeometryShadow, 0 |  0 );
+   if (!SWIG_IsOK(res1)) {
+     SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Geometry_GetSpatialReference" "', argument " "1"" of type '" "OGRGeometryShadow *""'"); 
+   }
+   arg1 = reinterpret_cast< OGRGeometryShadow * >(argp1);
+   {
+     CPLErrorReset();
+     result = (OSRSpatialReferenceShadow *)OGRGeometryShadow_GetSpatialReference(arg1);
+     CPLErr eclass = CPLGetLastErrorType();
+     if ( eclass == CE_Failure || eclass == CE_Fatal ) {
+       SWIG_exception( SWIG_RuntimeError, CPLGetLastErrorMsg() );
+       
+     }
+     
+     
+     
+     
+     
+     
+     
+     
+     
+     
+     
+   }
+   Tcl_SetObjResult(interp, SWIG_NewInstanceObj( SWIG_as_voidptr(result), SWIGTYPE_p_OSRSpatialReferenceShadow,0));
+   return TCL_OK;
+ fail:
+   return TCL_ERROR;
+ }
+ 
+ 
+ SWIGINTERN int
+ _wrap_Geometry_AssignSpatialReference(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
+   OGRGeometryShadow *arg1 = (OGRGeometryShadow *) 0 ;
+   OSRSpatialReferenceShadow *arg2 = (OSRSpatialReferenceShadow *) 0 ;
+   void *argp1 = 0 ;
+   int res1 = 0 ;
+   void *argp2 = 0 ;
+   int res2 = 0 ;
+   
+   if (SWIG_GetArgs(interp, objc, objv,"oo:osgeo::Geometry_AssignSpatialReference self reference ",(void *)0,(void *)0) == TCL_ERROR) SWIG_fail;
+   res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_OGRGeometryShadow, 0 |  0 );
+   if (!SWIG_IsOK(res1)) {
+     SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Geometry_AssignSpatialReference" "', argument " "1"" of type '" "OGRGeometryShadow *""'"); 
+   }
+   arg1 = reinterpret_cast< OGRGeometryShadow * >(argp1);
+   res2 = SWIG_ConvertPtr(objv[2], &argp2,SWIGTYPE_p_OSRSpatialReferenceShadow, 0 |  0 );
+   if (!SWIG_IsOK(res2)) {
+     SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "Geometry_AssignSpatialReference" "', argument " "2"" of type '" "OSRSpatialReferenceShadow *""'"); 
+   }
+   arg2 = reinterpret_cast< OSRSpatialReferenceShadow * >(argp2);
+   {
+     CPLErrorReset();
+     OGRGeometryShadow_AssignSpatialReference(arg1,arg2);
+     CPLErr eclass = CPLGetLastErrorType();
+     if ( eclass == CE_Failure || eclass == CE_Fatal ) {
+       SWIG_exception( SWIG_RuntimeError, CPLGetLastErrorMsg() );
+       
+     }
+     
+     
+     
+     
+     
+     
+     
+     
+     
+     
+     
+   }
+   
+   return TCL_OK;
+ fail:
+   return TCL_ERROR;
+ }
+ 
+ 
+ SWIGINTERN int
+ _wrap_Geometry_CloseRings(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
+   OGRGeometryShadow *arg1 = (OGRGeometryShadow *) 0 ;
+   void *argp1 = 0 ;
+   int res1 = 0 ;
+   
+   if (SWIG_GetArgs(interp, objc, objv,"o:osgeo::Geometry_CloseRings self ",(void *)0) == TCL_ERROR) SWIG_fail;
+   res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_OGRGeometryShadow, 0 |  0 );
+   if (!SWIG_IsOK(res1)) {
+     SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Geometry_CloseRings" "', argument " "1"" of type '" "OGRGeometryShadow *""'"); 
+   }
+   arg1 = reinterpret_cast< OGRGeometryShadow * >(argp1);
+   {
+     CPLErrorReset();
+     OGRGeometryShadow_CloseRings(arg1);
+     CPLErr eclass = CPLGetLastErrorType();
+     if ( eclass == CE_Failure || eclass == CE_Fatal ) {
+       SWIG_exception( SWIG_RuntimeError, CPLGetLastErrorMsg() );
+       
+     }
+     
+     
+     
+     
+     
+     
+     
+     
+     
+     
+     
+   }
+   
+   return TCL_OK;
+ fail:
+   return TCL_ERROR;
+ }
+ 
+ 
+ SWIGINTERN int
+ _wrap_Geometry_FlattenTo2D(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
+   OGRGeometryShadow *arg1 = (OGRGeometryShadow *) 0 ;
+   void *argp1 = 0 ;
+   int res1 = 0 ;
+   
+   if (SWIG_GetArgs(interp, objc, objv,"o:osgeo::Geometry_FlattenTo2D self ",(void *)0) == TCL_ERROR) SWIG_fail;
+   res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_OGRGeometryShadow, 0 |  0 );
+   if (!SWIG_IsOK(res1)) {
+     SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Geometry_FlattenTo2D" "', argument " "1"" of type '" "OGRGeometryShadow *""'"); 
+   }
+   arg1 = reinterpret_cast< OGRGeometryShadow * >(argp1);
+   {
+     CPLErrorReset();
+     OGRGeometryShadow_FlattenTo2D(arg1);
+     CPLErr eclass = CPLGetLastErrorType();
+     if ( eclass == CE_Failure || eclass == CE_Fatal ) {
+       SWIG_exception( SWIG_RuntimeError, CPLGetLastErrorMsg() );
+       
+     }
+     
+     
+     
+     
+     
+     
+     
+     
+     
+     
+     
+   }
+   
+   return TCL_OK;
+ fail:
+   return TCL_ERROR;
+ }
+ 
+ 
+ SWIGINTERN int
+ _wrap_Geometry_GetEnvelope(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
+   OGRGeometryShadow *arg1 = (OGRGeometryShadow *) 0 ;
+   double *arg2 ;
+   void *argp1 = 0 ;
+   int res1 = 0 ;
+   double argout2[4] ;
+   
+   {
+     /* %typemap(in,numinputs=0) (double argout2[ANY]) */
+     arg2 = argout2;
+   }
+   if (SWIG_GetArgs(interp, objc, objv,"o:osgeo::Geometry_GetEnvelope self ",(void *)0) == TCL_ERROR) SWIG_fail;
+   res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_OGRGeometryShadow, 0 |  0 );
+   if (!SWIG_IsOK(res1)) {
+     SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Geometry_GetEnvelope" "', argument " "1"" of type '" "OGRGeometryShadow *""'"); 
+   }
+   arg1 = reinterpret_cast< OGRGeometryShadow * >(argp1);
+   {
+     CPLErrorReset();
+     OGRGeometryShadow_GetEnvelope(arg1,arg2);
+     CPLErr eclass = CPLGetLastErrorType();
+     if ( eclass == CE_Failure || eclass == CE_Fatal ) {
+       SWIG_exception( SWIG_RuntimeError, CPLGetLastErrorMsg() );
+       
+     }
+     
+     
+     
+     
+     
+     
+     
+     
+     
+     
+     
+   }
+   
+   {
+     /* %typemap(argout) (double argout[ANY]) */
+     Tcl_Obj *out = CreateListFromDoubleArray( interp, arg2, 4 );
+     if (out == NULL) SWIG_fail;
+     Tcl_ListObjAppendElement(interp,Tcl_GetObjResult(interp),out);
+   }
+   return TCL_OK;
+ fail:
+   return TCL_ERROR;
+ }
+ 
+ 
+ SWIGINTERN int
+ _wrap_Geometry_Centroid(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
+   OGRGeometryShadow *arg1 = (OGRGeometryShadow *) 0 ;
+   void *argp1 = 0 ;
+   int res1 = 0 ;
+   OGRGeometryShadow *result = 0 ;
+   
+   if (SWIG_GetArgs(interp, objc, objv,"o:osgeo::Geometry_Centroid self ",(void *)0) == TCL_ERROR) SWIG_fail;
+   res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_OGRGeometryShadow, 0 |  0 );
+   if (!SWIG_IsOK(res1)) {
+     SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Geometry_Centroid" "', argument " "1"" of type '" "OGRGeometryShadow *""'"); 
+   }
+   arg1 = reinterpret_cast< OGRGeometryShadow * >(argp1);
+   {
+     CPLErrorReset();
+     result = (OGRGeometryShadow *)OGRGeometryShadow_Centroid(arg1);
+     CPLErr eclass = CPLGetLastErrorType();
+     if ( eclass == CE_Failure || eclass == CE_Fatal ) {
+       SWIG_exception( SWIG_RuntimeError, CPLGetLastErrorMsg() );
+       
+     }
+     
+     
+     
+     
+     
+     
+     
+     
+     
+     
+     
+   }
+   Tcl_SetObjResult(interp, SWIG_NewInstanceObj( SWIG_as_voidptr(result), SWIGTYPE_p_OGRGeometryShadow,0));
+   return TCL_OK;
+ fail:
+   return TCL_ERROR;
+ }
+ 
+ 
+ SWIGINTERN int
+ _wrap_Geometry_WkbSize(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
+   OGRGeometryShadow *arg1 = (OGRGeometryShadow *) 0 ;
+   void *argp1 = 0 ;
+   int res1 = 0 ;
+   int result;
+   
+   if (SWIG_GetArgs(interp, objc, objv,"o:osgeo::Geometry_WkbSize self ",(void *)0) == TCL_ERROR) SWIG_fail;
+   res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_OGRGeometryShadow, 0 |  0 );
+   if (!SWIG_IsOK(res1)) {
+     SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Geometry_WkbSize" "', argument " "1"" of type '" "OGRGeometryShadow *""'"); 
+   }
+   arg1 = reinterpret_cast< OGRGeometryShadow * >(argp1);
+   {
+     CPLErrorReset();
+     result = (int)OGRGeometryShadow_WkbSize(arg1);
+     CPLErr eclass = CPLGetLastErrorType();
+     if ( eclass == CE_Failure || eclass == CE_Fatal ) {
+       SWIG_exception( SWIG_RuntimeError, CPLGetLastErrorMsg() );
+       
+     }
+     
+     
+     
+     
+     
+     
+     
+     
+     
+     
+     
+   }
+   Tcl_SetObjResult(interp,SWIG_From_int(static_cast< int >(result)));
+   return TCL_OK;
+ fail:
+   return TCL_ERROR;
+ }
+ 
+ 
+ SWIGINTERN int
+ _wrap_Geometry_GetCoordinateDimension(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
+   OGRGeometryShadow *arg1 = (OGRGeometryShadow *) 0 ;
+   void *argp1 = 0 ;
+   int res1 = 0 ;
+   int result;
+   
+   if (SWIG_GetArgs(interp, objc, objv,"o:osgeo::Geometry_GetCoordinateDimension self ",(void *)0) == TCL_ERROR) SWIG_fail;
+   res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_OGRGeometryShadow, 0 |  0 );
+   if (!SWIG_IsOK(res1)) {
+     SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Geometry_GetCoordinateDimension" "', argument " "1"" of type '" "OGRGeometryShadow *""'"); 
+   }
+   arg1 = reinterpret_cast< OGRGeometryShadow * >(argp1);
+   {
+     CPLErrorReset();
+     result = (int)OGRGeometryShadow_GetCoordinateDimension(arg1);
+     CPLErr eclass = CPLGetLastErrorType();
+     if ( eclass == CE_Failure || eclass == CE_Fatal ) {
+       SWIG_exception( SWIG_RuntimeError, CPLGetLastErrorMsg() );
+       
+     }
+     
+     
+     
+     
+     
+     
+     
+     
+     
+     
+     
+   }
+   Tcl_SetObjResult(interp,SWIG_From_int(static_cast< int >(result)));
+   return TCL_OK;
+ fail:
+   return TCL_ERROR;
+ }
+ 
+ 
+ SWIGINTERN int
+ _wrap_Geometry_SetCoordinateDimension(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
+   OGRGeometryShadow *arg1 = (OGRGeometryShadow *) 0 ;
+   int arg2 ;
+   void *argp1 = 0 ;
+   int res1 = 0 ;
+   int val2 ;
+   int ecode2 = 0 ;
+   
+   if (SWIG_GetArgs(interp, objc, objv,"oo:osgeo::Geometry_SetCoordinateDimension self dimension ",(void *)0,(void *)0) == TCL_ERROR) SWIG_fail;
+   res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_OGRGeometryShadow, 0 |  0 );
+   if (!SWIG_IsOK(res1)) {
+     SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Geometry_SetCoordinateDimension" "', argument " "1"" of type '" "OGRGeometryShadow *""'"); 
+   }
+   arg1 = reinterpret_cast< OGRGeometryShadow * >(argp1);
+   ecode2 = SWIG_AsVal_int SWIG_TCL_CALL_ARGS_2(objv[2], &val2);
+   if (!SWIG_IsOK(ecode2)) {
+     SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "Geometry_SetCoordinateDimension" "', argument " "2"" of type '" "int""'");
+   } 
+   arg2 = static_cast< int >(val2);
+   {
+     CPLErrorReset();
+     OGRGeometryShadow_SetCoordinateDimension(arg1,arg2);
+     CPLErr eclass = CPLGetLastErrorType();
+     if ( eclass == CE_Failure || eclass == CE_Fatal ) {
+       SWIG_exception( SWIG_RuntimeError, CPLGetLastErrorMsg() );
+       
+     }
+     
+     
+     
+     
+     
+     
+     
+     
+     
+     
+     
+   }
+   
+   return TCL_OK;
+ fail:
+   return TCL_ERROR;
+ }
+ 
+ 
+ SWIGINTERN int
+ _wrap_Geometry_GetDimension(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
+   OGRGeometryShadow *arg1 = (OGRGeometryShadow *) 0 ;
+   void *argp1 = 0 ;
+   int res1 = 0 ;
+   int result;
+   
+   if (SWIG_GetArgs(interp, objc, objv,"o:osgeo::Geometry_GetDimension self ",(void *)0) == TCL_ERROR) SWIG_fail;
+   res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_OGRGeometryShadow, 0 |  0 );
+   if (!SWIG_IsOK(res1)) {
+     SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Geometry_GetDimension" "', argument " "1"" of type '" "OGRGeometryShadow *""'"); 
+   }
+   arg1 = reinterpret_cast< OGRGeometryShadow * >(argp1);
+   {
+     CPLErrorReset();
+     result = (int)OGRGeometryShadow_GetDimension(arg1);
+     CPLErr eclass = CPLGetLastErrorType();
+     if ( eclass == CE_Failure || eclass == CE_Fatal ) {
+       SWIG_exception( SWIG_RuntimeError, CPLGetLastErrorMsg() );
+       
+     }
+     
+     
+     
+     
+     
+     
+     
+     
+     
+     
+     
+   }
+   Tcl_SetObjResult(interp,SWIG_From_int(static_cast< int >(result)));
+   return TCL_OK;
+ fail:
+   return TCL_ERROR;
+ }
+ 
+ 
+ SWIGINTERN void swig_delete_Geometry(void *obj) {
+ OGRGeometryShadow *arg1 = (OGRGeometryShadow *) obj;
+ delete_OGRGeometryShadow(arg1);
+ }
+ static swig_method swig_OGRGeometryShadow_methods[] = {
+     {"ExportToWkt", _wrap_Geometry_ExportToWkt}, 
+     {"ExportToWkb", _wrap_Geometry_ExportToWkb}, 
+     {"ExportToGML", _wrap_Geometry_ExportToGML}, 
+     {"ExportToKML", _wrap_Geometry_ExportToKML}, 
+     {"ExportToJson", _wrap_Geometry_ExportToJson}, 
+     {"AddPoint", _wrap_Geometry_AddPoint}, 
+     {"AddPoint_2D", _wrap_Geometry_AddPoint_2D}, 
+     {"AddGeometryDirectly", _wrap_Geometry_AddGeometryDirectly}, 
+     {"AddGeometry", _wrap_Geometry_AddGeometry}, 
+     {"Clone", _wrap_Geometry_Clone}, 
+     {"GetGeometryType", _wrap_Geometry_GetGeometryType}, 
+     {"GetGeometryName", _wrap_Geometry_GetGeometryName}, 
+     {"GetArea", _wrap_Geometry_GetArea}, 
+     {"GetPointCount", _wrap_Geometry_GetPointCount}, 
+     {"GetX", _wrap_Geometry_GetX}, 
+     {"GetY", _wrap_Geometry_GetY}, 
+     {"GetZ", _wrap_Geometry_GetZ}, 
+     {"GetPoint", _wrap_Geometry_GetPoint}, 
+     {"GetPoint_2D", _wrap_Geometry_GetPoint_2D}, 
+     {"GetGeometryCount", _wrap_Geometry_GetGeometryCount}, 
+     {"SetPoint", _wrap_Geometry_SetPoint}, 
+     {"SetPoint_2D", _wrap_Geometry_SetPoint_2D}, 
+     {"GetGeometryRef", _wrap_Geometry_GetGeometryRef}, 
+     {"GetBoundary", _wrap_Geometry_GetBoundary}, 
+     {"ConvexHull", _wrap_Geometry_ConvexHull}, 
+     {"Buffer", _wrap_Geometry_Buffer}, 
+     {"Intersection", _wrap_Geometry_Intersection}, 
+     {"Union", _wrap_Geometry_Union}, 
+     {"Difference", _wrap_Geometry_Difference}, 
+     {"SymmetricDifference", _wrap_Geometry_SymmetricDifference}, 
+     {"Distance", _wrap_Geometry_Distance}, 
+     {"Empty", _wrap_Geometry_Empty}, 
+     {"IsEmpty", _wrap_Geometry_IsEmpty}, 
+     {"IsValid", _wrap_Geometry_IsValid}, 
+     {"IsSimple", _wrap_Geometry_IsSimple}, 
+     {"IsRing", _wrap_Geometry_IsRing}, 
+     {"Intersect", _wrap_Geometry_Intersect}, 
+     {"Equal", _wrap_Geometry_Equal}, 
+     {"Disjoint", _wrap_Geometry_Disjoint}, 
+     {"Touches", _wrap_Geometry_Touches}, 
+     {"Crosses", _wrap_Geometry_Crosses}, 
+     {"Within", _wrap_Geometry_Within}, 
+     {"Contains", _wrap_Geometry_Contains}, 
+     {"Overlaps", _wrap_Geometry_Overlaps}, 
+     {"TransformTo", _wrap_Geometry_TransformTo}, 
+     {"Transform", _wrap_Geometry_Transform}, 
+     {"GetSpatialReference", _wrap_Geometry_GetSpatialReference}, 
+     {"AssignSpatialReference", _wrap_Geometry_AssignSpatialReference}, 
+     {"CloseRings", _wrap_Geometry_CloseRings}, 
+     {"FlattenTo2D", _wrap_Geometry_FlattenTo2D}, 
+     {"GetEnvelope", _wrap_Geometry_GetEnvelope}, 
+     {"Centroid", _wrap_Geometry_Centroid}, 
+     {"WkbSize", _wrap_Geometry_WkbSize}, 
+     {"GetCoordinateDimension", _wrap_Geometry_GetCoordinateDimension}, 
+     {"SetCoordinateDimension", _wrap_Geometry_SetCoordinateDimension}, 
+     {"GetDimension", _wrap_Geometry_GetDimension}, 
+     {0,0}
+ };
+ static swig_attribute swig_OGRGeometryShadow_attributes[] = {
+     {0,0,0}
+ };
+ static swig_class *swig_OGRGeometryShadow_bases[] = {0};
+ static const char * swig_OGRGeometryShadow_base_names[] = {0};
+ static swig_class _wrap_class_OGRGeometryShadow = { "Geometry", &SWIGTYPE_p_OGRGeometryShadow,_wrap_new_Geometry, swig_delete_Geometry, swig_OGRGeometryShadow_methods, swig_OGRGeometryShadow_attributes, swig_OGRGeometryShadow_bases,swig_OGRGeometryShadow_base_names, &swig_module };
+ SWIGINTERN int
+ _wrap_GetDriverCount(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
+   int result;
+   
+   if (SWIG_GetArgs(interp, objc, objv,":osgeo::GetDriverCount ") == TCL_ERROR) SWIG_fail;
+   {
+     CPLErrorReset();
+     result = (int)OGRGetDriverCount();
+     CPLErr eclass = CPLGetLastErrorType();
+     if ( eclass == CE_Failure || eclass == CE_Fatal ) {
+       SWIG_exception( SWIG_RuntimeError, CPLGetLastErrorMsg() );
+       
+     }
+     
+     
+     
+     
+     
+     
+     
+     
+     
+     
+     
+   }
+   Tcl_SetObjResult(interp,SWIG_From_int(static_cast< int >(result)));
+   return TCL_OK;
+ fail:
+   return TCL_ERROR;
+ }
+ 
+ 
+ SWIGINTERN int
+ _wrap_GetOpenDSCount(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
+   int result;
+   
+   if (SWIG_GetArgs(interp, objc, objv,":osgeo::GetOpenDSCount ") == TCL_ERROR) SWIG_fail;
+   {
+     CPLErrorReset();
+     result = (int)OGRGetOpenDSCount();
+     CPLErr eclass = CPLGetLastErrorType();
+     if ( eclass == CE_Failure || eclass == CE_Fatal ) {
+       SWIG_exception( SWIG_RuntimeError, CPLGetLastErrorMsg() );
+       
+     }
+     
+     
+     
+     
+     
+     
+     
+     
+     
+     
+     
+   }
+   Tcl_SetObjResult(interp,SWIG_From_int(static_cast< int >(result)));
+   return TCL_OK;
+ fail:
+   return TCL_ERROR;
+ }
+ 
+ 
+ SWIGINTERN int
+ _wrap_SetGenerate_DB2_V72_BYTE_ORDER(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
+   int arg1 ;
+   int val1 ;
+   int ecode1 = 0 ;
+   OGRErr result;
+   
+   if (SWIG_GetArgs(interp, objc, objv,"o:osgeo::SetGenerate_DB2_V72_BYTE_ORDER bGenerate_DB2_V72_BYTE_ORDER ",(void *)0) == TCL_ERROR) SWIG_fail;
+   ecode1 = SWIG_AsVal_int SWIG_TCL_CALL_ARGS_2(objv[1], &val1);
+   if (!SWIG_IsOK(ecode1)) {
+     SWIG_exception_fail(SWIG_ArgError(ecode1), "in method '" "SetGenerate_DB2_V72_BYTE_ORDER" "', argument " "1"" of type '" "int""'");
+   } 
+   arg1 = static_cast< int >(val1);
+   {
+     CPLErrorReset();
+     result = (OGRErr)OGRSetGenerate_DB2_V72_BYTE_ORDER(arg1);
+     CPLErr eclass = CPLGetLastErrorType();
+     if ( eclass == CE_Failure || eclass == CE_Fatal ) {
+       SWIG_exception( SWIG_RuntimeError, CPLGetLastErrorMsg() );
+       
+     }
+     
+     
+     
+     
+     
+     
+     
+     
+     
+     
+     
+   }
+   {
+     /* %typemap(out) OGRErr */
+     if (result != 0) {
+       Tcl_SetResult(interp, (char*) OGRErrMessages(result), TCL_STATIC);
+       SWIG_fail;
+     }
+   }
+   {
+     /* %typemap(ret) OGRErr */
+     if (!strcmp(Tcl_GetStringResult(interp), "{}") || !strcmp(Tcl_GetStringResult(interp), "")) {
+       Tcl_SetObjResult(interp, Tcl_NewLongObj( result ));
+     }
+   }
+   return TCL_OK;
+ fail:
+   return TCL_ERROR;
+ }
+ 
+ 
+ SWIGINTERN int
+ _wrap_RegisterAll(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
+   if (SWIG_GetArgs(interp, objc, objv,":osgeo::RegisterAll ") == TCL_ERROR) SWIG_fail;
+   {
+     CPLErrorReset();
+     OGRRegisterAll();
+     CPLErr eclass = CPLGetLastErrorType();
+     if ( eclass == CE_Failure || eclass == CE_Fatal ) {
+       SWIG_exception( SWIG_RuntimeError, CPLGetLastErrorMsg() );
+       
+     }
+     
+     
+     
+     
+     
+     
+     
+     
+     
+     
+     
+   }
+   
+   return TCL_OK;
+ fail:
+   return TCL_ERROR;
+ }
+ 
+ 
+ SWIGINTERN int
+ _wrap_GetOpenDS(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
+   int arg1 ;
+   int val1 ;
+   int ecode1 = 0 ;
+   OGRDataSourceShadow *result = 0 ;
+   
+   if (SWIG_GetArgs(interp, objc, objv,"o:osgeo::GetOpenDS ds_number ",(void *)0) == TCL_ERROR) SWIG_fail;
+   ecode1 = SWIG_AsVal_int SWIG_TCL_CALL_ARGS_2(objv[1], &val1);
+   if (!SWIG_IsOK(ecode1)) {
+     SWIG_exception_fail(SWIG_ArgError(ecode1), "in method '" "GetOpenDS" "', argument " "1"" of type '" "int""'");
+   } 
+   arg1 = static_cast< int >(val1);
+   {
+     CPLErrorReset();
+     result = (OGRDataSourceShadow *)GetOpenDS(arg1);
+     CPLErr eclass = CPLGetLastErrorType();
+     if ( eclass == CE_Failure || eclass == CE_Fatal ) {
+       SWIG_exception( SWIG_RuntimeError, CPLGetLastErrorMsg() );
+       
+     }
+     
+     
+     
+     
+     
+     
+     
+     
+     
+     
+     
+   }
+   Tcl_SetObjResult(interp, SWIG_NewInstanceObj( SWIG_as_voidptr(result), SWIGTYPE_p_OGRDataSourceShadow,0));
+   return TCL_OK;
+ fail:
+   return TCL_ERROR;
+ }
+ 
+ 
+ SWIGINTERN int
+ _wrap_Open(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
+   char *arg1 = (char *) 0 ;
+   int arg2 = (int) 0 ;
+   int res1 ;
+   char *buf1 = 0 ;
+   int alloc1 = 0 ;
+   int val2 ;
+   int ecode2 = 0 ;
+   OGRDataSourceShadow *result = 0 ;
+   
+   if (SWIG_GetArgs(interp, objc, objv,"o|o:osgeo::Open filename ?update? ",(void *)0,(void *)0) == TCL_ERROR) SWIG_fail;
+   res1 = SWIG_AsCharPtrAndSize(objv[1], &buf1, NULL, &alloc1);
+   if (!SWIG_IsOK(res1)) {
+     SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Open" "', argument " "1"" of type '" "char const *""'");
+   }
+   arg1 = reinterpret_cast< char * >(buf1);
+   if (objc > 2) {
+     ecode2 = SWIG_AsVal_int SWIG_TCL_CALL_ARGS_2(objv[2], &val2);
+     if (!SWIG_IsOK(ecode2)) {
+       SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "Open" "', argument " "2"" of type '" "int""'");
+     } 
+     arg2 = static_cast< int >(val2);
+   }
+   {
+     CPLErrorReset();
+     result = (OGRDataSourceShadow *)Open((char const *)arg1,arg2);
+     CPLErr eclass = CPLGetLastErrorType();
+     if ( eclass == CE_Failure || eclass == CE_Fatal ) {
+       SWIG_exception( SWIG_RuntimeError, CPLGetLastErrorMsg() );
+       
+     }
+     
+     
+     
+     
+     
+     
+     
+     
+     
+     
+     
+   }
+   Tcl_SetObjResult(interp, SWIG_NewInstanceObj( SWIG_as_voidptr(result), SWIGTYPE_p_OGRDataSourceShadow,0));
+   if (alloc1 == SWIG_NEWOBJ) delete[] buf1;
+   return TCL_OK;
+ fail:
+   if (alloc1 == SWIG_NEWOBJ) delete[] buf1;
+   return TCL_ERROR;
+ }
+ 
+ 
+ SWIGINTERN int
+ _wrap_OpenShared(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
+   char *arg1 = (char *) 0 ;
+   int arg2 = (int) 0 ;
+   int res1 ;
+   char *buf1 = 0 ;
+   int alloc1 = 0 ;
+   int val2 ;
+   int ecode2 = 0 ;
+   OGRDataSourceShadow *result = 0 ;
+   
+   if (SWIG_GetArgs(interp, objc, objv,"o|o:osgeo::OpenShared filename ?update? ",(void *)0,(void *)0) == TCL_ERROR) SWIG_fail;
+   res1 = SWIG_AsCharPtrAndSize(objv[1], &buf1, NULL, &alloc1);
+   if (!SWIG_IsOK(res1)) {
+     SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "OpenShared" "', argument " "1"" of type '" "char const *""'");
+   }
+   arg1 = reinterpret_cast< char * >(buf1);
+   if (objc > 2) {
+     ecode2 = SWIG_AsVal_int SWIG_TCL_CALL_ARGS_2(objv[2], &val2);
+     if (!SWIG_IsOK(ecode2)) {
+       SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "OpenShared" "', argument " "2"" of type '" "int""'");
+     } 
+     arg2 = static_cast< int >(val2);
+   }
+   {
+     CPLErrorReset();
+     result = (OGRDataSourceShadow *)OpenShared((char const *)arg1,arg2);
+     CPLErr eclass = CPLGetLastErrorType();
+     if ( eclass == CE_Failure || eclass == CE_Fatal ) {
+       SWIG_exception( SWIG_RuntimeError, CPLGetLastErrorMsg() );
+       
+     }
+     
+     
+     
+     
+     
+     
+     
+     
+     
+     
+     
+   }
+   Tcl_SetObjResult(interp, SWIG_NewInstanceObj( SWIG_as_voidptr(result), SWIGTYPE_p_OGRDataSourceShadow,0));
+   if (alloc1 == SWIG_NEWOBJ) delete[] buf1;
+   return TCL_OK;
+ fail:
+   if (alloc1 == SWIG_NEWOBJ) delete[] buf1;
+   return TCL_ERROR;
+ }
+ 
+ 
+ SWIGINTERN int
+ _wrap_GetDriverByName(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
+   char *arg1 = (char *) 0 ;
+   int res1 ;
+   char *buf1 = 0 ;
+   int alloc1 = 0 ;
+   OGRDriverShadow *result = 0 ;
+   
+   if (SWIG_GetArgs(interp, objc, objv,"o:osgeo::GetDriverByName name ",(void *)0) == TCL_ERROR) SWIG_fail;
+   res1 = SWIG_AsCharPtrAndSize(objv[1], &buf1, NULL, &alloc1);
+   if (!SWIG_IsOK(res1)) {
+     SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "GetDriverByName" "', argument " "1"" of type '" "char const *""'");
+   }
+   arg1 = reinterpret_cast< char * >(buf1);
+   {
+     CPLErrorReset();
+     result = (OGRDriverShadow *)GetDriverByName((char const *)arg1);
+     CPLErr eclass = CPLGetLastErrorType();
+     if ( eclass == CE_Failure || eclass == CE_Fatal ) {
+       SWIG_exception( SWIG_RuntimeError, CPLGetLastErrorMsg() );
+       
+     }
+     
+     
+     
+     
+     
+     
+     
+     
+     
+     
+     
+   }
+   Tcl_SetObjResult(interp, SWIG_NewInstanceObj( SWIG_as_voidptr(result), SWIGTYPE_p_OGRDriverShadow,0));
+   if (alloc1 == SWIG_NEWOBJ) delete[] buf1;
+   return TCL_OK;
+ fail:
+   if (alloc1 == SWIG_NEWOBJ) delete[] buf1;
+   return TCL_ERROR;
+ }
+ 
+ 
+ SWIGINTERN int
+ _wrap_GetDriver(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
+   int arg1 ;
+   int val1 ;
+   int ecode1 = 0 ;
+   OGRDriverShadow *result = 0 ;
+   
+   if (SWIG_GetArgs(interp, objc, objv,"o:osgeo::GetDriver driver_number ",(void *)0) == TCL_ERROR) SWIG_fail;
+   ecode1 = SWIG_AsVal_int SWIG_TCL_CALL_ARGS_2(objv[1], &val1);
+   if (!SWIG_IsOK(ecode1)) {
+     SWIG_exception_fail(SWIG_ArgError(ecode1), "in method '" "GetDriver" "', argument " "1"" of type '" "int""'");
+   } 
+   arg1 = static_cast< int >(val1);
+   {
+     CPLErrorReset();
+     result = (OGRDriverShadow *)GetDriver(arg1);
+     CPLErr eclass = CPLGetLastErrorType();
+     if ( eclass == CE_Failure || eclass == CE_Fatal ) {
+       SWIG_exception( SWIG_RuntimeError, CPLGetLastErrorMsg() );
+       
+     }
+     
+     
+     
+     
+     
+     
+     
+     
+     
+     
+     
+   }
+   Tcl_SetObjResult(interp, SWIG_NewInstanceObj( SWIG_as_voidptr(result), SWIGTYPE_p_OGRDriverShadow,0));
+   return TCL_OK;
+ fail:
+   return TCL_ERROR;
+ }
+ 
+ 
+ 
+ static swig_command_info swig_commands[] = {
+     { SWIG_prefix "UseExceptions", (swig_wrapper_func) _wrap_UseExceptions, NULL},
+     { SWIG_prefix "DontUseExceptions", (swig_wrapper_func) _wrap_DontUseExceptions, NULL},
+     { SWIG_prefix "Driver_name_get", (swig_wrapper_func) _wrap_Driver_name_get, NULL},
+     { SWIG_prefix "Driver_CreateDataSource", (swig_wrapper_func) _wrap_Driver_CreateDataSource, NULL},
+     { SWIG_prefix "Driver_CopyDataSource", (swig_wrapper_func) _wrap_Driver_CopyDataSource, NULL},
+     { SWIG_prefix "Driver_Open", (swig_wrapper_func) _wrap_Driver_Open, NULL},
+     { SWIG_prefix "Driver_DeleteDataSource", (swig_wrapper_func) _wrap_Driver_DeleteDataSource, NULL},
+     { SWIG_prefix "Driver_TestCapability", (swig_wrapper_func) _wrap_Driver_TestCapability, NULL},
+     { SWIG_prefix "Driver_GetName", (swig_wrapper_func) _wrap_Driver_GetName, NULL},
+     { SWIG_prefix "Driver", (swig_wrapper_func) SWIG_ObjectConstructor, (ClientData)&_wrap_class_OGRDriverShadow},
+     { SWIG_prefix "DataSource_name_get", (swig_wrapper_func) _wrap_DataSource_name_get, NULL},
+     { SWIG_prefix "delete_DataSource", (swig_wrapper_func) _wrap_delete_DataSource, NULL},
+     { SWIG_prefix "DataSource_GetRefCount", (swig_wrapper_func) _wrap_DataSource_GetRefCount, NULL},
+     { SWIG_prefix "DataSource_GetSummaryRefCount", (swig_wrapper_func) _wrap_DataSource_GetSummaryRefCount, NULL},
+     { SWIG_prefix "DataSource_GetLayerCount", (swig_wrapper_func) _wrap_DataSource_GetLayerCount, NULL},
+     { SWIG_prefix "DataSource_GetDriver", (swig_wrapper_func) _wrap_DataSource_GetDriver, NULL},
+     { SWIG_prefix "DataSource_GetName", (swig_wrapper_func) _wrap_DataSource_GetName, NULL},
+     { SWIG_prefix "DataSource_DeleteLayer", (swig_wrapper_func) _wrap_DataSource_DeleteLayer, NULL},
+     { SWIG_prefix "DataSource_CreateLayer", (swig_wrapper_func) _wrap_DataSource_CreateLayer, NULL},
+     { SWIG_prefix "DataSource_CopyLayer", (swig_wrapper_func) _wrap_DataSource_CopyLayer, NULL},
+     { SWIG_prefix "DataSource_GetLayerByIndex", (swig_wrapper_func) _wrap_DataSource_GetLayerByIndex, NULL},
+     { SWIG_prefix "DataSource_GetLayerByName", (swig_wrapper_func) _wrap_DataSource_GetLayerByName, NULL},
+     { SWIG_prefix "DataSource_TestCapability", (swig_wrapper_func) _wrap_DataSource_TestCapability, NULL},
+     { SWIG_prefix "DataSource_ExecuteSQL", (swig_wrapper_func) _wrap_DataSource_ExecuteSQL, NULL},
+     { SWIG_prefix "DataSource_ReleaseResultSet", (swig_wrapper_func) _wrap_DataSource_ReleaseResultSet, NULL},
+     { SWIG_prefix "DataSource", (swig_wrapper_func) SWIG_ObjectConstructor, (ClientData)&_wrap_class_OGRDataSourceShadow},
+     { SWIG_prefix "Layer_GetRefCount", (swig_wrapper_func) _wrap_Layer_GetRefCount, NULL},
+     { SWIG_prefix "Layer_SetSpatialFilter", (swig_wrapper_func) _wrap_Layer_SetSpatialFilter, NULL},
+     { SWIG_prefix "Layer_SetSpatialFilterRect", (swig_wrapper_func) _wrap_Layer_SetSpatialFilterRect, NULL},
+     { SWIG_prefix "Layer_GetSpatialFilter", (swig_wrapper_func) _wrap_Layer_GetSpatialFilter, NULL},
+     { SWIG_prefix "Layer_SetAttributeFilter", (swig_wrapper_func) _wrap_Layer_SetAttributeFilter, NULL},
+     { SWIG_prefix "Layer_ResetReading", (swig_wrapper_func) _wrap_Layer_ResetReading, NULL},
+     { SWIG_prefix "Layer_GetName", (swig_wrapper_func) _wrap_Layer_GetName, NULL},
+     { SWIG_prefix "Layer_GetGeometryColumn", (swig_wrapper_func) _wrap_Layer_GetGeometryColumn, NULL},
+     { SWIG_prefix "Layer_GetFIDColumn", (swig_wrapper_func) _wrap_Layer_GetFIDColumn, NULL},
+     { SWIG_prefix "Layer_GetFeature", (swig_wrapper_func) _wrap_Layer_GetFeature, NULL},
+     { SWIG_prefix "Layer_GetNextFeature", (swig_wrapper_func) _wrap_Layer_GetNextFeature, NULL},
+     { SWIG_prefix "Layer_SetNextByIndex", (swig_wrapper_func) _wrap_Layer_SetNextByIndex, NULL},
+     { SWIG_prefix "Layer_SetFeature", (swig_wrapper_func) _wrap_Layer_SetFeature, NULL},
+     { SWIG_prefix "Layer_CreateFeature", (swig_wrapper_func) _wrap_Layer_CreateFeature, NULL},
+     { SWIG_prefix "Layer_DeleteFeature", (swig_wrapper_func) _wrap_Layer_DeleteFeature, NULL},
+     { SWIG_prefix "Layer_SyncToDisk", (swig_wrapper_func) _wrap_Layer_SyncToDisk, NULL},
+     { SWIG_prefix "Layer_GetLayerDefn", (swig_wrapper_func) _wrap_Layer_GetLayerDefn, NULL},
+     { SWIG_prefix "Layer_GetFeatureCount", (swig_wrapper_func) _wrap_Layer_GetFeatureCount, NULL},
+     { SWIG_prefix "Layer_GetExtent", (swig_wrapper_func) _wrap_Layer_GetExtent, NULL},
+     { SWIG_prefix "Layer_TestCapability", (swig_wrapper_func) _wrap_Layer_TestCapability, NULL},
+     { SWIG_prefix "Layer_CreateField", (swig_wrapper_func) _wrap_Layer_CreateField, NULL},
+     { SWIG_prefix "Layer_StartTransaction", (swig_wrapper_func) _wrap_Layer_StartTransaction, NULL},
+     { SWIG_prefix "Layer_CommitTransaction", (swig_wrapper_func) _wrap_Layer_CommitTransaction, NULL},
+     { SWIG_prefix "Layer_RollbackTransaction", (swig_wrapper_func) _wrap_Layer_RollbackTransaction, NULL},
+     { SWIG_prefix "Layer_GetSpatialRef", (swig_wrapper_func) _wrap_Layer_GetSpatialRef, NULL},
+     { SWIG_prefix "Layer_GetFeaturesRead", (swig_wrapper_func) _wrap_Layer_GetFeaturesRead, NULL},
+     { SWIG_prefix "Layer", (swig_wrapper_func) SWIG_ObjectConstructor, (ClientData)&_wrap_class_OGRLayerShadow},
+     { SWIG_prefix "delete_Feature", (swig_wrapper_func) _wrap_delete_Feature, NULL},
+     { SWIG_prefix "new_Feature", (swig_wrapper_func) _wrap_new_Feature, NULL},
+     { SWIG_prefix "Feature_GetDefnRef", (swig_wrapper_func) _wrap_Feature_GetDefnRef, NULL},
+     { SWIG_prefix "Feature_SetGeometry", (swig_wrapper_func) _wrap_Feature_SetGeometry, NULL},
+     { SWIG_prefix "Feature_SetGeometryDirectly", (swig_wrapper_func) _wrap_Feature_SetGeometryDirectly, NULL},
+     { SWIG_prefix "Feature_GetGeometryRef", (swig_wrapper_func) _wrap_Feature_GetGeometryRef, NULL},
+     { SWIG_prefix "Feature_Clone", (swig_wrapper_func) _wrap_Feature_Clone, NULL},
+     { SWIG_prefix "Feature_Equal", (swig_wrapper_func) _wrap_Feature_Equal, NULL},
+     { SWIG_prefix "Feature_GetFieldCount", (swig_wrapper_func) _wrap_Feature_GetFieldCount, NULL},
+     { SWIG_prefix "Feature_GetFieldDefnRef", (swig_wrapper_func) _wrap_Feature_GetFieldDefnRef, NULL},
+     { SWIG_prefix "Feature_GetFieldAsString", (swig_wrapper_func) _wrap_Feature_GetFieldAsString, NULL},
+     { SWIG_prefix "Feature_GetFieldAsInteger", (swig_wrapper_func) _wrap_Feature_GetFieldAsInteger, NULL},
+     { SWIG_prefix "Feature_GetFieldAsDouble", (swig_wrapper_func) _wrap_Feature_GetFieldAsDouble, NULL},
+     { SWIG_prefix "Feature_GetFieldAsDateTime", (swig_wrapper_func) _wrap_Feature_GetFieldAsDateTime, NULL},
+     { SWIG_prefix "Feature_GetFieldAsIntegerList", (swig_wrapper_func) _wrap_Feature_GetFieldAsIntegerList, NULL},
+     { SWIG_prefix "Feature_GetFieldAsDoubleList", (swig_wrapper_func) _wrap_Feature_GetFieldAsDoubleList, NULL},
+     { SWIG_prefix "Feature_GetFieldAsStringList", (swig_wrapper_func) _wrap_Feature_GetFieldAsStringList, NULL},
+     { SWIG_prefix "Feature_IsFieldSet", (swig_wrapper_func) _wrap_Feature_IsFieldSet, NULL},
+     { SWIG_prefix "Feature_GetFieldIndex", (swig_wrapper_func) _wrap_Feature_GetFieldIndex, NULL},
+     { SWIG_prefix "Feature_GetFID", (swig_wrapper_func) _wrap_Feature_GetFID, NULL},
+     { SWIG_prefix "Feature_SetFID", (swig_wrapper_func) _wrap_Feature_SetFID, NULL},
+     { SWIG_prefix "Feature_DumpReadable", (swig_wrapper_func) _wrap_Feature_DumpReadable, NULL},
+     { SWIG_prefix "Feature_UnsetField", (swig_wrapper_func) _wrap_Feature_UnsetField, NULL},
+     { SWIG_prefix "Feature_SetField", (swig_wrapper_func) _wrap_Feature_SetField, NULL},
+     { SWIG_prefix "Feature_SetFieldIntegerList", (swig_wrapper_func) _wrap_Feature_SetFieldIntegerList, NULL},
+     { SWIG_prefix "Feature_SetFieldDoubleList", (swig_wrapper_func) _wrap_Feature_SetFieldDoubleList, NULL},
+     { SWIG_prefix "Feature_SetFieldStringList", (swig_wrapper_func) _wrap_Feature_SetFieldStringList, NULL},
+     { SWIG_prefix "Feature_SetFrom", (swig_wrapper_func) _wrap_Feature_SetFrom, NULL},
+     { SWIG_prefix "Feature_GetStyleString", (swig_wrapper_func) _wrap_Feature_GetStyleString, NULL},
+     { SWIG_prefix "Feature_SetStyleString", (swig_wrapper_func) _wrap_Feature_SetStyleString, NULL},
+     { SWIG_prefix "Feature_GetFieldType", (swig_wrapper_func) _wrap_Feature_GetFieldType, NULL},
+     { SWIG_prefix "Feature", (swig_wrapper_func) SWIG_ObjectConstructor, (ClientData)&_wrap_class_OGRFeatureShadow},
+     { SWIG_prefix "delete_FeatureDefn", (swig_wrapper_func) _wrap_delete_FeatureDefn, NULL},
+     { SWIG_prefix "new_FeatureDefn", (swig_wrapper_func) _wrap_new_FeatureDefn, NULL},
+     { SWIG_prefix "FeatureDefn_GetName", (swig_wrapper_func) _wrap_FeatureDefn_GetName, NULL},
+     { SWIG_prefix "FeatureDefn_GetFieldCount", (swig_wrapper_func) _wrap_FeatureDefn_GetFieldCount, NULL},
+     { SWIG_prefix "FeatureDefn_GetFieldDefn", (swig_wrapper_func) _wrap_FeatureDefn_GetFieldDefn, NULL},
+     { SWIG_prefix "FeatureDefn_GetFieldIndex", (swig_wrapper_func) _wrap_FeatureDefn_GetFieldIndex, NULL},
+     { SWIG_prefix "FeatureDefn_AddFieldDefn", (swig_wrapper_func) _wrap_FeatureDefn_AddFieldDefn, NULL},
+     { SWIG_prefix "FeatureDefn_GetGeomType", (swig_wrapper_func) _wrap_FeatureDefn_GetGeomType, NULL},
+     { SWIG_prefix "FeatureDefn_SetGeomType", (swig_wrapper_func) _wrap_FeatureDefn_SetGeomType, NULL},
+     { SWIG_prefix "FeatureDefn_GetReferenceCount", (swig_wrapper_func) _wrap_FeatureDefn_GetReferenceCount, NULL},
+     { SWIG_prefix "FeatureDefn", (swig_wrapper_func) SWIG_ObjectConstructor, (ClientData)&_wrap_class_OGRFeatureDefnShadow},
+     { SWIG_prefix "delete_FieldDefn", (swig_wrapper_func) _wrap_delete_FieldDefn, NULL},
+     { SWIG_prefix "new_FieldDefn", (swig_wrapper_func) _wrap_new_FieldDefn, NULL},
+     { SWIG_prefix "FieldDefn_GetName", (swig_wrapper_func) _wrap_FieldDefn_GetName, NULL},
+     { SWIG_prefix "FieldDefn_GetNameRef", (swig_wrapper_func) _wrap_FieldDefn_GetNameRef, NULL},
+     { SWIG_prefix "FieldDefn_SetName", (swig_wrapper_func) _wrap_FieldDefn_SetName, NULL},
+     { SWIG_prefix "FieldDefn_GetType", (swig_wrapper_func) _wrap_FieldDefn_GetType, NULL},
+     { SWIG_prefix "FieldDefn_SetType", (swig_wrapper_func) _wrap_FieldDefn_SetType, NULL},
+     { SWIG_prefix "FieldDefn_GetJustify", (swig_wrapper_func) _wrap_FieldDefn_GetJustify, NULL},
+     { SWIG_prefix "FieldDefn_SetJustify", (swig_wrapper_func) _wrap_FieldDefn_SetJustify, NULL},
+     { SWIG_prefix "FieldDefn_GetWidth", (swig_wrapper_func) _wrap_FieldDefn_GetWidth, NULL},
+     { SWIG_prefix "FieldDefn_SetWidth", (swig_wrapper_func) _wrap_FieldDefn_SetWidth, NULL},
+     { SWIG_prefix "FieldDefn_GetPrecision", (swig_wrapper_func) _wrap_FieldDefn_GetPrecision, NULL},
+     { SWIG_prefix "FieldDefn_SetPrecision", (swig_wrapper_func) _wrap_FieldDefn_SetPrecision, NULL},
+     { SWIG_prefix "FieldDefn_GetFieldTypeName", (swig_wrapper_func) _wrap_FieldDefn_GetFieldTypeName, NULL},
+     { SWIG_prefix "FieldDefn", (swig_wrapper_func) SWIG_ObjectConstructor, (ClientData)&_wrap_class_OGRFieldDefnShadow},
+     { SWIG_prefix "CreateGeometryFromWkb", (swig_wrapper_func) _wrap_CreateGeometryFromWkb, NULL},
+     { SWIG_prefix "CreateGeometryFromWkt", (swig_wrapper_func) _wrap_CreateGeometryFromWkt, NULL},
+     { SWIG_prefix "CreateGeometryFromGML", (swig_wrapper_func) _wrap_CreateGeometryFromGML, NULL},
+     { SWIG_prefix "CreateGeometryFromJson", (swig_wrapper_func) _wrap_CreateGeometryFromJson, NULL},
+     { SWIG_prefix "BuildPolygonFromEdges", (swig_wrapper_func) _wrap_BuildPolygonFromEdges, NULL},
+     { SWIG_prefix "delete_Geometry", (swig_wrapper_func) _wrap_delete_Geometry, NULL},
+     { SWIG_prefix "new_Geometry", (swig_wrapper_func) _wrap_new_Geometry, NULL},
+     { SWIG_prefix "Geometry_ExportToWkt", (swig_wrapper_func) _wrap_Geometry_ExportToWkt, NULL},
+     { SWIG_prefix "Geometry_ExportToWkb", (swig_wrapper_func) _wrap_Geometry_ExportToWkb, NULL},
+     { SWIG_prefix "Geometry_ExportToGML", (swig_wrapper_func) _wrap_Geometry_ExportToGML, NULL},
+     { SWIG_prefix "Geometry_ExportToKML", (swig_wrapper_func) _wrap_Geometry_ExportToKML, NULL},
+     { SWIG_prefix "Geometry_ExportToJson", (swig_wrapper_func) _wrap_Geometry_ExportToJson, NULL},
+     { SWIG_prefix "Geometry_AddPoint", (swig_wrapper_func) _wrap_Geometry_AddPoint, NULL},
+     { SWIG_prefix "Geometry_AddPoint_2D", (swig_wrapper_func) _wrap_Geometry_AddPoint_2D, NULL},
+     { SWIG_prefix "Geometry_AddGeometryDirectly", (swig_wrapper_func) _wrap_Geometry_AddGeometryDirectly, NULL},
+     { SWIG_prefix "Geometry_AddGeometry", (swig_wrapper_func) _wrap_Geometry_AddGeometry, NULL},
+     { SWIG_prefix "Geometry_Clone", (swig_wrapper_func) _wrap_Geometry_Clone, NULL},
+     { SWIG_prefix "Geometry_GetGeometryType", (swig_wrapper_func) _wrap_Geometry_GetGeometryType, NULL},
+     { SWIG_prefix "Geometry_GetGeometryName", (swig_wrapper_func) _wrap_Geometry_GetGeometryName, NULL},
+     { SWIG_prefix "Geometry_GetArea", (swig_wrapper_func) _wrap_Geometry_GetArea, NULL},
+     { SWIG_prefix "Geometry_GetPointCount", (swig_wrapper_func) _wrap_Geometry_GetPointCount, NULL},
+     { SWIG_prefix "Geometry_GetX", (swig_wrapper_func) _wrap_Geometry_GetX, NULL},
+     { SWIG_prefix "Geometry_GetY", (swig_wrapper_func) _wrap_Geometry_GetY, NULL},
+     { SWIG_prefix "Geometry_GetZ", (swig_wrapper_func) _wrap_Geometry_GetZ, NULL},
+     { SWIG_prefix "Geometry_GetPoint", (swig_wrapper_func) _wrap_Geometry_GetPoint, NULL},
+     { SWIG_prefix "Geometry_GetPoint_2D", (swig_wrapper_func) _wrap_Geometry_GetPoint_2D, NULL},
+     { SWIG_prefix "Geometry_GetGeometryCount", (swig_wrapper_func) _wrap_Geometry_GetGeometryCount, NULL},
+     { SWIG_prefix "Geometry_SetPoint", (swig_wrapper_func) _wrap_Geometry_SetPoint, NULL},
+     { SWIG_prefix "Geometry_SetPoint_2D", (swig_wrapper_func) _wrap_Geometry_SetPoint_2D, NULL},
+     { SWIG_prefix "Geometry_GetGeometryRef", (swig_wrapper_func) _wrap_Geometry_GetGeometryRef, NULL},
+     { SWIG_prefix "Geometry_GetBoundary", (swig_wrapper_func) _wrap_Geometry_GetBoundary, NULL},
+     { SWIG_prefix "Geometry_ConvexHull", (swig_wrapper_func) _wrap_Geometry_ConvexHull, NULL},
+     { SWIG_prefix "Geometry_Buffer", (swig_wrapper_func) _wrap_Geometry_Buffer, NULL},
+     { SWIG_prefix "Geometry_Intersection", (swig_wrapper_func) _wrap_Geometry_Intersection, NULL},
+     { SWIG_prefix "Geometry_Union", (swig_wrapper_func) _wrap_Geometry_Union, NULL},
+     { SWIG_prefix "Geometry_Difference", (swig_wrapper_func) _wrap_Geometry_Difference, NULL},
+     { SWIG_prefix "Geometry_SymmetricDifference", (swig_wrapper_func) _wrap_Geometry_SymmetricDifference, NULL},
+     { SWIG_prefix "Geometry_Distance", (swig_wrapper_func) _wrap_Geometry_Distance, NULL},
+     { SWIG_prefix "Geometry_Empty", (swig_wrapper_func) _wrap_Geometry_Empty, NULL},
+     { SWIG_prefix "Geometry_IsEmpty", (swig_wrapper_func) _wrap_Geometry_IsEmpty, NULL},
+     { SWIG_prefix "Geometry_IsValid", (swig_wrapper_func) _wrap_Geometry_IsValid, NULL},
+     { SWIG_prefix "Geometry_IsSimple", (swig_wrapper_func) _wrap_Geometry_IsSimple, NULL},
+     { SWIG_prefix "Geometry_IsRing", (swig_wrapper_func) _wrap_Geometry_IsRing, NULL},
+     { SWIG_prefix "Geometry_Intersect", (swig_wrapper_func) _wrap_Geometry_Intersect, NULL},
+     { SWIG_prefix "Geometry_Equal", (swig_wrapper_func) _wrap_Geometry_Equal, NULL},
+     { SWIG_prefix "Geometry_Disjoint", (swig_wrapper_func) _wrap_Geometry_Disjoint, NULL},
+     { SWIG_prefix "Geometry_Touches", (swig_wrapper_func) _wrap_Geometry_Touches, NULL},
+     { SWIG_prefix "Geometry_Crosses", (swig_wrapper_func) _wrap_Geometry_Crosses, NULL},
+     { SWIG_prefix "Geometry_Within", (swig_wrapper_func) _wrap_Geometry_Within, NULL},
+     { SWIG_prefix "Geometry_Contains", (swig_wrapper_func) _wrap_Geometry_Contains, NULL},
+     { SWIG_prefix "Geometry_Overlaps", (swig_wrapper_func) _wrap_Geometry_Overlaps, NULL},
+     { SWIG_prefix "Geometry_TransformTo", (swig_wrapper_func) _wrap_Geometry_TransformTo, NULL},
+     { SWIG_prefix "Geometry_Transform", (swig_wrapper_func) _wrap_Geometry_Transform, NULL},
+     { SWIG_prefix "Geometry_GetSpatialReference", (swig_wrapper_func) _wrap_Geometry_GetSpatialReference, NULL},
+     { SWIG_prefix "Geometry_AssignSpatialReference", (swig_wrapper_func) _wrap_Geometry_AssignSpatialReference, NULL},
+     { SWIG_prefix "Geometry_CloseRings", (swig_wrapper_func) _wrap_Geometry_CloseRings, NULL},
+     { SWIG_prefix "Geometry_FlattenTo2D", (swig_wrapper_func) _wrap_Geometry_FlattenTo2D, NULL},
+     { SWIG_prefix "Geometry_GetEnvelope", (swig_wrapper_func) _wrap_Geometry_GetEnvelope, NULL},
+     { SWIG_prefix "Geometry_Centroid", (swig_wrapper_func) _wrap_Geometry_Centroid, NULL},
+     { SWIG_prefix "Geometry_WkbSize", (swig_wrapper_func) _wrap_Geometry_WkbSize, NULL},
+     { SWIG_prefix "Geometry_GetCoordinateDimension", (swig_wrapper_func) _wrap_Geometry_GetCoordinateDimension, NULL},
+     { SWIG_prefix "Geometry_SetCoordinateDimension", (swig_wrapper_func) _wrap_Geometry_SetCoordinateDimension, NULL},
+     { SWIG_prefix "Geometry_GetDimension", (swig_wrapper_func) _wrap_Geometry_GetDimension, NULL},
+     { SWIG_prefix "Geometry", (swig_wrapper_func) SWIG_ObjectConstructor, (ClientData)&_wrap_class_OGRGeometryShadow},
+     { SWIG_prefix "GetDriverCount", (swig_wrapper_func) _wrap_GetDriverCount, NULL},
+     { SWIG_prefix "GetOpenDSCount", (swig_wrapper_func) _wrap_GetOpenDSCount, NULL},
+     { SWIG_prefix "SetGenerate_DB2_V72_BYTE_ORDER", (swig_wrapper_func) _wrap_SetGenerate_DB2_V72_BYTE_ORDER, NULL},
+     { SWIG_prefix "RegisterAll", (swig_wrapper_func) _wrap_RegisterAll, NULL},
+     { SWIG_prefix "GetOpenDS", (swig_wrapper_func) _wrap_GetOpenDS, NULL},
+     { SWIG_prefix "Open", (swig_wrapper_func) _wrap_Open, NULL},
+     { SWIG_prefix "OpenShared", (swig_wrapper_func) _wrap_OpenShared, NULL},
+     { SWIG_prefix "GetDriverByName", (swig_wrapper_func) _wrap_GetDriverByName, NULL},
+     { SWIG_prefix "GetDriver", (swig_wrapper_func) _wrap_GetDriver, NULL},
+     {0, 0, 0}
+ };
+ 
+ static swig_var_info swig_variables[] = {
+     {0,0,0,0}
+ };
+ 
+ static swig_const_info swig_constants[] = {
+     {0,0,0,0,0,0}
+ };
+ 
+ /* -------- TYPE CONVERSION AND EQUIVALENCE RULES (BEGIN) -------- */
+ 
+ static swig_type_info _swigt__p_GIntBig = {"_p_GIntBig", "GIntBig *", 0, 0, (void*)0, 0};
+ static swig_type_info _swigt__p_OGRDataSourceShadow = {"_p_OGRDataSourceShadow", "OGRDataSourceShadow *", 0, 0, (void*)&_wrap_class_OGRDataSourceShadow, 0};
+ static swig_type_info _swigt__p_OGRDriverShadow = {"_p_OGRDriverShadow", "OGRDriverShadow *", 0, 0, (void*)&_wrap_class_OGRDriverShadow, 0};
+ static swig_type_info _swigt__p_OGRFeatureDefnShadow = {"_p_OGRFeatureDefnShadow", "OGRFeatureDefnShadow *", 0, 0, (void*)&_wrap_class_OGRFeatureDefnShadow, 0};
+ static swig_type_info _swigt__p_OGRFeatureShadow = {"_p_OGRFeatureShadow", "OGRFeatureShadow *", 0, 0, (void*)&_wrap_class_OGRFeatureShadow, 0};
+ static swig_type_info _swigt__p_OGRFieldDefnShadow = {"_p_OGRFieldDefnShadow", "OGRFieldDefnShadow *", 0, 0, (void*)&_wrap_class_OGRFieldDefnShadow, 0};
+ static swig_type_info _swigt__p_OGRGeometryShadow = {"_p_OGRGeometryShadow", "OGRGeometryShadow *", 0, 0, (void*)&_wrap_class_OGRGeometryShadow, 0};
+ static swig_type_info _swigt__p_OGRLayerShadow = {"_p_OGRLayerShadow", "OGRLayerShadow *", 0, 0, (void*)&_wrap_class_OGRLayerShadow, 0};
+ static swig_type_info _swigt__p_OSRCoordinateTransformationShadow = {"_p_OSRCoordinateTransformationShadow", "OSRCoordinateTransformationShadow *", 0, 0, (void*)0, 0};
+ static swig_type_info _swigt__p_OSRSpatialReferenceShadow = {"_p_OSRSpatialReferenceShadow", "OSRSpatialReferenceShadow *", 0, 0, (void*)0, 0};
+ static swig_type_info _swigt__p_char = {"_p_char", "char *", 0, 0, (void*)0, 0};
+ static swig_type_info _swigt__p_double = {"_p_double", "double *", 0, 0, (void*)0, 0};
+ static swig_type_info _swigt__p_int = {"_p_int", "OGRFieldType *|int *|OGRwkbGeometryType *|OGRJustification *|OGRwkbByteOrder *|OGRErr *", 0, 0, (void*)0, 0};
+ static swig_type_info _swigt__p_p_char = {"_p_p_char", "char **", 0, 0, (void*)0, 0};
+ static swig_type_info _swigt__p_p_double = {"_p_p_double", "double **", 0, 0, (void*)0, 0};
+ static swig_type_info _swigt__p_p_int = {"_p_p_int", "int **", 0, 0, (void*)0, 0};
+ static swig_type_info _swigt__p_p_p_char = {"_p_p_p_char", "char ***", 0, 0, (void*)0, 0};
+ 
+ static swig_type_info *swig_type_initial[] = {
+   &_swigt__p_GIntBig,
+   &_swigt__p_OGRDataSourceShadow,
+   &_swigt__p_OGRDriverShadow,
+   &_swigt__p_OGRFeatureDefnShadow,
+   &_swigt__p_OGRFeatureShadow,
+   &_swigt__p_OGRFieldDefnShadow,
+   &_swigt__p_OGRGeometryShadow,
+   &_swigt__p_OGRLayerShadow,
+   &_swigt__p_OSRCoordinateTransformationShadow,
+   &_swigt__p_OSRSpatialReferenceShadow,
+   &_swigt__p_char,
+   &_swigt__p_double,
+   &_swigt__p_int,
+   &_swigt__p_p_char,
+   &_swigt__p_p_double,
+   &_swigt__p_p_int,
+   &_swigt__p_p_p_char,
+ };
+ 
+ static swig_cast_info _swigc__p_GIntBig[] = {  {&_swigt__p_GIntBig, 0, 0, 0},{0, 0, 0, 0}};
+ static swig_cast_info _swigc__p_OGRDataSourceShadow[] = {  {&_swigt__p_OGRDataSourceShadow, 0, 0, 0},{0, 0, 0, 0}};
+ static swig_cast_info _swigc__p_OGRDriverShadow[] = {  {&_swigt__p_OGRDriverShadow, 0, 0, 0},{0, 0, 0, 0}};
+ static swig_cast_info _swigc__p_OGRFeatureDefnShadow[] = {  {&_swigt__p_OGRFeatureDefnShadow, 0, 0, 0},{0, 0, 0, 0}};
+ static swig_cast_info _swigc__p_OGRFeatureShadow[] = {  {&_swigt__p_OGRFeatureShadow, 0, 0, 0},{0, 0, 0, 0}};
+ static swig_cast_info _swigc__p_OGRFieldDefnShadow[] = {  {&_swigt__p_OGRFieldDefnShadow, 0, 0, 0},{0, 0, 0, 0}};
+ static swig_cast_info _swigc__p_OGRGeometryShadow[] = {  {&_swigt__p_OGRGeometryShadow, 0, 0, 0},{0, 0, 0, 0}};
+ static swig_cast_info _swigc__p_OGRLayerShadow[] = {  {&_swigt__p_OGRLayerShadow, 0, 0, 0},{0, 0, 0, 0}};
+ static swig_cast_info _swigc__p_OSRCoordinateTransformationShadow[] = {  {&_swigt__p_OSRCoordinateTransformationShadow, 0, 0, 0},{0, 0, 0, 0}};
+ static swig_cast_info _swigc__p_OSRSpatialReferenceShadow[] = {  {&_swigt__p_OSRSpatialReferenceShadow, 0, 0, 0},{0, 0, 0, 0}};
+ static swig_cast_info _swigc__p_char[] = {  {&_swigt__p_char, 0, 0, 0},{0, 0, 0, 0}};
+ static swig_cast_info _swigc__p_double[] = {  {&_swigt__p_double, 0, 0, 0},{0, 0, 0, 0}};
+ static swig_cast_info _swigc__p_int[] = {  {&_swigt__p_int, 0, 0, 0},{0, 0, 0, 0}};
+ static swig_cast_info _swigc__p_p_char[] = {  {&_swigt__p_p_char, 0, 0, 0},{0, 0, 0, 0}};
+ static swig_cast_info _swigc__p_p_double[] = {  {&_swigt__p_p_double, 0, 0, 0},{0, 0, 0, 0}};
+ static swig_cast_info _swigc__p_p_int[] = {  {&_swigt__p_p_int, 0, 0, 0},{0, 0, 0, 0}};
+ static swig_cast_info _swigc__p_p_p_char[] = {  {&_swigt__p_p_p_char, 0, 0, 0},{0, 0, 0, 0}};
+ 
+ static swig_cast_info *swig_cast_initial[] = {
+   _swigc__p_GIntBig,
+   _swigc__p_OGRDataSourceShadow,
+   _swigc__p_OGRDriverShadow,
+   _swigc__p_OGRFeatureDefnShadow,
+   _swigc__p_OGRFeatureShadow,
+   _swigc__p_OGRFieldDefnShadow,
+   _swigc__p_OGRGeometryShadow,
+   _swigc__p_OGRLayerShadow,
+   _swigc__p_OSRCoordinateTransformationShadow,
+   _swigc__p_OSRSpatialReferenceShadow,
+   _swigc__p_char,
+   _swigc__p_double,
+   _swigc__p_int,
+   _swigc__p_p_char,
+   _swigc__p_p_double,
+   _swigc__p_p_int,
+   _swigc__p_p_p_char,
+ };
+ 
+ 
+ /* -------- TYPE CONVERSION AND EQUIVALENCE RULES (END) -------- */
+ 
+ #ifdef __cplusplus
+ }
+ #endif
+ /* -----------------------------------------------------------------------------
+  * Type initialization:
+  * This problem is tough by the requirement that no dynamic 
+  * memory is used. Also, since swig_type_info structures store pointers to 
+  * swig_cast_info structures and swig_cast_info structures store pointers back
+  * to swig_type_info structures, we need some lookup code at initialization. 
+  * The idea is that swig generates all the structures that are needed. 
+  * The runtime then collects these partially filled structures. 
+  * The SWIG_InitializeModule function takes these initial arrays out of 
+  * swig_module, and does all the lookup, filling in the swig_module.types
+  * array with the correct data and linking the correct swig_cast_info
+  * structures together.
+  *
+  * The generated swig_type_info structures are assigned staticly to an initial 
+  * array. We just loop through that array, and handle each type individually.
+  * First we lookup if this type has been already loaded, and if so, use the
+  * loaded structure instead of the generated one. Then we have to fill in the
+  * cast linked list. The cast data is initially stored in something like a
+  * two-dimensional array. Each row corresponds to a type (there are the same
+  * number of rows as there are in the swig_type_initial array). Each entry in
+  * a column is one of the swig_cast_info structures for that type.
+  * The cast_initial array is actually an array of arrays, because each row has
+  * a variable number of columns. So to actually build the cast linked list,
+  * we find the array of casts associated with the type, and loop through it 
+  * adding the casts to the list. The one last trick we need to do is making
+  * sure the type pointer in the swig_cast_info struct is correct.
+  *
+  * First off, we lookup the cast->type name to see if it is already loaded. 
+  * There are three cases to handle:
+  *  1) If the cast->type has already been loaded AND the type we are adding
+  *     casting info to has not been loaded (it is in this module), THEN we
+  *     replace the cast->type pointer with the type pointer that has already
+  *     been loaded.
+  *  2) If BOTH types (the one we are adding casting info to, and the 
+  *     cast->type) are loaded, THEN the cast info has already been loaded by
+  *     the previous module so we just ignore it.
+  *  3) Finally, if cast->type has not already been loaded, then we add that
+  *     swig_cast_info to the linked list (because the cast->type) pointer will
+  *     be correct.
+  * ----------------------------------------------------------------------------- */
+ 
+ #ifdef __cplusplus
+ extern "C" {
+ #if 0
+ } /* c-mode */
+ #endif
+ #endif
+ 
+ #if 0
+ #define SWIGRUNTIME_DEBUG
+ #endif
+ 
+ 
+ SWIGRUNTIME void
+ SWIG_InitializeModule(void *clientdata) {
+   size_t i;
+   swig_module_info *module_head, *iter;
+   int found, init;
+   
+   clientdata = clientdata;
+   
+   /* check to see if the circular list has been setup, if not, set it up */
+   if (swig_module.next==0) {
+     /* Initialize the swig_module */
+     swig_module.type_initial = swig_type_initial;
+     swig_module.cast_initial = swig_cast_initial;
+     swig_module.next = &swig_module;
+     init = 1;
+   } else {
+     init = 0;
+   }
+   
+   /* Try and load any already created modules */
+   module_head = SWIG_GetModule(clientdata);
+   if (!module_head) {
+     /* This is the first module loaded for this interpreter */
+     /* so set the swig module into the interpreter */
+     SWIG_SetModule(clientdata, &swig_module);
+     module_head = &swig_module;
+   } else {
+     /* the interpreter has loaded a SWIG module, but has it loaded this one? */
+     found=0;
+     iter=module_head;
+     do {
+       if (iter==&swig_module) {
+         found=1;
+         break;
+       }
+       iter=iter->next;
+     } while (iter!= module_head);
+     
+     /* if the is found in the list, then all is done and we may leave */
+     if (found) return;
+     /* otherwise we must add out module into the list */
+     swig_module.next = module_head->next;
+     module_head->next = &swig_module;
+   }
+   
+   /* When multiple interpeters are used, a module could have already been initialized in
+        a different interpreter, but not yet have a pointer in this interpreter.
+        In this case, we do not want to continue adding types... everything should be
+        set up already */
+   if (init == 0) return;
+   
+   /* Now work on filling in swig_module.types */
+ #ifdef SWIGRUNTIME_DEBUG
+   printf("SWIG_InitializeModule: size %d\n", swig_module.size);
+ #endif
+   for (i = 0; i < swig_module.size; ++i) {
+     swig_type_info *type = 0;
+     swig_type_info *ret;
+     swig_cast_info *cast;
+     
+ #ifdef SWIGRUNTIME_DEBUG
+     printf("SWIG_InitializeModule: type %d %s\n", i, swig_module.type_initial[i]->name);
+ #endif
+     
+     /* if there is another module already loaded */
+     if (swig_module.next != &swig_module) {
+       type = SWIG_MangledTypeQueryModule(swig_module.next, &swig_module, swig_module.type_initial[i]->name);
+     }
+     if (type) {
+       /* Overwrite clientdata field */
+ #ifdef SWIGRUNTIME_DEBUG
+       printf("SWIG_InitializeModule: found type %s\n", type->name);
+ #endif
+       if (swig_module.type_initial[i]->clientdata) {
+         type->clientdata = swig_module.type_initial[i]->clientdata;
+ #ifdef SWIGRUNTIME_DEBUG
+         printf("SWIG_InitializeModule: found and overwrite type %s \n", type->name);
+ #endif
+       }
+     } else {
+       type = swig_module.type_initial[i];
+     }
+     
+     /* Insert casting types */
+     cast = swig_module.cast_initial[i];
+     while (cast->type) {
+       /* Don't need to add information already in the list */
+       ret = 0;
+ #ifdef SWIGRUNTIME_DEBUG
+       printf("SWIG_InitializeModule: look cast %s\n", cast->type->name);
+ #endif
+       if (swig_module.next != &swig_module) {
+         ret = SWIG_MangledTypeQueryModule(swig_module.next, &swig_module, cast->type->name);
+ #ifdef SWIGRUNTIME_DEBUG
+         if (ret) printf("SWIG_InitializeModule: found cast %s\n", ret->name);
+ #endif
+       }
+       if (ret) {
+         if (type == swig_module.type_initial[i]) {
+ #ifdef SWIGRUNTIME_DEBUG
+           printf("SWIG_InitializeModule: skip old type %s\n", ret->name);
+ #endif
+           cast->type = ret;
+           ret = 0;
+         } else {
+           /* Check for casting already in the list */
+           swig_cast_info *ocast = SWIG_TypeCheck(ret->name, type);
+ #ifdef SWIGRUNTIME_DEBUG
+           if (ocast) printf("SWIG_InitializeModule: skip old cast %s\n", ret->name);
+ #endif
+           if (!ocast) ret = 0;
+         }
+       }
+       
+       if (!ret) {
+ #ifdef SWIGRUNTIME_DEBUG
+         printf("SWIG_InitializeModule: adding cast %s\n", cast->type->name);
+ #endif
+         if (type->cast) {
+           type->cast->prev = cast;
+           cast->next = type->cast;
+         }
+         type->cast = cast;
+       }
+       cast++;
+     }
+     /* Set entry in modules->types array equal to the type */
+     swig_module.types[i] = type;
+   }
+   swig_module.types[i] = 0;
+   
+ #ifdef SWIGRUNTIME_DEBUG
+   printf("**** SWIG_InitializeModule: Cast List ******\n");
+   for (i = 0; i < swig_module.size; ++i) {
+     int j = 0;
+     swig_cast_info *cast = swig_module.cast_initial[i];
+     printf("SWIG_InitializeModule: type %d %s\n", i, swig_module.type_initial[i]->name);
+     while (cast->type) {
+       printf("SWIG_InitializeModule: cast type %s\n", cast->type->name);
+       cast++;
+       ++j;
+     }
+     printf("---- Total casts: %d\n",j);
+   }
+   printf("**** SWIG_InitializeModule: Cast List ******\n");
+ #endif
+ }
+ 
+ /* This function will propagate the clientdata field of type to
+ * any new swig_type_info structures that have been added into the list
+ * of equivalent types.  It is like calling
+ * SWIG_TypeClientData(type, clientdata) a second time.
+ */
+ SWIGRUNTIME void
+ SWIG_PropagateClientData(void) {
+   size_t i;
+   swig_cast_info *equiv;
+   static int init_run = 0;
+   
+   if (init_run) return;
+   init_run = 1;
+   
+   for (i = 0; i < swig_module.size; i++) {
+     if (swig_module.types[i]->clientdata) {
+       equiv = swig_module.types[i]->cast;
+       while (equiv) {
+         if (!equiv->converter) {
+           if (equiv->type && !equiv->type->clientdata)
+           SWIG_TypeClientData(equiv->type, swig_module.types[i]->clientdata);
+         }
+         equiv = equiv->next;
+       }
+     }
+   }
+ }
+ 
+ #ifdef __cplusplus
+ #if 0
+ {
+   /* c-mode */
+ #endif
+ }
+ #endif
+ 
+ 
+ #ifdef __cplusplus
+ extern "C" {
+ #endif
+   
+   /* -----------------------------------------------------------------------------
+    * constants/methods manipulation
+    * ----------------------------------------------------------------------------- */
+   
+   /* Install Constants */
+   
+   SWIGINTERN void
+   SWIG_Tcl_InstallConstants(Tcl_Interp *interp, swig_const_info constants[]) {
+     int i;
+     Tcl_Obj *obj;
+     
+     if (!swigconstTableinit) {
+       Tcl_InitHashTable(&swigconstTable, TCL_STRING_KEYS);
+       swigconstTableinit = 1;
+     }
+     for (i = 0; constants[i].type; i++) {
+       switch(constants[i].type) {
+       case SWIG_TCL_POINTER:
+         obj = SWIG_NewPointerObj(constants[i].pvalue, *(constants[i]).ptype,0);
+         break;
+       case SWIG_TCL_BINARY:
+         obj = SWIG_NewPackedObj(constants[i].pvalue, constants[i].lvalue, *(constants[i].ptype));
+         break;
+       default:
+         obj = 0;
+         break;
+       }
+       if (obj) {
+         SWIG_Tcl_SetConstantObj(interp, constants[i].name, obj);
+       }
+     }
+   }
+   
+ #ifdef __cplusplus
+ }
+ #endif
+ 
+ /* -----------------------------------------------------------------------------*
+  *  Partial Init method
+  * -----------------------------------------------------------------------------*/
+ 
+ SWIGEXPORT int SWIG_init(Tcl_Interp *interp) {
+   int i;
+   if (interp == 0) return TCL_ERROR;
+ #ifdef USE_TCL_STUBS
+   if (Tcl_InitStubs(interp, (char*)"8.1", 0) == NULL) {
+     return TCL_ERROR;
+   }
+ #endif  
+   Tcl_PkgProvide(interp, (char*)SWIG_name, (char*)SWIG_version);
+   
+ #ifdef SWIG_namespace
+   Tcl_Eval(interp, "namespace eval " SWIG_namespace " { }");
+ #endif
+   
+   SWIG_InitializeModule((void *) interp);
+   SWIG_PropagateClientData();
+   
+   for (i = 0; swig_commands[i].name; i++) {
+     Tcl_CreateObjCommand(interp, (char *) swig_commands[i].name, (swig_wrapper_func) swig_commands[i].wrapper,
+       swig_commands[i].clientdata, NULL);
+   }
+   for (i = 0; swig_variables[i].name; i++) {
+     Tcl_SetVar(interp, (char *) swig_variables[i].name, (char *) "", TCL_GLOBAL_ONLY);
+     Tcl_TraceVar(interp, (char *) swig_variables[i].name, TCL_TRACE_READS | TCL_GLOBAL_ONLY, 
+       (Tcl_VarTraceProc *) swig_variables[i].get, (ClientData) swig_variables[i].addr);
+     Tcl_TraceVar(interp, (char *) swig_variables[i].name, TCL_TRACE_WRITES | TCL_GLOBAL_ONLY, 
+       (Tcl_VarTraceProc *) swig_variables[i].set, (ClientData) swig_variables[i].addr);
+   }
+   
+   SWIG_Tcl_InstallConstants(interp, swig_constants);
+   
+   
+   SWIG_Tcl_SetConstantObj(interp, "osgeo::wkb25Bit", SWIG_From_int(static_cast< int >(wkb25DBit)));
+   SWIG_Tcl_SetConstantObj(interp, "osgeo::wkbUnknown", SWIG_From_int(static_cast< int >(0)));
+   SWIG_Tcl_SetConstantObj(interp, "osgeo::wkbPoint", SWIG_From_int(static_cast< int >(1)));
+   SWIG_Tcl_SetConstantObj(interp, "osgeo::wkbLineString", SWIG_From_int(static_cast< int >(2)));
+   SWIG_Tcl_SetConstantObj(interp, "osgeo::wkbPolygon", SWIG_From_int(static_cast< int >(3)));
+   SWIG_Tcl_SetConstantObj(interp, "osgeo::wkbMultiPoint", SWIG_From_int(static_cast< int >(4)));
+   SWIG_Tcl_SetConstantObj(interp, "osgeo::wkbMultiLineString", SWIG_From_int(static_cast< int >(5)));
+   SWIG_Tcl_SetConstantObj(interp, "osgeo::wkbMultiPolygon", SWIG_From_int(static_cast< int >(6)));
+   SWIG_Tcl_SetConstantObj(interp, "osgeo::wkbGeometryCollection", SWIG_From_int(static_cast< int >(7)));
+   SWIG_Tcl_SetConstantObj(interp, "osgeo::wkbNone", SWIG_From_int(static_cast< int >(100)));
+   SWIG_Tcl_SetConstantObj(interp, "osgeo::wkbLinearRing", SWIG_From_int(static_cast< int >(101)));
+   SWIG_Tcl_SetConstantObj(interp, "osgeo::wkbPoint25D", SWIG_From_int(static_cast< int >(wkbPoint+wkb25DBit)));
+   SWIG_Tcl_SetConstantObj(interp, "osgeo::wkbLineString25D", SWIG_From_int(static_cast< int >(wkbLineString+wkb25DBit)));
+   SWIG_Tcl_SetConstantObj(interp, "osgeo::wkbPolygon25D", SWIG_From_int(static_cast< int >(wkbPolygon+wkb25DBit)));
+   SWIG_Tcl_SetConstantObj(interp, "osgeo::wkbMultiPoint25D", SWIG_From_int(static_cast< int >(wkbMultiPoint+wkb25DBit)));
+   SWIG_Tcl_SetConstantObj(interp, "osgeo::wkbMultiLineString25D", SWIG_From_int(static_cast< int >(wkbMultiLineString+wkb25DBit)));
+   SWIG_Tcl_SetConstantObj(interp, "osgeo::wkbMultiPolygon25D", SWIG_From_int(static_cast< int >(wkbMultiPolygon+wkb25DBit)));
+   SWIG_Tcl_SetConstantObj(interp, "osgeo::wkbGeometryCollection25D", SWIG_From_int(static_cast< int >(wkbGeometryCollection+wkb25DBit)));
+   SWIG_Tcl_SetConstantObj(interp, "osgeo::OFTInteger", SWIG_From_int(static_cast< int >(0)));
+   SWIG_Tcl_SetConstantObj(interp, "osgeo::OFTIntegerList", SWIG_From_int(static_cast< int >(1)));
+   SWIG_Tcl_SetConstantObj(interp, "osgeo::OFTReal", SWIG_From_int(static_cast< int >(2)));
+   SWIG_Tcl_SetConstantObj(interp, "osgeo::OFTRealList", SWIG_From_int(static_cast< int >(3)));
+   SWIG_Tcl_SetConstantObj(interp, "osgeo::OFTString", SWIG_From_int(static_cast< int >(4)));
+   SWIG_Tcl_SetConstantObj(interp, "osgeo::OFTStringList", SWIG_From_int(static_cast< int >(5)));
+   SWIG_Tcl_SetConstantObj(interp, "osgeo::OFTWideString", SWIG_From_int(static_cast< int >(6)));
+   SWIG_Tcl_SetConstantObj(interp, "osgeo::OFTWideStringList", SWIG_From_int(static_cast< int >(7)));
+   SWIG_Tcl_SetConstantObj(interp, "osgeo::OFTBinary", SWIG_From_int(static_cast< int >(8)));
+   SWIG_Tcl_SetConstantObj(interp, "osgeo::OFTDate", SWIG_From_int(static_cast< int >(9)));
+   SWIG_Tcl_SetConstantObj(interp, "osgeo::OFTTime", SWIG_From_int(static_cast< int >(10)));
+   SWIG_Tcl_SetConstantObj(interp, "osgeo::OFTDateTime", SWIG_From_int(static_cast< int >(11)));
+   SWIG_Tcl_SetConstantObj(interp, "osgeo::OJUndefined", SWIG_From_int(static_cast< int >(0)));
+   SWIG_Tcl_SetConstantObj(interp, "osgeo::OJLeft", SWIG_From_int(static_cast< int >(1)));
+   SWIG_Tcl_SetConstantObj(interp, "osgeo::OJRight", SWIG_From_int(static_cast< int >(2)));
+   SWIG_Tcl_SetConstantObj(interp, "osgeo::wkbXDR", SWIG_From_int(static_cast< int >(0)));
+   SWIG_Tcl_SetConstantObj(interp, "osgeo::wkbNDR", SWIG_From_int(static_cast< int >(1)));
+   SWIG_Tcl_SetConstantObj(interp, "osgeo::OLCRandomRead", SWIG_FromCharPtr("RandomRead"));
+   SWIG_Tcl_SetConstantObj(interp, "osgeo::OLCSequentialWrite", SWIG_FromCharPtr("SequentialWrite"));
+   SWIG_Tcl_SetConstantObj(interp, "osgeo::OLCRandomWrite", SWIG_FromCharPtr("RandomWrite"));
+   SWIG_Tcl_SetConstantObj(interp, "osgeo::OLCFastSpatialFilter", SWIG_FromCharPtr("FastSpatialFilter"));
+   SWIG_Tcl_SetConstantObj(interp, "osgeo::OLCFastFeatureCount", SWIG_FromCharPtr("FastFeatureCount"));
+   SWIG_Tcl_SetConstantObj(interp, "osgeo::OLCFastGetExtent", SWIG_FromCharPtr("FastGetExtent"));
+   SWIG_Tcl_SetConstantObj(interp, "osgeo::OLCCreateField", SWIG_FromCharPtr("CreateField"));
+   SWIG_Tcl_SetConstantObj(interp, "osgeo::OLCTransactions", SWIG_FromCharPtr("Transactions"));
+   SWIG_Tcl_SetConstantObj(interp, "osgeo::OLCDeleteFeature", SWIG_FromCharPtr("DeleteFeature"));
+   SWIG_Tcl_SetConstantObj(interp, "osgeo::OLCFastSetNextByIndex", SWIG_FromCharPtr("FastSetNextByIndex"));
+   SWIG_Tcl_SetConstantObj(interp, "osgeo::ODsCCreateLayer", SWIG_FromCharPtr("CreateLayer"));
+   SWIG_Tcl_SetConstantObj(interp, "osgeo::ODsCDeleteLayer", SWIG_FromCharPtr("DeleteLayer"));
+   SWIG_Tcl_SetConstantObj(interp, "osgeo::ODrCCreateDataSource", SWIG_FromCharPtr("CreateDataSource"));
+   SWIG_Tcl_SetConstantObj(interp, "osgeo::ODrCDeleteDataSource", SWIG_FromCharPtr("DeleteDataSource"));
+   
+   /* ogr_tcl.i %init code */
+   if ( OGRGetDriverCount() == 0 ) {
+     OGRRegisterAll();
+   }
+   
+   /* Setup exception handling */
+   UseExceptions();
+   
+   return TCL_OK;
+ }
+ SWIGEXPORT int Ogr_SafeInit(Tcl_Interp *interp) {
+   return SWIG_init(interp);
+ }
+ 
diff -rNc gdal-1.6.1/swig/tcl/osr_wrap.cpp gdal-1.6.1-patched/swig/tcl/osr_wrap.cpp
*** gdal-1.6.1/swig/tcl/osr_wrap.cpp	1970-01-01 02:00:00.000000000 +0200
--- gdal-1.6.1-patched/swig/tcl/osr_wrap.cpp	2009-06-30 15:40:06.000000000 +0300
***************
*** 0 ****
--- 1,8900 ----
+ /* ----------------------------------------------------------------------------
+  * This file was automatically generated by SWIG (http://www.swig.org).
+  * Version 1.3.36
+  * 
+  * This file is not intended to be easily readable and contains a number of 
+  * coding conventions designed to improve portability and efficiency. Do not make
+  * changes to this file unless you know what you are doing--modify the SWIG 
+  * interface file instead. 
+  * ----------------------------------------------------------------------------- */
+ 
+ 
+ #ifdef __cplusplus
+ template<typename T> class SwigValueWrapper {
+     T *tt;
+ public:
+     SwigValueWrapper() : tt(0) { }
+     SwigValueWrapper(const SwigValueWrapper<T>& rhs) : tt(new T(*rhs.tt)) { }
+     SwigValueWrapper(const T& t) : tt(new T(t)) { }
+     ~SwigValueWrapper() { delete tt; } 
+     SwigValueWrapper& operator=(const T& t) { delete tt; tt = new T(t); return *this; }
+     operator T&() const { return *tt; }
+     T *operator&() { return tt; }
+ private:
+     SwigValueWrapper& operator=(const SwigValueWrapper<T>& rhs);
+ };
+ 
+ template <typename T> T SwigValueInit() {
+   return T();
+ }
+ #endif
+ 
+ /* -----------------------------------------------------------------------------
+  *  This section contains generic SWIG labels for method/variable
+  *  declarations/attributes, and other compiler dependent labels.
+  * ----------------------------------------------------------------------------- */
+ 
+ /* template workaround for compilers that cannot correctly implement the C++ standard */
+ #ifndef SWIGTEMPLATEDISAMBIGUATOR
+ # if defined(__SUNPRO_CC) && (__SUNPRO_CC <= 0x560)
+ #  define SWIGTEMPLATEDISAMBIGUATOR template
+ # elif defined(__HP_aCC)
+ /* Needed even with `aCC -AA' when `aCC -V' reports HP ANSI C++ B3910B A.03.55 */
+ /* If we find a maximum version that requires this, the test would be __HP_aCC <= 35500 for A.03.55 */
+ #  define SWIGTEMPLATEDISAMBIGUATOR template
+ # else
+ #  define SWIGTEMPLATEDISAMBIGUATOR
+ # endif
+ #endif
+ 
+ /* inline attribute */
+ #ifndef SWIGINLINE
+ # if defined(__cplusplus) || (defined(__GNUC__) && !defined(__STRICT_ANSI__))
+ #   define SWIGINLINE inline
+ # else
+ #   define SWIGINLINE
+ # endif
+ #endif
+ 
+ /* attribute recognised by some compilers to avoid 'unused' warnings */
+ #ifndef SWIGUNUSED
+ # if defined(__GNUC__)
+ #   if !(defined(__cplusplus)) || (__GNUC__ > 3 || (__GNUC__ == 3 && __GNUC_MINOR__ >= 4))
+ #     define SWIGUNUSED __attribute__ ((__unused__)) 
+ #   else
+ #     define SWIGUNUSED
+ #   endif
+ # elif defined(__ICC)
+ #   define SWIGUNUSED __attribute__ ((__unused__)) 
+ # else
+ #   define SWIGUNUSED 
+ # endif
+ #endif
+ 
+ #ifndef SWIG_MSC_UNSUPPRESS_4505
+ # if defined(_MSC_VER)
+ #   pragma warning(disable : 4505) /* unreferenced local function has been removed */
+ # endif 
+ #endif
+ 
+ #ifndef SWIGUNUSEDPARM
+ # ifdef __cplusplus
+ #   define SWIGUNUSEDPARM(p)
+ # else
+ #   define SWIGUNUSEDPARM(p) p SWIGUNUSED 
+ # endif
+ #endif
+ 
+ /* internal SWIG method */
+ #ifndef SWIGINTERN
+ # define SWIGINTERN static SWIGUNUSED
+ #endif
+ 
+ /* internal inline SWIG method */
+ #ifndef SWIGINTERNINLINE
+ # define SWIGINTERNINLINE SWIGINTERN SWIGINLINE
+ #endif
+ 
+ /* exporting methods */
+ #if (__GNUC__ >= 4) || (__GNUC__ == 3 && __GNUC_MINOR__ >= 4)
+ #  ifndef GCC_HASCLASSVISIBILITY
+ #    define GCC_HASCLASSVISIBILITY
+ #  endif
+ #endif
+ 
+ #ifndef SWIGEXPORT
+ # if defined(_WIN32) || defined(__WIN32__) || defined(__CYGWIN__)
+ #   if defined(STATIC_LINKED)
+ #     define SWIGEXPORT
+ #   else
+ #     define SWIGEXPORT __declspec(dllexport)
+ #   endif
+ # else
+ #   if defined(__GNUC__) && defined(GCC_HASCLASSVISIBILITY)
+ #     define SWIGEXPORT __attribute__ ((visibility("default")))
+ #   else
+ #     define SWIGEXPORT
+ #   endif
+ # endif
+ #endif
+ 
+ /* calling conventions for Windows */
+ #ifndef SWIGSTDCALL
+ # if defined(_WIN32) || defined(__WIN32__) || defined(__CYGWIN__)
+ #   define SWIGSTDCALL __stdcall
+ # else
+ #   define SWIGSTDCALL
+ # endif 
+ #endif
+ 
+ /* Deal with Microsoft's attempt at deprecating C standard runtime functions */
+ #if !defined(SWIG_NO_CRT_SECURE_NO_DEPRECATE) && defined(_MSC_VER) && !defined(_CRT_SECURE_NO_DEPRECATE)
+ # define _CRT_SECURE_NO_DEPRECATE
+ #endif
+ 
+ /* Deal with Microsoft's attempt at deprecating methods in the standard C++ library */
+ #if !defined(SWIG_NO_SCL_SECURE_NO_DEPRECATE) && defined(_MSC_VER) && !defined(_SCL_SECURE_NO_DEPRECATE)
+ # define _SCL_SECURE_NO_DEPRECATE
+ #endif
+ 
+ 
+ 
+ #include <stdio.h>
+ #include <tcl.h>
+ #include <errno.h>
+ #include <stdlib.h>
+ #include <stdarg.h>
+ #include <ctype.h>
+ 
+ /* -----------------------------------------------------------------------------
+  * swigrun.swg
+  *
+  * This file contains generic CAPI SWIG runtime support for pointer
+  * type checking.
+  * ----------------------------------------------------------------------------- */
+ 
+ /* This should only be incremented when either the layout of swig_type_info changes,
+    or for whatever reason, the runtime changes incompatibly */
+ #define SWIG_RUNTIME_VERSION "4"
+ 
+ /* define SWIG_TYPE_TABLE_NAME as "SWIG_TYPE_TABLE" */
+ #ifdef SWIG_TYPE_TABLE
+ # define SWIG_QUOTE_STRING(x) #x
+ # define SWIG_EXPAND_AND_QUOTE_STRING(x) SWIG_QUOTE_STRING(x)
+ # define SWIG_TYPE_TABLE_NAME SWIG_EXPAND_AND_QUOTE_STRING(SWIG_TYPE_TABLE)
+ #else
+ # define SWIG_TYPE_TABLE_NAME
+ #endif
+ 
+ /*
+   You can use the SWIGRUNTIME and SWIGRUNTIMEINLINE macros for
+   creating a static or dynamic library from the swig runtime code.
+   In 99.9% of the cases, swig just needs to declare them as 'static'.
+   
+   But only do this if is strictly necessary, ie, if you have problems
+   with your compiler or so.
+ */
+ 
+ #ifndef SWIGRUNTIME
+ # define SWIGRUNTIME SWIGINTERN
+ #endif
+ 
+ #ifndef SWIGRUNTIMEINLINE
+ # define SWIGRUNTIMEINLINE SWIGRUNTIME SWIGINLINE
+ #endif
+ 
+ /*  Generic buffer size */
+ #ifndef SWIG_BUFFER_SIZE
+ # define SWIG_BUFFER_SIZE 1024
+ #endif
+ 
+ /* Flags for pointer conversions */
+ #define SWIG_POINTER_DISOWN        0x1
+ #define SWIG_CAST_NEW_MEMORY       0x2
+ 
+ /* Flags for new pointer objects */
+ #define SWIG_POINTER_OWN           0x1
+ 
+ 
+ /* 
+    Flags/methods for returning states.
+    
+    The swig conversion methods, as ConvertPtr, return and integer 
+    that tells if the conversion was successful or not. And if not,
+    an error code can be returned (see swigerrors.swg for the codes).
+    
+    Use the following macros/flags to set or process the returning
+    states.
+    
+    In old swig versions, you usually write code as:
+ 
+      if (SWIG_ConvertPtr(obj,vptr,ty.flags) != -1) {
+        // success code
+      } else {
+        //fail code
+      }
+ 
+    Now you can be more explicit as:
+ 
+     int res = SWIG_ConvertPtr(obj,vptr,ty.flags);
+     if (SWIG_IsOK(res)) {
+       // success code
+     } else {
+       // fail code
+     }
+ 
+    that seems to be the same, but now you can also do
+ 
+     Type *ptr;
+     int res = SWIG_ConvertPtr(obj,(void **)(&ptr),ty.flags);
+     if (SWIG_IsOK(res)) {
+       // success code
+       if (SWIG_IsNewObj(res) {
+         ...
+ 	delete *ptr;
+       } else {
+         ...
+       }
+     } else {
+       // fail code
+     }
+     
+    I.e., now SWIG_ConvertPtr can return new objects and you can
+    identify the case and take care of the deallocation. Of course that
+    requires also to SWIG_ConvertPtr to return new result values, as
+ 
+       int SWIG_ConvertPtr(obj, ptr,...) {         
+         if (<obj is ok>) {			       
+           if (<need new object>) {		       
+             *ptr = <ptr to new allocated object>; 
+             return SWIG_NEWOBJ;		       
+           } else {				       
+             *ptr = <ptr to old object>;	       
+             return SWIG_OLDOBJ;		       
+           } 				       
+         } else {				       
+           return SWIG_BADOBJ;		       
+         }					       
+       }
+ 
+    Of course, returning the plain '0(success)/-1(fail)' still works, but you can be
+    more explicit by returning SWIG_BADOBJ, SWIG_ERROR or any of the
+    swig errors code.
+ 
+    Finally, if the SWIG_CASTRANK_MODE is enabled, the result code
+    allows to return the 'cast rank', for example, if you have this
+ 
+        int food(double)
+        int fooi(int);
+ 
+    and you call
+  
+       food(1)   // cast rank '1'  (1 -> 1.0)
+       fooi(1)   // cast rank '0'
+ 
+    just use the SWIG_AddCast()/SWIG_CheckState()
+ 
+ 
+  */
+ #define SWIG_OK                    (0) 
+ #define SWIG_ERROR                 (-1)
+ #define SWIG_IsOK(r)               (r >= 0)
+ #define SWIG_ArgError(r)           ((r != SWIG_ERROR) ? r : SWIG_TypeError)  
+ 
+ /* The CastRankLimit says how many bits are used for the cast rank */
+ #define SWIG_CASTRANKLIMIT         (1 << 8)
+ /* The NewMask denotes the object was created (using new/malloc) */
+ #define SWIG_NEWOBJMASK            (SWIG_CASTRANKLIMIT  << 1)
+ /* The TmpMask is for in/out typemaps that use temporal objects */
+ #define SWIG_TMPOBJMASK            (SWIG_NEWOBJMASK << 1)
+ /* Simple returning values */
+ #define SWIG_BADOBJ                (SWIG_ERROR)
+ #define SWIG_OLDOBJ                (SWIG_OK)
+ #define SWIG_NEWOBJ                (SWIG_OK | SWIG_NEWOBJMASK)
+ #define SWIG_TMPOBJ                (SWIG_OK | SWIG_TMPOBJMASK)
+ /* Check, add and del mask methods */
+ #define SWIG_AddNewMask(r)         (SWIG_IsOK(r) ? (r | SWIG_NEWOBJMASK) : r)
+ #define SWIG_DelNewMask(r)         (SWIG_IsOK(r) ? (r & ~SWIG_NEWOBJMASK) : r)
+ #define SWIG_IsNewObj(r)           (SWIG_IsOK(r) && (r & SWIG_NEWOBJMASK))
+ #define SWIG_AddTmpMask(r)         (SWIG_IsOK(r) ? (r | SWIG_TMPOBJMASK) : r)
+ #define SWIG_DelTmpMask(r)         (SWIG_IsOK(r) ? (r & ~SWIG_TMPOBJMASK) : r)
+ #define SWIG_IsTmpObj(r)           (SWIG_IsOK(r) && (r & SWIG_TMPOBJMASK))
+ 
+ 
+ /* Cast-Rank Mode */
+ #if defined(SWIG_CASTRANK_MODE)
+ #  ifndef SWIG_TypeRank
+ #    define SWIG_TypeRank             unsigned long
+ #  endif
+ #  ifndef SWIG_MAXCASTRANK            /* Default cast allowed */
+ #    define SWIG_MAXCASTRANK          (2)
+ #  endif
+ #  define SWIG_CASTRANKMASK          ((SWIG_CASTRANKLIMIT) -1)
+ #  define SWIG_CastRank(r)           (r & SWIG_CASTRANKMASK)
+ SWIGINTERNINLINE int SWIG_AddCast(int r) { 
+   return SWIG_IsOK(r) ? ((SWIG_CastRank(r) < SWIG_MAXCASTRANK) ? (r + 1) : SWIG_ERROR) : r;
+ }
+ SWIGINTERNINLINE int SWIG_CheckState(int r) { 
+   return SWIG_IsOK(r) ? SWIG_CastRank(r) + 1 : 0; 
+ }
+ #else /* no cast-rank mode */
+ #  define SWIG_AddCast
+ #  define SWIG_CheckState(r) (SWIG_IsOK(r) ? 1 : 0)
+ #endif
+ 
+ 
+ 
+ 
+ #include <string.h>
+ 
+ #ifdef __cplusplus
+ extern "C" {
+ #endif
+ 
+ typedef void *(*swig_converter_func)(void *, int *);
+ typedef struct swig_type_info *(*swig_dycast_func)(void **);
+ 
+ /* Structure to store information on one type */
+ typedef struct swig_type_info {
+   const char             *name;			/* mangled name of this type */
+   const char             *str;			/* human readable name of this type */
+   swig_dycast_func        dcast;		/* dynamic cast function down a hierarchy */
+   struct swig_cast_info  *cast;			/* linked list of types that can cast into this type */
+   void                   *clientdata;		/* language specific type data */
+   int                    owndata;		/* flag if the structure owns the clientdata */
+ } swig_type_info;
+ 
+ /* Structure to store a type and conversion function used for casting */
+ typedef struct swig_cast_info {
+   swig_type_info         *type;			/* pointer to type that is equivalent to this type */
+   swig_converter_func     converter;		/* function to cast the void pointers */
+   struct swig_cast_info  *next;			/* pointer to next cast in linked list */
+   struct swig_cast_info  *prev;			/* pointer to the previous cast */
+ } swig_cast_info;
+ 
+ /* Structure used to store module information
+  * Each module generates one structure like this, and the runtime collects
+  * all of these structures and stores them in a circularly linked list.*/
+ typedef struct swig_module_info {
+   swig_type_info         **types;		/* Array of pointers to swig_type_info structures that are in this module */
+   size_t                 size;		        /* Number of types in this module */
+   struct swig_module_info *next;		/* Pointer to next element in circularly linked list */
+   swig_type_info         **type_initial;	/* Array of initially generated type structures */
+   swig_cast_info         **cast_initial;	/* Array of initially generated casting structures */
+   void                    *clientdata;		/* Language specific module data */
+ } swig_module_info;
+ 
+ /* 
+   Compare two type names skipping the space characters, therefore
+   "char*" == "char *" and "Class<int>" == "Class<int >", etc.
+ 
+   Return 0 when the two name types are equivalent, as in
+   strncmp, but skipping ' '.
+ */
+ SWIGRUNTIME int
+ SWIG_TypeNameComp(const char *f1, const char *l1,
+ 		  const char *f2, const char *l2) {
+   for (;(f1 != l1) && (f2 != l2); ++f1, ++f2) {
+     while ((*f1 == ' ') && (f1 != l1)) ++f1;
+     while ((*f2 == ' ') && (f2 != l2)) ++f2;
+     if (*f1 != *f2) return (*f1 > *f2) ? 1 : -1;
+   }
+   return (int)((l1 - f1) - (l2 - f2));
+ }
+ 
+ /*
+   Check type equivalence in a name list like <name1>|<name2>|...
+   Return 0 if not equal, 1 if equal
+ */
+ SWIGRUNTIME int
+ SWIG_TypeEquiv(const char *nb, const char *tb) {
+   int equiv = 0;
+   const char* te = tb + strlen(tb);
+   const char* ne = nb;
+   while (!equiv && *ne) {
+     for (nb = ne; *ne; ++ne) {
+       if (*ne == '|') break;
+     }
+     equiv = (SWIG_TypeNameComp(nb, ne, tb, te) == 0) ? 1 : 0;
+     if (*ne) ++ne;
+   }
+   return equiv;
+ }
+ 
+ /*
+   Check type equivalence in a name list like <name1>|<name2>|...
+   Return 0 if equal, -1 if nb < tb, 1 if nb > tb
+ */
+ SWIGRUNTIME int
+ SWIG_TypeCompare(const char *nb, const char *tb) {
+   int equiv = 0;
+   const char* te = tb + strlen(tb);
+   const char* ne = nb;
+   while (!equiv && *ne) {
+     for (nb = ne; *ne; ++ne) {
+       if (*ne == '|') break;
+     }
+     equiv = (SWIG_TypeNameComp(nb, ne, tb, te) == 0) ? 1 : 0;
+     if (*ne) ++ne;
+   }
+   return equiv;
+ }
+ 
+ 
+ /* think of this as a c++ template<> or a scheme macro */
+ #define SWIG_TypeCheck_Template(comparison, ty)         \
+   if (ty) {                                             \
+     swig_cast_info *iter = ty->cast;                    \
+     while (iter) {                                      \
+       if (comparison) {                                 \
+         if (iter == ty->cast) return iter;              \
+         /* Move iter to the top of the linked list */   \
+         iter->prev->next = iter->next;                  \
+         if (iter->next)                                 \
+           iter->next->prev = iter->prev;                \
+         iter->next = ty->cast;                          \
+         iter->prev = 0;                                 \
+         if (ty->cast) ty->cast->prev = iter;            \
+         ty->cast = iter;                                \
+         return iter;                                    \
+       }                                                 \
+       iter = iter->next;                                \
+     }                                                   \
+   }                                                     \
+   return 0
+ 
+ /*
+   Check the typename
+ */
+ SWIGRUNTIME swig_cast_info *
+ SWIG_TypeCheck(const char *c, swig_type_info *ty) {
+   SWIG_TypeCheck_Template(strcmp(iter->type->name, c) == 0, ty);
+ }
+ 
+ /* Same as previous function, except strcmp is replaced with a pointer comparison */
+ SWIGRUNTIME swig_cast_info *
+ SWIG_TypeCheckStruct(swig_type_info *from, swig_type_info *into) {
+   SWIG_TypeCheck_Template(iter->type == from, into);
+ }
+ 
+ /*
+   Cast a pointer up an inheritance hierarchy
+ */
+ SWIGRUNTIMEINLINE void *
+ SWIG_TypeCast(swig_cast_info *ty, void *ptr, int *newmemory) {
+   return ((!ty) || (!ty->converter)) ? ptr : (*ty->converter)(ptr, newmemory);
+ }
+ 
+ /* 
+    Dynamic pointer casting. Down an inheritance hierarchy
+ */
+ SWIGRUNTIME swig_type_info *
+ SWIG_TypeDynamicCast(swig_type_info *ty, void **ptr) {
+   swig_type_info *lastty = ty;
+   if (!ty || !ty->dcast) return ty;
+   while (ty && (ty->dcast)) {
+     ty = (*ty->dcast)(ptr);
+     if (ty) lastty = ty;
+   }
+   return lastty;
+ }
+ 
+ /*
+   Return the name associated with this type
+ */
+ SWIGRUNTIMEINLINE const char *
+ SWIG_TypeName(const swig_type_info *ty) {
+   return ty->name;
+ }
+ 
+ /*
+   Return the pretty name associated with this type,
+   that is an unmangled type name in a form presentable to the user.
+ */
+ SWIGRUNTIME const char *
+ SWIG_TypePrettyName(const swig_type_info *type) {
+   /* The "str" field contains the equivalent pretty names of the
+      type, separated by vertical-bar characters.  We choose
+      to print the last name, as it is often (?) the most
+      specific. */
+   if (!type) return NULL;
+   if (type->str != NULL) {
+     const char *last_name = type->str;
+     const char *s;
+     for (s = type->str; *s; s++)
+       if (*s == '|') last_name = s+1;
+     return last_name;
+   }
+   else
+     return type->name;
+ }
+ 
+ /* 
+    Set the clientdata field for a type
+ */
+ SWIGRUNTIME void
+ SWIG_TypeClientData(swig_type_info *ti, void *clientdata) {
+   swig_cast_info *cast = ti->cast;
+   /* if (ti->clientdata == clientdata) return; */
+   ti->clientdata = clientdata;
+   
+   while (cast) {
+     if (!cast->converter) {
+       swig_type_info *tc = cast->type;
+       if (!tc->clientdata) {
+ 	SWIG_TypeClientData(tc, clientdata);
+       }
+     }    
+     cast = cast->next;
+   }
+ }
+ SWIGRUNTIME void
+ SWIG_TypeNewClientData(swig_type_info *ti, void *clientdata) {
+   SWIG_TypeClientData(ti, clientdata);
+   ti->owndata = 1;
+ }
+   
+ /*
+   Search for a swig_type_info structure only by mangled name
+   Search is a O(log #types)
+   
+   We start searching at module start, and finish searching when start == end.  
+   Note: if start == end at the beginning of the function, we go all the way around
+   the circular list.
+ */
+ SWIGRUNTIME swig_type_info *
+ SWIG_MangledTypeQueryModule(swig_module_info *start, 
+                             swig_module_info *end, 
+ 		            const char *name) {
+   swig_module_info *iter = start;
+   do {
+     if (iter->size) {
+       register size_t l = 0;
+       register size_t r = iter->size - 1;
+       do {
+ 	/* since l+r >= 0, we can (>> 1) instead (/ 2) */
+ 	register size_t i = (l + r) >> 1; 
+ 	const char *iname = iter->types[i]->name;
+ 	if (iname) {
+ 	  register int compare = strcmp(name, iname);
+ 	  if (compare == 0) {	    
+ 	    return iter->types[i];
+ 	  } else if (compare < 0) {
+ 	    if (i) {
+ 	      r = i - 1;
+ 	    } else {
+ 	      break;
+ 	    }
+ 	  } else if (compare > 0) {
+ 	    l = i + 1;
+ 	  }
+ 	} else {
+ 	  break; /* should never happen */
+ 	}
+       } while (l <= r);
+     }
+     iter = iter->next;
+   } while (iter != end);
+   return 0;
+ }
+ 
+ /*
+   Search for a swig_type_info structure for either a mangled name or a human readable name.
+   It first searches the mangled names of the types, which is a O(log #types)
+   If a type is not found it then searches the human readable names, which is O(#types).
+   
+   We start searching at module start, and finish searching when start == end.  
+   Note: if start == end at the beginning of the function, we go all the way around
+   the circular list.
+ */
+ SWIGRUNTIME swig_type_info *
+ SWIG_TypeQueryModule(swig_module_info *start, 
+                      swig_module_info *end, 
+ 		     const char *name) {
+   /* STEP 1: Search the name field using binary search */
+   swig_type_info *ret = SWIG_MangledTypeQueryModule(start, end, name);
+   if (ret) {
+     return ret;
+   } else {
+     /* STEP 2: If the type hasn't been found, do a complete search
+        of the str field (the human readable name) */
+     swig_module_info *iter = start;
+     do {
+       register size_t i = 0;
+       for (; i < iter->size; ++i) {
+ 	if (iter->types[i]->str && (SWIG_TypeEquiv(iter->types[i]->str, name)))
+ 	  return iter->types[i];
+       }
+       iter = iter->next;
+     } while (iter != end);
+   }
+   
+   /* neither found a match */
+   return 0;
+ }
+ 
+ /* 
+    Pack binary data into a string
+ */
+ SWIGRUNTIME char *
+ SWIG_PackData(char *c, void *ptr, size_t sz) {
+   static const char hex[17] = "0123456789abcdef";
+   register const unsigned char *u = (unsigned char *) ptr;
+   register const unsigned char *eu =  u + sz;
+   for (; u != eu; ++u) {
+     register unsigned char uu = *u;
+     *(c++) = hex[(uu & 0xf0) >> 4];
+     *(c++) = hex[uu & 0xf];
+   }
+   return c;
+ }
+ 
+ /* 
+    Unpack binary data from a string
+ */
+ SWIGRUNTIME const char *
+ SWIG_UnpackData(const char *c, void *ptr, size_t sz) {
+   register unsigned char *u = (unsigned char *) ptr;
+   register const unsigned char *eu = u + sz;
+   for (; u != eu; ++u) {
+     register char d = *(c++);
+     register unsigned char uu;
+     if ((d >= '0') && (d <= '9'))
+       uu = ((d - '0') << 4);
+     else if ((d >= 'a') && (d <= 'f'))
+       uu = ((d - ('a'-10)) << 4);
+     else 
+       return (char *) 0;
+     d = *(c++);
+     if ((d >= '0') && (d <= '9'))
+       uu |= (d - '0');
+     else if ((d >= 'a') && (d <= 'f'))
+       uu |= (d - ('a'-10));
+     else 
+       return (char *) 0;
+     *u = uu;
+   }
+   return c;
+ }
+ 
+ /* 
+    Pack 'void *' into a string buffer.
+ */
+ SWIGRUNTIME char *
+ SWIG_PackVoidPtr(char *buff, void *ptr, const char *name, size_t bsz) {
+   char *r = buff;
+   if ((2*sizeof(void *) + 2) > bsz) return 0;
+   *(r++) = '_';
+   r = SWIG_PackData(r,&ptr,sizeof(void *));
+   if (strlen(name) + 1 > (bsz - (r - buff))) return 0;
+   strcpy(r,name);
+   return buff;
+ }
+ 
+ SWIGRUNTIME const char *
+ SWIG_UnpackVoidPtr(const char *c, void **ptr, const char *name) {
+   if (*c != '_') {
+     if (strcmp(c,"NULL") == 0) {
+       *ptr = (void *) 0;
+       return name;
+     } else {
+       return 0;
+     }
+   }
+   return SWIG_UnpackData(++c,ptr,sizeof(void *));
+ }
+ 
+ SWIGRUNTIME char *
+ SWIG_PackDataName(char *buff, void *ptr, size_t sz, const char *name, size_t bsz) {
+   char *r = buff;
+   size_t lname = (name ? strlen(name) : 0);
+   if ((2*sz + 2 + lname) > bsz) return 0;
+   *(r++) = '_';
+   r = SWIG_PackData(r,ptr,sz);
+   if (lname) {
+     strncpy(r,name,lname+1);
+   } else {
+     *r = 0;
+   }
+   return buff;
+ }
+ 
+ SWIGRUNTIME const char *
+ SWIG_UnpackDataName(const char *c, void *ptr, size_t sz, const char *name) {
+   if (*c != '_') {
+     if (strcmp(c,"NULL") == 0) {
+       memset(ptr,0,sz);
+       return name;
+     } else {
+       return 0;
+     }
+   }
+   return SWIG_UnpackData(++c,ptr,sz);
+ }
+ 
+ #ifdef __cplusplus
+ }
+ #endif
+ 
+ /*  Errors in SWIG */
+ #define  SWIG_UnknownError    	   -1 
+ #define  SWIG_IOError        	   -2 
+ #define  SWIG_RuntimeError   	   -3 
+ #define  SWIG_IndexError     	   -4 
+ #define  SWIG_TypeError      	   -5 
+ #define  SWIG_DivisionByZero 	   -6 
+ #define  SWIG_OverflowError  	   -7 
+ #define  SWIG_SyntaxError    	   -8 
+ #define  SWIG_ValueError     	   -9 
+ #define  SWIG_SystemError    	   -10
+ #define  SWIG_AttributeError 	   -11
+ #define  SWIG_MemoryError    	   -12 
+ #define  SWIG_NullReferenceError   -13
+ 
+ 
+ 
+ /* -----------------------------------------------------------------------------
+  * error manipulation
+  * ----------------------------------------------------------------------------- */
+ 
+ SWIGINTERN const char*
+ SWIG_Tcl_ErrorType(int code) {
+   const char* type = 0;
+   switch(code) {
+   case SWIG_MemoryError:
+     type = "MemoryError";
+     break;
+   case SWIG_IOError:
+     type = "IOError";
+     break;
+   case SWIG_RuntimeError:
+     type = "RuntimeError";
+     break;
+   case SWIG_IndexError:
+     type = "IndexError";
+     break;
+   case SWIG_TypeError:
+     type = "TypeError";
+     break;
+   case SWIG_DivisionByZero:
+     type = "ZeroDivisionError";
+     break;
+   case SWIG_OverflowError:
+     type = "OverflowError";
+     break;
+   case SWIG_SyntaxError:
+     type = "SyntaxError";
+     break;
+   case SWIG_ValueError:
+     type = "ValueError";
+     break;
+   case SWIG_SystemError:
+     type = "SystemError";
+     break;
+   case SWIG_AttributeError:
+     type = "AttributeError";
+     break;
+   default:
+     type = "RuntimeError";
+   }
+   return type;
+ }
+ 
+ 
+ SWIGINTERN void
+ SWIG_Tcl_SetErrorObj(Tcl_Interp *interp, const char *ctype, Tcl_Obj *obj)
+ {
+   Tcl_ResetResult(interp);
+   Tcl_SetObjResult(interp, obj);
+   Tcl_SetErrorCode(interp, "SWIG", ctype, NULL);
+ }
+ 
+ SWIGINTERN void
+ SWIG_Tcl_SetErrorMsg(Tcl_Interp *interp, const char *ctype, const char *mesg)
+ {
+   Tcl_ResetResult(interp);
+   Tcl_SetErrorCode(interp, "SWIG", ctype, NULL);
+   Tcl_AppendResult(interp, ctype, " ", mesg, NULL);
+   /*
+   Tcl_AddErrorInfo(interp, ctype);
+   Tcl_AddErrorInfo(interp, " ");
+   Tcl_AddErrorInfo(interp, mesg);
+   */
+ }
+ 
+ SWIGINTERNINLINE void
+ SWIG_Tcl_AddErrorMsg(Tcl_Interp *interp, const char* mesg)
+ {
+   Tcl_AddErrorInfo(interp, mesg);
+ }
+ 
+ 
+ 
+ /* -----------------------------------------------------------------------------
+  * SWIG API. Portion that goes into the runtime
+  * ----------------------------------------------------------------------------- */
+ #ifdef __cplusplus
+ extern "C" {
+ #endif
+ 
+ /* -----------------------------------------------------------------------------
+  * Constant declarations
+  * ----------------------------------------------------------------------------- */
+ 
+ /* Constant Types */
+ #define SWIG_TCL_POINTER 4
+ #define SWIG_TCL_BINARY  5
+ 
+ /* Constant information structure */
+ typedef struct swig_const_info {
+     int type;
+     char *name;
+     long lvalue;
+     double dvalue;
+     void   *pvalue;
+     swig_type_info **ptype;
+ } swig_const_info;
+ 
+ typedef int   (*swig_wrapper)(ClientData, Tcl_Interp *, int, Tcl_Obj *CONST []);
+ typedef int   (*swig_wrapper_func)(ClientData, Tcl_Interp *, int, Tcl_Obj *CONST []);
+ typedef char *(*swig_variable_func)(ClientData, Tcl_Interp *, char *, char *, int);
+ typedef void  (*swig_delete_func)(ClientData);
+ 
+ typedef struct swig_method {
+   const char     *name;
+   swig_wrapper   method;
+ } swig_method;
+ 
+ typedef struct swig_attribute {
+   const char     *name;
+   swig_wrapper   getmethod;
+   swig_wrapper   setmethod;
+ } swig_attribute;
+ 
+ typedef struct swig_class {
+   const char         *name;
+   swig_type_info   **type;
+   swig_wrapper       constructor;
+   void              (*destructor)(void *);
+   swig_method        *methods;
+   swig_attribute     *attributes;
+   struct swig_class **bases;
+   const char              **base_names;
+   swig_module_info   *module;
+ } swig_class;
+ 
+ typedef struct swig_instance {
+   Tcl_Obj       *thisptr;
+   void          *thisvalue;
+   swig_class   *classptr;
+   int            destroy;
+   Tcl_Command    cmdtok;
+ } swig_instance;
+ 
+ /* Structure for command table */
+ typedef struct {
+   const char *name;
+   int       (*wrapper)(ClientData, Tcl_Interp *, int, Tcl_Obj *CONST []);
+   ClientData  clientdata;
+ } swig_command_info;
+ 
+ /* Structure for variable linking table */
+ typedef struct {
+   const char *name;
+   void *addr;
+   char * (*get)(ClientData, Tcl_Interp *, char *, char *, int);
+   char * (*set)(ClientData, Tcl_Interp *, char *, char *, int);
+ } swig_var_info;
+ 
+ 
+ /* -----------------------------------------------------------------------------*
+  *  Install a constant object 
+  * -----------------------------------------------------------------------------*/
+ 
+ static Tcl_HashTable   swigconstTable;
+ static int             swigconstTableinit = 0;
+ 
+ SWIGINTERN void
+ SWIG_Tcl_SetConstantObj(Tcl_Interp *interp, const char* name, Tcl_Obj *obj) {
+   int newobj;
+   Tcl_ObjSetVar2(interp,Tcl_NewStringObj(name,-1), NULL, obj, TCL_GLOBAL_ONLY);
+   Tcl_SetHashValue(Tcl_CreateHashEntry(&swigconstTable, name, &newobj), (ClientData) obj);
+ }
+ 
+ SWIGINTERN Tcl_Obj *
+ SWIG_Tcl_GetConstantObj(const char *key) {
+   Tcl_HashEntry *entryPtr;
+   if (!swigconstTableinit) return 0;
+   entryPtr = Tcl_FindHashEntry(&swigconstTable, key);
+   if (entryPtr) {
+     return (Tcl_Obj *) Tcl_GetHashValue(entryPtr);
+   }
+   return 0;
+ }
+ 
+ #ifdef __cplusplus
+ }
+ #endif
+ 
+ 
+ 
+ /* -----------------------------------------------------------------------------
+  * See the LICENSE file for information on copyright, usage and redistribution
+  * of SWIG, and the README file for authors - http://www.swig.org/release.html.
+  *
+  * tclrun.swg
+  *
+  * This file contains the runtime support for Tcl modules and includes
+  * code for managing global variables and pointer type checking.
+  * ----------------------------------------------------------------------------- */
+ 
+ /* Common SWIG API */
+ 
+ /* for raw pointers */
+ #define SWIG_ConvertPtr(oc, ptr, ty, flags)             SWIG_Tcl_ConvertPtr(interp, oc, ptr, ty, flags)
+ #define SWIG_NewPointerObj(ptr, type, flags)            SWIG_Tcl_NewPointerObj(ptr, type, flags)
+ 
+ /* for raw packed data */
+ #define SWIG_ConvertPacked(obj, ptr, sz, ty)            SWIG_Tcl_ConvertPacked(interp, obj, ptr, sz, ty)
+ #define SWIG_NewPackedObj(ptr, sz, type)                SWIG_Tcl_NewPackedObj(ptr, sz, type)
+ 
+ /* for class or struct pointers */
+ #define SWIG_ConvertInstance(obj, pptr, type, flags)    SWIG_Tcl_ConvertPtr(interp, obj, pptr, type, flags)
+ #define SWIG_NewInstanceObj(thisvalue, type, flags)     SWIG_Tcl_NewInstanceObj(interp, thisvalue, type, flags)
+ 
+ /* for C or C++ function pointers */
+ #define SWIG_ConvertFunctionPtr(obj, pptr, type)        SWIG_Tcl_ConvertPtr(interp, obj, pptr, type, 0)
+ #define SWIG_NewFunctionPtrObj(ptr, type)               SWIG_Tcl_NewPointerObj(ptr, type, 0)
+ 
+ /* for C++ member pointers, ie, member methods */
+ #define SWIG_ConvertMember(obj, ptr, sz, ty)            SWIG_Tcl_ConvertPacked(interp,obj, ptr, sz, ty)
+ #define SWIG_NewMemberObj(ptr, sz, type)                SWIG_Tcl_NewPackedObj(ptr, sz, type)
+ 
+ 
+ /* Runtime API */
+ 
+ #define SWIG_GetModule(clientdata)                      SWIG_Tcl_GetModule((Tcl_Interp *) (clientdata))	     
+ #define SWIG_SetModule(clientdata, pointer)          	SWIG_Tcl_SetModule((Tcl_Interp *) (clientdata), pointer)
+ 
+ 
+ /* Error manipulation */
+ 
+ #define SWIG_ErrorType(code)                            SWIG_Tcl_ErrorType(code)                                      
+ #define SWIG_Error(code, msg)            		SWIG_Tcl_SetErrorMsg(interp, SWIG_Tcl_ErrorType(code), msg)
+ #define SWIG_fail                        		goto fail						    
+ 
+ 
+ /* Tcl-specific SWIG API */
+ 
+ #define SWIG_Acquire(ptr)                               SWIG_Tcl_Acquire(ptr)                                     
+ #define SWIG_MethodCommand                           	SWIG_Tcl_MethodCommand				       
+ #define SWIG_Disown(ptr)                             	SWIG_Tcl_Disown(ptr)				       
+ #define SWIG_ConvertPtrFromString(c, ptr, ty, flags) 	SWIG_Tcl_ConvertPtrFromString(interp, c, ptr, ty, flags)  
+ #define SWIG_MakePtr(c, ptr, ty, flags)              	SWIG_Tcl_MakePtr(c, ptr, ty, flags)		       
+ #define SWIG_PointerTypeFromString(c)                	SWIG_Tcl_PointerTypeFromString(c)			       
+ #define SWIG_GetArgs                                 	SWIG_Tcl_GetArgs					       
+ #define SWIG_GetConstantObj(key)                     	SWIG_Tcl_GetConstantObj(key)			       
+ #define SWIG_ObjectConstructor                       	SWIG_Tcl_ObjectConstructor				       
+ #define SWIG_Thisown(ptr)                            	SWIG_Tcl_Thisown(ptr)				       
+ #define SWIG_ObjectDelete                            	SWIG_Tcl_ObjectDelete				       
+ 
+ 
+ #define SWIG_TCL_DECL_ARGS_2(arg1, arg2)                (Tcl_Interp *interp SWIGUNUSED, arg1, arg2)
+ #define SWIG_TCL_CALL_ARGS_2(arg1, arg2)                (interp, arg1, arg2)
+ /* -----------------------------------------------------------------------------
+  * pointers/data manipulation
+  * ----------------------------------------------------------------------------- */
+ 
+ /* For backward compatibility only */
+ #define SWIG_POINTER_EXCEPTION  0
+ #define SWIG_GetConstant        SWIG_GetConstantObj
+ #define SWIG_Tcl_GetConstant    SWIG_Tcl_GetConstantObj
+ 
+ #include "assert.h"
+ 
+ #ifdef __cplusplus
+ extern "C" {
+ #if 0
+ } /* cc-mode */
+ #endif
+ #endif
+ 
+ /* Object support */
+ 
+ SWIGRUNTIME Tcl_HashTable*
+ SWIG_Tcl_ObjectTable(void) {
+   static Tcl_HashTable  swigobjectTable;
+   static int            swigobjectTableinit = 0;
+   if (!swigobjectTableinit) {
+     Tcl_InitHashTable(&swigobjectTable, TCL_ONE_WORD_KEYS);
+     swigobjectTableinit = 1;
+   }
+   return &swigobjectTable;
+ }
+ 
+ /* Acquire ownership of a pointer */
+ SWIGRUNTIME void
+ SWIG_Tcl_Acquire(void *ptr) {
+   int newobj;
+   Tcl_CreateHashEntry(SWIG_Tcl_ObjectTable(), (char *) ptr, &newobj);
+ }
+ 
+ SWIGRUNTIME int
+ SWIG_Tcl_Thisown(void *ptr) {
+   if (Tcl_FindHashEntry(SWIG_Tcl_ObjectTable(), (char *) ptr)) {
+     return 1;
+   }
+   return 0;
+ }
+ 
+ /* Disown a pointer.  Returns 1 if we owned it to begin with */
+ SWIGRUNTIME int
+ SWIG_Tcl_Disown(void *ptr) {
+   Tcl_HashEntry *entryPtr = Tcl_FindHashEntry(SWIG_Tcl_ObjectTable(), (char *) ptr);
+   if (entryPtr) {
+     Tcl_DeleteHashEntry(entryPtr);
+     return 1;
+   }
+   return 0;
+ }
+ 
+ /* Convert a pointer value */
+ SWIGRUNTIME int
+ SWIG_Tcl_ConvertPtrFromString(Tcl_Interp *interp, const char *c, void **ptr, swig_type_info *ty, int flags) {
+   swig_cast_info *tc;
+   /* Pointer values must start with leading underscore */
+   while (*c != '_') {
+     *ptr = (void *) 0;
+     if (strcmp(c,"NULL") == 0) return SWIG_OK;
+ 
+     /* Empty string: not a pointer */
+     if (*c == 0) return SWIG_ERROR; 
+ 
+     /* Hmmm. It could be an object name. */
+ 
+     /* Check if this is a command at all. Prevents <c> cget -this         */
+     /* from being called when c is not a command, firing the unknown proc */
+     if (Tcl_VarEval(interp,"info commands ", c, (char *) NULL) == TCL_OK) {
+       Tcl_Obj *result = Tcl_GetObjResult(interp);
+       if (*(Tcl_GetStringFromObj(result, NULL)) == 0) {
+         /* It's not a command, so it can't be a pointer */
+         Tcl_ResetResult(interp);
+         return SWIG_ERROR;
+       }
+     } else {
+       /* This will only fail if the argument is multiple words. */
+       /* Multiple words are also not commands.                  */
+       Tcl_ResetResult(interp);
+       return SWIG_ERROR;
+     }
+ 
+     /* Check if this is really a SWIG pointer */
+     if (Tcl_VarEval(interp,c," cget -this", (char *) NULL) != TCL_OK) {
+       Tcl_ResetResult(interp);
+       return SWIG_ERROR;
+     }
+ 
+     c = Tcl_GetStringFromObj(Tcl_GetObjResult(interp), NULL);
+   }
+ 
+   c++;
+   c = SWIG_UnpackData(c,ptr,sizeof(void *));
+   if (ty) {
+     tc = c ? SWIG_TypeCheck(c,ty) : 0;
+     if (!tc) {
+       return SWIG_ERROR;
+     }
+     if (flags & SWIG_POINTER_DISOWN) {
+       SWIG_Disown((void *) *ptr);
+     }
+     {
+       int newmemory = 0;
+       *ptr = SWIG_TypeCast(tc,(void *) *ptr,&newmemory);
+       assert(!newmemory); /* newmemory handling not yet implemented */
+     }
+   }
+   return SWIG_OK;
+ }
+ 
+ /* Convert a pointer value */
+ SWIGRUNTIMEINLINE int
+ SWIG_Tcl_ConvertPtr(Tcl_Interp *interp, Tcl_Obj *oc, void **ptr, swig_type_info *ty, int flags) {
+   return SWIG_Tcl_ConvertPtrFromString(interp, Tcl_GetStringFromObj(oc,NULL), ptr, ty, flags);
+ }
+ 
+ /* Convert a pointer value */
+ SWIGRUNTIME char *
+ SWIG_Tcl_PointerTypeFromString(char *c) {
+   char d;
+   /* Pointer values must start with leading underscore. NULL has no type */
+   if (*c != '_') {
+     return 0;
+   }
+   c++;
+   /* Extract hex value from pointer */
+   while ((d = *c)) {
+     if (!(((d >= '0') && (d <= '9')) || ((d >= 'a') && (d <= 'f')))) break;
+     c++;
+   }
+   return c;
+ }
+ 
+ /* Convert a packed value value */
+ SWIGRUNTIME int
+ SWIG_Tcl_ConvertPacked(Tcl_Interp *SWIGUNUSEDPARM(interp) , Tcl_Obj *obj, void *ptr, int sz, swig_type_info *ty) {
+   swig_cast_info *tc;
+   const char  *c;
+ 
+   if (!obj) goto type_error;
+   c = Tcl_GetStringFromObj(obj,NULL);
+   /* Pointer values must start with leading underscore */
+   if (*c != '_') goto type_error;
+   c++;
+   c = SWIG_UnpackData(c,ptr,sz);
+   if (ty) {
+     tc = SWIG_TypeCheck(c,ty);
+     if (!tc) goto type_error;
+   }
+   return SWIG_OK;
+ 
+  type_error:
+ 
+   return SWIG_ERROR;
+ }
+ 
+ 
+ /* Take a pointer and convert it to a string */
+ SWIGRUNTIME void
+ SWIG_Tcl_MakePtr(char *c, void *ptr, swig_type_info *ty, int flags) {
+   if (ptr) {
+     *(c++) = '_';
+     c = SWIG_PackData(c,&ptr,sizeof(void *));
+     strcpy(c,ty->name);
+   } else {
+     strcpy(c,(char *)"NULL");
+   }
+   flags = 0;
+ }
+ 
+ /* Create a new pointer object */
+ SWIGRUNTIMEINLINE Tcl_Obj *
+ SWIG_Tcl_NewPointerObj(void *ptr, swig_type_info *type, int flags) {
+   Tcl_Obj *robj;
+   char result[SWIG_BUFFER_SIZE];
+   SWIG_MakePtr(result,ptr,type,flags);
+   robj = Tcl_NewStringObj(result,-1);
+   return robj;
+ }
+ 
+ SWIGRUNTIME Tcl_Obj *
+ SWIG_Tcl_NewPackedObj(void *ptr, int sz, swig_type_info *type) {
+   char result[1024];
+   char *r = result;
+   if ((2*sz + 1 + strlen(type->name)) > 1000) return 0;
+   *(r++) = '_';
+   r = SWIG_PackData(r,ptr,sz);
+   strcpy(r,type->name);
+   return Tcl_NewStringObj(result,-1);
+ }
+ 
+ /* -----------------------------------------------------------------------------*
+  *  Get type list 
+  * -----------------------------------------------------------------------------*/
+ 
+ SWIGRUNTIME swig_module_info * 
+ SWIG_Tcl_GetModule(Tcl_Interp *interp) {
+   const char *data;
+   swig_module_info *ret = 0;
+   
+   /* first check if pointer already created */
+   data = Tcl_GetVar(interp, (char *)"swig_runtime_data_type_pointer" SWIG_RUNTIME_VERSION SWIG_TYPE_TABLE_NAME, TCL_GLOBAL_ONLY);
+   if (data) {
+     SWIG_UnpackData(data, &ret, sizeof(swig_type_info **));
+   }
+ 
+   return ret;
+ }
+ 
+ SWIGRUNTIME void
+ SWIG_Tcl_SetModule(Tcl_Interp *interp, swig_module_info *module) {
+   char buf[SWIG_BUFFER_SIZE];
+   char *data;
+ 
+   /* create a new pointer */
+   data = SWIG_PackData(buf, &module, sizeof(swig_type_info **));
+   *data = 0;
+   Tcl_SetVar(interp, (char *)"swig_runtime_data_type_pointer" SWIG_RUNTIME_VERSION SWIG_TYPE_TABLE_NAME, buf, 0);
+ }
+ 
+ /* -----------------------------------------------------------------------------*
+  *  Object auxiliars
+  * -----------------------------------------------------------------------------*/
+ 
+ 
+ SWIGRUNTIME void
+ SWIG_Tcl_ObjectDelete(ClientData clientData) {
+   swig_instance *si = (swig_instance *) clientData;
+   if ((si) && (si->destroy) && (SWIG_Disown(si->thisvalue))) {
+     if (si->classptr->destructor) {
+       (si->classptr->destructor)(si->thisvalue);
+     }
+   }
+   Tcl_DecrRefCount(si->thisptr);
+   free(si);
+ }
+ 
+ /* Function to invoke object methods given an instance */
+ SWIGRUNTIME int
+ SWIG_Tcl_MethodCommand(ClientData clientData, Tcl_Interp *interp, int objc, Tcl_Obj *CONST _objv[]) {
+   char *method,   *attrname;
+   swig_instance   *inst = (swig_instance *) clientData;
+   swig_method     *meth;
+   swig_attribute  *attr;
+   Tcl_Obj         *oldarg;
+   Tcl_Obj         **objv;
+   int              rcode;
+   swig_class      *cls;
+   swig_class      *cls_stack[64];
+   int              cls_stack_bi[64];
+   int              cls_stack_top = 0;
+   int              numconf = 2;
+   int              bi;
+ 
+   objv = (Tcl_Obj **) _objv;
+   if (objc < 2) {
+     Tcl_SetResult(interp, (char *) "wrong # args.", TCL_STATIC);
+     return TCL_ERROR;
+   }
+   method = Tcl_GetStringFromObj(objv[1],NULL);
+   if (strcmp(method,"-acquire") == 0) {
+     inst->destroy = 1;
+     SWIG_Acquire(inst->thisvalue);
+     return TCL_OK;
+   }
+   if (strcmp(method,"-disown") == 0) {
+     if (inst->destroy) {
+       SWIG_Disown(inst->thisvalue);
+     }
+     inst->destroy = 0;
+     return TCL_OK;
+   }
+   if (strcmp(method,"-delete") == 0) {
+     Tcl_DeleteCommandFromToken(interp,inst->cmdtok);
+     return TCL_OK;
+   }
+   cls_stack[cls_stack_top] = inst->classptr;
+   cls_stack_bi[cls_stack_top] = -1;
+   cls = inst->classptr;
+   while (1) {
+     bi = cls_stack_bi[cls_stack_top];
+     cls = cls_stack[cls_stack_top];
+     if (bi != -1) {
+       if (!cls->bases[bi] && cls->base_names[bi]) {
+         /* lookup and cache the base class */
+ 	swig_type_info *info = SWIG_TypeQueryModule(cls->module, cls->module, cls->base_names[bi]);
+ 	if (info) cls->bases[bi] = (swig_class *) info->clientdata;
+       }
+       cls = cls->bases[bi];
+       if (cls) {
+         cls_stack_bi[cls_stack_top]++;
+         cls_stack_top++;
+         cls_stack[cls_stack_top] = cls;
+         cls_stack_bi[cls_stack_top] = -1;
+         continue;
+       }
+     }
+     if (!cls) {
+       cls_stack_top--;
+       if (cls_stack_top < 0) break;
+       else continue;
+     }
+     cls_stack_bi[cls_stack_top]++;
+ 
+     meth = cls->methods;
+     /* Check for methods */
+     while (meth && meth->name) {
+       if (strcmp(meth->name,method) == 0) {
+         oldarg = objv[1];
+         objv[1] = inst->thisptr;
+         Tcl_IncrRefCount(inst->thisptr);
+         rcode = (*meth->method)(clientData,interp,objc,objv);
+         objv[1] = oldarg;
+         Tcl_DecrRefCount(inst->thisptr);
+         return rcode;
+       }
+       meth++;
+     }
+     /* Check class methods for a match */
+     if (strcmp(method,"cget") == 0) {
+       if (objc < 3) {
+         Tcl_SetResult(interp, (char *) "wrong # args.", TCL_STATIC);
+         return TCL_ERROR;
+       }
+       attrname = Tcl_GetStringFromObj(objv[2],NULL);
+       attr = cls->attributes;
+       while (attr && attr->name) {
+         if ((strcmp(attr->name, attrname) == 0) && (attr->getmethod)) {
+           oldarg = objv[1];
+           objv[1] = inst->thisptr;
+           Tcl_IncrRefCount(inst->thisptr);
+           rcode = (*attr->getmethod)(clientData,interp,2, objv);
+           objv[1] = oldarg;
+           Tcl_DecrRefCount(inst->thisptr);
+           return rcode;
+         }
+         attr++;
+       }
+       if (strcmp(attrname, "-this") == 0) {
+         Tcl_SetObjResult(interp, Tcl_DuplicateObj(inst->thisptr));
+         return TCL_OK;
+       }
+       if (strcmp(attrname, "-thisown") == 0) {
+         if (SWIG_Thisown(inst->thisvalue)) {
+           Tcl_SetResult(interp,(char*)"1",TCL_STATIC);
+         } else {
+           Tcl_SetResult(interp,(char*)"0",TCL_STATIC);
+         }
+         return TCL_OK;
+       }
+     } else if (strcmp(method, "configure") == 0) {
+       int i;
+       if (objc < 4) {
+         Tcl_SetResult(interp, (char *) "wrong # args.", TCL_STATIC);
+         return TCL_ERROR;
+       }
+       i = 2;
+       while (i < objc) {
+         attrname = Tcl_GetStringFromObj(objv[i],NULL);
+         attr = cls->attributes;
+         while (attr && attr->name) {
+           if ((strcmp(attr->name, attrname) == 0) && (attr->setmethod)) {
+             oldarg = objv[i];
+             objv[i] = inst->thisptr;
+             Tcl_IncrRefCount(inst->thisptr);
+             rcode = (*attr->setmethod)(clientData,interp,3, &objv[i-1]);
+             objv[i] = oldarg;
+             Tcl_DecrRefCount(inst->thisptr);
+             if (rcode != TCL_OK) return rcode;
+             numconf += 2;
+           }
+           attr++;
+         }
+         i+=2;
+       }
+     }
+   }
+   if (strcmp(method,"configure") == 0) {
+     if (numconf >= objc) {
+       return TCL_OK;
+     } else {
+       Tcl_SetResult(interp,(char *) "Invalid attribute name.", TCL_STATIC);
+       return TCL_ERROR;
+     }
+   }
+   if (strcmp(method,"cget") == 0) {
+     Tcl_SetResult(interp,(char *) "Invalid attribute name.", TCL_STATIC);
+     return TCL_ERROR;
+   }
+   Tcl_SetResult(interp, (char *) "Invalid method. Must be one of: configure cget -acquire -disown -delete", TCL_STATIC);
+   cls = inst->classptr;
+   bi = 0;
+   while (cls) {
+     meth = cls->methods;
+     while (meth && meth->name) {
+       char *cr = (char *) Tcl_GetStringResult(interp);
+       size_t meth_len = strlen(meth->name);
+       char* where = strchr(cr,':');
+       while(where) {
+         where = strstr(where, meth->name);
+         if(where) {
+           if(where[-1] == ' ' && (where[meth_len] == ' ' || where[meth_len]==0)) {
+             break;
+           } else {
+             where++;
+           }
+         }
+       }
+ 
+       if (!where)
+         Tcl_AppendElement(interp, (char *) meth->name);
+       meth++;
+     }
+     cls = inst->classptr->bases[bi++];
+   }
+   return TCL_ERROR;
+ }
+ 
+ /* This function takes the current result and turns it into an object command */
+ SWIGRUNTIME Tcl_Obj *
+ SWIG_Tcl_NewInstanceObj(Tcl_Interp *interp, void *thisvalue, swig_type_info *type, int flags) {
+   Tcl_Obj *robj = SWIG_NewPointerObj(thisvalue, type,0);
+   /* Check to see if this pointer belongs to a class or not */
+   if ((type->clientdata) && (interp)) {
+     Tcl_CmdInfo    ci;
+     char          *name;
+     name = Tcl_GetStringFromObj(robj,NULL);
+     if (!Tcl_GetCommandInfo(interp,name, &ci) || (flags)) {
+       swig_instance *newinst = (swig_instance *) malloc(sizeof(swig_instance));
+       newinst->thisptr = Tcl_DuplicateObj(robj);
+       Tcl_IncrRefCount(newinst->thisptr);
+       newinst->thisvalue = thisvalue;
+       newinst->classptr = (swig_class *) type->clientdata;
+       newinst->destroy = flags;
+       newinst->cmdtok = Tcl_CreateObjCommand(interp, Tcl_GetStringFromObj(robj,NULL), (swig_wrapper_func) SWIG_MethodCommand, (ClientData) newinst, (swig_delete_func) SWIG_ObjectDelete);
+       if (flags) {
+         SWIG_Acquire(thisvalue);
+       }
+     }
+   }
+   return robj;
+ }
+ 
+ /* Function to create objects */
+ SWIGRUNTIME int
+ SWIG_Tcl_ObjectConstructor(ClientData clientData, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
+   Tcl_Obj          *newObj = 0;
+   void             *thisvalue = 0;
+   swig_instance   *newinst = 0;
+   swig_class      *classptr = (swig_class *) clientData;
+   swig_wrapper     cons = 0;
+   char             *name = 0;
+   int               firstarg = 0;
+   int               thisarg = 0;
+   int               destroy = 1;
+ 
+   if (!classptr) {
+     Tcl_SetResult(interp, (char *) "swig: internal runtime error. No class object defined.", TCL_STATIC);
+     return TCL_ERROR;
+   }
+   cons = classptr->constructor;
+   if (objc > 1) {
+     char *s = Tcl_GetStringFromObj(objv[1],NULL);
+     if (strcmp(s,"-this") == 0) {
+       thisarg = 2;
+       cons = 0;
+     } else if (strcmp(s,"-args") == 0) {
+       firstarg = 1;
+     } else if (objc == 2) {
+       firstarg = 1;
+       name = s;
+     } else if (objc >= 3) {
+       char *s1;
+       name = s;
+       s1 = Tcl_GetStringFromObj(objv[2],NULL);
+       if (strcmp(s1,"-this") == 0) {
+ 	thisarg = 3;
+ 	cons = 0;
+       } else {
+ 	firstarg = 1;
+       }
+     }
+   }
+   if (cons) {
+     int result;
+     result = (*cons)(0, interp, objc-firstarg, &objv[firstarg]);
+     if (result != TCL_OK) {
+       return result;
+     }
+     newObj = Tcl_DuplicateObj(Tcl_GetObjResult(interp));
+     if (!name) name = Tcl_GetStringFromObj(newObj,NULL);
+   } else if (thisarg > 0) {
+     if (thisarg < objc) {
+       destroy = 0;
+       newObj = Tcl_DuplicateObj(objv[thisarg]);
+       if (!name) name = Tcl_GetStringFromObj(newObj,NULL);
+     } else {
+       Tcl_SetResult(interp, (char *) "wrong # args.", TCL_STATIC);
+       return TCL_ERROR;
+     }
+   } else {
+     Tcl_SetResult(interp, (char *) "No constructor available.", TCL_STATIC);
+     return TCL_ERROR;
+   }
+   if (SWIG_Tcl_ConvertPtr(interp,newObj, (void **) &thisvalue, *(classptr->type), 0) != SWIG_OK) {
+     Tcl_DecrRefCount(newObj);
+     return TCL_ERROR;
+   }
+   newinst = (swig_instance *) malloc(sizeof(swig_instance));
+   newinst->thisptr = newObj;
+   Tcl_IncrRefCount(newObj);
+   newinst->thisvalue = thisvalue;
+   newinst->classptr = classptr;
+   newinst->destroy = destroy;
+   if (destroy) {
+     SWIG_Acquire(thisvalue);
+   }
+   newinst->cmdtok = Tcl_CreateObjCommand(interp,name, (swig_wrapper) SWIG_MethodCommand, (ClientData) newinst, (swig_delete_func) SWIG_ObjectDelete);
+   return TCL_OK;
+ }
+ 
+ /* -----------------------------------------------------------------------------*
+  *   Get arguments 
+  * -----------------------------------------------------------------------------*/
+ SWIGRUNTIME int
+ SWIG_Tcl_GetArgs(Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[], const char *fmt, ...) {
+   int        argno = 0, opt = 0;
+   long       tempi;
+   double     tempd;
+   const char *c;
+   va_list    ap;
+   void      *vptr;
+   Tcl_Obj   *obj = 0;
+   swig_type_info *ty;
+ 
+   va_start(ap,fmt);
+   for (c = fmt; (*c && (*c != ':') && (*c != ';')); c++,argno++) {
+     if (*c == '|') {
+       opt = 1;
+       c++;
+     }
+     if (argno >= (objc-1)) {
+       if (!opt) {
+         Tcl_SetResult(interp, (char *) "Wrong number of arguments ", TCL_STATIC);
+         goto argerror;
+       } else {
+         va_end(ap);
+         return TCL_OK;
+       }
+     }
+ 
+     vptr = va_arg(ap,void *);
+     if (vptr) {
+       if (isupper(*c)) {
+         obj = SWIG_Tcl_GetConstantObj(Tcl_GetStringFromObj(objv[argno+1],0));
+         if (!obj) obj = objv[argno+1];
+       } else {
+         obj = objv[argno+1];
+       }
+       switch(*c) {
+       case 'i': case 'I':
+       case 'l': case 'L':
+       case 'h': case 'H':
+       case 'b': case 'B':
+         if (Tcl_GetLongFromObj(interp,obj,&tempi) != TCL_OK) goto argerror;
+         if ((*c == 'i') || (*c == 'I')) *((int *)vptr) = (int)tempi;
+         else if ((*c == 'l') || (*c == 'L')) *((long *)vptr) = (long)tempi;
+         else if ((*c == 'h') || (*c == 'H')) *((short*)vptr) = (short)tempi;
+         else if ((*c == 'b') || (*c == 'B')) *((unsigned char *)vptr) = (unsigned char)tempi;
+         break;
+       case 'f': case 'F':
+       case 'd': case 'D':
+         if (Tcl_GetDoubleFromObj(interp,obj,&tempd) != TCL_OK) goto argerror;
+         if ((*c == 'f') || (*c == 'F')) *((float *) vptr) = (float)tempd;
+         else if ((*c == 'd') || (*c == 'D')) *((double*) vptr) = tempd;
+         break;
+       case 's': case 'S':
+         if (*(c+1) == '#') {
+           int *vlptr = (int *) va_arg(ap, void *);
+           *((char **) vptr) = Tcl_GetStringFromObj(obj, vlptr);
+           c++;
+         } else {
+           *((char **)vptr) = Tcl_GetStringFromObj(obj,NULL);
+         }
+         break;
+       case 'c': case 'C':
+         *((char *)vptr) = *(Tcl_GetStringFromObj(obj,NULL));
+         break;
+       case 'p': case 'P':
+         ty = (swig_type_info *) va_arg(ap, void *);
+         if (SWIG_Tcl_ConvertPtr(interp, obj, (void **) vptr, ty, 0) != SWIG_OK) goto argerror;
+         break;
+       case 'o': case 'O':
+         *((Tcl_Obj **)vptr) = objv[argno+1];
+         break;
+       default:
+         break;
+       }
+     }
+   }
+ 
+   if ((*c != ';') && ((objc-1) > argno)) {
+     Tcl_SetResult(interp, (char *) "Wrong # args.", TCL_STATIC);
+     goto argerror;
+   }
+   va_end(ap);
+   return TCL_OK;
+ 
+  argerror:
+   {
+     char temp[32];
+     sprintf(temp,"%d", argno+1);
+     c = strchr(fmt,':');
+     if (!c) c = strchr(fmt,';');
+     if (!c) c = (char *)"";
+     Tcl_AppendResult(interp,c," argument ", temp, NULL);
+     va_end(ap);
+     return TCL_ERROR;
+   }
+ }
+ 
+ #ifdef __cplusplus
+ #if 0
+ { /* cc-mode */
+ #endif
+ }
+ #endif
+ 
+ 
+ 
+ #define SWIG_exception_fail(code, msg) do { SWIG_Error(code, msg); SWIG_fail; } while(0) 
+ 
+ #define SWIG_contract_assert(expr, msg) if (!(expr)) { SWIG_Error(SWIG_RuntimeError, msg); SWIG_fail; } else 
+ 
+ 
+ 
+ /* -------- TYPES TABLE (BEGIN) -------- */
+ 
+ #define SWIGTYPE_p_OSRCoordinateTransformationShadow swig_types[0]
+ #define SWIGTYPE_p_OSRSpatialReferenceShadow swig_types[1]
+ #define SWIGTYPE_p_char swig_types[2]
+ #define SWIGTYPE_p_double swig_types[3]
+ #define SWIGTYPE_p_int swig_types[4]
+ #define SWIGTYPE_p_long swig_types[5]
+ #define SWIGTYPE_p_p_char swig_types[6]
+ #define SWIGTYPE_p_p_double swig_types[7]
+ static swig_type_info *swig_types[9];
+ static swig_module_info swig_module = {swig_types, 8, 0, 0, 0, 0};
+ #define SWIG_TypeQuery(name) SWIG_TypeQueryModule(&swig_module, &swig_module, name)
+ #define SWIG_MangledTypeQuery(name) SWIG_MangledTypeQueryModule(&swig_module, &swig_module, name)
+ 
+ /* -------- TYPES TABLE (END) -------- */
+ 
+ #define SWIG_init    Osr_Init
+ #define SWIG_name    "osr"
+ #define SWIG_prefix  "osgeo::"
+ #define SWIG_namespace "osgeo"
+ 
+ #define SWIG_version "1.0"
+ 
+ #define SWIGVERSION 0x010336 
+ #define SWIG_VERSION SWIGVERSION
+ 
+ 
+ #define SWIG_as_voidptr(a) const_cast< void * >(static_cast< const void * >(a)) 
+ #define SWIG_as_voidptrptr(a) ((void)SWIG_as_voidptr(*a),reinterpret_cast< void** >(a)) 
+ 
+ 
+ #include <stdexcept>
+ 
+ 
+ 
+ #ifdef __cplusplus
+ extern "C" {
+ #endif
+ #ifdef MAC_TCL
+ #pragma export on
+ #endif
+ SWIGEXPORT int SWIG_init(Tcl_Interp *);
+ #ifdef MAC_TCL
+ #pragma export off
+ #endif
+ #ifdef __cplusplus
+ }
+ #endif
+ 
+ 
+ 
+ #include <limits.h>
+ #if !defined(SWIG_NO_LLONG_MAX)
+ # if !defined(LLONG_MAX) && defined(__GNUC__) && defined (__LONG_LONG_MAX__)
+ #   define LLONG_MAX __LONG_LONG_MAX__
+ #   define LLONG_MIN (-LLONG_MAX - 1LL)
+ #   define ULLONG_MAX (LLONG_MAX * 2ULL + 1ULL)
+ # endif
+ #endif
+ 
+ 
+ SWIGINTERNINLINE Tcl_Obj *
+ SWIG_FromCharPtrAndSize(const char* carray, size_t size)
+ {
+   return (size < INT_MAX) ? Tcl_NewStringObj(carray, static_cast< int >(size)) : NULL;
+ }
+ 
+ 
+ SWIGINTERNINLINE Tcl_Obj * 
+ SWIG_FromCharPtr(const char *cptr)
+ { 
+   return SWIG_FromCharPtrAndSize(cptr, (cptr ? strlen(cptr) : 0));
+ }
+ 
+ 
+   #define SWIG_From_double   Tcl_NewDoubleObj 
+ 
+ 
+ #include <iostream>
+ using namespace std;
+ 
+ #include "cpl_string.h"
+ #include "cpl_conv.h"
+ 
+ #include "ogr_srs_api.h"
+ 
+ #ifdef DEBUG
+ typedef struct OGRSpatialReferenceHS OSRSpatialReferenceShadow;
+ typedef struct OGRCoordinateTransformationHS OSRCoordinateTransformationShadow;
+ typedef struct OGRCoordinateTransformationHS OGRCoordinateTransformationShadow;
+ #else
+ typedef void OSRSpatialReferenceShadow;
+ typedef void OSRCoordinateTransformationShadow;
+ #endif
+ 
+ 
+ 
+ OGRErr GetWellKnownGeogCSAsWKT( const char *name, char **argout ) {
+   OGRSpatialReferenceH srs = OSRNewSpatialReference("");
+   OGRErr rcode = OSRSetWellKnownGeogCS( srs, name );
+   if( rcode == OGRERR_NONE )
+       rcode = OSRExportToWkt ( srs, argout );  
+   OSRDestroySpatialReference( srs );
+   return rcode;
+ }
+ 
+ 
+ SWIGINTERN int
+ SWIG_AsCharPtrAndSize(Tcl_Obj *obj, char** cptr, size_t* psize, int *alloc)
+ { 
+   int len = 0;
+   char *cstr = Tcl_GetStringFromObj(obj, &len);
+   if (cstr) {
+     if (cptr)  *cptr = cstr;
+     if (psize) *psize = len + 1;
+     if (alloc) *alloc = SWIG_OLDOBJ;
+     return SWIG_OK;
+   }
+   return SWIG_TypeError;
+ }
+ 
+ 
+ 
+ 
+ 
+ 
+ #include "ogr_core.h"
+ static char const *
+ OGRErrMessages( int rc ) {
+   switch( rc ) {
+   case OGRERR_NONE:
+     return "OGR Error: None";
+   case OGRERR_NOT_ENOUGH_DATA:
+     return "OGR Error: Not enough data to deserialize";
+   case OGRERR_NOT_ENOUGH_MEMORY:
+     return "OGR Error: Not enough memory";
+   case OGRERR_UNSUPPORTED_GEOMETRY_TYPE:
+     return "OGR Error: Unsupported geometry type";
+   case OGRERR_UNSUPPORTED_OPERATION:
+     return "OGR Error: Unsupported operation";
+   case OGRERR_CORRUPT_DATA:
+     return "OGR Error: Corrupt data";
+   case OGRERR_FAILURE:
+     return "OGR Error: General Error";
+   case OGRERR_UNSUPPORTED_SRS:
+     return "OGR Error: Unsupported SRS";
+   case OGRERR_INVALID_HANDLE:
+     return "OGR Error: Invalid handle";
+   default:
+     return "OGR Error: Unknown";
+   }
+ }
+ 
+ 
+ OGRErr GetUserInputAsWKT( const char *name, char **argout ) {
+   OGRSpatialReferenceH srs = OSRNewSpatialReference("");
+   OGRErr rcode = OSRSetFromUserInput( srs, name );
+   if( rcode == OGRERR_NONE )
+       rcode = OSRExportToWkt ( srs, argout );  
+   OSRDestroySpatialReference( srs );
+   return rcode;
+ }
+ 
+ SWIGINTERN OSRSpatialReferenceShadow *new_OSRSpatialReferenceShadow(char const *wkt=""){
+     return (OSRSpatialReferenceShadow*) OSRNewSpatialReference(wkt);
+   }
+ SWIGINTERN void delete_OSRSpatialReferenceShadow(OSRSpatialReferenceShadow *self){
+     if (OSRDereference( self ) == 0 ) {
+       OSRDestroySpatialReference( self );
+     }
+   }
+ SWIGINTERN char *OSRSpatialReferenceShadow___str__(OSRSpatialReferenceShadow *self){
+     char *buf = 0;
+     OSRExportToPrettyWkt( self, &buf, 0 );
+     return buf;
+   }
+ SWIGINTERN int OSRSpatialReferenceShadow_IsSame(OSRSpatialReferenceShadow *self,OSRSpatialReferenceShadow *rhs){
+     return OSRIsSame( self, rhs );
+   }
+ 
+ SWIGINTERNINLINE Tcl_Obj* 
+ SWIG_From_long  (long value)
+ {
+   if (((long) INT_MIN <= value) && (value <= (long) INT_MAX)) {
+     return Tcl_NewIntObj(static_cast< int >(value));
+   } else {
+     return Tcl_NewLongObj(value);
+   }
+ }
+ 
+ 
+ SWIGINTERNINLINE Tcl_Obj *
+ SWIG_From_int  (int value)
+ {    
+   return SWIG_From_long  (value);
+ }
+ 
+ SWIGINTERN int OSRSpatialReferenceShadow_IsSameGeogCS(OSRSpatialReferenceShadow *self,OSRSpatialReferenceShadow *rhs){
+     return OSRIsSameGeogCS( self, rhs );
+   }
+ SWIGINTERN int OSRSpatialReferenceShadow_IsGeographic(OSRSpatialReferenceShadow *self){
+     return OSRIsGeographic(self);
+   }
+ SWIGINTERN int OSRSpatialReferenceShadow_IsProjected(OSRSpatialReferenceShadow *self){
+     return OSRIsProjected(self);
+   }
+ SWIGINTERN int OSRSpatialReferenceShadow_IsLocal(OSRSpatialReferenceShadow *self){
+     return OSRIsLocal(self);
+   }
+ 
+ SWIGINTERN int
+ SWIG_AsVal_long SWIG_TCL_DECL_ARGS_2(Tcl_Obj *obj, long* val)
+ {
+   long v;
+   if (Tcl_GetLongFromObj(0,obj, &v) == TCL_OK) {
+     if (val) *val = (long) v;
+     return SWIG_OK;
+   }
+   return SWIG_TypeError;
+ }
+ 
+ 
+ SWIGINTERN int
+ SWIG_AsVal_int SWIG_TCL_DECL_ARGS_2(Tcl_Obj * obj, int *val)
+ {
+   long v;
+   int res = SWIG_AsVal_long SWIG_TCL_CALL_ARGS_2(obj, &v);
+   if (SWIG_IsOK(res)) {
+     if ((v < INT_MIN || v > INT_MAX)) {
+       return SWIG_OverflowError;
+     } else {
+       if (val) *val = static_cast< int >(v);
+     }
+   }  
+   return res;
+ }
+ 
+ SWIGINTERN OGRErr OSRSpatialReferenceShadow_SetAuthority(OSRSpatialReferenceShadow *self,char const *pszTargetKey,char const *pszAuthority,int nCode){
+     return OSRSetAuthority( self, pszTargetKey, pszAuthority, nCode );
+   }
+ SWIGINTERN char const *OSRSpatialReferenceShadow_GetAttrValue(OSRSpatialReferenceShadow *self,char const *name,int child=0){
+     return OSRGetAttrValue( self, name, child );
+   }
+ SWIGINTERN OGRErr OSRSpatialReferenceShadow_SetAttrValue(OSRSpatialReferenceShadow *self,char const *name,char const *value){
+     return OSRSetAttrValue( self, name, value ); 
+   }
+ 
+ SWIGINTERN int
+ SWIG_AsVal_double SWIG_TCL_DECL_ARGS_2(Tcl_Obj *obj, double *val)
+ {
+   double v;
+   if (Tcl_GetDoubleFromObj(0, obj, &v) == TCL_OK) {
+     if (val) *val = v;
+     return SWIG_OK;
+   }
+   return SWIG_TypeError;
+ }
+ 
+ SWIGINTERN OGRErr OSRSpatialReferenceShadow_SetAngularUnits(OSRSpatialReferenceShadow *self,char const *name,double to_radians){
+     return OSRSetAngularUnits( self, name, to_radians );
+   }
+ SWIGINTERN double OSRSpatialReferenceShadow_GetAngularUnits(OSRSpatialReferenceShadow *self){
+     // Return code ignored.
+     return OSRGetAngularUnits( self, 0 );
+   }
+ SWIGINTERN OGRErr OSRSpatialReferenceShadow_SetLinearUnits(OSRSpatialReferenceShadow *self,char const *name,double to_meters){
+     return OSRSetLinearUnits( self, name, to_meters );
+   }
+ SWIGINTERN OGRErr OSRSpatialReferenceShadow_SetLinearUnitsAndUpdateParameters(OSRSpatialReferenceShadow *self,char const *name,double to_meters){
+     return OSRSetLinearUnitsAndUpdateParameters( self, name, to_meters );
+   }
+ SWIGINTERN double OSRSpatialReferenceShadow_GetLinearUnits(OSRSpatialReferenceShadow *self){
+     // Return code ignored.
+     return OSRGetLinearUnits( self, 0 );
+   }
+ SWIGINTERN char const *OSRSpatialReferenceShadow_GetLinearUnitsName(OSRSpatialReferenceShadow *self){
+     const char *name = 0;
+     if ( OSRIsProjected( self ) ) {
+       name = OSRGetAttrValue( self, "PROJCS|UNIT", 0 );
+     }
+     else if ( OSRIsLocal( self ) ) {
+       name = OSRGetAttrValue( self, "LOCAL_CS|UNIT", 0 );
+     }
+ 
+     if (name != 0) 
+       return name;
+ 
+     return "Meter";
+   }
+ SWIGINTERN char const *OSRSpatialReferenceShadow_GetAuthorityCode(OSRSpatialReferenceShadow *self,char const *target_key){
+     return OSRGetAuthorityCode( self, target_key );
+   }
+ SWIGINTERN char const *OSRSpatialReferenceShadow_GetAuthorityName(OSRSpatialReferenceShadow *self,char const *target_key){
+     return OSRGetAuthorityName( self, target_key );
+   }
+ SWIGINTERN OGRErr OSRSpatialReferenceShadow_SetUTM(OSRSpatialReferenceShadow *self,int zone,int north=1){
+     return OSRSetUTM( self, zone, north );
+   }
+ SWIGINTERN OGRErr OSRSpatialReferenceShadow_SetStatePlane(OSRSpatialReferenceShadow *self,int zone,int is_nad83=1,char const *unitsname="",double units=0.0){
+     return OSRSetStatePlaneWithUnits( self, zone, is_nad83, unitsname, units );
+   }
+ SWIGINTERN OGRErr OSRSpatialReferenceShadow_AutoIdentifyEPSG(OSRSpatialReferenceShadow *self){
+     return OSRAutoIdentifyEPSG( self );
+   }
+ SWIGINTERN OGRErr OSRSpatialReferenceShadow_SetProjection(OSRSpatialReferenceShadow *self,char const *arg){
+     return OSRSetProjection( self, arg );
+   }
+ SWIGINTERN OGRErr OSRSpatialReferenceShadow_SetProjParm(OSRSpatialReferenceShadow *self,char const *name,double val){
+     return OSRSetProjParm( self, name, val ); 
+   }
+ SWIGINTERN double OSRSpatialReferenceShadow_GetProjParm(OSRSpatialReferenceShadow *self,char const *name,double default_val=0.0){
+     // Return code ignored.
+     return OSRGetProjParm( self, name, default_val, 0 );
+   }
+ SWIGINTERN OGRErr OSRSpatialReferenceShadow_SetNormProjParm(OSRSpatialReferenceShadow *self,char const *name,double val){
+     return OSRSetNormProjParm( self, name, val );
+   }
+ SWIGINTERN double OSRSpatialReferenceShadow_GetNormProjParm(OSRSpatialReferenceShadow *self,char const *name,double default_val=0.0){
+     // Return code ignored.
+     return OSRGetNormProjParm( self, name, default_val, 0 );
+   }
+ SWIGINTERN OGRErr OSRSpatialReferenceShadow_SetACEA(OSRSpatialReferenceShadow *self,double stdp1,double stdp2,double clat,double clong,double fe,double fn){
+     return OSRSetACEA( self, stdp1, stdp2, clat, clong, 
+                        fe, fn );
+   }
+ SWIGINTERN OGRErr OSRSpatialReferenceShadow_SetAE(OSRSpatialReferenceShadow *self,double clat,double clong,double fe,double fn){
+     return OSRSetAE( self, clat, clong, 
+                      fe, fn );
+   }
+ SWIGINTERN OGRErr OSRSpatialReferenceShadow_SetBonne(OSRSpatialReferenceShadow *self,double stdp,double cm,double fe,double fn){
+     return OSRSetBonne( self, stdp, cm, fe, fn );
+   }
+ SWIGINTERN OGRErr OSRSpatialReferenceShadow_SetCEA(OSRSpatialReferenceShadow *self,double stdp1,double cm,double fe,double fn){
+     return OSRSetCEA( self, stdp1, cm, 
+                       fe, fn );
+   }
+ SWIGINTERN OGRErr OSRSpatialReferenceShadow_SetCS(OSRSpatialReferenceShadow *self,double clat,double clong,double fe,double fn){
+     return OSRSetCS( self, clat, clong, 
+                      fe, fn );
+   }
+ SWIGINTERN OGRErr OSRSpatialReferenceShadow_SetEC(OSRSpatialReferenceShadow *self,double stdp1,double stdp2,double clat,double clong,double fe,double fn){
+     return OSRSetEC( self, stdp1, stdp2, clat, clong, 
+                      fe, fn );
+   }
+ SWIGINTERN OGRErr OSRSpatialReferenceShadow_SetEckertIV(OSRSpatialReferenceShadow *self,double cm,double fe,double fn){
+     return OSRSetEckertIV( self, cm, fe, fn);
+   }
+ SWIGINTERN OGRErr OSRSpatialReferenceShadow_SetEckertVI(OSRSpatialReferenceShadow *self,double cm,double fe,double fn){
+     return OSRSetEckertVI( self, cm, fe, fn);
+   }
+ SWIGINTERN OGRErr OSRSpatialReferenceShadow_SetEquirectangular(OSRSpatialReferenceShadow *self,double clat,double clong,double fe,double fn){
+     return OSRSetEquirectangular( self, clat, clong, 
+                                   fe, fn );
+   }
+ SWIGINTERN OGRErr OSRSpatialReferenceShadow_SetEquirectangular2(OSRSpatialReferenceShadow *self,double clat,double clong,double pseudostdparallellat,double fe,double fn){
+     return OSRSetEquirectangular2( self, clat, clong,
+                                    pseudostdparallellat,
+                                    fe, fn );
+   }
+ SWIGINTERN OGRErr OSRSpatialReferenceShadow_SetGaussSchreiberTMercator(OSRSpatialReferenceShadow *self,double clat,double clong,double sc,double fe,double fn){
+     return OSRSetGaussSchreiberTMercator( self, clat, clong, sc, fe, fn );
+   }
+ SWIGINTERN OGRErr OSRSpatialReferenceShadow_SetGS(OSRSpatialReferenceShadow *self,double cm,double fe,double fn){
+     return OSRSetGS( self, cm, fe, fn );
+   }
+ SWIGINTERN OGRErr OSRSpatialReferenceShadow_SetGH(OSRSpatialReferenceShadow *self,double cm,double fe,double fn){
+     return OSRSetGH( self, cm, fe, fn );
+   }
+ SWIGINTERN OGRErr OSRSpatialReferenceShadow_SetGEOS(OSRSpatialReferenceShadow *self,double cm,double satelliteheight,double fe,double fn){
+     return OSRSetGEOS( self, cm, satelliteheight,
+                        fe, fn );
+   }
+ SWIGINTERN OGRErr OSRSpatialReferenceShadow_SetGnomonic(OSRSpatialReferenceShadow *self,double clat,double clong,double fe,double fn){
+     return OSRSetGnomonic( self, clat, clong, 
+                            fe, fn );
+   }
+ SWIGINTERN OGRErr OSRSpatialReferenceShadow_SetHOM(OSRSpatialReferenceShadow *self,double clat,double clong,double azimuth,double recttoskew,double scale,double fe,double fn){
+     return OSRSetHOM( self, clat, clong, azimuth, recttoskew,
+                       scale, fe, fn );
+   }
+ SWIGINTERN OGRErr OSRSpatialReferenceShadow_SetHOM2PNO(OSRSpatialReferenceShadow *self,double clat,double dfLat1,double dfLong1,double dfLat2,double dfLong2,double scale,double fe,double fn){
+     return OSRSetHOM2PNO( self, clat, dfLat1, dfLong1, dfLat2, dfLong2, 
+                           scale, fe, fn );
+   }
+ SWIGINTERN OGRErr OSRSpatialReferenceShadow_SetKrovak(OSRSpatialReferenceShadow *self,double clat,double clong,double azimuth,double pseudostdparallellat,double scale,double fe,double fn){
+     return OSRSetKrovak( self, clat, clong, 
+                          azimuth, pseudostdparallellat, 
+                          scale, fe, fn );
+   }
+ SWIGINTERN OGRErr OSRSpatialReferenceShadow_SetLAEA(OSRSpatialReferenceShadow *self,double clat,double clong,double fe,double fn){
+     return OSRSetLAEA( self, clat, clong, 
+                        fe, fn );
+   }
+ SWIGINTERN OGRErr OSRSpatialReferenceShadow_SetLCC(OSRSpatialReferenceShadow *self,double stdp1,double stdp2,double clat,double clong,double fe,double fn){
+     return OSRSetLCC( self, stdp1, stdp2, clat, clong, 
+                       fe, fn );
+   }
+ SWIGINTERN OGRErr OSRSpatialReferenceShadow_SetLCC1SP(OSRSpatialReferenceShadow *self,double clat,double clong,double scale,double fe,double fn){
+     return OSRSetLCC1SP( self, clat, clong, scale, 
+                          fe, fn );
+   }
+ SWIGINTERN OGRErr OSRSpatialReferenceShadow_SetLCCB(OSRSpatialReferenceShadow *self,double stdp1,double stdp2,double clat,double clong,double fe,double fn){
+     return OSRSetLCCB( self, stdp1, stdp2, clat, clong, 
+                        fe, fn );
+   }
+ SWIGINTERN OGRErr OSRSpatialReferenceShadow_SetMC(OSRSpatialReferenceShadow *self,double clat,double clong,double fe,double fn){
+     return OSRSetMC( self, clat, clong,    
+                      fe, fn );
+   }
+ SWIGINTERN OGRErr OSRSpatialReferenceShadow_SetMercator(OSRSpatialReferenceShadow *self,double clat,double clong,double scale,double fe,double fn){
+     return OSRSetMercator( self, clat, clong, 
+                            scale, fe, fn );
+   }
+ SWIGINTERN OGRErr OSRSpatialReferenceShadow_SetMollweide(OSRSpatialReferenceShadow *self,double cm,double fe,double fn){
+     return OSRSetMollweide( self, cm, 
+                             fe, fn );
+   }
+ SWIGINTERN OGRErr OSRSpatialReferenceShadow_SetNZMG(OSRSpatialReferenceShadow *self,double clat,double clong,double fe,double fn){
+     return OSRSetNZMG( self, clat, clong, 
+                        fe, fn );
+   }
+ SWIGINTERN OGRErr OSRSpatialReferenceShadow_SetOS(OSRSpatialReferenceShadow *self,double dfOriginLat,double dfCMeridian,double scale,double fe,double fn){
+     return OSRSetOS( self, dfOriginLat, dfCMeridian, scale, 
+                      fe, fn );
+   }
+ SWIGINTERN OGRErr OSRSpatialReferenceShadow_SetOrthographic(OSRSpatialReferenceShadow *self,double clat,double clong,double fe,double fn){
+     return OSRSetOrthographic( self, clat, clong, 
+                                fe, fn );
+   }
+ SWIGINTERN OGRErr OSRSpatialReferenceShadow_SetPolyconic(OSRSpatialReferenceShadow *self,double clat,double clong,double fe,double fn){
+     return OSRSetPolyconic( self, clat, clong, 
+                             fe, fn );
+   }
+ SWIGINTERN OGRErr OSRSpatialReferenceShadow_SetPS(OSRSpatialReferenceShadow *self,double clat,double clong,double scale,double fe,double fn){
+     return OSRSetPS( self, clat, clong, scale,
+                      fe, fn );
+   }
+ SWIGINTERN OGRErr OSRSpatialReferenceShadow_SetRobinson(OSRSpatialReferenceShadow *self,double clong,double fe,double fn){
+     return OSRSetRobinson( self, clong, fe, fn );
+   }
+ SWIGINTERN OGRErr OSRSpatialReferenceShadow_SetSinusoidal(OSRSpatialReferenceShadow *self,double clong,double fe,double fn){
+     return OSRSetSinusoidal( self, clong, fe, fn );
+   }
+ SWIGINTERN OGRErr OSRSpatialReferenceShadow_SetStereographic(OSRSpatialReferenceShadow *self,double clat,double clong,double scale,double fe,double fn){
+     return OSRSetStereographic( self, clat, clong, scale, 
+                                 fe, fn );
+   }
+ SWIGINTERN OGRErr OSRSpatialReferenceShadow_SetSOC(OSRSpatialReferenceShadow *self,double latitudeoforigin,double cm,double fe,double fn){
+     return OSRSetSOC( self, latitudeoforigin, cm,
+ 	              fe, fn );
+   }
+ SWIGINTERN OGRErr OSRSpatialReferenceShadow_SetTM(OSRSpatialReferenceShadow *self,double clat,double clong,double scale,double fe,double fn){
+     return OSRSetTM( self, clat, clong, scale, 
+                      fe, fn );
+   }
+ SWIGINTERN OGRErr OSRSpatialReferenceShadow_SetTMVariant(OSRSpatialReferenceShadow *self,char const *pszVariantName,double clat,double clong,double scale,double fe,double fn){
+     return OSRSetTMVariant( self, pszVariantName, clat, clong,  
+                             scale, fe, fn );
+   }
+ SWIGINTERN OGRErr OSRSpatialReferenceShadow_SetTMG(OSRSpatialReferenceShadow *self,double clat,double clong,double fe,double fn){
+     return OSRSetTMG( self, clat, clong, 
+                       fe, fn );
+   }
+ SWIGINTERN OGRErr OSRSpatialReferenceShadow_SetTMSO(OSRSpatialReferenceShadow *self,double clat,double clong,double scale,double fe,double fn){
+     return OSRSetTMSO( self, clat, clong, scale, 
+                        fe, fn );
+   }
+ SWIGINTERN OGRErr OSRSpatialReferenceShadow_SetVDG(OSRSpatialReferenceShadow *self,double clong,double fe,double fn){
+     return OSRSetVDG( self, clong, fe, fn );
+   }
+ SWIGINTERN OGRErr OSRSpatialReferenceShadow_SetWellKnownGeogCS(OSRSpatialReferenceShadow *self,char const *name){
+     return OSRSetWellKnownGeogCS( self, name );
+   }
+ SWIGINTERN OGRErr OSRSpatialReferenceShadow_SetFromUserInput(OSRSpatialReferenceShadow *self,char const *name){
+     return OSRSetFromUserInput( self, name );
+   }
+ SWIGINTERN OGRErr OSRSpatialReferenceShadow_CopyGeogCSFrom(OSRSpatialReferenceShadow *self,OSRSpatialReferenceShadow *rhs){
+     return OSRCopyGeogCSFrom( self, rhs );
+   }
+ SWIGINTERN OGRErr OSRSpatialReferenceShadow_SetTOWGS84(OSRSpatialReferenceShadow *self,double p1,double p2,double p3,double p4=0.0,double p5=0.0,double p6=0.0,double p7=0.0){
+     return OSRSetTOWGS84( self, p1, p2, p3, p4, p5, p6, p7 );
+   }
+ 
+ static Tcl_Obj*
+ CreateListFromDoubleArray(Tcl_Interp *interp, double *first, unsigned int size ) {
+   Tcl_Obj *out = Tcl_NewListObj(0, NULL);
+   for( unsigned int i=0; i<size; i++ ) {
+     Tcl_Obj *val = Tcl_NewDoubleObj( *first );
+     ++first;
+     if (Tcl_ListObjAppendElement(interp, out, val) != TCL_OK) {
+         Tcl_DecrRefCount(val);
+         Tcl_DecrRefCount(out);
+         /* Error msg in interp result */
+         return NULL; /* signifies error */
+     }
+   }
+   return out;
+ }
+ 
+ SWIGINTERN OGRErr OSRSpatialReferenceShadow_GetTOWGS84(OSRSpatialReferenceShadow *self,double argout[7]){
+     return OSRGetTOWGS84( self, argout, 7 );
+   }
+ SWIGINTERN OGRErr OSRSpatialReferenceShadow_SetLocalCS(OSRSpatialReferenceShadow *self,char const *pszName){
+     return OSRSetLocalCS( self, pszName );
+   }
+ SWIGINTERN OGRErr OSRSpatialReferenceShadow_SetGeogCS(OSRSpatialReferenceShadow *self,char const *pszGeogName,char const *pszDatumName,char const *pszEllipsoidName,double dfSemiMajor,double dfInvFlattening,char const *pszPMName="Greenwich",double dfPMOffset=0.0,char const *pszUnits="degree",double dfConvertToRadians=0.0174532925199433){
+     return OSRSetGeogCS( self, pszGeogName, pszDatumName, pszEllipsoidName,
+                          dfSemiMajor, dfInvFlattening,
+                          pszPMName, dfPMOffset, pszUnits, dfConvertToRadians );
+   }
+ SWIGINTERN OGRErr OSRSpatialReferenceShadow_SetProjCS(OSRSpatialReferenceShadow *self,char const *name="unnamed"){
+     return OSRSetProjCS( self, name );
+   }
+ SWIGINTERN OGRErr OSRSpatialReferenceShadow_ImportFromWkt(OSRSpatialReferenceShadow *self,char **ppszInput){
+     return OSRImportFromWkt( self, ppszInput );
+   }
+ SWIGINTERN OGRErr OSRSpatialReferenceShadow_ImportFromProj4(OSRSpatialReferenceShadow *self,char *ppszInput){
+     return OSRImportFromProj4( self, ppszInput );
+   }
+ SWIGINTERN OGRErr OSRSpatialReferenceShadow_ImportFromUrl(OSRSpatialReferenceShadow *self,char *url){
+     return OSRImportFromUrl( self, url );
+   }
+ SWIGINTERN OGRErr OSRSpatialReferenceShadow_ImportFromESRI(OSRSpatialReferenceShadow *self,char **ppszInput){
+     return OSRImportFromESRI( self, ppszInput );
+   }
+ SWIGINTERN OGRErr OSRSpatialReferenceShadow_ImportFromEPSG(OSRSpatialReferenceShadow *self,int arg){
+     return OSRImportFromEPSG(self, arg);
+   }
+ SWIGINTERN OGRErr OSRSpatialReferenceShadow_ImportFromPCI(OSRSpatialReferenceShadow *self,char const *proj,char const *units="METRE",double argin[17]=0){
+     return OSRImportFromPCI( self, proj, units, argin );
+   }
+ SWIGINTERN OGRErr OSRSpatialReferenceShadow_ImportFromUSGS(OSRSpatialReferenceShadow *self,long proj_code,long zone=0,double argin[15]=0,long datum_code=0){
+     return OSRImportFromUSGS( self, proj_code, zone, argin, datum_code );
+   }
+ SWIGINTERN OGRErr OSRSpatialReferenceShadow_ImportFromXML(OSRSpatialReferenceShadow *self,char const *xmlString){
+     return OSRImportFromXML( self, xmlString );
+   }
+ SWIGINTERN OGRErr OSRSpatialReferenceShadow_ImportFromMICoordSys(OSRSpatialReferenceShadow *self,char const *pszCoordSys){
+     return OSRImportFromMICoordSys( self, pszCoordSys );
+   }
+ SWIGINTERN OGRErr OSRSpatialReferenceShadow_ExportToWkt(OSRSpatialReferenceShadow *self,char **argout){
+     return OSRExportToWkt( self, argout );
+   }
+ SWIGINTERN OGRErr OSRSpatialReferenceShadow_ExportToPrettyWkt(OSRSpatialReferenceShadow *self,char **argout,int simplify=0){
+     return OSRExportToPrettyWkt( self, argout, simplify );
+   }
+ SWIGINTERN OGRErr OSRSpatialReferenceShadow_ExportToProj4(OSRSpatialReferenceShadow *self,char **argout){
+     return OSRExportToProj4( self, argout );
+   }
+ SWIGINTERN OGRErr OSRSpatialReferenceShadow_ExportToPCI(OSRSpatialReferenceShadow *self,char **proj,char **units,double *parms[17]){
+     return OSRExportToPCI( self, proj, units, parms );
+   }
+ SWIGINTERN OGRErr OSRSpatialReferenceShadow_ExportToUSGS(OSRSpatialReferenceShadow *self,long *code,long *zone,double *parms[15],long *datum){
+     return OSRExportToUSGS( self, code, zone, parms, datum );
+   }
+ SWIGINTERN OGRErr OSRSpatialReferenceShadow_ExportToXML(OSRSpatialReferenceShadow *self,char **argout,char const *dialect=""){
+     return OSRExportToXML( self, argout, dialect );
+   }
+ SWIGINTERN OGRErr OSRSpatialReferenceShadow_ExportToMICoordSys(OSRSpatialReferenceShadow *self,char **argout){
+     return OSRExportToMICoordSys( self, argout );
+   }
+ SWIGINTERN OSRSpatialReferenceShadow *OSRSpatialReferenceShadow_CloneGeogCS(OSRSpatialReferenceShadow *self){
+     return (OSRSpatialReferenceShadow*) OSRCloneGeogCS(self);
+   }
+ SWIGINTERN OGRErr OSRSpatialReferenceShadow_Validate(OSRSpatialReferenceShadow *self){
+     return OSRValidate(self);
+   }
+ SWIGINTERN OGRErr OSRSpatialReferenceShadow_StripCTParms(OSRSpatialReferenceShadow *self){
+     return OSRStripCTParms(self);
+   }
+ SWIGINTERN OGRErr OSRSpatialReferenceShadow_FixupOrdering(OSRSpatialReferenceShadow *self){
+     return OSRFixupOrdering(self);
+   }
+ SWIGINTERN OGRErr OSRSpatialReferenceShadow_Fixup(OSRSpatialReferenceShadow *self){
+     return OSRFixup(self);
+   }
+ SWIGINTERN OGRErr OSRSpatialReferenceShadow_MorphToESRI(OSRSpatialReferenceShadow *self){
+     return OSRMorphToESRI(self);
+   }
+ SWIGINTERN OGRErr OSRSpatialReferenceShadow_MorphFromESRI(OSRSpatialReferenceShadow *self){
+     return OSRMorphFromESRI(self);
+   }
+ SWIGINTERN OSRCoordinateTransformationShadow *new_OSRCoordinateTransformationShadow(OSRSpatialReferenceShadow *src,OSRSpatialReferenceShadow *dst){
+     OSRCoordinateTransformationShadow *obj = (OSRCoordinateTransformationShadow*) OCTNewCoordinateTransformation( src, dst );
+     return obj;
+   }
+ SWIGINTERN void delete_OSRCoordinateTransformationShadow(OSRCoordinateTransformationShadow *self){
+     OCTDestroyCoordinateTransformation( self );
+   }
+ SWIGINTERN void OSRCoordinateTransformationShadow_TransformPoint__SWIG_0(OSRCoordinateTransformationShadow *self,double inout[3]){
+     OCTTransform( self, 1, &inout[0], &inout[1], &inout[2] );
+   }
+ SWIGINTERN void OSRCoordinateTransformationShadow_TransformPoint__SWIG_1(OSRCoordinateTransformationShadow *self,double argout[3],double x,double y,double z=0.0){
+     argout[0] = x;
+     argout[1] = y;
+     argout[2] = z;
+     OCTTransform( self, 1, &argout[0], &argout[1], &argout[2] );
+   }
+ SWIGINTERN void OSRCoordinateTransformationShadow_TransformPoints(OSRCoordinateTransformationShadow *self,int nCount,double *x,double *y,double *z){
+     OCTTransform( self, nCount, x, y, z );
+   }
+ #ifdef __cplusplus
+ extern "C" {
+ #endif
+ SWIGINTERN int
+ _wrap_GetWellKnownGeogCSAsWKT(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
+   char *arg1 = (char *) 0 ;
+   char **arg2 = (char **) 0 ;
+   int res1 ;
+   char *buf1 = 0 ;
+   int alloc1 = 0 ;
+   char *argout2 = 0 ;
+   OGRErr result;
+   
+   {
+     /* %typemap(in,numinputs=0) (char **argout2) */
+     arg2 = &argout2;
+   }
+   if (SWIG_GetArgs(interp, objc, objv,"o:osgeo::GetWellKnownGeogCSAsWKT name ",(void *)0) == TCL_ERROR) SWIG_fail;
+   res1 = SWIG_AsCharPtrAndSize(objv[1], &buf1, NULL, &alloc1);
+   if (!SWIG_IsOK(res1)) {
+     SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "GetWellKnownGeogCSAsWKT" "', argument " "1"" of type '" "char const *""'");
+   }
+   arg1 = reinterpret_cast< char * >(buf1);
+   result = (OGRErr)GetWellKnownGeogCSAsWKT((char const *)arg1,arg2);
+   {
+     /* %typemap(out) OGRErr */
+     if (result != 0) {
+       Tcl_SetResult(interp, (char*) OGRErrMessages(result), TCL_STATIC);
+       SWIG_fail;
+     }
+   }
+   {
+     /* %typemap(argout) (char **argout) */
+     Tcl_Obj *o;
+     if ( arg2 ) {
+       o = Tcl_NewStringObj( *arg2, -1 );
+     } else {
+       o = Tcl_NewObj();
+     }
+     Tcl_ListObjAppendElement(interp,Tcl_GetObjResult(interp),o);
+   }
+   if (alloc1 == SWIG_NEWOBJ) delete[] buf1;
+   {
+     /* %typemap(ret) OGRErr */
+     if (!strcmp(Tcl_GetStringResult(interp), "{}") || !strcmp(Tcl_GetStringResult(interp), "")) {
+       Tcl_SetObjResult(interp, Tcl_NewLongObj( result ));
+     }
+   }
+   return TCL_OK;
+ fail:
+   if (alloc1 == SWIG_NEWOBJ) delete[] buf1;
+   return TCL_ERROR;
+ }
+ 
+ 
+ SWIGINTERN int
+ _wrap_GetUserInputAsWKT(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
+   char *arg1 = (char *) 0 ;
+   char **arg2 = (char **) 0 ;
+   int res1 ;
+   char *buf1 = 0 ;
+   int alloc1 = 0 ;
+   char *argout2 = 0 ;
+   OGRErr result;
+   
+   {
+     /* %typemap(in,numinputs=0) (char **argout2) */
+     arg2 = &argout2;
+   }
+   if (SWIG_GetArgs(interp, objc, objv,"o:osgeo::GetUserInputAsWKT name ",(void *)0) == TCL_ERROR) SWIG_fail;
+   res1 = SWIG_AsCharPtrAndSize(objv[1], &buf1, NULL, &alloc1);
+   if (!SWIG_IsOK(res1)) {
+     SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "GetUserInputAsWKT" "', argument " "1"" of type '" "char const *""'");
+   }
+   arg1 = reinterpret_cast< char * >(buf1);
+   result = (OGRErr)GetUserInputAsWKT((char const *)arg1,arg2);
+   {
+     /* %typemap(out) OGRErr */
+     if (result != 0) {
+       Tcl_SetResult(interp, (char*) OGRErrMessages(result), TCL_STATIC);
+       SWIG_fail;
+     }
+   }
+   {
+     /* %typemap(argout) (char **argout) */
+     Tcl_Obj *o;
+     if ( arg2 ) {
+       o = Tcl_NewStringObj( *arg2, -1 );
+     } else {
+       o = Tcl_NewObj();
+     }
+     Tcl_ListObjAppendElement(interp,Tcl_GetObjResult(interp),o);
+   }
+   if (alloc1 == SWIG_NEWOBJ) delete[] buf1;
+   {
+     /* %typemap(ret) OGRErr */
+     if (!strcmp(Tcl_GetStringResult(interp), "{}") || !strcmp(Tcl_GetStringResult(interp), "")) {
+       Tcl_SetObjResult(interp, Tcl_NewLongObj( result ));
+     }
+   }
+   return TCL_OK;
+ fail:
+   if (alloc1 == SWIG_NEWOBJ) delete[] buf1;
+   return TCL_ERROR;
+ }
+ 
+ 
+ SWIGINTERN int
+ _wrap_GetProjectionMethods(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
+   char **result = 0 ;
+   
+   if (SWIG_GetArgs(interp, objc, objv,":osgeo::GetProjectionMethods ") == TCL_ERROR) SWIG_fail;
+   result = (char **)OPTGetProjectionMethods();
+   {
+     /*XXX Test it*/
+     /* %typemap(out) char **CSL */
+     char **stringarray = result;
+     if ( stringarray == NULL ) {
+       Tcl_ResetResult(interp); /* NONE = Empty string */
+     } else {
+       int len = CSLCount( stringarray );
+       Tcl_Obj *out = Tcl_NewListObj(0, NULL);
+       for ( int i = 0; i < len; ++i ) {
+         Tcl_Obj *o = Tcl_NewStringObj( stringarray[i], -1 );
+         if (Tcl_ListObjAppendElement(interp, out, o) != TCL_OK) {
+           Tcl_DecrRefCount(o);
+           Tcl_DecrRefCount(out);
+           /* Error msg in interp result */
+           SWIG_fail;
+         }
+       }
+       CSLDestroy(result);
+       Tcl_SetObjResult(interp, out);
+     }
+   }
+   return TCL_OK;
+ fail:
+   return TCL_ERROR;
+ }
+ 
+ 
+ SWIGINTERN int
+ _wrap_GetProjectionMethodParameterList(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
+   char *arg1 = (char *) 0 ;
+   char **arg2 = (char **) 0 ;
+   int res1 ;
+   char *buf1 = 0 ;
+   int alloc1 = 0 ;
+   void *argp2 = 0 ;
+   int res2 = 0 ;
+   char **result = 0 ;
+   
+   if (SWIG_GetArgs(interp, objc, objv,"oo:osgeo::GetProjectionMethodParameterList method username ",(void *)0,(void *)0) == TCL_ERROR) SWIG_fail;
+   res1 = SWIG_AsCharPtrAndSize(objv[1], &buf1, NULL, &alloc1);
+   if (!SWIG_IsOK(res1)) {
+     SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "GetProjectionMethodParameterList" "', argument " "1"" of type '" "char *""'");
+   }
+   arg1 = reinterpret_cast< char * >(buf1);
+   res2 = SWIG_ConvertPtr(objv[2], &argp2,SWIGTYPE_p_p_char, 0 |  0 );
+   if (!SWIG_IsOK(res2)) {
+     SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "GetProjectionMethodParameterList" "', argument " "2"" of type '" "char **""'"); 
+   }
+   arg2 = reinterpret_cast< char ** >(argp2);
+   result = (char **)OPTGetParameterList(arg1,arg2);
+   {
+     /*XXX Test it*/
+     /* %typemap(out) char **CSL */
+     char **stringarray = result;
+     if ( stringarray == NULL ) {
+       Tcl_ResetResult(interp); /* NONE = Empty string */
+     } else {
+       int len = CSLCount( stringarray );
+       Tcl_Obj *out = Tcl_NewListObj(0, NULL);
+       for ( int i = 0; i < len; ++i ) {
+         Tcl_Obj *o = Tcl_NewStringObj( stringarray[i], -1 );
+         if (Tcl_ListObjAppendElement(interp, out, o) != TCL_OK) {
+           Tcl_DecrRefCount(o);
+           Tcl_DecrRefCount(out);
+           /* Error msg in interp result */
+           SWIG_fail;
+         }
+       }
+       CSLDestroy(result);
+       Tcl_SetObjResult(interp, out);
+     }
+   }
+   if (alloc1 == SWIG_NEWOBJ) delete[] buf1;
+   return TCL_OK;
+ fail:
+   if (alloc1 == SWIG_NEWOBJ) delete[] buf1;
+   return TCL_ERROR;
+ }
+ 
+ 
+ SWIGINTERN int
+ _wrap_GetProjectionMethodParamInfo(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
+   char *arg1 = (char *) 0 ;
+   char *arg2 = (char *) 0 ;
+   char **arg3 = (char **) 0 ;
+   char **arg4 = (char **) 0 ;
+   double *arg5 = (double *) 0 ;
+   int res1 ;
+   char *buf1 = 0 ;
+   int alloc1 = 0 ;
+   int res2 ;
+   char *buf2 = 0 ;
+   int alloc2 = 0 ;
+   void *argp3 = 0 ;
+   int res3 = 0 ;
+   void *argp4 = 0 ;
+   int res4 = 0 ;
+   void *argp5 = 0 ;
+   int res5 = 0 ;
+   
+   if (SWIG_GetArgs(interp, objc, objv,"ooooo:osgeo::GetProjectionMethodParamInfo method param usrname type defaultval ",(void *)0,(void *)0,(void *)0,(void *)0,(void *)0) == TCL_ERROR) SWIG_fail;
+   res1 = SWIG_AsCharPtrAndSize(objv[1], &buf1, NULL, &alloc1);
+   if (!SWIG_IsOK(res1)) {
+     SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "GetProjectionMethodParamInfo" "', argument " "1"" of type '" "char *""'");
+   }
+   arg1 = reinterpret_cast< char * >(buf1);
+   res2 = SWIG_AsCharPtrAndSize(objv[2], &buf2, NULL, &alloc2);
+   if (!SWIG_IsOK(res2)) {
+     SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "GetProjectionMethodParamInfo" "', argument " "2"" of type '" "char *""'");
+   }
+   arg2 = reinterpret_cast< char * >(buf2);
+   res3 = SWIG_ConvertPtr(objv[3], &argp3,SWIGTYPE_p_p_char, 0 |  0 );
+   if (!SWIG_IsOK(res3)) {
+     SWIG_exception_fail(SWIG_ArgError(res3), "in method '" "GetProjectionMethodParamInfo" "', argument " "3"" of type '" "char **""'"); 
+   }
+   arg3 = reinterpret_cast< char ** >(argp3);
+   res4 = SWIG_ConvertPtr(objv[4], &argp4,SWIGTYPE_p_p_char, 0 |  0 );
+   if (!SWIG_IsOK(res4)) {
+     SWIG_exception_fail(SWIG_ArgError(res4), "in method '" "GetProjectionMethodParamInfo" "', argument " "4"" of type '" "char **""'"); 
+   }
+   arg4 = reinterpret_cast< char ** >(argp4);
+   res5 = SWIG_ConvertPtr(objv[5], &argp5,SWIGTYPE_p_double, 0 |  0 );
+   if (!SWIG_IsOK(res5)) {
+     SWIG_exception_fail(SWIG_ArgError(res5), "in method '" "GetProjectionMethodParamInfo" "', argument " "5"" of type '" "double *""'"); 
+   }
+   arg5 = reinterpret_cast< double * >(argp5);
+   OPTGetParameterInfo(arg1,arg2,arg3,arg4,arg5);
+   
+   if (alloc1 == SWIG_NEWOBJ) delete[] buf1;
+   if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
+   return TCL_OK;
+ fail:
+   if (alloc1 == SWIG_NEWOBJ) delete[] buf1;
+   if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
+   return TCL_ERROR;
+ }
+ 
+ 
+ SWIGINTERN int
+ _wrap_new_SpatialReference(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
+   char *arg1 = (char *) "" ;
+   int res1 ;
+   char *buf1 = 0 ;
+   int alloc1 = 0 ;
+   OSRSpatialReferenceShadow *result = 0 ;
+   
+   if (SWIG_GetArgs(interp, objc, objv,"|o:osgeo::new_SpatialReference ?wkt? ",(void *)0) == TCL_ERROR) SWIG_fail;
+   if (objc > 1) {
+     res1 = SWIG_AsCharPtrAndSize(objv[1], &buf1, NULL, &alloc1);
+     if (!SWIG_IsOK(res1)) {
+       SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "new_SpatialReference" "', argument " "1"" of type '" "char const *""'");
+     }
+     arg1 = reinterpret_cast< char * >(buf1);
+   }
+   result = (OSRSpatialReferenceShadow *)new_OSRSpatialReferenceShadow((char const *)arg1);
+   Tcl_SetObjResult(interp, SWIG_NewInstanceObj( SWIG_as_voidptr(result), SWIGTYPE_p_OSRSpatialReferenceShadow,0));
+   if (alloc1 == SWIG_NEWOBJ) delete[] buf1;
+   return TCL_OK;
+ fail:
+   if (alloc1 == SWIG_NEWOBJ) delete[] buf1;
+   return TCL_ERROR;
+ }
+ 
+ 
+ SWIGINTERN int
+ _wrap_delete_SpatialReference(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
+   OSRSpatialReferenceShadow *arg1 = (OSRSpatialReferenceShadow *) 0 ;
+   void *argp1 = 0 ;
+   int res1 = 0 ;
+   
+   if (SWIG_GetArgs(interp, objc, objv,"o:osgeo::delete_SpatialReference self ",(void *)0) == TCL_ERROR) SWIG_fail;
+   res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_OSRSpatialReferenceShadow, SWIG_POINTER_DISOWN |  0 );
+   if (!SWIG_IsOK(res1)) {
+     SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "delete_SpatialReference" "', argument " "1"" of type '" "OSRSpatialReferenceShadow *""'"); 
+   }
+   arg1 = reinterpret_cast< OSRSpatialReferenceShadow * >(argp1);
+   delete_OSRSpatialReferenceShadow(arg1);
+   
+   return TCL_OK;
+ fail:
+   return TCL_ERROR;
+ }
+ 
+ 
+ SWIGINTERN int
+ _wrap_SpatialReference___str__(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
+   OSRSpatialReferenceShadow *arg1 = (OSRSpatialReferenceShadow *) 0 ;
+   void *argp1 = 0 ;
+   int res1 = 0 ;
+   char *result = 0 ;
+   
+   if (SWIG_GetArgs(interp, objc, objv,"o:osgeo::SpatialReference___str__ self ",(void *)0) == TCL_ERROR) SWIG_fail;
+   res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_OSRSpatialReferenceShadow, 0 |  0 );
+   if (!SWIG_IsOK(res1)) {
+     SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SpatialReference___str__" "', argument " "1"" of type '" "OSRSpatialReferenceShadow *""'"); 
+   }
+   arg1 = reinterpret_cast< OSRSpatialReferenceShadow * >(argp1);
+   result = (char *)OSRSpatialReferenceShadow___str__(arg1);
+   Tcl_SetObjResult(interp,SWIG_FromCharPtr((const char *)result));
+   delete[] result;
+   return TCL_OK;
+ fail:
+   return TCL_ERROR;
+ }
+ 
+ 
+ SWIGINTERN int
+ _wrap_SpatialReference_IsSame(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
+   OSRSpatialReferenceShadow *arg1 = (OSRSpatialReferenceShadow *) 0 ;
+   OSRSpatialReferenceShadow *arg2 = (OSRSpatialReferenceShadow *) 0 ;
+   void *argp1 = 0 ;
+   int res1 = 0 ;
+   void *argp2 = 0 ;
+   int res2 = 0 ;
+   int result;
+   
+   if (SWIG_GetArgs(interp, objc, objv,"oo:osgeo::SpatialReference_IsSame self rhs ",(void *)0,(void *)0) == TCL_ERROR) SWIG_fail;
+   res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_OSRSpatialReferenceShadow, 0 |  0 );
+   if (!SWIG_IsOK(res1)) {
+     SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SpatialReference_IsSame" "', argument " "1"" of type '" "OSRSpatialReferenceShadow *""'"); 
+   }
+   arg1 = reinterpret_cast< OSRSpatialReferenceShadow * >(argp1);
+   res2 = SWIG_ConvertPtr(objv[2], &argp2,SWIGTYPE_p_OSRSpatialReferenceShadow, 0 |  0 );
+   if (!SWIG_IsOK(res2)) {
+     SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "SpatialReference_IsSame" "', argument " "2"" of type '" "OSRSpatialReferenceShadow *""'"); 
+   }
+   arg2 = reinterpret_cast< OSRSpatialReferenceShadow * >(argp2);
+   result = (int)OSRSpatialReferenceShadow_IsSame(arg1,arg2);
+   Tcl_SetObjResult(interp,SWIG_From_int(static_cast< int >(result)));
+   return TCL_OK;
+ fail:
+   return TCL_ERROR;
+ }
+ 
+ 
+ SWIGINTERN int
+ _wrap_SpatialReference_IsSameGeogCS(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
+   OSRSpatialReferenceShadow *arg1 = (OSRSpatialReferenceShadow *) 0 ;
+   OSRSpatialReferenceShadow *arg2 = (OSRSpatialReferenceShadow *) 0 ;
+   void *argp1 = 0 ;
+   int res1 = 0 ;
+   void *argp2 = 0 ;
+   int res2 = 0 ;
+   int result;
+   
+   if (SWIG_GetArgs(interp, objc, objv,"oo:osgeo::SpatialReference_IsSameGeogCS self rhs ",(void *)0,(void *)0) == TCL_ERROR) SWIG_fail;
+   res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_OSRSpatialReferenceShadow, 0 |  0 );
+   if (!SWIG_IsOK(res1)) {
+     SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SpatialReference_IsSameGeogCS" "', argument " "1"" of type '" "OSRSpatialReferenceShadow *""'"); 
+   }
+   arg1 = reinterpret_cast< OSRSpatialReferenceShadow * >(argp1);
+   res2 = SWIG_ConvertPtr(objv[2], &argp2,SWIGTYPE_p_OSRSpatialReferenceShadow, 0 |  0 );
+   if (!SWIG_IsOK(res2)) {
+     SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "SpatialReference_IsSameGeogCS" "', argument " "2"" of type '" "OSRSpatialReferenceShadow *""'"); 
+   }
+   arg2 = reinterpret_cast< OSRSpatialReferenceShadow * >(argp2);
+   result = (int)OSRSpatialReferenceShadow_IsSameGeogCS(arg1,arg2);
+   Tcl_SetObjResult(interp,SWIG_From_int(static_cast< int >(result)));
+   return TCL_OK;
+ fail:
+   return TCL_ERROR;
+ }
+ 
+ 
+ SWIGINTERN int
+ _wrap_SpatialReference_IsGeographic(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
+   OSRSpatialReferenceShadow *arg1 = (OSRSpatialReferenceShadow *) 0 ;
+   void *argp1 = 0 ;
+   int res1 = 0 ;
+   int result;
+   
+   if (SWIG_GetArgs(interp, objc, objv,"o:osgeo::SpatialReference_IsGeographic self ",(void *)0) == TCL_ERROR) SWIG_fail;
+   res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_OSRSpatialReferenceShadow, 0 |  0 );
+   if (!SWIG_IsOK(res1)) {
+     SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SpatialReference_IsGeographic" "', argument " "1"" of type '" "OSRSpatialReferenceShadow *""'"); 
+   }
+   arg1 = reinterpret_cast< OSRSpatialReferenceShadow * >(argp1);
+   result = (int)OSRSpatialReferenceShadow_IsGeographic(arg1);
+   Tcl_SetObjResult(interp,SWIG_From_int(static_cast< int >(result)));
+   return TCL_OK;
+ fail:
+   return TCL_ERROR;
+ }
+ 
+ 
+ SWIGINTERN int
+ _wrap_SpatialReference_IsProjected(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
+   OSRSpatialReferenceShadow *arg1 = (OSRSpatialReferenceShadow *) 0 ;
+   void *argp1 = 0 ;
+   int res1 = 0 ;
+   int result;
+   
+   if (SWIG_GetArgs(interp, objc, objv,"o:osgeo::SpatialReference_IsProjected self ",(void *)0) == TCL_ERROR) SWIG_fail;
+   res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_OSRSpatialReferenceShadow, 0 |  0 );
+   if (!SWIG_IsOK(res1)) {
+     SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SpatialReference_IsProjected" "', argument " "1"" of type '" "OSRSpatialReferenceShadow *""'"); 
+   }
+   arg1 = reinterpret_cast< OSRSpatialReferenceShadow * >(argp1);
+   result = (int)OSRSpatialReferenceShadow_IsProjected(arg1);
+   Tcl_SetObjResult(interp,SWIG_From_int(static_cast< int >(result)));
+   return TCL_OK;
+ fail:
+   return TCL_ERROR;
+ }
+ 
+ 
+ SWIGINTERN int
+ _wrap_SpatialReference_IsLocal(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
+   OSRSpatialReferenceShadow *arg1 = (OSRSpatialReferenceShadow *) 0 ;
+   void *argp1 = 0 ;
+   int res1 = 0 ;
+   int result;
+   
+   if (SWIG_GetArgs(interp, objc, objv,"o:osgeo::SpatialReference_IsLocal self ",(void *)0) == TCL_ERROR) SWIG_fail;
+   res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_OSRSpatialReferenceShadow, 0 |  0 );
+   if (!SWIG_IsOK(res1)) {
+     SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SpatialReference_IsLocal" "', argument " "1"" of type '" "OSRSpatialReferenceShadow *""'"); 
+   }
+   arg1 = reinterpret_cast< OSRSpatialReferenceShadow * >(argp1);
+   result = (int)OSRSpatialReferenceShadow_IsLocal(arg1);
+   Tcl_SetObjResult(interp,SWIG_From_int(static_cast< int >(result)));
+   return TCL_OK;
+ fail:
+   return TCL_ERROR;
+ }
+ 
+ 
+ SWIGINTERN int
+ _wrap_SpatialReference_SetAuthority(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
+   OSRSpatialReferenceShadow *arg1 = (OSRSpatialReferenceShadow *) 0 ;
+   char *arg2 = (char *) 0 ;
+   char *arg3 = (char *) 0 ;
+   int arg4 ;
+   void *argp1 = 0 ;
+   int res1 = 0 ;
+   int res2 ;
+   char *buf2 = 0 ;
+   int alloc2 = 0 ;
+   int res3 ;
+   char *buf3 = 0 ;
+   int alloc3 = 0 ;
+   int val4 ;
+   int ecode4 = 0 ;
+   OGRErr result;
+   
+   if (SWIG_GetArgs(interp, objc, objv,"oooo:osgeo::SpatialReference_SetAuthority self pszTargetKey pszAuthority nCode ",(void *)0,(void *)0,(void *)0,(void *)0) == TCL_ERROR) SWIG_fail;
+   res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_OSRSpatialReferenceShadow, 0 |  0 );
+   if (!SWIG_IsOK(res1)) {
+     SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SpatialReference_SetAuthority" "', argument " "1"" of type '" "OSRSpatialReferenceShadow *""'"); 
+   }
+   arg1 = reinterpret_cast< OSRSpatialReferenceShadow * >(argp1);
+   res2 = SWIG_AsCharPtrAndSize(objv[2], &buf2, NULL, &alloc2);
+   if (!SWIG_IsOK(res2)) {
+     SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "SpatialReference_SetAuthority" "', argument " "2"" of type '" "char const *""'");
+   }
+   arg2 = reinterpret_cast< char * >(buf2);
+   res3 = SWIG_AsCharPtrAndSize(objv[3], &buf3, NULL, &alloc3);
+   if (!SWIG_IsOK(res3)) {
+     SWIG_exception_fail(SWIG_ArgError(res3), "in method '" "SpatialReference_SetAuthority" "', argument " "3"" of type '" "char const *""'");
+   }
+   arg3 = reinterpret_cast< char * >(buf3);
+   ecode4 = SWIG_AsVal_int SWIG_TCL_CALL_ARGS_2(objv[4], &val4);
+   if (!SWIG_IsOK(ecode4)) {
+     SWIG_exception_fail(SWIG_ArgError(ecode4), "in method '" "SpatialReference_SetAuthority" "', argument " "4"" of type '" "int""'");
+   } 
+   arg4 = static_cast< int >(val4);
+   result = (OGRErr)OSRSpatialReferenceShadow_SetAuthority(arg1,(char const *)arg2,(char const *)arg3,arg4);
+   {
+     /* %typemap(out) OGRErr */
+     if (result != 0) {
+       Tcl_SetResult(interp, (char*) OGRErrMessages(result), TCL_STATIC);
+       SWIG_fail;
+     }
+   }
+   if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
+   if (alloc3 == SWIG_NEWOBJ) delete[] buf3;
+   {
+     /* %typemap(ret) OGRErr */
+     if (!strcmp(Tcl_GetStringResult(interp), "{}") || !strcmp(Tcl_GetStringResult(interp), "")) {
+       Tcl_SetObjResult(interp, Tcl_NewLongObj( result ));
+     }
+   }
+   return TCL_OK;
+ fail:
+   if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
+   if (alloc3 == SWIG_NEWOBJ) delete[] buf3;
+   return TCL_ERROR;
+ }
+ 
+ 
+ SWIGINTERN int
+ _wrap_SpatialReference_GetAttrValue(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
+   OSRSpatialReferenceShadow *arg1 = (OSRSpatialReferenceShadow *) 0 ;
+   char *arg2 = (char *) 0 ;
+   int arg3 = (int) 0 ;
+   void *argp1 = 0 ;
+   int res1 = 0 ;
+   int res2 ;
+   char *buf2 = 0 ;
+   int alloc2 = 0 ;
+   int val3 ;
+   int ecode3 = 0 ;
+   char *result = 0 ;
+   
+   if (SWIG_GetArgs(interp, objc, objv,"oo|o:osgeo::SpatialReference_GetAttrValue self name ?child? ",(void *)0,(void *)0,(void *)0) == TCL_ERROR) SWIG_fail;
+   res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_OSRSpatialReferenceShadow, 0 |  0 );
+   if (!SWIG_IsOK(res1)) {
+     SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SpatialReference_GetAttrValue" "', argument " "1"" of type '" "OSRSpatialReferenceShadow *""'"); 
+   }
+   arg1 = reinterpret_cast< OSRSpatialReferenceShadow * >(argp1);
+   res2 = SWIG_AsCharPtrAndSize(objv[2], &buf2, NULL, &alloc2);
+   if (!SWIG_IsOK(res2)) {
+     SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "SpatialReference_GetAttrValue" "', argument " "2"" of type '" "char const *""'");
+   }
+   arg2 = reinterpret_cast< char * >(buf2);
+   if (objc > 3) {
+     ecode3 = SWIG_AsVal_int SWIG_TCL_CALL_ARGS_2(objv[3], &val3);
+     if (!SWIG_IsOK(ecode3)) {
+       SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "SpatialReference_GetAttrValue" "', argument " "3"" of type '" "int""'");
+     } 
+     arg3 = static_cast< int >(val3);
+   }
+   result = (char *)OSRSpatialReferenceShadow_GetAttrValue(arg1,(char const *)arg2,arg3);
+   Tcl_SetObjResult(interp,SWIG_FromCharPtr((const char *)result));
+   if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
+   return TCL_OK;
+ fail:
+   if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
+   return TCL_ERROR;
+ }
+ 
+ 
+ SWIGINTERN int
+ _wrap_SpatialReference_SetAttrValue(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
+   OSRSpatialReferenceShadow *arg1 = (OSRSpatialReferenceShadow *) 0 ;
+   char *arg2 = (char *) 0 ;
+   char *arg3 = (char *) 0 ;
+   void *argp1 = 0 ;
+   int res1 = 0 ;
+   int res2 ;
+   char *buf2 = 0 ;
+   int alloc2 = 0 ;
+   int res3 ;
+   char *buf3 = 0 ;
+   int alloc3 = 0 ;
+   OGRErr result;
+   
+   if (SWIG_GetArgs(interp, objc, objv,"ooo:osgeo::SpatialReference_SetAttrValue self name value ",(void *)0,(void *)0,(void *)0) == TCL_ERROR) SWIG_fail;
+   res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_OSRSpatialReferenceShadow, 0 |  0 );
+   if (!SWIG_IsOK(res1)) {
+     SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SpatialReference_SetAttrValue" "', argument " "1"" of type '" "OSRSpatialReferenceShadow *""'"); 
+   }
+   arg1 = reinterpret_cast< OSRSpatialReferenceShadow * >(argp1);
+   res2 = SWIG_AsCharPtrAndSize(objv[2], &buf2, NULL, &alloc2);
+   if (!SWIG_IsOK(res2)) {
+     SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "SpatialReference_SetAttrValue" "', argument " "2"" of type '" "char const *""'");
+   }
+   arg2 = reinterpret_cast< char * >(buf2);
+   res3 = SWIG_AsCharPtrAndSize(objv[3], &buf3, NULL, &alloc3);
+   if (!SWIG_IsOK(res3)) {
+     SWIG_exception_fail(SWIG_ArgError(res3), "in method '" "SpatialReference_SetAttrValue" "', argument " "3"" of type '" "char const *""'");
+   }
+   arg3 = reinterpret_cast< char * >(buf3);
+   result = (OGRErr)OSRSpatialReferenceShadow_SetAttrValue(arg1,(char const *)arg2,(char const *)arg3);
+   {
+     /* %typemap(out) OGRErr */
+     if (result != 0) {
+       Tcl_SetResult(interp, (char*) OGRErrMessages(result), TCL_STATIC);
+       SWIG_fail;
+     }
+   }
+   if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
+   if (alloc3 == SWIG_NEWOBJ) delete[] buf3;
+   {
+     /* %typemap(ret) OGRErr */
+     if (!strcmp(Tcl_GetStringResult(interp), "{}") || !strcmp(Tcl_GetStringResult(interp), "")) {
+       Tcl_SetObjResult(interp, Tcl_NewLongObj( result ));
+     }
+   }
+   return TCL_OK;
+ fail:
+   if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
+   if (alloc3 == SWIG_NEWOBJ) delete[] buf3;
+   return TCL_ERROR;
+ }
+ 
+ 
+ SWIGINTERN int
+ _wrap_SpatialReference_SetAngularUnits(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
+   OSRSpatialReferenceShadow *arg1 = (OSRSpatialReferenceShadow *) 0 ;
+   char *arg2 = (char *) 0 ;
+   double arg3 ;
+   void *argp1 = 0 ;
+   int res1 = 0 ;
+   int res2 ;
+   char *buf2 = 0 ;
+   int alloc2 = 0 ;
+   double val3 ;
+   int ecode3 = 0 ;
+   OGRErr result;
+   
+   if (SWIG_GetArgs(interp, objc, objv,"ooo:osgeo::SpatialReference_SetAngularUnits self name to_radians ",(void *)0,(void *)0,(void *)0) == TCL_ERROR) SWIG_fail;
+   res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_OSRSpatialReferenceShadow, 0 |  0 );
+   if (!SWIG_IsOK(res1)) {
+     SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SpatialReference_SetAngularUnits" "', argument " "1"" of type '" "OSRSpatialReferenceShadow *""'"); 
+   }
+   arg1 = reinterpret_cast< OSRSpatialReferenceShadow * >(argp1);
+   res2 = SWIG_AsCharPtrAndSize(objv[2], &buf2, NULL, &alloc2);
+   if (!SWIG_IsOK(res2)) {
+     SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "SpatialReference_SetAngularUnits" "', argument " "2"" of type '" "char const *""'");
+   }
+   arg2 = reinterpret_cast< char * >(buf2);
+   ecode3 = SWIG_AsVal_double SWIG_TCL_CALL_ARGS_2(objv[3], &val3);
+   if (!SWIG_IsOK(ecode3)) {
+     SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "SpatialReference_SetAngularUnits" "', argument " "3"" of type '" "double""'");
+   } 
+   arg3 = static_cast< double >(val3);
+   result = (OGRErr)OSRSpatialReferenceShadow_SetAngularUnits(arg1,(char const *)arg2,arg3);
+   {
+     /* %typemap(out) OGRErr */
+     if (result != 0) {
+       Tcl_SetResult(interp, (char*) OGRErrMessages(result), TCL_STATIC);
+       SWIG_fail;
+     }
+   }
+   if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
+   {
+     /* %typemap(ret) OGRErr */
+     if (!strcmp(Tcl_GetStringResult(interp), "{}") || !strcmp(Tcl_GetStringResult(interp), "")) {
+       Tcl_SetObjResult(interp, Tcl_NewLongObj( result ));
+     }
+   }
+   return TCL_OK;
+ fail:
+   if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
+   return TCL_ERROR;
+ }
+ 
+ 
+ SWIGINTERN int
+ _wrap_SpatialReference_GetAngularUnits(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
+   OSRSpatialReferenceShadow *arg1 = (OSRSpatialReferenceShadow *) 0 ;
+   void *argp1 = 0 ;
+   int res1 = 0 ;
+   double result;
+   
+   if (SWIG_GetArgs(interp, objc, objv,"o:osgeo::SpatialReference_GetAngularUnits self ",(void *)0) == TCL_ERROR) SWIG_fail;
+   res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_OSRSpatialReferenceShadow, 0 |  0 );
+   if (!SWIG_IsOK(res1)) {
+     SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SpatialReference_GetAngularUnits" "', argument " "1"" of type '" "OSRSpatialReferenceShadow *""'"); 
+   }
+   arg1 = reinterpret_cast< OSRSpatialReferenceShadow * >(argp1);
+   result = (double)OSRSpatialReferenceShadow_GetAngularUnits(arg1);
+   Tcl_SetObjResult(interp,SWIG_From_double(static_cast< double >(result)));
+   return TCL_OK;
+ fail:
+   return TCL_ERROR;
+ }
+ 
+ 
+ SWIGINTERN int
+ _wrap_SpatialReference_SetLinearUnits(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
+   OSRSpatialReferenceShadow *arg1 = (OSRSpatialReferenceShadow *) 0 ;
+   char *arg2 = (char *) 0 ;
+   double arg3 ;
+   void *argp1 = 0 ;
+   int res1 = 0 ;
+   int res2 ;
+   char *buf2 = 0 ;
+   int alloc2 = 0 ;
+   double val3 ;
+   int ecode3 = 0 ;
+   OGRErr result;
+   
+   if (SWIG_GetArgs(interp, objc, objv,"ooo:osgeo::SpatialReference_SetLinearUnits self name to_meters ",(void *)0,(void *)0,(void *)0) == TCL_ERROR) SWIG_fail;
+   res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_OSRSpatialReferenceShadow, 0 |  0 );
+   if (!SWIG_IsOK(res1)) {
+     SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SpatialReference_SetLinearUnits" "', argument " "1"" of type '" "OSRSpatialReferenceShadow *""'"); 
+   }
+   arg1 = reinterpret_cast< OSRSpatialReferenceShadow * >(argp1);
+   res2 = SWIG_AsCharPtrAndSize(objv[2], &buf2, NULL, &alloc2);
+   if (!SWIG_IsOK(res2)) {
+     SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "SpatialReference_SetLinearUnits" "', argument " "2"" of type '" "char const *""'");
+   }
+   arg2 = reinterpret_cast< char * >(buf2);
+   ecode3 = SWIG_AsVal_double SWIG_TCL_CALL_ARGS_2(objv[3], &val3);
+   if (!SWIG_IsOK(ecode3)) {
+     SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "SpatialReference_SetLinearUnits" "', argument " "3"" of type '" "double""'");
+   } 
+   arg3 = static_cast< double >(val3);
+   result = (OGRErr)OSRSpatialReferenceShadow_SetLinearUnits(arg1,(char const *)arg2,arg3);
+   {
+     /* %typemap(out) OGRErr */
+     if (result != 0) {
+       Tcl_SetResult(interp, (char*) OGRErrMessages(result), TCL_STATIC);
+       SWIG_fail;
+     }
+   }
+   if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
+   {
+     /* %typemap(ret) OGRErr */
+     if (!strcmp(Tcl_GetStringResult(interp), "{}") || !strcmp(Tcl_GetStringResult(interp), "")) {
+       Tcl_SetObjResult(interp, Tcl_NewLongObj( result ));
+     }
+   }
+   return TCL_OK;
+ fail:
+   if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
+   return TCL_ERROR;
+ }
+ 
+ 
+ SWIGINTERN int
+ _wrap_SpatialReference_SetLinearUnitsAndUpdateParameters(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
+   OSRSpatialReferenceShadow *arg1 = (OSRSpatialReferenceShadow *) 0 ;
+   char *arg2 = (char *) 0 ;
+   double arg3 ;
+   void *argp1 = 0 ;
+   int res1 = 0 ;
+   int res2 ;
+   char *buf2 = 0 ;
+   int alloc2 = 0 ;
+   double val3 ;
+   int ecode3 = 0 ;
+   OGRErr result;
+   
+   if (SWIG_GetArgs(interp, objc, objv,"ooo:osgeo::SpatialReference_SetLinearUnitsAndUpdateParameters self name to_meters ",(void *)0,(void *)0,(void *)0) == TCL_ERROR) SWIG_fail;
+   res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_OSRSpatialReferenceShadow, 0 |  0 );
+   if (!SWIG_IsOK(res1)) {
+     SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SpatialReference_SetLinearUnitsAndUpdateParameters" "', argument " "1"" of type '" "OSRSpatialReferenceShadow *""'"); 
+   }
+   arg1 = reinterpret_cast< OSRSpatialReferenceShadow * >(argp1);
+   res2 = SWIG_AsCharPtrAndSize(objv[2], &buf2, NULL, &alloc2);
+   if (!SWIG_IsOK(res2)) {
+     SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "SpatialReference_SetLinearUnitsAndUpdateParameters" "', argument " "2"" of type '" "char const *""'");
+   }
+   arg2 = reinterpret_cast< char * >(buf2);
+   ecode3 = SWIG_AsVal_double SWIG_TCL_CALL_ARGS_2(objv[3], &val3);
+   if (!SWIG_IsOK(ecode3)) {
+     SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "SpatialReference_SetLinearUnitsAndUpdateParameters" "', argument " "3"" of type '" "double""'");
+   } 
+   arg3 = static_cast< double >(val3);
+   result = (OGRErr)OSRSpatialReferenceShadow_SetLinearUnitsAndUpdateParameters(arg1,(char const *)arg2,arg3);
+   {
+     /* %typemap(out) OGRErr */
+     if (result != 0) {
+       Tcl_SetResult(interp, (char*) OGRErrMessages(result), TCL_STATIC);
+       SWIG_fail;
+     }
+   }
+   if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
+   {
+     /* %typemap(ret) OGRErr */
+     if (!strcmp(Tcl_GetStringResult(interp), "{}") || !strcmp(Tcl_GetStringResult(interp), "")) {
+       Tcl_SetObjResult(interp, Tcl_NewLongObj( result ));
+     }
+   }
+   return TCL_OK;
+ fail:
+   if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
+   return TCL_ERROR;
+ }
+ 
+ 
+ SWIGINTERN int
+ _wrap_SpatialReference_GetLinearUnits(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
+   OSRSpatialReferenceShadow *arg1 = (OSRSpatialReferenceShadow *) 0 ;
+   void *argp1 = 0 ;
+   int res1 = 0 ;
+   double result;
+   
+   if (SWIG_GetArgs(interp, objc, objv,"o:osgeo::SpatialReference_GetLinearUnits self ",(void *)0) == TCL_ERROR) SWIG_fail;
+   res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_OSRSpatialReferenceShadow, 0 |  0 );
+   if (!SWIG_IsOK(res1)) {
+     SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SpatialReference_GetLinearUnits" "', argument " "1"" of type '" "OSRSpatialReferenceShadow *""'"); 
+   }
+   arg1 = reinterpret_cast< OSRSpatialReferenceShadow * >(argp1);
+   result = (double)OSRSpatialReferenceShadow_GetLinearUnits(arg1);
+   Tcl_SetObjResult(interp,SWIG_From_double(static_cast< double >(result)));
+   return TCL_OK;
+ fail:
+   return TCL_ERROR;
+ }
+ 
+ 
+ SWIGINTERN int
+ _wrap_SpatialReference_GetLinearUnitsName(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
+   OSRSpatialReferenceShadow *arg1 = (OSRSpatialReferenceShadow *) 0 ;
+   void *argp1 = 0 ;
+   int res1 = 0 ;
+   char *result = 0 ;
+   
+   if (SWIG_GetArgs(interp, objc, objv,"o:osgeo::SpatialReference_GetLinearUnitsName self ",(void *)0) == TCL_ERROR) SWIG_fail;
+   res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_OSRSpatialReferenceShadow, 0 |  0 );
+   if (!SWIG_IsOK(res1)) {
+     SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SpatialReference_GetLinearUnitsName" "', argument " "1"" of type '" "OSRSpatialReferenceShadow *""'"); 
+   }
+   arg1 = reinterpret_cast< OSRSpatialReferenceShadow * >(argp1);
+   result = (char *)OSRSpatialReferenceShadow_GetLinearUnitsName(arg1);
+   Tcl_SetObjResult(interp,SWIG_FromCharPtr((const char *)result));
+   return TCL_OK;
+ fail:
+   return TCL_ERROR;
+ }
+ 
+ 
+ SWIGINTERN int
+ _wrap_SpatialReference_GetAuthorityCode(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
+   OSRSpatialReferenceShadow *arg1 = (OSRSpatialReferenceShadow *) 0 ;
+   char *arg2 = (char *) 0 ;
+   void *argp1 = 0 ;
+   int res1 = 0 ;
+   int res2 ;
+   char *buf2 = 0 ;
+   int alloc2 = 0 ;
+   char *result = 0 ;
+   
+   if (SWIG_GetArgs(interp, objc, objv,"oo:osgeo::SpatialReference_GetAuthorityCode self target_key ",(void *)0,(void *)0) == TCL_ERROR) SWIG_fail;
+   res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_OSRSpatialReferenceShadow, 0 |  0 );
+   if (!SWIG_IsOK(res1)) {
+     SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SpatialReference_GetAuthorityCode" "', argument " "1"" of type '" "OSRSpatialReferenceShadow *""'"); 
+   }
+   arg1 = reinterpret_cast< OSRSpatialReferenceShadow * >(argp1);
+   res2 = SWIG_AsCharPtrAndSize(objv[2], &buf2, NULL, &alloc2);
+   if (!SWIG_IsOK(res2)) {
+     SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "SpatialReference_GetAuthorityCode" "', argument " "2"" of type '" "char const *""'");
+   }
+   arg2 = reinterpret_cast< char * >(buf2);
+   result = (char *)OSRSpatialReferenceShadow_GetAuthorityCode(arg1,(char const *)arg2);
+   Tcl_SetObjResult(interp,SWIG_FromCharPtr((const char *)result));
+   if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
+   return TCL_OK;
+ fail:
+   if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
+   return TCL_ERROR;
+ }
+ 
+ 
+ SWIGINTERN int
+ _wrap_SpatialReference_GetAuthorityName(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
+   OSRSpatialReferenceShadow *arg1 = (OSRSpatialReferenceShadow *) 0 ;
+   char *arg2 = (char *) 0 ;
+   void *argp1 = 0 ;
+   int res1 = 0 ;
+   int res2 ;
+   char *buf2 = 0 ;
+   int alloc2 = 0 ;
+   char *result = 0 ;
+   
+   if (SWIG_GetArgs(interp, objc, objv,"oo:osgeo::SpatialReference_GetAuthorityName self target_key ",(void *)0,(void *)0) == TCL_ERROR) SWIG_fail;
+   res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_OSRSpatialReferenceShadow, 0 |  0 );
+   if (!SWIG_IsOK(res1)) {
+     SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SpatialReference_GetAuthorityName" "', argument " "1"" of type '" "OSRSpatialReferenceShadow *""'"); 
+   }
+   arg1 = reinterpret_cast< OSRSpatialReferenceShadow * >(argp1);
+   res2 = SWIG_AsCharPtrAndSize(objv[2], &buf2, NULL, &alloc2);
+   if (!SWIG_IsOK(res2)) {
+     SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "SpatialReference_GetAuthorityName" "', argument " "2"" of type '" "char const *""'");
+   }
+   arg2 = reinterpret_cast< char * >(buf2);
+   result = (char *)OSRSpatialReferenceShadow_GetAuthorityName(arg1,(char const *)arg2);
+   Tcl_SetObjResult(interp,SWIG_FromCharPtr((const char *)result));
+   if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
+   return TCL_OK;
+ fail:
+   if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
+   return TCL_ERROR;
+ }
+ 
+ 
+ SWIGINTERN int
+ _wrap_SpatialReference_SetUTM(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
+   OSRSpatialReferenceShadow *arg1 = (OSRSpatialReferenceShadow *) 0 ;
+   int arg2 ;
+   int arg3 = (int) 1 ;
+   void *argp1 = 0 ;
+   int res1 = 0 ;
+   int val2 ;
+   int ecode2 = 0 ;
+   int val3 ;
+   int ecode3 = 0 ;
+   OGRErr result;
+   
+   if (SWIG_GetArgs(interp, objc, objv,"oo|o:osgeo::SpatialReference_SetUTM self zone ?north? ",(void *)0,(void *)0,(void *)0) == TCL_ERROR) SWIG_fail;
+   res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_OSRSpatialReferenceShadow, 0 |  0 );
+   if (!SWIG_IsOK(res1)) {
+     SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SpatialReference_SetUTM" "', argument " "1"" of type '" "OSRSpatialReferenceShadow *""'"); 
+   }
+   arg1 = reinterpret_cast< OSRSpatialReferenceShadow * >(argp1);
+   ecode2 = SWIG_AsVal_int SWIG_TCL_CALL_ARGS_2(objv[2], &val2);
+   if (!SWIG_IsOK(ecode2)) {
+     SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "SpatialReference_SetUTM" "', argument " "2"" of type '" "int""'");
+   } 
+   arg2 = static_cast< int >(val2);
+   if (objc > 3) {
+     ecode3 = SWIG_AsVal_int SWIG_TCL_CALL_ARGS_2(objv[3], &val3);
+     if (!SWIG_IsOK(ecode3)) {
+       SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "SpatialReference_SetUTM" "', argument " "3"" of type '" "int""'");
+     } 
+     arg3 = static_cast< int >(val3);
+   }
+   result = (OGRErr)OSRSpatialReferenceShadow_SetUTM(arg1,arg2,arg3);
+   {
+     /* %typemap(out) OGRErr */
+     if (result != 0) {
+       Tcl_SetResult(interp, (char*) OGRErrMessages(result), TCL_STATIC);
+       SWIG_fail;
+     }
+   }
+   {
+     /* %typemap(ret) OGRErr */
+     if (!strcmp(Tcl_GetStringResult(interp), "{}") || !strcmp(Tcl_GetStringResult(interp), "")) {
+       Tcl_SetObjResult(interp, Tcl_NewLongObj( result ));
+     }
+   }
+   return TCL_OK;
+ fail:
+   return TCL_ERROR;
+ }
+ 
+ 
+ SWIGINTERN int
+ _wrap_SpatialReference_SetStatePlane(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
+   OSRSpatialReferenceShadow *arg1 = (OSRSpatialReferenceShadow *) 0 ;
+   int arg2 ;
+   int arg3 = (int) 1 ;
+   char *arg4 = (char *) "" ;
+   double arg5 = (double) 0.0 ;
+   void *argp1 = 0 ;
+   int res1 = 0 ;
+   int val2 ;
+   int ecode2 = 0 ;
+   int val3 ;
+   int ecode3 = 0 ;
+   int res4 ;
+   char *buf4 = 0 ;
+   int alloc4 = 0 ;
+   double val5 ;
+   int ecode5 = 0 ;
+   OGRErr result;
+   
+   if (SWIG_GetArgs(interp, objc, objv,"oo|ooo:osgeo::SpatialReference_SetStatePlane self zone ?is_nad83? ?unitsname? ?units? ",(void *)0,(void *)0,(void *)0,(void *)0,(void *)0) == TCL_ERROR) SWIG_fail;
+   res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_OSRSpatialReferenceShadow, 0 |  0 );
+   if (!SWIG_IsOK(res1)) {
+     SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SpatialReference_SetStatePlane" "', argument " "1"" of type '" "OSRSpatialReferenceShadow *""'"); 
+   }
+   arg1 = reinterpret_cast< OSRSpatialReferenceShadow * >(argp1);
+   ecode2 = SWIG_AsVal_int SWIG_TCL_CALL_ARGS_2(objv[2], &val2);
+   if (!SWIG_IsOK(ecode2)) {
+     SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "SpatialReference_SetStatePlane" "', argument " "2"" of type '" "int""'");
+   } 
+   arg2 = static_cast< int >(val2);
+   if (objc > 3) {
+     ecode3 = SWIG_AsVal_int SWIG_TCL_CALL_ARGS_2(objv[3], &val3);
+     if (!SWIG_IsOK(ecode3)) {
+       SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "SpatialReference_SetStatePlane" "', argument " "3"" of type '" "int""'");
+     } 
+     arg3 = static_cast< int >(val3);
+   }
+   if (objc > 4) {
+     res4 = SWIG_AsCharPtrAndSize(objv[4], &buf4, NULL, &alloc4);
+     if (!SWIG_IsOK(res4)) {
+       SWIG_exception_fail(SWIG_ArgError(res4), "in method '" "SpatialReference_SetStatePlane" "', argument " "4"" of type '" "char const *""'");
+     }
+     arg4 = reinterpret_cast< char * >(buf4);
+   }
+   if (objc > 5) {
+     ecode5 = SWIG_AsVal_double SWIG_TCL_CALL_ARGS_2(objv[5], &val5);
+     if (!SWIG_IsOK(ecode5)) {
+       SWIG_exception_fail(SWIG_ArgError(ecode5), "in method '" "SpatialReference_SetStatePlane" "', argument " "5"" of type '" "double""'");
+     } 
+     arg5 = static_cast< double >(val5);
+   }
+   result = (OGRErr)OSRSpatialReferenceShadow_SetStatePlane(arg1,arg2,arg3,(char const *)arg4,arg5);
+   {
+     /* %typemap(out) OGRErr */
+     if (result != 0) {
+       Tcl_SetResult(interp, (char*) OGRErrMessages(result), TCL_STATIC);
+       SWIG_fail;
+     }
+   }
+   if (alloc4 == SWIG_NEWOBJ) delete[] buf4;
+   {
+     /* %typemap(ret) OGRErr */
+     if (!strcmp(Tcl_GetStringResult(interp), "{}") || !strcmp(Tcl_GetStringResult(interp), "")) {
+       Tcl_SetObjResult(interp, Tcl_NewLongObj( result ));
+     }
+   }
+   return TCL_OK;
+ fail:
+   if (alloc4 == SWIG_NEWOBJ) delete[] buf4;
+   return TCL_ERROR;
+ }
+ 
+ 
+ SWIGINTERN int
+ _wrap_SpatialReference_AutoIdentifyEPSG(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
+   OSRSpatialReferenceShadow *arg1 = (OSRSpatialReferenceShadow *) 0 ;
+   void *argp1 = 0 ;
+   int res1 = 0 ;
+   OGRErr result;
+   
+   if (SWIG_GetArgs(interp, objc, objv,"o:osgeo::SpatialReference_AutoIdentifyEPSG self ",(void *)0) == TCL_ERROR) SWIG_fail;
+   res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_OSRSpatialReferenceShadow, 0 |  0 );
+   if (!SWIG_IsOK(res1)) {
+     SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SpatialReference_AutoIdentifyEPSG" "', argument " "1"" of type '" "OSRSpatialReferenceShadow *""'"); 
+   }
+   arg1 = reinterpret_cast< OSRSpatialReferenceShadow * >(argp1);
+   result = (OGRErr)OSRSpatialReferenceShadow_AutoIdentifyEPSG(arg1);
+   {
+     /* %typemap(out) OGRErr */
+     if (result != 0) {
+       Tcl_SetResult(interp, (char*) OGRErrMessages(result), TCL_STATIC);
+       SWIG_fail;
+     }
+   }
+   {
+     /* %typemap(ret) OGRErr */
+     if (!strcmp(Tcl_GetStringResult(interp), "{}") || !strcmp(Tcl_GetStringResult(interp), "")) {
+       Tcl_SetObjResult(interp, Tcl_NewLongObj( result ));
+     }
+   }
+   return TCL_OK;
+ fail:
+   return TCL_ERROR;
+ }
+ 
+ 
+ SWIGINTERN int
+ _wrap_SpatialReference_SetProjection(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
+   OSRSpatialReferenceShadow *arg1 = (OSRSpatialReferenceShadow *) 0 ;
+   char *arg2 = (char *) 0 ;
+   void *argp1 = 0 ;
+   int res1 = 0 ;
+   int res2 ;
+   char *buf2 = 0 ;
+   int alloc2 = 0 ;
+   OGRErr result;
+   
+   if (SWIG_GetArgs(interp, objc, objv,"oo:osgeo::SpatialReference_SetProjection self arg ",(void *)0,(void *)0) == TCL_ERROR) SWIG_fail;
+   res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_OSRSpatialReferenceShadow, 0 |  0 );
+   if (!SWIG_IsOK(res1)) {
+     SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SpatialReference_SetProjection" "', argument " "1"" of type '" "OSRSpatialReferenceShadow *""'"); 
+   }
+   arg1 = reinterpret_cast< OSRSpatialReferenceShadow * >(argp1);
+   res2 = SWIG_AsCharPtrAndSize(objv[2], &buf2, NULL, &alloc2);
+   if (!SWIG_IsOK(res2)) {
+     SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "SpatialReference_SetProjection" "', argument " "2"" of type '" "char const *""'");
+   }
+   arg2 = reinterpret_cast< char * >(buf2);
+   result = (OGRErr)OSRSpatialReferenceShadow_SetProjection(arg1,(char const *)arg2);
+   {
+     /* %typemap(out) OGRErr */
+     if (result != 0) {
+       Tcl_SetResult(interp, (char*) OGRErrMessages(result), TCL_STATIC);
+       SWIG_fail;
+     }
+   }
+   if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
+   {
+     /* %typemap(ret) OGRErr */
+     if (!strcmp(Tcl_GetStringResult(interp), "{}") || !strcmp(Tcl_GetStringResult(interp), "")) {
+       Tcl_SetObjResult(interp, Tcl_NewLongObj( result ));
+     }
+   }
+   return TCL_OK;
+ fail:
+   if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
+   return TCL_ERROR;
+ }
+ 
+ 
+ SWIGINTERN int
+ _wrap_SpatialReference_SetProjParm(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
+   OSRSpatialReferenceShadow *arg1 = (OSRSpatialReferenceShadow *) 0 ;
+   char *arg2 = (char *) 0 ;
+   double arg3 ;
+   void *argp1 = 0 ;
+   int res1 = 0 ;
+   int res2 ;
+   char *buf2 = 0 ;
+   int alloc2 = 0 ;
+   double val3 ;
+   int ecode3 = 0 ;
+   OGRErr result;
+   
+   if (SWIG_GetArgs(interp, objc, objv,"ooo:osgeo::SpatialReference_SetProjParm self name val ",(void *)0,(void *)0,(void *)0) == TCL_ERROR) SWIG_fail;
+   res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_OSRSpatialReferenceShadow, 0 |  0 );
+   if (!SWIG_IsOK(res1)) {
+     SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SpatialReference_SetProjParm" "', argument " "1"" of type '" "OSRSpatialReferenceShadow *""'"); 
+   }
+   arg1 = reinterpret_cast< OSRSpatialReferenceShadow * >(argp1);
+   res2 = SWIG_AsCharPtrAndSize(objv[2], &buf2, NULL, &alloc2);
+   if (!SWIG_IsOK(res2)) {
+     SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "SpatialReference_SetProjParm" "', argument " "2"" of type '" "char const *""'");
+   }
+   arg2 = reinterpret_cast< char * >(buf2);
+   ecode3 = SWIG_AsVal_double SWIG_TCL_CALL_ARGS_2(objv[3], &val3);
+   if (!SWIG_IsOK(ecode3)) {
+     SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "SpatialReference_SetProjParm" "', argument " "3"" of type '" "double""'");
+   } 
+   arg3 = static_cast< double >(val3);
+   result = (OGRErr)OSRSpatialReferenceShadow_SetProjParm(arg1,(char const *)arg2,arg3);
+   {
+     /* %typemap(out) OGRErr */
+     if (result != 0) {
+       Tcl_SetResult(interp, (char*) OGRErrMessages(result), TCL_STATIC);
+       SWIG_fail;
+     }
+   }
+   if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
+   {
+     /* %typemap(ret) OGRErr */
+     if (!strcmp(Tcl_GetStringResult(interp), "{}") || !strcmp(Tcl_GetStringResult(interp), "")) {
+       Tcl_SetObjResult(interp, Tcl_NewLongObj( result ));
+     }
+   }
+   return TCL_OK;
+ fail:
+   if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
+   return TCL_ERROR;
+ }
+ 
+ 
+ SWIGINTERN int
+ _wrap_SpatialReference_GetProjParm(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
+   OSRSpatialReferenceShadow *arg1 = (OSRSpatialReferenceShadow *) 0 ;
+   char *arg2 = (char *) 0 ;
+   double arg3 = (double) 0.0 ;
+   void *argp1 = 0 ;
+   int res1 = 0 ;
+   int res2 ;
+   char *buf2 = 0 ;
+   int alloc2 = 0 ;
+   double val3 ;
+   int ecode3 = 0 ;
+   double result;
+   
+   if (SWIG_GetArgs(interp, objc, objv,"oo|o:osgeo::SpatialReference_GetProjParm self name ?default_val? ",(void *)0,(void *)0,(void *)0) == TCL_ERROR) SWIG_fail;
+   res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_OSRSpatialReferenceShadow, 0 |  0 );
+   if (!SWIG_IsOK(res1)) {
+     SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SpatialReference_GetProjParm" "', argument " "1"" of type '" "OSRSpatialReferenceShadow *""'"); 
+   }
+   arg1 = reinterpret_cast< OSRSpatialReferenceShadow * >(argp1);
+   res2 = SWIG_AsCharPtrAndSize(objv[2], &buf2, NULL, &alloc2);
+   if (!SWIG_IsOK(res2)) {
+     SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "SpatialReference_GetProjParm" "', argument " "2"" of type '" "char const *""'");
+   }
+   arg2 = reinterpret_cast< char * >(buf2);
+   if (objc > 3) {
+     ecode3 = SWIG_AsVal_double SWIG_TCL_CALL_ARGS_2(objv[3], &val3);
+     if (!SWIG_IsOK(ecode3)) {
+       SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "SpatialReference_GetProjParm" "', argument " "3"" of type '" "double""'");
+     } 
+     arg3 = static_cast< double >(val3);
+   }
+   result = (double)OSRSpatialReferenceShadow_GetProjParm(arg1,(char const *)arg2,arg3);
+   Tcl_SetObjResult(interp,SWIG_From_double(static_cast< double >(result)));
+   if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
+   return TCL_OK;
+ fail:
+   if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
+   return TCL_ERROR;
+ }
+ 
+ 
+ SWIGINTERN int
+ _wrap_SpatialReference_SetNormProjParm(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
+   OSRSpatialReferenceShadow *arg1 = (OSRSpatialReferenceShadow *) 0 ;
+   char *arg2 = (char *) 0 ;
+   double arg3 ;
+   void *argp1 = 0 ;
+   int res1 = 0 ;
+   int res2 ;
+   char *buf2 = 0 ;
+   int alloc2 = 0 ;
+   double val3 ;
+   int ecode3 = 0 ;
+   OGRErr result;
+   
+   if (SWIG_GetArgs(interp, objc, objv,"ooo:osgeo::SpatialReference_SetNormProjParm self name val ",(void *)0,(void *)0,(void *)0) == TCL_ERROR) SWIG_fail;
+   res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_OSRSpatialReferenceShadow, 0 |  0 );
+   if (!SWIG_IsOK(res1)) {
+     SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SpatialReference_SetNormProjParm" "', argument " "1"" of type '" "OSRSpatialReferenceShadow *""'"); 
+   }
+   arg1 = reinterpret_cast< OSRSpatialReferenceShadow * >(argp1);
+   res2 = SWIG_AsCharPtrAndSize(objv[2], &buf2, NULL, &alloc2);
+   if (!SWIG_IsOK(res2)) {
+     SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "SpatialReference_SetNormProjParm" "', argument " "2"" of type '" "char const *""'");
+   }
+   arg2 = reinterpret_cast< char * >(buf2);
+   ecode3 = SWIG_AsVal_double SWIG_TCL_CALL_ARGS_2(objv[3], &val3);
+   if (!SWIG_IsOK(ecode3)) {
+     SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "SpatialReference_SetNormProjParm" "', argument " "3"" of type '" "double""'");
+   } 
+   arg3 = static_cast< double >(val3);
+   result = (OGRErr)OSRSpatialReferenceShadow_SetNormProjParm(arg1,(char const *)arg2,arg3);
+   {
+     /* %typemap(out) OGRErr */
+     if (result != 0) {
+       Tcl_SetResult(interp, (char*) OGRErrMessages(result), TCL_STATIC);
+       SWIG_fail;
+     }
+   }
+   if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
+   {
+     /* %typemap(ret) OGRErr */
+     if (!strcmp(Tcl_GetStringResult(interp), "{}") || !strcmp(Tcl_GetStringResult(interp), "")) {
+       Tcl_SetObjResult(interp, Tcl_NewLongObj( result ));
+     }
+   }
+   return TCL_OK;
+ fail:
+   if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
+   return TCL_ERROR;
+ }
+ 
+ 
+ SWIGINTERN int
+ _wrap_SpatialReference_GetNormProjParm(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
+   OSRSpatialReferenceShadow *arg1 = (OSRSpatialReferenceShadow *) 0 ;
+   char *arg2 = (char *) 0 ;
+   double arg3 = (double) 0.0 ;
+   void *argp1 = 0 ;
+   int res1 = 0 ;
+   int res2 ;
+   char *buf2 = 0 ;
+   int alloc2 = 0 ;
+   double val3 ;
+   int ecode3 = 0 ;
+   double result;
+   
+   if (SWIG_GetArgs(interp, objc, objv,"oo|o:osgeo::SpatialReference_GetNormProjParm self name ?default_val? ",(void *)0,(void *)0,(void *)0) == TCL_ERROR) SWIG_fail;
+   res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_OSRSpatialReferenceShadow, 0 |  0 );
+   if (!SWIG_IsOK(res1)) {
+     SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SpatialReference_GetNormProjParm" "', argument " "1"" of type '" "OSRSpatialReferenceShadow *""'"); 
+   }
+   arg1 = reinterpret_cast< OSRSpatialReferenceShadow * >(argp1);
+   res2 = SWIG_AsCharPtrAndSize(objv[2], &buf2, NULL, &alloc2);
+   if (!SWIG_IsOK(res2)) {
+     SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "SpatialReference_GetNormProjParm" "', argument " "2"" of type '" "char const *""'");
+   }
+   arg2 = reinterpret_cast< char * >(buf2);
+   if (objc > 3) {
+     ecode3 = SWIG_AsVal_double SWIG_TCL_CALL_ARGS_2(objv[3], &val3);
+     if (!SWIG_IsOK(ecode3)) {
+       SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "SpatialReference_GetNormProjParm" "', argument " "3"" of type '" "double""'");
+     } 
+     arg3 = static_cast< double >(val3);
+   }
+   result = (double)OSRSpatialReferenceShadow_GetNormProjParm(arg1,(char const *)arg2,arg3);
+   Tcl_SetObjResult(interp,SWIG_From_double(static_cast< double >(result)));
+   if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
+   return TCL_OK;
+ fail:
+   if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
+   return TCL_ERROR;
+ }
+ 
+ 
+ SWIGINTERN int
+ _wrap_SpatialReference_SetACEA(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
+   OSRSpatialReferenceShadow *arg1 = (OSRSpatialReferenceShadow *) 0 ;
+   double arg2 ;
+   double arg3 ;
+   double arg4 ;
+   double arg5 ;
+   double arg6 ;
+   double arg7 ;
+   void *argp1 = 0 ;
+   int res1 = 0 ;
+   double val2 ;
+   int ecode2 = 0 ;
+   double val3 ;
+   int ecode3 = 0 ;
+   double val4 ;
+   int ecode4 = 0 ;
+   double val5 ;
+   int ecode5 = 0 ;
+   double val6 ;
+   int ecode6 = 0 ;
+   double val7 ;
+   int ecode7 = 0 ;
+   OGRErr result;
+   
+   if (SWIG_GetArgs(interp, objc, objv,"ooooooo:osgeo::SpatialReference_SetACEA self stdp1 stdp2 clat clong fe fn ",(void *)0,(void *)0,(void *)0,(void *)0,(void *)0,(void *)0,(void *)0) == TCL_ERROR) SWIG_fail;
+   res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_OSRSpatialReferenceShadow, 0 |  0 );
+   if (!SWIG_IsOK(res1)) {
+     SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SpatialReference_SetACEA" "', argument " "1"" of type '" "OSRSpatialReferenceShadow *""'"); 
+   }
+   arg1 = reinterpret_cast< OSRSpatialReferenceShadow * >(argp1);
+   ecode2 = SWIG_AsVal_double SWIG_TCL_CALL_ARGS_2(objv[2], &val2);
+   if (!SWIG_IsOK(ecode2)) {
+     SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "SpatialReference_SetACEA" "', argument " "2"" of type '" "double""'");
+   } 
+   arg2 = static_cast< double >(val2);
+   ecode3 = SWIG_AsVal_double SWIG_TCL_CALL_ARGS_2(objv[3], &val3);
+   if (!SWIG_IsOK(ecode3)) {
+     SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "SpatialReference_SetACEA" "', argument " "3"" of type '" "double""'");
+   } 
+   arg3 = static_cast< double >(val3);
+   ecode4 = SWIG_AsVal_double SWIG_TCL_CALL_ARGS_2(objv[4], &val4);
+   if (!SWIG_IsOK(ecode4)) {
+     SWIG_exception_fail(SWIG_ArgError(ecode4), "in method '" "SpatialReference_SetACEA" "', argument " "4"" of type '" "double""'");
+   } 
+   arg4 = static_cast< double >(val4);
+   ecode5 = SWIG_AsVal_double SWIG_TCL_CALL_ARGS_2(objv[5], &val5);
+   if (!SWIG_IsOK(ecode5)) {
+     SWIG_exception_fail(SWIG_ArgError(ecode5), "in method '" "SpatialReference_SetACEA" "', argument " "5"" of type '" "double""'");
+   } 
+   arg5 = static_cast< double >(val5);
+   ecode6 = SWIG_AsVal_double SWIG_TCL_CALL_ARGS_2(objv[6], &val6);
+   if (!SWIG_IsOK(ecode6)) {
+     SWIG_exception_fail(SWIG_ArgError(ecode6), "in method '" "SpatialReference_SetACEA" "', argument " "6"" of type '" "double""'");
+   } 
+   arg6 = static_cast< double >(val6);
+   ecode7 = SWIG_AsVal_double SWIG_TCL_CALL_ARGS_2(objv[7], &val7);
+   if (!SWIG_IsOK(ecode7)) {
+     SWIG_exception_fail(SWIG_ArgError(ecode7), "in method '" "SpatialReference_SetACEA" "', argument " "7"" of type '" "double""'");
+   } 
+   arg7 = static_cast< double >(val7);
+   result = (OGRErr)OSRSpatialReferenceShadow_SetACEA(arg1,arg2,arg3,arg4,arg5,arg6,arg7);
+   {
+     /* %typemap(out) OGRErr */
+     if (result != 0) {
+       Tcl_SetResult(interp, (char*) OGRErrMessages(result), TCL_STATIC);
+       SWIG_fail;
+     }
+   }
+   {
+     /* %typemap(ret) OGRErr */
+     if (!strcmp(Tcl_GetStringResult(interp), "{}") || !strcmp(Tcl_GetStringResult(interp), "")) {
+       Tcl_SetObjResult(interp, Tcl_NewLongObj( result ));
+     }
+   }
+   return TCL_OK;
+ fail:
+   return TCL_ERROR;
+ }
+ 
+ 
+ SWIGINTERN int
+ _wrap_SpatialReference_SetAE(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
+   OSRSpatialReferenceShadow *arg1 = (OSRSpatialReferenceShadow *) 0 ;
+   double arg2 ;
+   double arg3 ;
+   double arg4 ;
+   double arg5 ;
+   void *argp1 = 0 ;
+   int res1 = 0 ;
+   double val2 ;
+   int ecode2 = 0 ;
+   double val3 ;
+   int ecode3 = 0 ;
+   double val4 ;
+   int ecode4 = 0 ;
+   double val5 ;
+   int ecode5 = 0 ;
+   OGRErr result;
+   
+   if (SWIG_GetArgs(interp, objc, objv,"ooooo:osgeo::SpatialReference_SetAE self clat clong fe fn ",(void *)0,(void *)0,(void *)0,(void *)0,(void *)0) == TCL_ERROR) SWIG_fail;
+   res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_OSRSpatialReferenceShadow, 0 |  0 );
+   if (!SWIG_IsOK(res1)) {
+     SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SpatialReference_SetAE" "', argument " "1"" of type '" "OSRSpatialReferenceShadow *""'"); 
+   }
+   arg1 = reinterpret_cast< OSRSpatialReferenceShadow * >(argp1);
+   ecode2 = SWIG_AsVal_double SWIG_TCL_CALL_ARGS_2(objv[2], &val2);
+   if (!SWIG_IsOK(ecode2)) {
+     SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "SpatialReference_SetAE" "', argument " "2"" of type '" "double""'");
+   } 
+   arg2 = static_cast< double >(val2);
+   ecode3 = SWIG_AsVal_double SWIG_TCL_CALL_ARGS_2(objv[3], &val3);
+   if (!SWIG_IsOK(ecode3)) {
+     SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "SpatialReference_SetAE" "', argument " "3"" of type '" "double""'");
+   } 
+   arg3 = static_cast< double >(val3);
+   ecode4 = SWIG_AsVal_double SWIG_TCL_CALL_ARGS_2(objv[4], &val4);
+   if (!SWIG_IsOK(ecode4)) {
+     SWIG_exception_fail(SWIG_ArgError(ecode4), "in method '" "SpatialReference_SetAE" "', argument " "4"" of type '" "double""'");
+   } 
+   arg4 = static_cast< double >(val4);
+   ecode5 = SWIG_AsVal_double SWIG_TCL_CALL_ARGS_2(objv[5], &val5);
+   if (!SWIG_IsOK(ecode5)) {
+     SWIG_exception_fail(SWIG_ArgError(ecode5), "in method '" "SpatialReference_SetAE" "', argument " "5"" of type '" "double""'");
+   } 
+   arg5 = static_cast< double >(val5);
+   result = (OGRErr)OSRSpatialReferenceShadow_SetAE(arg1,arg2,arg3,arg4,arg5);
+   {
+     /* %typemap(out) OGRErr */
+     if (result != 0) {
+       Tcl_SetResult(interp, (char*) OGRErrMessages(result), TCL_STATIC);
+       SWIG_fail;
+     }
+   }
+   {
+     /* %typemap(ret) OGRErr */
+     if (!strcmp(Tcl_GetStringResult(interp), "{}") || !strcmp(Tcl_GetStringResult(interp), "")) {
+       Tcl_SetObjResult(interp, Tcl_NewLongObj( result ));
+     }
+   }
+   return TCL_OK;
+ fail:
+   return TCL_ERROR;
+ }
+ 
+ 
+ SWIGINTERN int
+ _wrap_SpatialReference_SetBonne(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
+   OSRSpatialReferenceShadow *arg1 = (OSRSpatialReferenceShadow *) 0 ;
+   double arg2 ;
+   double arg3 ;
+   double arg4 ;
+   double arg5 ;
+   void *argp1 = 0 ;
+   int res1 = 0 ;
+   double val2 ;
+   int ecode2 = 0 ;
+   double val3 ;
+   int ecode3 = 0 ;
+   double val4 ;
+   int ecode4 = 0 ;
+   double val5 ;
+   int ecode5 = 0 ;
+   OGRErr result;
+   
+   if (SWIG_GetArgs(interp, objc, objv,"ooooo:osgeo::SpatialReference_SetBonne self stdp cm fe fn ",(void *)0,(void *)0,(void *)0,(void *)0,(void *)0) == TCL_ERROR) SWIG_fail;
+   res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_OSRSpatialReferenceShadow, 0 |  0 );
+   if (!SWIG_IsOK(res1)) {
+     SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SpatialReference_SetBonne" "', argument " "1"" of type '" "OSRSpatialReferenceShadow *""'"); 
+   }
+   arg1 = reinterpret_cast< OSRSpatialReferenceShadow * >(argp1);
+   ecode2 = SWIG_AsVal_double SWIG_TCL_CALL_ARGS_2(objv[2], &val2);
+   if (!SWIG_IsOK(ecode2)) {
+     SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "SpatialReference_SetBonne" "', argument " "2"" of type '" "double""'");
+   } 
+   arg2 = static_cast< double >(val2);
+   ecode3 = SWIG_AsVal_double SWIG_TCL_CALL_ARGS_2(objv[3], &val3);
+   if (!SWIG_IsOK(ecode3)) {
+     SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "SpatialReference_SetBonne" "', argument " "3"" of type '" "double""'");
+   } 
+   arg3 = static_cast< double >(val3);
+   ecode4 = SWIG_AsVal_double SWIG_TCL_CALL_ARGS_2(objv[4], &val4);
+   if (!SWIG_IsOK(ecode4)) {
+     SWIG_exception_fail(SWIG_ArgError(ecode4), "in method '" "SpatialReference_SetBonne" "', argument " "4"" of type '" "double""'");
+   } 
+   arg4 = static_cast< double >(val4);
+   ecode5 = SWIG_AsVal_double SWIG_TCL_CALL_ARGS_2(objv[5], &val5);
+   if (!SWIG_IsOK(ecode5)) {
+     SWIG_exception_fail(SWIG_ArgError(ecode5), "in method '" "SpatialReference_SetBonne" "', argument " "5"" of type '" "double""'");
+   } 
+   arg5 = static_cast< double >(val5);
+   result = (OGRErr)OSRSpatialReferenceShadow_SetBonne(arg1,arg2,arg3,arg4,arg5);
+   {
+     /* %typemap(out) OGRErr */
+     if (result != 0) {
+       Tcl_SetResult(interp, (char*) OGRErrMessages(result), TCL_STATIC);
+       SWIG_fail;
+     }
+   }
+   {
+     /* %typemap(ret) OGRErr */
+     if (!strcmp(Tcl_GetStringResult(interp), "{}") || !strcmp(Tcl_GetStringResult(interp), "")) {
+       Tcl_SetObjResult(interp, Tcl_NewLongObj( result ));
+     }
+   }
+   return TCL_OK;
+ fail:
+   return TCL_ERROR;
+ }
+ 
+ 
+ SWIGINTERN int
+ _wrap_SpatialReference_SetCEA(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
+   OSRSpatialReferenceShadow *arg1 = (OSRSpatialReferenceShadow *) 0 ;
+   double arg2 ;
+   double arg3 ;
+   double arg4 ;
+   double arg5 ;
+   void *argp1 = 0 ;
+   int res1 = 0 ;
+   double val2 ;
+   int ecode2 = 0 ;
+   double val3 ;
+   int ecode3 = 0 ;
+   double val4 ;
+   int ecode4 = 0 ;
+   double val5 ;
+   int ecode5 = 0 ;
+   OGRErr result;
+   
+   if (SWIG_GetArgs(interp, objc, objv,"ooooo:osgeo::SpatialReference_SetCEA self stdp1 cm fe fn ",(void *)0,(void *)0,(void *)0,(void *)0,(void *)0) == TCL_ERROR) SWIG_fail;
+   res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_OSRSpatialReferenceShadow, 0 |  0 );
+   if (!SWIG_IsOK(res1)) {
+     SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SpatialReference_SetCEA" "', argument " "1"" of type '" "OSRSpatialReferenceShadow *""'"); 
+   }
+   arg1 = reinterpret_cast< OSRSpatialReferenceShadow * >(argp1);
+   ecode2 = SWIG_AsVal_double SWIG_TCL_CALL_ARGS_2(objv[2], &val2);
+   if (!SWIG_IsOK(ecode2)) {
+     SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "SpatialReference_SetCEA" "', argument " "2"" of type '" "double""'");
+   } 
+   arg2 = static_cast< double >(val2);
+   ecode3 = SWIG_AsVal_double SWIG_TCL_CALL_ARGS_2(objv[3], &val3);
+   if (!SWIG_IsOK(ecode3)) {
+     SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "SpatialReference_SetCEA" "', argument " "3"" of type '" "double""'");
+   } 
+   arg3 = static_cast< double >(val3);
+   ecode4 = SWIG_AsVal_double SWIG_TCL_CALL_ARGS_2(objv[4], &val4);
+   if (!SWIG_IsOK(ecode4)) {
+     SWIG_exception_fail(SWIG_ArgError(ecode4), "in method '" "SpatialReference_SetCEA" "', argument " "4"" of type '" "double""'");
+   } 
+   arg4 = static_cast< double >(val4);
+   ecode5 = SWIG_AsVal_double SWIG_TCL_CALL_ARGS_2(objv[5], &val5);
+   if (!SWIG_IsOK(ecode5)) {
+     SWIG_exception_fail(SWIG_ArgError(ecode5), "in method '" "SpatialReference_SetCEA" "', argument " "5"" of type '" "double""'");
+   } 
+   arg5 = static_cast< double >(val5);
+   result = (OGRErr)OSRSpatialReferenceShadow_SetCEA(arg1,arg2,arg3,arg4,arg5);
+   {
+     /* %typemap(out) OGRErr */
+     if (result != 0) {
+       Tcl_SetResult(interp, (char*) OGRErrMessages(result), TCL_STATIC);
+       SWIG_fail;
+     }
+   }
+   {
+     /* %typemap(ret) OGRErr */
+     if (!strcmp(Tcl_GetStringResult(interp), "{}") || !strcmp(Tcl_GetStringResult(interp), "")) {
+       Tcl_SetObjResult(interp, Tcl_NewLongObj( result ));
+     }
+   }
+   return TCL_OK;
+ fail:
+   return TCL_ERROR;
+ }
+ 
+ 
+ SWIGINTERN int
+ _wrap_SpatialReference_SetCS(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
+   OSRSpatialReferenceShadow *arg1 = (OSRSpatialReferenceShadow *) 0 ;
+   double arg2 ;
+   double arg3 ;
+   double arg4 ;
+   double arg5 ;
+   void *argp1 = 0 ;
+   int res1 = 0 ;
+   double val2 ;
+   int ecode2 = 0 ;
+   double val3 ;
+   int ecode3 = 0 ;
+   double val4 ;
+   int ecode4 = 0 ;
+   double val5 ;
+   int ecode5 = 0 ;
+   OGRErr result;
+   
+   if (SWIG_GetArgs(interp, objc, objv,"ooooo:osgeo::SpatialReference_SetCS self clat clong fe fn ",(void *)0,(void *)0,(void *)0,(void *)0,(void *)0) == TCL_ERROR) SWIG_fail;
+   res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_OSRSpatialReferenceShadow, 0 |  0 );
+   if (!SWIG_IsOK(res1)) {
+     SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SpatialReference_SetCS" "', argument " "1"" of type '" "OSRSpatialReferenceShadow *""'"); 
+   }
+   arg1 = reinterpret_cast< OSRSpatialReferenceShadow * >(argp1);
+   ecode2 = SWIG_AsVal_double SWIG_TCL_CALL_ARGS_2(objv[2], &val2);
+   if (!SWIG_IsOK(ecode2)) {
+     SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "SpatialReference_SetCS" "', argument " "2"" of type '" "double""'");
+   } 
+   arg2 = static_cast< double >(val2);
+   ecode3 = SWIG_AsVal_double SWIG_TCL_CALL_ARGS_2(objv[3], &val3);
+   if (!SWIG_IsOK(ecode3)) {
+     SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "SpatialReference_SetCS" "', argument " "3"" of type '" "double""'");
+   } 
+   arg3 = static_cast< double >(val3);
+   ecode4 = SWIG_AsVal_double SWIG_TCL_CALL_ARGS_2(objv[4], &val4);
+   if (!SWIG_IsOK(ecode4)) {
+     SWIG_exception_fail(SWIG_ArgError(ecode4), "in method '" "SpatialReference_SetCS" "', argument " "4"" of type '" "double""'");
+   } 
+   arg4 = static_cast< double >(val4);
+   ecode5 = SWIG_AsVal_double SWIG_TCL_CALL_ARGS_2(objv[5], &val5);
+   if (!SWIG_IsOK(ecode5)) {
+     SWIG_exception_fail(SWIG_ArgError(ecode5), "in method '" "SpatialReference_SetCS" "', argument " "5"" of type '" "double""'");
+   } 
+   arg5 = static_cast< double >(val5);
+   result = (OGRErr)OSRSpatialReferenceShadow_SetCS(arg1,arg2,arg3,arg4,arg5);
+   {
+     /* %typemap(out) OGRErr */
+     if (result != 0) {
+       Tcl_SetResult(interp, (char*) OGRErrMessages(result), TCL_STATIC);
+       SWIG_fail;
+     }
+   }
+   {
+     /* %typemap(ret) OGRErr */
+     if (!strcmp(Tcl_GetStringResult(interp), "{}") || !strcmp(Tcl_GetStringResult(interp), "")) {
+       Tcl_SetObjResult(interp, Tcl_NewLongObj( result ));
+     }
+   }
+   return TCL_OK;
+ fail:
+   return TCL_ERROR;
+ }
+ 
+ 
+ SWIGINTERN int
+ _wrap_SpatialReference_SetEC(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
+   OSRSpatialReferenceShadow *arg1 = (OSRSpatialReferenceShadow *) 0 ;
+   double arg2 ;
+   double arg3 ;
+   double arg4 ;
+   double arg5 ;
+   double arg6 ;
+   double arg7 ;
+   void *argp1 = 0 ;
+   int res1 = 0 ;
+   double val2 ;
+   int ecode2 = 0 ;
+   double val3 ;
+   int ecode3 = 0 ;
+   double val4 ;
+   int ecode4 = 0 ;
+   double val5 ;
+   int ecode5 = 0 ;
+   double val6 ;
+   int ecode6 = 0 ;
+   double val7 ;
+   int ecode7 = 0 ;
+   OGRErr result;
+   
+   if (SWIG_GetArgs(interp, objc, objv,"ooooooo:osgeo::SpatialReference_SetEC self stdp1 stdp2 clat clong fe fn ",(void *)0,(void *)0,(void *)0,(void *)0,(void *)0,(void *)0,(void *)0) == TCL_ERROR) SWIG_fail;
+   res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_OSRSpatialReferenceShadow, 0 |  0 );
+   if (!SWIG_IsOK(res1)) {
+     SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SpatialReference_SetEC" "', argument " "1"" of type '" "OSRSpatialReferenceShadow *""'"); 
+   }
+   arg1 = reinterpret_cast< OSRSpatialReferenceShadow * >(argp1);
+   ecode2 = SWIG_AsVal_double SWIG_TCL_CALL_ARGS_2(objv[2], &val2);
+   if (!SWIG_IsOK(ecode2)) {
+     SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "SpatialReference_SetEC" "', argument " "2"" of type '" "double""'");
+   } 
+   arg2 = static_cast< double >(val2);
+   ecode3 = SWIG_AsVal_double SWIG_TCL_CALL_ARGS_2(objv[3], &val3);
+   if (!SWIG_IsOK(ecode3)) {
+     SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "SpatialReference_SetEC" "', argument " "3"" of type '" "double""'");
+   } 
+   arg3 = static_cast< double >(val3);
+   ecode4 = SWIG_AsVal_double SWIG_TCL_CALL_ARGS_2(objv[4], &val4);
+   if (!SWIG_IsOK(ecode4)) {
+     SWIG_exception_fail(SWIG_ArgError(ecode4), "in method '" "SpatialReference_SetEC" "', argument " "4"" of type '" "double""'");
+   } 
+   arg4 = static_cast< double >(val4);
+   ecode5 = SWIG_AsVal_double SWIG_TCL_CALL_ARGS_2(objv[5], &val5);
+   if (!SWIG_IsOK(ecode5)) {
+     SWIG_exception_fail(SWIG_ArgError(ecode5), "in method '" "SpatialReference_SetEC" "', argument " "5"" of type '" "double""'");
+   } 
+   arg5 = static_cast< double >(val5);
+   ecode6 = SWIG_AsVal_double SWIG_TCL_CALL_ARGS_2(objv[6], &val6);
+   if (!SWIG_IsOK(ecode6)) {
+     SWIG_exception_fail(SWIG_ArgError(ecode6), "in method '" "SpatialReference_SetEC" "', argument " "6"" of type '" "double""'");
+   } 
+   arg6 = static_cast< double >(val6);
+   ecode7 = SWIG_AsVal_double SWIG_TCL_CALL_ARGS_2(objv[7], &val7);
+   if (!SWIG_IsOK(ecode7)) {
+     SWIG_exception_fail(SWIG_ArgError(ecode7), "in method '" "SpatialReference_SetEC" "', argument " "7"" of type '" "double""'");
+   } 
+   arg7 = static_cast< double >(val7);
+   result = (OGRErr)OSRSpatialReferenceShadow_SetEC(arg1,arg2,arg3,arg4,arg5,arg6,arg7);
+   {
+     /* %typemap(out) OGRErr */
+     if (result != 0) {
+       Tcl_SetResult(interp, (char*) OGRErrMessages(result), TCL_STATIC);
+       SWIG_fail;
+     }
+   }
+   {
+     /* %typemap(ret) OGRErr */
+     if (!strcmp(Tcl_GetStringResult(interp), "{}") || !strcmp(Tcl_GetStringResult(interp), "")) {
+       Tcl_SetObjResult(interp, Tcl_NewLongObj( result ));
+     }
+   }
+   return TCL_OK;
+ fail:
+   return TCL_ERROR;
+ }
+ 
+ 
+ SWIGINTERN int
+ _wrap_SpatialReference_SetEckertIV(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
+   OSRSpatialReferenceShadow *arg1 = (OSRSpatialReferenceShadow *) 0 ;
+   double arg2 ;
+   double arg3 ;
+   double arg4 ;
+   void *argp1 = 0 ;
+   int res1 = 0 ;
+   double val2 ;
+   int ecode2 = 0 ;
+   double val3 ;
+   int ecode3 = 0 ;
+   double val4 ;
+   int ecode4 = 0 ;
+   OGRErr result;
+   
+   if (SWIG_GetArgs(interp, objc, objv,"oooo:osgeo::SpatialReference_SetEckertIV self cm fe fn ",(void *)0,(void *)0,(void *)0,(void *)0) == TCL_ERROR) SWIG_fail;
+   res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_OSRSpatialReferenceShadow, 0 |  0 );
+   if (!SWIG_IsOK(res1)) {
+     SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SpatialReference_SetEckertIV" "', argument " "1"" of type '" "OSRSpatialReferenceShadow *""'"); 
+   }
+   arg1 = reinterpret_cast< OSRSpatialReferenceShadow * >(argp1);
+   ecode2 = SWIG_AsVal_double SWIG_TCL_CALL_ARGS_2(objv[2], &val2);
+   if (!SWIG_IsOK(ecode2)) {
+     SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "SpatialReference_SetEckertIV" "', argument " "2"" of type '" "double""'");
+   } 
+   arg2 = static_cast< double >(val2);
+   ecode3 = SWIG_AsVal_double SWIG_TCL_CALL_ARGS_2(objv[3], &val3);
+   if (!SWIG_IsOK(ecode3)) {
+     SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "SpatialReference_SetEckertIV" "', argument " "3"" of type '" "double""'");
+   } 
+   arg3 = static_cast< double >(val3);
+   ecode4 = SWIG_AsVal_double SWIG_TCL_CALL_ARGS_2(objv[4], &val4);
+   if (!SWIG_IsOK(ecode4)) {
+     SWIG_exception_fail(SWIG_ArgError(ecode4), "in method '" "SpatialReference_SetEckertIV" "', argument " "4"" of type '" "double""'");
+   } 
+   arg4 = static_cast< double >(val4);
+   result = (OGRErr)OSRSpatialReferenceShadow_SetEckertIV(arg1,arg2,arg3,arg4);
+   {
+     /* %typemap(out) OGRErr */
+     if (result != 0) {
+       Tcl_SetResult(interp, (char*) OGRErrMessages(result), TCL_STATIC);
+       SWIG_fail;
+     }
+   }
+   {
+     /* %typemap(ret) OGRErr */
+     if (!strcmp(Tcl_GetStringResult(interp), "{}") || !strcmp(Tcl_GetStringResult(interp), "")) {
+       Tcl_SetObjResult(interp, Tcl_NewLongObj( result ));
+     }
+   }
+   return TCL_OK;
+ fail:
+   return TCL_ERROR;
+ }
+ 
+ 
+ SWIGINTERN int
+ _wrap_SpatialReference_SetEckertVI(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
+   OSRSpatialReferenceShadow *arg1 = (OSRSpatialReferenceShadow *) 0 ;
+   double arg2 ;
+   double arg3 ;
+   double arg4 ;
+   void *argp1 = 0 ;
+   int res1 = 0 ;
+   double val2 ;
+   int ecode2 = 0 ;
+   double val3 ;
+   int ecode3 = 0 ;
+   double val4 ;
+   int ecode4 = 0 ;
+   OGRErr result;
+   
+   if (SWIG_GetArgs(interp, objc, objv,"oooo:osgeo::SpatialReference_SetEckertVI self cm fe fn ",(void *)0,(void *)0,(void *)0,(void *)0) == TCL_ERROR) SWIG_fail;
+   res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_OSRSpatialReferenceShadow, 0 |  0 );
+   if (!SWIG_IsOK(res1)) {
+     SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SpatialReference_SetEckertVI" "', argument " "1"" of type '" "OSRSpatialReferenceShadow *""'"); 
+   }
+   arg1 = reinterpret_cast< OSRSpatialReferenceShadow * >(argp1);
+   ecode2 = SWIG_AsVal_double SWIG_TCL_CALL_ARGS_2(objv[2], &val2);
+   if (!SWIG_IsOK(ecode2)) {
+     SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "SpatialReference_SetEckertVI" "', argument " "2"" of type '" "double""'");
+   } 
+   arg2 = static_cast< double >(val2);
+   ecode3 = SWIG_AsVal_double SWIG_TCL_CALL_ARGS_2(objv[3], &val3);
+   if (!SWIG_IsOK(ecode3)) {
+     SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "SpatialReference_SetEckertVI" "', argument " "3"" of type '" "double""'");
+   } 
+   arg3 = static_cast< double >(val3);
+   ecode4 = SWIG_AsVal_double SWIG_TCL_CALL_ARGS_2(objv[4], &val4);
+   if (!SWIG_IsOK(ecode4)) {
+     SWIG_exception_fail(SWIG_ArgError(ecode4), "in method '" "SpatialReference_SetEckertVI" "', argument " "4"" of type '" "double""'");
+   } 
+   arg4 = static_cast< double >(val4);
+   result = (OGRErr)OSRSpatialReferenceShadow_SetEckertVI(arg1,arg2,arg3,arg4);
+   {
+     /* %typemap(out) OGRErr */
+     if (result != 0) {
+       Tcl_SetResult(interp, (char*) OGRErrMessages(result), TCL_STATIC);
+       SWIG_fail;
+     }
+   }
+   {
+     /* %typemap(ret) OGRErr */
+     if (!strcmp(Tcl_GetStringResult(interp), "{}") || !strcmp(Tcl_GetStringResult(interp), "")) {
+       Tcl_SetObjResult(interp, Tcl_NewLongObj( result ));
+     }
+   }
+   return TCL_OK;
+ fail:
+   return TCL_ERROR;
+ }
+ 
+ 
+ SWIGINTERN int
+ _wrap_SpatialReference_SetEquirectangular(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
+   OSRSpatialReferenceShadow *arg1 = (OSRSpatialReferenceShadow *) 0 ;
+   double arg2 ;
+   double arg3 ;
+   double arg4 ;
+   double arg5 ;
+   void *argp1 = 0 ;
+   int res1 = 0 ;
+   double val2 ;
+   int ecode2 = 0 ;
+   double val3 ;
+   int ecode3 = 0 ;
+   double val4 ;
+   int ecode4 = 0 ;
+   double val5 ;
+   int ecode5 = 0 ;
+   OGRErr result;
+   
+   if (SWIG_GetArgs(interp, objc, objv,"ooooo:osgeo::SpatialReference_SetEquirectangular self clat clong fe fn ",(void *)0,(void *)0,(void *)0,(void *)0,(void *)0) == TCL_ERROR) SWIG_fail;
+   res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_OSRSpatialReferenceShadow, 0 |  0 );
+   if (!SWIG_IsOK(res1)) {
+     SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SpatialReference_SetEquirectangular" "', argument " "1"" of type '" "OSRSpatialReferenceShadow *""'"); 
+   }
+   arg1 = reinterpret_cast< OSRSpatialReferenceShadow * >(argp1);
+   ecode2 = SWIG_AsVal_double SWIG_TCL_CALL_ARGS_2(objv[2], &val2);
+   if (!SWIG_IsOK(ecode2)) {
+     SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "SpatialReference_SetEquirectangular" "', argument " "2"" of type '" "double""'");
+   } 
+   arg2 = static_cast< double >(val2);
+   ecode3 = SWIG_AsVal_double SWIG_TCL_CALL_ARGS_2(objv[3], &val3);
+   if (!SWIG_IsOK(ecode3)) {
+     SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "SpatialReference_SetEquirectangular" "', argument " "3"" of type '" "double""'");
+   } 
+   arg3 = static_cast< double >(val3);
+   ecode4 = SWIG_AsVal_double SWIG_TCL_CALL_ARGS_2(objv[4], &val4);
+   if (!SWIG_IsOK(ecode4)) {
+     SWIG_exception_fail(SWIG_ArgError(ecode4), "in method '" "SpatialReference_SetEquirectangular" "', argument " "4"" of type '" "double""'");
+   } 
+   arg4 = static_cast< double >(val4);
+   ecode5 = SWIG_AsVal_double SWIG_TCL_CALL_ARGS_2(objv[5], &val5);
+   if (!SWIG_IsOK(ecode5)) {
+     SWIG_exception_fail(SWIG_ArgError(ecode5), "in method '" "SpatialReference_SetEquirectangular" "', argument " "5"" of type '" "double""'");
+   } 
+   arg5 = static_cast< double >(val5);
+   result = (OGRErr)OSRSpatialReferenceShadow_SetEquirectangular(arg1,arg2,arg3,arg4,arg5);
+   {
+     /* %typemap(out) OGRErr */
+     if (result != 0) {
+       Tcl_SetResult(interp, (char*) OGRErrMessages(result), TCL_STATIC);
+       SWIG_fail;
+     }
+   }
+   {
+     /* %typemap(ret) OGRErr */
+     if (!strcmp(Tcl_GetStringResult(interp), "{}") || !strcmp(Tcl_GetStringResult(interp), "")) {
+       Tcl_SetObjResult(interp, Tcl_NewLongObj( result ));
+     }
+   }
+   return TCL_OK;
+ fail:
+   return TCL_ERROR;
+ }
+ 
+ 
+ SWIGINTERN int
+ _wrap_SpatialReference_SetEquirectangular2(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
+   OSRSpatialReferenceShadow *arg1 = (OSRSpatialReferenceShadow *) 0 ;
+   double arg2 ;
+   double arg3 ;
+   double arg4 ;
+   double arg5 ;
+   double arg6 ;
+   void *argp1 = 0 ;
+   int res1 = 0 ;
+   double val2 ;
+   int ecode2 = 0 ;
+   double val3 ;
+   int ecode3 = 0 ;
+   double val4 ;
+   int ecode4 = 0 ;
+   double val5 ;
+   int ecode5 = 0 ;
+   double val6 ;
+   int ecode6 = 0 ;
+   OGRErr result;
+   
+   if (SWIG_GetArgs(interp, objc, objv,"oooooo:osgeo::SpatialReference_SetEquirectangular2 self clat clong pseudostdparallellat fe fn ",(void *)0,(void *)0,(void *)0,(void *)0,(void *)0,(void *)0) == TCL_ERROR) SWIG_fail;
+   res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_OSRSpatialReferenceShadow, 0 |  0 );
+   if (!SWIG_IsOK(res1)) {
+     SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SpatialReference_SetEquirectangular2" "', argument " "1"" of type '" "OSRSpatialReferenceShadow *""'"); 
+   }
+   arg1 = reinterpret_cast< OSRSpatialReferenceShadow * >(argp1);
+   ecode2 = SWIG_AsVal_double SWIG_TCL_CALL_ARGS_2(objv[2], &val2);
+   if (!SWIG_IsOK(ecode2)) {
+     SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "SpatialReference_SetEquirectangular2" "', argument " "2"" of type '" "double""'");
+   } 
+   arg2 = static_cast< double >(val2);
+   ecode3 = SWIG_AsVal_double SWIG_TCL_CALL_ARGS_2(objv[3], &val3);
+   if (!SWIG_IsOK(ecode3)) {
+     SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "SpatialReference_SetEquirectangular2" "', argument " "3"" of type '" "double""'");
+   } 
+   arg3 = static_cast< double >(val3);
+   ecode4 = SWIG_AsVal_double SWIG_TCL_CALL_ARGS_2(objv[4], &val4);
+   if (!SWIG_IsOK(ecode4)) {
+     SWIG_exception_fail(SWIG_ArgError(ecode4), "in method '" "SpatialReference_SetEquirectangular2" "', argument " "4"" of type '" "double""'");
+   } 
+   arg4 = static_cast< double >(val4);
+   ecode5 = SWIG_AsVal_double SWIG_TCL_CALL_ARGS_2(objv[5], &val5);
+   if (!SWIG_IsOK(ecode5)) {
+     SWIG_exception_fail(SWIG_ArgError(ecode5), "in method '" "SpatialReference_SetEquirectangular2" "', argument " "5"" of type '" "double""'");
+   } 
+   arg5 = static_cast< double >(val5);
+   ecode6 = SWIG_AsVal_double SWIG_TCL_CALL_ARGS_2(objv[6], &val6);
+   if (!SWIG_IsOK(ecode6)) {
+     SWIG_exception_fail(SWIG_ArgError(ecode6), "in method '" "SpatialReference_SetEquirectangular2" "', argument " "6"" of type '" "double""'");
+   } 
+   arg6 = static_cast< double >(val6);
+   result = (OGRErr)OSRSpatialReferenceShadow_SetEquirectangular2(arg1,arg2,arg3,arg4,arg5,arg6);
+   {
+     /* %typemap(out) OGRErr */
+     if (result != 0) {
+       Tcl_SetResult(interp, (char*) OGRErrMessages(result), TCL_STATIC);
+       SWIG_fail;
+     }
+   }
+   {
+     /* %typemap(ret) OGRErr */
+     if (!strcmp(Tcl_GetStringResult(interp), "{}") || !strcmp(Tcl_GetStringResult(interp), "")) {
+       Tcl_SetObjResult(interp, Tcl_NewLongObj( result ));
+     }
+   }
+   return TCL_OK;
+ fail:
+   return TCL_ERROR;
+ }
+ 
+ 
+ SWIGINTERN int
+ _wrap_SpatialReference_SetGaussSchreiberTMercator(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
+   OSRSpatialReferenceShadow *arg1 = (OSRSpatialReferenceShadow *) 0 ;
+   double arg2 ;
+   double arg3 ;
+   double arg4 ;
+   double arg5 ;
+   double arg6 ;
+   void *argp1 = 0 ;
+   int res1 = 0 ;
+   double val2 ;
+   int ecode2 = 0 ;
+   double val3 ;
+   int ecode3 = 0 ;
+   double val4 ;
+   int ecode4 = 0 ;
+   double val5 ;
+   int ecode5 = 0 ;
+   double val6 ;
+   int ecode6 = 0 ;
+   OGRErr result;
+   
+   if (SWIG_GetArgs(interp, objc, objv,"oooooo:osgeo::SpatialReference_SetGaussSchreiberTMercator self clat clong sc fe fn ",(void *)0,(void *)0,(void *)0,(void *)0,(void *)0,(void *)0) == TCL_ERROR) SWIG_fail;
+   res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_OSRSpatialReferenceShadow, 0 |  0 );
+   if (!SWIG_IsOK(res1)) {
+     SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SpatialReference_SetGaussSchreiberTMercator" "', argument " "1"" of type '" "OSRSpatialReferenceShadow *""'"); 
+   }
+   arg1 = reinterpret_cast< OSRSpatialReferenceShadow * >(argp1);
+   ecode2 = SWIG_AsVal_double SWIG_TCL_CALL_ARGS_2(objv[2], &val2);
+   if (!SWIG_IsOK(ecode2)) {
+     SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "SpatialReference_SetGaussSchreiberTMercator" "', argument " "2"" of type '" "double""'");
+   } 
+   arg2 = static_cast< double >(val2);
+   ecode3 = SWIG_AsVal_double SWIG_TCL_CALL_ARGS_2(objv[3], &val3);
+   if (!SWIG_IsOK(ecode3)) {
+     SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "SpatialReference_SetGaussSchreiberTMercator" "', argument " "3"" of type '" "double""'");
+   } 
+   arg3 = static_cast< double >(val3);
+   ecode4 = SWIG_AsVal_double SWIG_TCL_CALL_ARGS_2(objv[4], &val4);
+   if (!SWIG_IsOK(ecode4)) {
+     SWIG_exception_fail(SWIG_ArgError(ecode4), "in method '" "SpatialReference_SetGaussSchreiberTMercator" "', argument " "4"" of type '" "double""'");
+   } 
+   arg4 = static_cast< double >(val4);
+   ecode5 = SWIG_AsVal_double SWIG_TCL_CALL_ARGS_2(objv[5], &val5);
+   if (!SWIG_IsOK(ecode5)) {
+     SWIG_exception_fail(SWIG_ArgError(ecode5), "in method '" "SpatialReference_SetGaussSchreiberTMercator" "', argument " "5"" of type '" "double""'");
+   } 
+   arg5 = static_cast< double >(val5);
+   ecode6 = SWIG_AsVal_double SWIG_TCL_CALL_ARGS_2(objv[6], &val6);
+   if (!SWIG_IsOK(ecode6)) {
+     SWIG_exception_fail(SWIG_ArgError(ecode6), "in method '" "SpatialReference_SetGaussSchreiberTMercator" "', argument " "6"" of type '" "double""'");
+   } 
+   arg6 = static_cast< double >(val6);
+   result = (OGRErr)OSRSpatialReferenceShadow_SetGaussSchreiberTMercator(arg1,arg2,arg3,arg4,arg5,arg6);
+   {
+     /* %typemap(out) OGRErr */
+     if (result != 0) {
+       Tcl_SetResult(interp, (char*) OGRErrMessages(result), TCL_STATIC);
+       SWIG_fail;
+     }
+   }
+   {
+     /* %typemap(ret) OGRErr */
+     if (!strcmp(Tcl_GetStringResult(interp), "{}") || !strcmp(Tcl_GetStringResult(interp), "")) {
+       Tcl_SetObjResult(interp, Tcl_NewLongObj( result ));
+     }
+   }
+   return TCL_OK;
+ fail:
+   return TCL_ERROR;
+ }
+ 
+ 
+ SWIGINTERN int
+ _wrap_SpatialReference_SetGS(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
+   OSRSpatialReferenceShadow *arg1 = (OSRSpatialReferenceShadow *) 0 ;
+   double arg2 ;
+   double arg3 ;
+   double arg4 ;
+   void *argp1 = 0 ;
+   int res1 = 0 ;
+   double val2 ;
+   int ecode2 = 0 ;
+   double val3 ;
+   int ecode3 = 0 ;
+   double val4 ;
+   int ecode4 = 0 ;
+   OGRErr result;
+   
+   if (SWIG_GetArgs(interp, objc, objv,"oooo:osgeo::SpatialReference_SetGS self cm fe fn ",(void *)0,(void *)0,(void *)0,(void *)0) == TCL_ERROR) SWIG_fail;
+   res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_OSRSpatialReferenceShadow, 0 |  0 );
+   if (!SWIG_IsOK(res1)) {
+     SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SpatialReference_SetGS" "', argument " "1"" of type '" "OSRSpatialReferenceShadow *""'"); 
+   }
+   arg1 = reinterpret_cast< OSRSpatialReferenceShadow * >(argp1);
+   ecode2 = SWIG_AsVal_double SWIG_TCL_CALL_ARGS_2(objv[2], &val2);
+   if (!SWIG_IsOK(ecode2)) {
+     SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "SpatialReference_SetGS" "', argument " "2"" of type '" "double""'");
+   } 
+   arg2 = static_cast< double >(val2);
+   ecode3 = SWIG_AsVal_double SWIG_TCL_CALL_ARGS_2(objv[3], &val3);
+   if (!SWIG_IsOK(ecode3)) {
+     SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "SpatialReference_SetGS" "', argument " "3"" of type '" "double""'");
+   } 
+   arg3 = static_cast< double >(val3);
+   ecode4 = SWIG_AsVal_double SWIG_TCL_CALL_ARGS_2(objv[4], &val4);
+   if (!SWIG_IsOK(ecode4)) {
+     SWIG_exception_fail(SWIG_ArgError(ecode4), "in method '" "SpatialReference_SetGS" "', argument " "4"" of type '" "double""'");
+   } 
+   arg4 = static_cast< double >(val4);
+   result = (OGRErr)OSRSpatialReferenceShadow_SetGS(arg1,arg2,arg3,arg4);
+   {
+     /* %typemap(out) OGRErr */
+     if (result != 0) {
+       Tcl_SetResult(interp, (char*) OGRErrMessages(result), TCL_STATIC);
+       SWIG_fail;
+     }
+   }
+   {
+     /* %typemap(ret) OGRErr */
+     if (!strcmp(Tcl_GetStringResult(interp), "{}") || !strcmp(Tcl_GetStringResult(interp), "")) {
+       Tcl_SetObjResult(interp, Tcl_NewLongObj( result ));
+     }
+   }
+   return TCL_OK;
+ fail:
+   return TCL_ERROR;
+ }
+ 
+ 
+ SWIGINTERN int
+ _wrap_SpatialReference_SetGH(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
+   OSRSpatialReferenceShadow *arg1 = (OSRSpatialReferenceShadow *) 0 ;
+   double arg2 ;
+   double arg3 ;
+   double arg4 ;
+   void *argp1 = 0 ;
+   int res1 = 0 ;
+   double val2 ;
+   int ecode2 = 0 ;
+   double val3 ;
+   int ecode3 = 0 ;
+   double val4 ;
+   int ecode4 = 0 ;
+   OGRErr result;
+   
+   if (SWIG_GetArgs(interp, objc, objv,"oooo:osgeo::SpatialReference_SetGH self cm fe fn ",(void *)0,(void *)0,(void *)0,(void *)0) == TCL_ERROR) SWIG_fail;
+   res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_OSRSpatialReferenceShadow, 0 |  0 );
+   if (!SWIG_IsOK(res1)) {
+     SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SpatialReference_SetGH" "', argument " "1"" of type '" "OSRSpatialReferenceShadow *""'"); 
+   }
+   arg1 = reinterpret_cast< OSRSpatialReferenceShadow * >(argp1);
+   ecode2 = SWIG_AsVal_double SWIG_TCL_CALL_ARGS_2(objv[2], &val2);
+   if (!SWIG_IsOK(ecode2)) {
+     SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "SpatialReference_SetGH" "', argument " "2"" of type '" "double""'");
+   } 
+   arg2 = static_cast< double >(val2);
+   ecode3 = SWIG_AsVal_double SWIG_TCL_CALL_ARGS_2(objv[3], &val3);
+   if (!SWIG_IsOK(ecode3)) {
+     SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "SpatialReference_SetGH" "', argument " "3"" of type '" "double""'");
+   } 
+   arg3 = static_cast< double >(val3);
+   ecode4 = SWIG_AsVal_double SWIG_TCL_CALL_ARGS_2(objv[4], &val4);
+   if (!SWIG_IsOK(ecode4)) {
+     SWIG_exception_fail(SWIG_ArgError(ecode4), "in method '" "SpatialReference_SetGH" "', argument " "4"" of type '" "double""'");
+   } 
+   arg4 = static_cast< double >(val4);
+   result = (OGRErr)OSRSpatialReferenceShadow_SetGH(arg1,arg2,arg3,arg4);
+   {
+     /* %typemap(out) OGRErr */
+     if (result != 0) {
+       Tcl_SetResult(interp, (char*) OGRErrMessages(result), TCL_STATIC);
+       SWIG_fail;
+     }
+   }
+   {
+     /* %typemap(ret) OGRErr */
+     if (!strcmp(Tcl_GetStringResult(interp), "{}") || !strcmp(Tcl_GetStringResult(interp), "")) {
+       Tcl_SetObjResult(interp, Tcl_NewLongObj( result ));
+     }
+   }
+   return TCL_OK;
+ fail:
+   return TCL_ERROR;
+ }
+ 
+ 
+ SWIGINTERN int
+ _wrap_SpatialReference_SetGEOS(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
+   OSRSpatialReferenceShadow *arg1 = (OSRSpatialReferenceShadow *) 0 ;
+   double arg2 ;
+   double arg3 ;
+   double arg4 ;
+   double arg5 ;
+   void *argp1 = 0 ;
+   int res1 = 0 ;
+   double val2 ;
+   int ecode2 = 0 ;
+   double val3 ;
+   int ecode3 = 0 ;
+   double val4 ;
+   int ecode4 = 0 ;
+   double val5 ;
+   int ecode5 = 0 ;
+   OGRErr result;
+   
+   if (SWIG_GetArgs(interp, objc, objv,"ooooo:osgeo::SpatialReference_SetGEOS self cm satelliteheight fe fn ",(void *)0,(void *)0,(void *)0,(void *)0,(void *)0) == TCL_ERROR) SWIG_fail;
+   res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_OSRSpatialReferenceShadow, 0 |  0 );
+   if (!SWIG_IsOK(res1)) {
+     SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SpatialReference_SetGEOS" "', argument " "1"" of type '" "OSRSpatialReferenceShadow *""'"); 
+   }
+   arg1 = reinterpret_cast< OSRSpatialReferenceShadow * >(argp1);
+   ecode2 = SWIG_AsVal_double SWIG_TCL_CALL_ARGS_2(objv[2], &val2);
+   if (!SWIG_IsOK(ecode2)) {
+     SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "SpatialReference_SetGEOS" "', argument " "2"" of type '" "double""'");
+   } 
+   arg2 = static_cast< double >(val2);
+   ecode3 = SWIG_AsVal_double SWIG_TCL_CALL_ARGS_2(objv[3], &val3);
+   if (!SWIG_IsOK(ecode3)) {
+     SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "SpatialReference_SetGEOS" "', argument " "3"" of type '" "double""'");
+   } 
+   arg3 = static_cast< double >(val3);
+   ecode4 = SWIG_AsVal_double SWIG_TCL_CALL_ARGS_2(objv[4], &val4);
+   if (!SWIG_IsOK(ecode4)) {
+     SWIG_exception_fail(SWIG_ArgError(ecode4), "in method '" "SpatialReference_SetGEOS" "', argument " "4"" of type '" "double""'");
+   } 
+   arg4 = static_cast< double >(val4);
+   ecode5 = SWIG_AsVal_double SWIG_TCL_CALL_ARGS_2(objv[5], &val5);
+   if (!SWIG_IsOK(ecode5)) {
+     SWIG_exception_fail(SWIG_ArgError(ecode5), "in method '" "SpatialReference_SetGEOS" "', argument " "5"" of type '" "double""'");
+   } 
+   arg5 = static_cast< double >(val5);
+   result = (OGRErr)OSRSpatialReferenceShadow_SetGEOS(arg1,arg2,arg3,arg4,arg5);
+   {
+     /* %typemap(out) OGRErr */
+     if (result != 0) {
+       Tcl_SetResult(interp, (char*) OGRErrMessages(result), TCL_STATIC);
+       SWIG_fail;
+     }
+   }
+   {
+     /* %typemap(ret) OGRErr */
+     if (!strcmp(Tcl_GetStringResult(interp), "{}") || !strcmp(Tcl_GetStringResult(interp), "")) {
+       Tcl_SetObjResult(interp, Tcl_NewLongObj( result ));
+     }
+   }
+   return TCL_OK;
+ fail:
+   return TCL_ERROR;
+ }
+ 
+ 
+ SWIGINTERN int
+ _wrap_SpatialReference_SetGnomonic(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
+   OSRSpatialReferenceShadow *arg1 = (OSRSpatialReferenceShadow *) 0 ;
+   double arg2 ;
+   double arg3 ;
+   double arg4 ;
+   double arg5 ;
+   void *argp1 = 0 ;
+   int res1 = 0 ;
+   double val2 ;
+   int ecode2 = 0 ;
+   double val3 ;
+   int ecode3 = 0 ;
+   double val4 ;
+   int ecode4 = 0 ;
+   double val5 ;
+   int ecode5 = 0 ;
+   OGRErr result;
+   
+   if (SWIG_GetArgs(interp, objc, objv,"ooooo:osgeo::SpatialReference_SetGnomonic self clat clong fe fn ",(void *)0,(void *)0,(void *)0,(void *)0,(void *)0) == TCL_ERROR) SWIG_fail;
+   res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_OSRSpatialReferenceShadow, 0 |  0 );
+   if (!SWIG_IsOK(res1)) {
+     SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SpatialReference_SetGnomonic" "', argument " "1"" of type '" "OSRSpatialReferenceShadow *""'"); 
+   }
+   arg1 = reinterpret_cast< OSRSpatialReferenceShadow * >(argp1);
+   ecode2 = SWIG_AsVal_double SWIG_TCL_CALL_ARGS_2(objv[2], &val2);
+   if (!SWIG_IsOK(ecode2)) {
+     SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "SpatialReference_SetGnomonic" "', argument " "2"" of type '" "double""'");
+   } 
+   arg2 = static_cast< double >(val2);
+   ecode3 = SWIG_AsVal_double SWIG_TCL_CALL_ARGS_2(objv[3], &val3);
+   if (!SWIG_IsOK(ecode3)) {
+     SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "SpatialReference_SetGnomonic" "', argument " "3"" of type '" "double""'");
+   } 
+   arg3 = static_cast< double >(val3);
+   ecode4 = SWIG_AsVal_double SWIG_TCL_CALL_ARGS_2(objv[4], &val4);
+   if (!SWIG_IsOK(ecode4)) {
+     SWIG_exception_fail(SWIG_ArgError(ecode4), "in method '" "SpatialReference_SetGnomonic" "', argument " "4"" of type '" "double""'");
+   } 
+   arg4 = static_cast< double >(val4);
+   ecode5 = SWIG_AsVal_double SWIG_TCL_CALL_ARGS_2(objv[5], &val5);
+   if (!SWIG_IsOK(ecode5)) {
+     SWIG_exception_fail(SWIG_ArgError(ecode5), "in method '" "SpatialReference_SetGnomonic" "', argument " "5"" of type '" "double""'");
+   } 
+   arg5 = static_cast< double >(val5);
+   result = (OGRErr)OSRSpatialReferenceShadow_SetGnomonic(arg1,arg2,arg3,arg4,arg5);
+   {
+     /* %typemap(out) OGRErr */
+     if (result != 0) {
+       Tcl_SetResult(interp, (char*) OGRErrMessages(result), TCL_STATIC);
+       SWIG_fail;
+     }
+   }
+   {
+     /* %typemap(ret) OGRErr */
+     if (!strcmp(Tcl_GetStringResult(interp), "{}") || !strcmp(Tcl_GetStringResult(interp), "")) {
+       Tcl_SetObjResult(interp, Tcl_NewLongObj( result ));
+     }
+   }
+   return TCL_OK;
+ fail:
+   return TCL_ERROR;
+ }
+ 
+ 
+ SWIGINTERN int
+ _wrap_SpatialReference_SetHOM(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
+   OSRSpatialReferenceShadow *arg1 = (OSRSpatialReferenceShadow *) 0 ;
+   double arg2 ;
+   double arg3 ;
+   double arg4 ;
+   double arg5 ;
+   double arg6 ;
+   double arg7 ;
+   double arg8 ;
+   void *argp1 = 0 ;
+   int res1 = 0 ;
+   double val2 ;
+   int ecode2 = 0 ;
+   double val3 ;
+   int ecode3 = 0 ;
+   double val4 ;
+   int ecode4 = 0 ;
+   double val5 ;
+   int ecode5 = 0 ;
+   double val6 ;
+   int ecode6 = 0 ;
+   double val7 ;
+   int ecode7 = 0 ;
+   double val8 ;
+   int ecode8 = 0 ;
+   OGRErr result;
+   
+   if (SWIG_GetArgs(interp, objc, objv,"oooooooo:osgeo::SpatialReference_SetHOM self clat clong azimuth recttoskew scale fe fn ",(void *)0,(void *)0,(void *)0,(void *)0,(void *)0,(void *)0,(void *)0,(void *)0) == TCL_ERROR) SWIG_fail;
+   res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_OSRSpatialReferenceShadow, 0 |  0 );
+   if (!SWIG_IsOK(res1)) {
+     SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SpatialReference_SetHOM" "', argument " "1"" of type '" "OSRSpatialReferenceShadow *""'"); 
+   }
+   arg1 = reinterpret_cast< OSRSpatialReferenceShadow * >(argp1);
+   ecode2 = SWIG_AsVal_double SWIG_TCL_CALL_ARGS_2(objv[2], &val2);
+   if (!SWIG_IsOK(ecode2)) {
+     SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "SpatialReference_SetHOM" "', argument " "2"" of type '" "double""'");
+   } 
+   arg2 = static_cast< double >(val2);
+   ecode3 = SWIG_AsVal_double SWIG_TCL_CALL_ARGS_2(objv[3], &val3);
+   if (!SWIG_IsOK(ecode3)) {
+     SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "SpatialReference_SetHOM" "', argument " "3"" of type '" "double""'");
+   } 
+   arg3 = static_cast< double >(val3);
+   ecode4 = SWIG_AsVal_double SWIG_TCL_CALL_ARGS_2(objv[4], &val4);
+   if (!SWIG_IsOK(ecode4)) {
+     SWIG_exception_fail(SWIG_ArgError(ecode4), "in method '" "SpatialReference_SetHOM" "', argument " "4"" of type '" "double""'");
+   } 
+   arg4 = static_cast< double >(val4);
+   ecode5 = SWIG_AsVal_double SWIG_TCL_CALL_ARGS_2(objv[5], &val5);
+   if (!SWIG_IsOK(ecode5)) {
+     SWIG_exception_fail(SWIG_ArgError(ecode5), "in method '" "SpatialReference_SetHOM" "', argument " "5"" of type '" "double""'");
+   } 
+   arg5 = static_cast< double >(val5);
+   ecode6 = SWIG_AsVal_double SWIG_TCL_CALL_ARGS_2(objv[6], &val6);
+   if (!SWIG_IsOK(ecode6)) {
+     SWIG_exception_fail(SWIG_ArgError(ecode6), "in method '" "SpatialReference_SetHOM" "', argument " "6"" of type '" "double""'");
+   } 
+   arg6 = static_cast< double >(val6);
+   ecode7 = SWIG_AsVal_double SWIG_TCL_CALL_ARGS_2(objv[7], &val7);
+   if (!SWIG_IsOK(ecode7)) {
+     SWIG_exception_fail(SWIG_ArgError(ecode7), "in method '" "SpatialReference_SetHOM" "', argument " "7"" of type '" "double""'");
+   } 
+   arg7 = static_cast< double >(val7);
+   ecode8 = SWIG_AsVal_double SWIG_TCL_CALL_ARGS_2(objv[8], &val8);
+   if (!SWIG_IsOK(ecode8)) {
+     SWIG_exception_fail(SWIG_ArgError(ecode8), "in method '" "SpatialReference_SetHOM" "', argument " "8"" of type '" "double""'");
+   } 
+   arg8 = static_cast< double >(val8);
+   result = (OGRErr)OSRSpatialReferenceShadow_SetHOM(arg1,arg2,arg3,arg4,arg5,arg6,arg7,arg8);
+   {
+     /* %typemap(out) OGRErr */
+     if (result != 0) {
+       Tcl_SetResult(interp, (char*) OGRErrMessages(result), TCL_STATIC);
+       SWIG_fail;
+     }
+   }
+   {
+     /* %typemap(ret) OGRErr */
+     if (!strcmp(Tcl_GetStringResult(interp), "{}") || !strcmp(Tcl_GetStringResult(interp), "")) {
+       Tcl_SetObjResult(interp, Tcl_NewLongObj( result ));
+     }
+   }
+   return TCL_OK;
+ fail:
+   return TCL_ERROR;
+ }
+ 
+ 
+ SWIGINTERN int
+ _wrap_SpatialReference_SetHOM2PNO(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
+   OSRSpatialReferenceShadow *arg1 = (OSRSpatialReferenceShadow *) 0 ;
+   double arg2 ;
+   double arg3 ;
+   double arg4 ;
+   double arg5 ;
+   double arg6 ;
+   double arg7 ;
+   double arg8 ;
+   double arg9 ;
+   void *argp1 = 0 ;
+   int res1 = 0 ;
+   double val2 ;
+   int ecode2 = 0 ;
+   double val3 ;
+   int ecode3 = 0 ;
+   double val4 ;
+   int ecode4 = 0 ;
+   double val5 ;
+   int ecode5 = 0 ;
+   double val6 ;
+   int ecode6 = 0 ;
+   double val7 ;
+   int ecode7 = 0 ;
+   double val8 ;
+   int ecode8 = 0 ;
+   double val9 ;
+   int ecode9 = 0 ;
+   OGRErr result;
+   
+   if (SWIG_GetArgs(interp, objc, objv,"ooooooooo:osgeo::SpatialReference_SetHOM2PNO self clat dfLat1 dfLong1 dfLat2 dfLong2 scale fe fn ",(void *)0,(void *)0,(void *)0,(void *)0,(void *)0,(void *)0,(void *)0,(void *)0,(void *)0) == TCL_ERROR) SWIG_fail;
+   res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_OSRSpatialReferenceShadow, 0 |  0 );
+   if (!SWIG_IsOK(res1)) {
+     SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SpatialReference_SetHOM2PNO" "', argument " "1"" of type '" "OSRSpatialReferenceShadow *""'"); 
+   }
+   arg1 = reinterpret_cast< OSRSpatialReferenceShadow * >(argp1);
+   ecode2 = SWIG_AsVal_double SWIG_TCL_CALL_ARGS_2(objv[2], &val2);
+   if (!SWIG_IsOK(ecode2)) {
+     SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "SpatialReference_SetHOM2PNO" "', argument " "2"" of type '" "double""'");
+   } 
+   arg2 = static_cast< double >(val2);
+   ecode3 = SWIG_AsVal_double SWIG_TCL_CALL_ARGS_2(objv[3], &val3);
+   if (!SWIG_IsOK(ecode3)) {
+     SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "SpatialReference_SetHOM2PNO" "', argument " "3"" of type '" "double""'");
+   } 
+   arg3 = static_cast< double >(val3);
+   ecode4 = SWIG_AsVal_double SWIG_TCL_CALL_ARGS_2(objv[4], &val4);
+   if (!SWIG_IsOK(ecode4)) {
+     SWIG_exception_fail(SWIG_ArgError(ecode4), "in method '" "SpatialReference_SetHOM2PNO" "', argument " "4"" of type '" "double""'");
+   } 
+   arg4 = static_cast< double >(val4);
+   ecode5 = SWIG_AsVal_double SWIG_TCL_CALL_ARGS_2(objv[5], &val5);
+   if (!SWIG_IsOK(ecode5)) {
+     SWIG_exception_fail(SWIG_ArgError(ecode5), "in method '" "SpatialReference_SetHOM2PNO" "', argument " "5"" of type '" "double""'");
+   } 
+   arg5 = static_cast< double >(val5);
+   ecode6 = SWIG_AsVal_double SWIG_TCL_CALL_ARGS_2(objv[6], &val6);
+   if (!SWIG_IsOK(ecode6)) {
+     SWIG_exception_fail(SWIG_ArgError(ecode6), "in method '" "SpatialReference_SetHOM2PNO" "', argument " "6"" of type '" "double""'");
+   } 
+   arg6 = static_cast< double >(val6);
+   ecode7 = SWIG_AsVal_double SWIG_TCL_CALL_ARGS_2(objv[7], &val7);
+   if (!SWIG_IsOK(ecode7)) {
+     SWIG_exception_fail(SWIG_ArgError(ecode7), "in method '" "SpatialReference_SetHOM2PNO" "', argument " "7"" of type '" "double""'");
+   } 
+   arg7 = static_cast< double >(val7);
+   ecode8 = SWIG_AsVal_double SWIG_TCL_CALL_ARGS_2(objv[8], &val8);
+   if (!SWIG_IsOK(ecode8)) {
+     SWIG_exception_fail(SWIG_ArgError(ecode8), "in method '" "SpatialReference_SetHOM2PNO" "', argument " "8"" of type '" "double""'");
+   } 
+   arg8 = static_cast< double >(val8);
+   ecode9 = SWIG_AsVal_double SWIG_TCL_CALL_ARGS_2(objv[9], &val9);
+   if (!SWIG_IsOK(ecode9)) {
+     SWIG_exception_fail(SWIG_ArgError(ecode9), "in method '" "SpatialReference_SetHOM2PNO" "', argument " "9"" of type '" "double""'");
+   } 
+   arg9 = static_cast< double >(val9);
+   result = (OGRErr)OSRSpatialReferenceShadow_SetHOM2PNO(arg1,arg2,arg3,arg4,arg5,arg6,arg7,arg8,arg9);
+   {
+     /* %typemap(out) OGRErr */
+     if (result != 0) {
+       Tcl_SetResult(interp, (char*) OGRErrMessages(result), TCL_STATIC);
+       SWIG_fail;
+     }
+   }
+   {
+     /* %typemap(ret) OGRErr */
+     if (!strcmp(Tcl_GetStringResult(interp), "{}") || !strcmp(Tcl_GetStringResult(interp), "")) {
+       Tcl_SetObjResult(interp, Tcl_NewLongObj( result ));
+     }
+   }
+   return TCL_OK;
+ fail:
+   return TCL_ERROR;
+ }
+ 
+ 
+ SWIGINTERN int
+ _wrap_SpatialReference_SetKrovak(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
+   OSRSpatialReferenceShadow *arg1 = (OSRSpatialReferenceShadow *) 0 ;
+   double arg2 ;
+   double arg3 ;
+   double arg4 ;
+   double arg5 ;
+   double arg6 ;
+   double arg7 ;
+   double arg8 ;
+   void *argp1 = 0 ;
+   int res1 = 0 ;
+   double val2 ;
+   int ecode2 = 0 ;
+   double val3 ;
+   int ecode3 = 0 ;
+   double val4 ;
+   int ecode4 = 0 ;
+   double val5 ;
+   int ecode5 = 0 ;
+   double val6 ;
+   int ecode6 = 0 ;
+   double val7 ;
+   int ecode7 = 0 ;
+   double val8 ;
+   int ecode8 = 0 ;
+   OGRErr result;
+   
+   if (SWIG_GetArgs(interp, objc, objv,"oooooooo:osgeo::SpatialReference_SetKrovak self clat clong azimuth pseudostdparallellat scale fe fn ",(void *)0,(void *)0,(void *)0,(void *)0,(void *)0,(void *)0,(void *)0,(void *)0) == TCL_ERROR) SWIG_fail;
+   res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_OSRSpatialReferenceShadow, 0 |  0 );
+   if (!SWIG_IsOK(res1)) {
+     SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SpatialReference_SetKrovak" "', argument " "1"" of type '" "OSRSpatialReferenceShadow *""'"); 
+   }
+   arg1 = reinterpret_cast< OSRSpatialReferenceShadow * >(argp1);
+   ecode2 = SWIG_AsVal_double SWIG_TCL_CALL_ARGS_2(objv[2], &val2);
+   if (!SWIG_IsOK(ecode2)) {
+     SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "SpatialReference_SetKrovak" "', argument " "2"" of type '" "double""'");
+   } 
+   arg2 = static_cast< double >(val2);
+   ecode3 = SWIG_AsVal_double SWIG_TCL_CALL_ARGS_2(objv[3], &val3);
+   if (!SWIG_IsOK(ecode3)) {
+     SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "SpatialReference_SetKrovak" "', argument " "3"" of type '" "double""'");
+   } 
+   arg3 = static_cast< double >(val3);
+   ecode4 = SWIG_AsVal_double SWIG_TCL_CALL_ARGS_2(objv[4], &val4);
+   if (!SWIG_IsOK(ecode4)) {
+     SWIG_exception_fail(SWIG_ArgError(ecode4), "in method '" "SpatialReference_SetKrovak" "', argument " "4"" of type '" "double""'");
+   } 
+   arg4 = static_cast< double >(val4);
+   ecode5 = SWIG_AsVal_double SWIG_TCL_CALL_ARGS_2(objv[5], &val5);
+   if (!SWIG_IsOK(ecode5)) {
+     SWIG_exception_fail(SWIG_ArgError(ecode5), "in method '" "SpatialReference_SetKrovak" "', argument " "5"" of type '" "double""'");
+   } 
+   arg5 = static_cast< double >(val5);
+   ecode6 = SWIG_AsVal_double SWIG_TCL_CALL_ARGS_2(objv[6], &val6);
+   if (!SWIG_IsOK(ecode6)) {
+     SWIG_exception_fail(SWIG_ArgError(ecode6), "in method '" "SpatialReference_SetKrovak" "', argument " "6"" of type '" "double""'");
+   } 
+   arg6 = static_cast< double >(val6);
+   ecode7 = SWIG_AsVal_double SWIG_TCL_CALL_ARGS_2(objv[7], &val7);
+   if (!SWIG_IsOK(ecode7)) {
+     SWIG_exception_fail(SWIG_ArgError(ecode7), "in method '" "SpatialReference_SetKrovak" "', argument " "7"" of type '" "double""'");
+   } 
+   arg7 = static_cast< double >(val7);
+   ecode8 = SWIG_AsVal_double SWIG_TCL_CALL_ARGS_2(objv[8], &val8);
+   if (!SWIG_IsOK(ecode8)) {
+     SWIG_exception_fail(SWIG_ArgError(ecode8), "in method '" "SpatialReference_SetKrovak" "', argument " "8"" of type '" "double""'");
+   } 
+   arg8 = static_cast< double >(val8);
+   result = (OGRErr)OSRSpatialReferenceShadow_SetKrovak(arg1,arg2,arg3,arg4,arg5,arg6,arg7,arg8);
+   {
+     /* %typemap(out) OGRErr */
+     if (result != 0) {
+       Tcl_SetResult(interp, (char*) OGRErrMessages(result), TCL_STATIC);
+       SWIG_fail;
+     }
+   }
+   {
+     /* %typemap(ret) OGRErr */
+     if (!strcmp(Tcl_GetStringResult(interp), "{}") || !strcmp(Tcl_GetStringResult(interp), "")) {
+       Tcl_SetObjResult(interp, Tcl_NewLongObj( result ));
+     }
+   }
+   return TCL_OK;
+ fail:
+   return TCL_ERROR;
+ }
+ 
+ 
+ SWIGINTERN int
+ _wrap_SpatialReference_SetLAEA(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
+   OSRSpatialReferenceShadow *arg1 = (OSRSpatialReferenceShadow *) 0 ;
+   double arg2 ;
+   double arg3 ;
+   double arg4 ;
+   double arg5 ;
+   void *argp1 = 0 ;
+   int res1 = 0 ;
+   double val2 ;
+   int ecode2 = 0 ;
+   double val3 ;
+   int ecode3 = 0 ;
+   double val4 ;
+   int ecode4 = 0 ;
+   double val5 ;
+   int ecode5 = 0 ;
+   OGRErr result;
+   
+   if (SWIG_GetArgs(interp, objc, objv,"ooooo:osgeo::SpatialReference_SetLAEA self clat clong fe fn ",(void *)0,(void *)0,(void *)0,(void *)0,(void *)0) == TCL_ERROR) SWIG_fail;
+   res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_OSRSpatialReferenceShadow, 0 |  0 );
+   if (!SWIG_IsOK(res1)) {
+     SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SpatialReference_SetLAEA" "', argument " "1"" of type '" "OSRSpatialReferenceShadow *""'"); 
+   }
+   arg1 = reinterpret_cast< OSRSpatialReferenceShadow * >(argp1);
+   ecode2 = SWIG_AsVal_double SWIG_TCL_CALL_ARGS_2(objv[2], &val2);
+   if (!SWIG_IsOK(ecode2)) {
+     SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "SpatialReference_SetLAEA" "', argument " "2"" of type '" "double""'");
+   } 
+   arg2 = static_cast< double >(val2);
+   ecode3 = SWIG_AsVal_double SWIG_TCL_CALL_ARGS_2(objv[3], &val3);
+   if (!SWIG_IsOK(ecode3)) {
+     SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "SpatialReference_SetLAEA" "', argument " "3"" of type '" "double""'");
+   } 
+   arg3 = static_cast< double >(val3);
+   ecode4 = SWIG_AsVal_double SWIG_TCL_CALL_ARGS_2(objv[4], &val4);
+   if (!SWIG_IsOK(ecode4)) {
+     SWIG_exception_fail(SWIG_ArgError(ecode4), "in method '" "SpatialReference_SetLAEA" "', argument " "4"" of type '" "double""'");
+   } 
+   arg4 = static_cast< double >(val4);
+   ecode5 = SWIG_AsVal_double SWIG_TCL_CALL_ARGS_2(objv[5], &val5);
+   if (!SWIG_IsOK(ecode5)) {
+     SWIG_exception_fail(SWIG_ArgError(ecode5), "in method '" "SpatialReference_SetLAEA" "', argument " "5"" of type '" "double""'");
+   } 
+   arg5 = static_cast< double >(val5);
+   result = (OGRErr)OSRSpatialReferenceShadow_SetLAEA(arg1,arg2,arg3,arg4,arg5);
+   {
+     /* %typemap(out) OGRErr */
+     if (result != 0) {
+       Tcl_SetResult(interp, (char*) OGRErrMessages(result), TCL_STATIC);
+       SWIG_fail;
+     }
+   }
+   {
+     /* %typemap(ret) OGRErr */
+     if (!strcmp(Tcl_GetStringResult(interp), "{}") || !strcmp(Tcl_GetStringResult(interp), "")) {
+       Tcl_SetObjResult(interp, Tcl_NewLongObj( result ));
+     }
+   }
+   return TCL_OK;
+ fail:
+   return TCL_ERROR;
+ }
+ 
+ 
+ SWIGINTERN int
+ _wrap_SpatialReference_SetLCC(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
+   OSRSpatialReferenceShadow *arg1 = (OSRSpatialReferenceShadow *) 0 ;
+   double arg2 ;
+   double arg3 ;
+   double arg4 ;
+   double arg5 ;
+   double arg6 ;
+   double arg7 ;
+   void *argp1 = 0 ;
+   int res1 = 0 ;
+   double val2 ;
+   int ecode2 = 0 ;
+   double val3 ;
+   int ecode3 = 0 ;
+   double val4 ;
+   int ecode4 = 0 ;
+   double val5 ;
+   int ecode5 = 0 ;
+   double val6 ;
+   int ecode6 = 0 ;
+   double val7 ;
+   int ecode7 = 0 ;
+   OGRErr result;
+   
+   if (SWIG_GetArgs(interp, objc, objv,"ooooooo:osgeo::SpatialReference_SetLCC self stdp1 stdp2 clat clong fe fn ",(void *)0,(void *)0,(void *)0,(void *)0,(void *)0,(void *)0,(void *)0) == TCL_ERROR) SWIG_fail;
+   res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_OSRSpatialReferenceShadow, 0 |  0 );
+   if (!SWIG_IsOK(res1)) {
+     SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SpatialReference_SetLCC" "', argument " "1"" of type '" "OSRSpatialReferenceShadow *""'"); 
+   }
+   arg1 = reinterpret_cast< OSRSpatialReferenceShadow * >(argp1);
+   ecode2 = SWIG_AsVal_double SWIG_TCL_CALL_ARGS_2(objv[2], &val2);
+   if (!SWIG_IsOK(ecode2)) {
+     SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "SpatialReference_SetLCC" "', argument " "2"" of type '" "double""'");
+   } 
+   arg2 = static_cast< double >(val2);
+   ecode3 = SWIG_AsVal_double SWIG_TCL_CALL_ARGS_2(objv[3], &val3);
+   if (!SWIG_IsOK(ecode3)) {
+     SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "SpatialReference_SetLCC" "', argument " "3"" of type '" "double""'");
+   } 
+   arg3 = static_cast< double >(val3);
+   ecode4 = SWIG_AsVal_double SWIG_TCL_CALL_ARGS_2(objv[4], &val4);
+   if (!SWIG_IsOK(ecode4)) {
+     SWIG_exception_fail(SWIG_ArgError(ecode4), "in method '" "SpatialReference_SetLCC" "', argument " "4"" of type '" "double""'");
+   } 
+   arg4 = static_cast< double >(val4);
+   ecode5 = SWIG_AsVal_double SWIG_TCL_CALL_ARGS_2(objv[5], &val5);
+   if (!SWIG_IsOK(ecode5)) {
+     SWIG_exception_fail(SWIG_ArgError(ecode5), "in method '" "SpatialReference_SetLCC" "', argument " "5"" of type '" "double""'");
+   } 
+   arg5 = static_cast< double >(val5);
+   ecode6 = SWIG_AsVal_double SWIG_TCL_CALL_ARGS_2(objv[6], &val6);
+   if (!SWIG_IsOK(ecode6)) {
+     SWIG_exception_fail(SWIG_ArgError(ecode6), "in method '" "SpatialReference_SetLCC" "', argument " "6"" of type '" "double""'");
+   } 
+   arg6 = static_cast< double >(val6);
+   ecode7 = SWIG_AsVal_double SWIG_TCL_CALL_ARGS_2(objv[7], &val7);
+   if (!SWIG_IsOK(ecode7)) {
+     SWIG_exception_fail(SWIG_ArgError(ecode7), "in method '" "SpatialReference_SetLCC" "', argument " "7"" of type '" "double""'");
+   } 
+   arg7 = static_cast< double >(val7);
+   result = (OGRErr)OSRSpatialReferenceShadow_SetLCC(arg1,arg2,arg3,arg4,arg5,arg6,arg7);
+   {
+     /* %typemap(out) OGRErr */
+     if (result != 0) {
+       Tcl_SetResult(interp, (char*) OGRErrMessages(result), TCL_STATIC);
+       SWIG_fail;
+     }
+   }
+   {
+     /* %typemap(ret) OGRErr */
+     if (!strcmp(Tcl_GetStringResult(interp), "{}") || !strcmp(Tcl_GetStringResult(interp), "")) {
+       Tcl_SetObjResult(interp, Tcl_NewLongObj( result ));
+     }
+   }
+   return TCL_OK;
+ fail:
+   return TCL_ERROR;
+ }
+ 
+ 
+ SWIGINTERN int
+ _wrap_SpatialReference_SetLCC1SP(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
+   OSRSpatialReferenceShadow *arg1 = (OSRSpatialReferenceShadow *) 0 ;
+   double arg2 ;
+   double arg3 ;
+   double arg4 ;
+   double arg5 ;
+   double arg6 ;
+   void *argp1 = 0 ;
+   int res1 = 0 ;
+   double val2 ;
+   int ecode2 = 0 ;
+   double val3 ;
+   int ecode3 = 0 ;
+   double val4 ;
+   int ecode4 = 0 ;
+   double val5 ;
+   int ecode5 = 0 ;
+   double val6 ;
+   int ecode6 = 0 ;
+   OGRErr result;
+   
+   if (SWIG_GetArgs(interp, objc, objv,"oooooo:osgeo::SpatialReference_SetLCC1SP self clat clong scale fe fn ",(void *)0,(void *)0,(void *)0,(void *)0,(void *)0,(void *)0) == TCL_ERROR) SWIG_fail;
+   res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_OSRSpatialReferenceShadow, 0 |  0 );
+   if (!SWIG_IsOK(res1)) {
+     SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SpatialReference_SetLCC1SP" "', argument " "1"" of type '" "OSRSpatialReferenceShadow *""'"); 
+   }
+   arg1 = reinterpret_cast< OSRSpatialReferenceShadow * >(argp1);
+   ecode2 = SWIG_AsVal_double SWIG_TCL_CALL_ARGS_2(objv[2], &val2);
+   if (!SWIG_IsOK(ecode2)) {
+     SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "SpatialReference_SetLCC1SP" "', argument " "2"" of type '" "double""'");
+   } 
+   arg2 = static_cast< double >(val2);
+   ecode3 = SWIG_AsVal_double SWIG_TCL_CALL_ARGS_2(objv[3], &val3);
+   if (!SWIG_IsOK(ecode3)) {
+     SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "SpatialReference_SetLCC1SP" "', argument " "3"" of type '" "double""'");
+   } 
+   arg3 = static_cast< double >(val3);
+   ecode4 = SWIG_AsVal_double SWIG_TCL_CALL_ARGS_2(objv[4], &val4);
+   if (!SWIG_IsOK(ecode4)) {
+     SWIG_exception_fail(SWIG_ArgError(ecode4), "in method '" "SpatialReference_SetLCC1SP" "', argument " "4"" of type '" "double""'");
+   } 
+   arg4 = static_cast< double >(val4);
+   ecode5 = SWIG_AsVal_double SWIG_TCL_CALL_ARGS_2(objv[5], &val5);
+   if (!SWIG_IsOK(ecode5)) {
+     SWIG_exception_fail(SWIG_ArgError(ecode5), "in method '" "SpatialReference_SetLCC1SP" "', argument " "5"" of type '" "double""'");
+   } 
+   arg5 = static_cast< double >(val5);
+   ecode6 = SWIG_AsVal_double SWIG_TCL_CALL_ARGS_2(objv[6], &val6);
+   if (!SWIG_IsOK(ecode6)) {
+     SWIG_exception_fail(SWIG_ArgError(ecode6), "in method '" "SpatialReference_SetLCC1SP" "', argument " "6"" of type '" "double""'");
+   } 
+   arg6 = static_cast< double >(val6);
+   result = (OGRErr)OSRSpatialReferenceShadow_SetLCC1SP(arg1,arg2,arg3,arg4,arg5,arg6);
+   {
+     /* %typemap(out) OGRErr */
+     if (result != 0) {
+       Tcl_SetResult(interp, (char*) OGRErrMessages(result), TCL_STATIC);
+       SWIG_fail;
+     }
+   }
+   {
+     /* %typemap(ret) OGRErr */
+     if (!strcmp(Tcl_GetStringResult(interp), "{}") || !strcmp(Tcl_GetStringResult(interp), "")) {
+       Tcl_SetObjResult(interp, Tcl_NewLongObj( result ));
+     }
+   }
+   return TCL_OK;
+ fail:
+   return TCL_ERROR;
+ }
+ 
+ 
+ SWIGINTERN int
+ _wrap_SpatialReference_SetLCCB(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
+   OSRSpatialReferenceShadow *arg1 = (OSRSpatialReferenceShadow *) 0 ;
+   double arg2 ;
+   double arg3 ;
+   double arg4 ;
+   double arg5 ;
+   double arg6 ;
+   double arg7 ;
+   void *argp1 = 0 ;
+   int res1 = 0 ;
+   double val2 ;
+   int ecode2 = 0 ;
+   double val3 ;
+   int ecode3 = 0 ;
+   double val4 ;
+   int ecode4 = 0 ;
+   double val5 ;
+   int ecode5 = 0 ;
+   double val6 ;
+   int ecode6 = 0 ;
+   double val7 ;
+   int ecode7 = 0 ;
+   OGRErr result;
+   
+   if (SWIG_GetArgs(interp, objc, objv,"ooooooo:osgeo::SpatialReference_SetLCCB self stdp1 stdp2 clat clong fe fn ",(void *)0,(void *)0,(void *)0,(void *)0,(void *)0,(void *)0,(void *)0) == TCL_ERROR) SWIG_fail;
+   res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_OSRSpatialReferenceShadow, 0 |  0 );
+   if (!SWIG_IsOK(res1)) {
+     SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SpatialReference_SetLCCB" "', argument " "1"" of type '" "OSRSpatialReferenceShadow *""'"); 
+   }
+   arg1 = reinterpret_cast< OSRSpatialReferenceShadow * >(argp1);
+   ecode2 = SWIG_AsVal_double SWIG_TCL_CALL_ARGS_2(objv[2], &val2);
+   if (!SWIG_IsOK(ecode2)) {
+     SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "SpatialReference_SetLCCB" "', argument " "2"" of type '" "double""'");
+   } 
+   arg2 = static_cast< double >(val2);
+   ecode3 = SWIG_AsVal_double SWIG_TCL_CALL_ARGS_2(objv[3], &val3);
+   if (!SWIG_IsOK(ecode3)) {
+     SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "SpatialReference_SetLCCB" "', argument " "3"" of type '" "double""'");
+   } 
+   arg3 = static_cast< double >(val3);
+   ecode4 = SWIG_AsVal_double SWIG_TCL_CALL_ARGS_2(objv[4], &val4);
+   if (!SWIG_IsOK(ecode4)) {
+     SWIG_exception_fail(SWIG_ArgError(ecode4), "in method '" "SpatialReference_SetLCCB" "', argument " "4"" of type '" "double""'");
+   } 
+   arg4 = static_cast< double >(val4);
+   ecode5 = SWIG_AsVal_double SWIG_TCL_CALL_ARGS_2(objv[5], &val5);
+   if (!SWIG_IsOK(ecode5)) {
+     SWIG_exception_fail(SWIG_ArgError(ecode5), "in method '" "SpatialReference_SetLCCB" "', argument " "5"" of type '" "double""'");
+   } 
+   arg5 = static_cast< double >(val5);
+   ecode6 = SWIG_AsVal_double SWIG_TCL_CALL_ARGS_2(objv[6], &val6);
+   if (!SWIG_IsOK(ecode6)) {
+     SWIG_exception_fail(SWIG_ArgError(ecode6), "in method '" "SpatialReference_SetLCCB" "', argument " "6"" of type '" "double""'");
+   } 
+   arg6 = static_cast< double >(val6);
+   ecode7 = SWIG_AsVal_double SWIG_TCL_CALL_ARGS_2(objv[7], &val7);
+   if (!SWIG_IsOK(ecode7)) {
+     SWIG_exception_fail(SWIG_ArgError(ecode7), "in method '" "SpatialReference_SetLCCB" "', argument " "7"" of type '" "double""'");
+   } 
+   arg7 = static_cast< double >(val7);
+   result = (OGRErr)OSRSpatialReferenceShadow_SetLCCB(arg1,arg2,arg3,arg4,arg5,arg6,arg7);
+   {
+     /* %typemap(out) OGRErr */
+     if (result != 0) {
+       Tcl_SetResult(interp, (char*) OGRErrMessages(result), TCL_STATIC);
+       SWIG_fail;
+     }
+   }
+   {
+     /* %typemap(ret) OGRErr */
+     if (!strcmp(Tcl_GetStringResult(interp), "{}") || !strcmp(Tcl_GetStringResult(interp), "")) {
+       Tcl_SetObjResult(interp, Tcl_NewLongObj( result ));
+     }
+   }
+   return TCL_OK;
+ fail:
+   return TCL_ERROR;
+ }
+ 
+ 
+ SWIGINTERN int
+ _wrap_SpatialReference_SetMC(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
+   OSRSpatialReferenceShadow *arg1 = (OSRSpatialReferenceShadow *) 0 ;
+   double arg2 ;
+   double arg3 ;
+   double arg4 ;
+   double arg5 ;
+   void *argp1 = 0 ;
+   int res1 = 0 ;
+   double val2 ;
+   int ecode2 = 0 ;
+   double val3 ;
+   int ecode3 = 0 ;
+   double val4 ;
+   int ecode4 = 0 ;
+   double val5 ;
+   int ecode5 = 0 ;
+   OGRErr result;
+   
+   if (SWIG_GetArgs(interp, objc, objv,"ooooo:osgeo::SpatialReference_SetMC self clat clong fe fn ",(void *)0,(void *)0,(void *)0,(void *)0,(void *)0) == TCL_ERROR) SWIG_fail;
+   res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_OSRSpatialReferenceShadow, 0 |  0 );
+   if (!SWIG_IsOK(res1)) {
+     SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SpatialReference_SetMC" "', argument " "1"" of type '" "OSRSpatialReferenceShadow *""'"); 
+   }
+   arg1 = reinterpret_cast< OSRSpatialReferenceShadow * >(argp1);
+   ecode2 = SWIG_AsVal_double SWIG_TCL_CALL_ARGS_2(objv[2], &val2);
+   if (!SWIG_IsOK(ecode2)) {
+     SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "SpatialReference_SetMC" "', argument " "2"" of type '" "double""'");
+   } 
+   arg2 = static_cast< double >(val2);
+   ecode3 = SWIG_AsVal_double SWIG_TCL_CALL_ARGS_2(objv[3], &val3);
+   if (!SWIG_IsOK(ecode3)) {
+     SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "SpatialReference_SetMC" "', argument " "3"" of type '" "double""'");
+   } 
+   arg3 = static_cast< double >(val3);
+   ecode4 = SWIG_AsVal_double SWIG_TCL_CALL_ARGS_2(objv[4], &val4);
+   if (!SWIG_IsOK(ecode4)) {
+     SWIG_exception_fail(SWIG_ArgError(ecode4), "in method '" "SpatialReference_SetMC" "', argument " "4"" of type '" "double""'");
+   } 
+   arg4 = static_cast< double >(val4);
+   ecode5 = SWIG_AsVal_double SWIG_TCL_CALL_ARGS_2(objv[5], &val5);
+   if (!SWIG_IsOK(ecode5)) {
+     SWIG_exception_fail(SWIG_ArgError(ecode5), "in method '" "SpatialReference_SetMC" "', argument " "5"" of type '" "double""'");
+   } 
+   arg5 = static_cast< double >(val5);
+   result = (OGRErr)OSRSpatialReferenceShadow_SetMC(arg1,arg2,arg3,arg4,arg5);
+   {
+     /* %typemap(out) OGRErr */
+     if (result != 0) {
+       Tcl_SetResult(interp, (char*) OGRErrMessages(result), TCL_STATIC);
+       SWIG_fail;
+     }
+   }
+   {
+     /* %typemap(ret) OGRErr */
+     if (!strcmp(Tcl_GetStringResult(interp), "{}") || !strcmp(Tcl_GetStringResult(interp), "")) {
+       Tcl_SetObjResult(interp, Tcl_NewLongObj( result ));
+     }
+   }
+   return TCL_OK;
+ fail:
+   return TCL_ERROR;
+ }
+ 
+ 
+ SWIGINTERN int
+ _wrap_SpatialReference_SetMercator(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
+   OSRSpatialReferenceShadow *arg1 = (OSRSpatialReferenceShadow *) 0 ;
+   double arg2 ;
+   double arg3 ;
+   double arg4 ;
+   double arg5 ;
+   double arg6 ;
+   void *argp1 = 0 ;
+   int res1 = 0 ;
+   double val2 ;
+   int ecode2 = 0 ;
+   double val3 ;
+   int ecode3 = 0 ;
+   double val4 ;
+   int ecode4 = 0 ;
+   double val5 ;
+   int ecode5 = 0 ;
+   double val6 ;
+   int ecode6 = 0 ;
+   OGRErr result;
+   
+   if (SWIG_GetArgs(interp, objc, objv,"oooooo:osgeo::SpatialReference_SetMercator self clat clong scale fe fn ",(void *)0,(void *)0,(void *)0,(void *)0,(void *)0,(void *)0) == TCL_ERROR) SWIG_fail;
+   res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_OSRSpatialReferenceShadow, 0 |  0 );
+   if (!SWIG_IsOK(res1)) {
+     SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SpatialReference_SetMercator" "', argument " "1"" of type '" "OSRSpatialReferenceShadow *""'"); 
+   }
+   arg1 = reinterpret_cast< OSRSpatialReferenceShadow * >(argp1);
+   ecode2 = SWIG_AsVal_double SWIG_TCL_CALL_ARGS_2(objv[2], &val2);
+   if (!SWIG_IsOK(ecode2)) {
+     SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "SpatialReference_SetMercator" "', argument " "2"" of type '" "double""'");
+   } 
+   arg2 = static_cast< double >(val2);
+   ecode3 = SWIG_AsVal_double SWIG_TCL_CALL_ARGS_2(objv[3], &val3);
+   if (!SWIG_IsOK(ecode3)) {
+     SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "SpatialReference_SetMercator" "', argument " "3"" of type '" "double""'");
+   } 
+   arg3 = static_cast< double >(val3);
+   ecode4 = SWIG_AsVal_double SWIG_TCL_CALL_ARGS_2(objv[4], &val4);
+   if (!SWIG_IsOK(ecode4)) {
+     SWIG_exception_fail(SWIG_ArgError(ecode4), "in method '" "SpatialReference_SetMercator" "', argument " "4"" of type '" "double""'");
+   } 
+   arg4 = static_cast< double >(val4);
+   ecode5 = SWIG_AsVal_double SWIG_TCL_CALL_ARGS_2(objv[5], &val5);
+   if (!SWIG_IsOK(ecode5)) {
+     SWIG_exception_fail(SWIG_ArgError(ecode5), "in method '" "SpatialReference_SetMercator" "', argument " "5"" of type '" "double""'");
+   } 
+   arg5 = static_cast< double >(val5);
+   ecode6 = SWIG_AsVal_double SWIG_TCL_CALL_ARGS_2(objv[6], &val6);
+   if (!SWIG_IsOK(ecode6)) {
+     SWIG_exception_fail(SWIG_ArgError(ecode6), "in method '" "SpatialReference_SetMercator" "', argument " "6"" of type '" "double""'");
+   } 
+   arg6 = static_cast< double >(val6);
+   result = (OGRErr)OSRSpatialReferenceShadow_SetMercator(arg1,arg2,arg3,arg4,arg5,arg6);
+   {
+     /* %typemap(out) OGRErr */
+     if (result != 0) {
+       Tcl_SetResult(interp, (char*) OGRErrMessages(result), TCL_STATIC);
+       SWIG_fail;
+     }
+   }
+   {
+     /* %typemap(ret) OGRErr */
+     if (!strcmp(Tcl_GetStringResult(interp), "{}") || !strcmp(Tcl_GetStringResult(interp), "")) {
+       Tcl_SetObjResult(interp, Tcl_NewLongObj( result ));
+     }
+   }
+   return TCL_OK;
+ fail:
+   return TCL_ERROR;
+ }
+ 
+ 
+ SWIGINTERN int
+ _wrap_SpatialReference_SetMollweide(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
+   OSRSpatialReferenceShadow *arg1 = (OSRSpatialReferenceShadow *) 0 ;
+   double arg2 ;
+   double arg3 ;
+   double arg4 ;
+   void *argp1 = 0 ;
+   int res1 = 0 ;
+   double val2 ;
+   int ecode2 = 0 ;
+   double val3 ;
+   int ecode3 = 0 ;
+   double val4 ;
+   int ecode4 = 0 ;
+   OGRErr result;
+   
+   if (SWIG_GetArgs(interp, objc, objv,"oooo:osgeo::SpatialReference_SetMollweide self cm fe fn ",(void *)0,(void *)0,(void *)0,(void *)0) == TCL_ERROR) SWIG_fail;
+   res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_OSRSpatialReferenceShadow, 0 |  0 );
+   if (!SWIG_IsOK(res1)) {
+     SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SpatialReference_SetMollweide" "', argument " "1"" of type '" "OSRSpatialReferenceShadow *""'"); 
+   }
+   arg1 = reinterpret_cast< OSRSpatialReferenceShadow * >(argp1);
+   ecode2 = SWIG_AsVal_double SWIG_TCL_CALL_ARGS_2(objv[2], &val2);
+   if (!SWIG_IsOK(ecode2)) {
+     SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "SpatialReference_SetMollweide" "', argument " "2"" of type '" "double""'");
+   } 
+   arg2 = static_cast< double >(val2);
+   ecode3 = SWIG_AsVal_double SWIG_TCL_CALL_ARGS_2(objv[3], &val3);
+   if (!SWIG_IsOK(ecode3)) {
+     SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "SpatialReference_SetMollweide" "', argument " "3"" of type '" "double""'");
+   } 
+   arg3 = static_cast< double >(val3);
+   ecode4 = SWIG_AsVal_double SWIG_TCL_CALL_ARGS_2(objv[4], &val4);
+   if (!SWIG_IsOK(ecode4)) {
+     SWIG_exception_fail(SWIG_ArgError(ecode4), "in method '" "SpatialReference_SetMollweide" "', argument " "4"" of type '" "double""'");
+   } 
+   arg4 = static_cast< double >(val4);
+   result = (OGRErr)OSRSpatialReferenceShadow_SetMollweide(arg1,arg2,arg3,arg4);
+   {
+     /* %typemap(out) OGRErr */
+     if (result != 0) {
+       Tcl_SetResult(interp, (char*) OGRErrMessages(result), TCL_STATIC);
+       SWIG_fail;
+     }
+   }
+   {
+     /* %typemap(ret) OGRErr */
+     if (!strcmp(Tcl_GetStringResult(interp), "{}") || !strcmp(Tcl_GetStringResult(interp), "")) {
+       Tcl_SetObjResult(interp, Tcl_NewLongObj( result ));
+     }
+   }
+   return TCL_OK;
+ fail:
+   return TCL_ERROR;
+ }
+ 
+ 
+ SWIGINTERN int
+ _wrap_SpatialReference_SetNZMG(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
+   OSRSpatialReferenceShadow *arg1 = (OSRSpatialReferenceShadow *) 0 ;
+   double arg2 ;
+   double arg3 ;
+   double arg4 ;
+   double arg5 ;
+   void *argp1 = 0 ;
+   int res1 = 0 ;
+   double val2 ;
+   int ecode2 = 0 ;
+   double val3 ;
+   int ecode3 = 0 ;
+   double val4 ;
+   int ecode4 = 0 ;
+   double val5 ;
+   int ecode5 = 0 ;
+   OGRErr result;
+   
+   if (SWIG_GetArgs(interp, objc, objv,"ooooo:osgeo::SpatialReference_SetNZMG self clat clong fe fn ",(void *)0,(void *)0,(void *)0,(void *)0,(void *)0) == TCL_ERROR) SWIG_fail;
+   res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_OSRSpatialReferenceShadow, 0 |  0 );
+   if (!SWIG_IsOK(res1)) {
+     SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SpatialReference_SetNZMG" "', argument " "1"" of type '" "OSRSpatialReferenceShadow *""'"); 
+   }
+   arg1 = reinterpret_cast< OSRSpatialReferenceShadow * >(argp1);
+   ecode2 = SWIG_AsVal_double SWIG_TCL_CALL_ARGS_2(objv[2], &val2);
+   if (!SWIG_IsOK(ecode2)) {
+     SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "SpatialReference_SetNZMG" "', argument " "2"" of type '" "double""'");
+   } 
+   arg2 = static_cast< double >(val2);
+   ecode3 = SWIG_AsVal_double SWIG_TCL_CALL_ARGS_2(objv[3], &val3);
+   if (!SWIG_IsOK(ecode3)) {
+     SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "SpatialReference_SetNZMG" "', argument " "3"" of type '" "double""'");
+   } 
+   arg3 = static_cast< double >(val3);
+   ecode4 = SWIG_AsVal_double SWIG_TCL_CALL_ARGS_2(objv[4], &val4);
+   if (!SWIG_IsOK(ecode4)) {
+     SWIG_exception_fail(SWIG_ArgError(ecode4), "in method '" "SpatialReference_SetNZMG" "', argument " "4"" of type '" "double""'");
+   } 
+   arg4 = static_cast< double >(val4);
+   ecode5 = SWIG_AsVal_double SWIG_TCL_CALL_ARGS_2(objv[5], &val5);
+   if (!SWIG_IsOK(ecode5)) {
+     SWIG_exception_fail(SWIG_ArgError(ecode5), "in method '" "SpatialReference_SetNZMG" "', argument " "5"" of type '" "double""'");
+   } 
+   arg5 = static_cast< double >(val5);
+   result = (OGRErr)OSRSpatialReferenceShadow_SetNZMG(arg1,arg2,arg3,arg4,arg5);
+   {
+     /* %typemap(out) OGRErr */
+     if (result != 0) {
+       Tcl_SetResult(interp, (char*) OGRErrMessages(result), TCL_STATIC);
+       SWIG_fail;
+     }
+   }
+   {
+     /* %typemap(ret) OGRErr */
+     if (!strcmp(Tcl_GetStringResult(interp), "{}") || !strcmp(Tcl_GetStringResult(interp), "")) {
+       Tcl_SetObjResult(interp, Tcl_NewLongObj( result ));
+     }
+   }
+   return TCL_OK;
+ fail:
+   return TCL_ERROR;
+ }
+ 
+ 
+ SWIGINTERN int
+ _wrap_SpatialReference_SetOS(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
+   OSRSpatialReferenceShadow *arg1 = (OSRSpatialReferenceShadow *) 0 ;
+   double arg2 ;
+   double arg3 ;
+   double arg4 ;
+   double arg5 ;
+   double arg6 ;
+   void *argp1 = 0 ;
+   int res1 = 0 ;
+   double val2 ;
+   int ecode2 = 0 ;
+   double val3 ;
+   int ecode3 = 0 ;
+   double val4 ;
+   int ecode4 = 0 ;
+   double val5 ;
+   int ecode5 = 0 ;
+   double val6 ;
+   int ecode6 = 0 ;
+   OGRErr result;
+   
+   if (SWIG_GetArgs(interp, objc, objv,"oooooo:osgeo::SpatialReference_SetOS self dfOriginLat dfCMeridian scale fe fn ",(void *)0,(void *)0,(void *)0,(void *)0,(void *)0,(void *)0) == TCL_ERROR) SWIG_fail;
+   res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_OSRSpatialReferenceShadow, 0 |  0 );
+   if (!SWIG_IsOK(res1)) {
+     SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SpatialReference_SetOS" "', argument " "1"" of type '" "OSRSpatialReferenceShadow *""'"); 
+   }
+   arg1 = reinterpret_cast< OSRSpatialReferenceShadow * >(argp1);
+   ecode2 = SWIG_AsVal_double SWIG_TCL_CALL_ARGS_2(objv[2], &val2);
+   if (!SWIG_IsOK(ecode2)) {
+     SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "SpatialReference_SetOS" "', argument " "2"" of type '" "double""'");
+   } 
+   arg2 = static_cast< double >(val2);
+   ecode3 = SWIG_AsVal_double SWIG_TCL_CALL_ARGS_2(objv[3], &val3);
+   if (!SWIG_IsOK(ecode3)) {
+     SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "SpatialReference_SetOS" "', argument " "3"" of type '" "double""'");
+   } 
+   arg3 = static_cast< double >(val3);
+   ecode4 = SWIG_AsVal_double SWIG_TCL_CALL_ARGS_2(objv[4], &val4);
+   if (!SWIG_IsOK(ecode4)) {
+     SWIG_exception_fail(SWIG_ArgError(ecode4), "in method '" "SpatialReference_SetOS" "', argument " "4"" of type '" "double""'");
+   } 
+   arg4 = static_cast< double >(val4);
+   ecode5 = SWIG_AsVal_double SWIG_TCL_CALL_ARGS_2(objv[5], &val5);
+   if (!SWIG_IsOK(ecode5)) {
+     SWIG_exception_fail(SWIG_ArgError(ecode5), "in method '" "SpatialReference_SetOS" "', argument " "5"" of type '" "double""'");
+   } 
+   arg5 = static_cast< double >(val5);
+   ecode6 = SWIG_AsVal_double SWIG_TCL_CALL_ARGS_2(objv[6], &val6);
+   if (!SWIG_IsOK(ecode6)) {
+     SWIG_exception_fail(SWIG_ArgError(ecode6), "in method '" "SpatialReference_SetOS" "', argument " "6"" of type '" "double""'");
+   } 
+   arg6 = static_cast< double >(val6);
+   result = (OGRErr)OSRSpatialReferenceShadow_SetOS(arg1,arg2,arg3,arg4,arg5,arg6);
+   {
+     /* %typemap(out) OGRErr */
+     if (result != 0) {
+       Tcl_SetResult(interp, (char*) OGRErrMessages(result), TCL_STATIC);
+       SWIG_fail;
+     }
+   }
+   {
+     /* %typemap(ret) OGRErr */
+     if (!strcmp(Tcl_GetStringResult(interp), "{}") || !strcmp(Tcl_GetStringResult(interp), "")) {
+       Tcl_SetObjResult(interp, Tcl_NewLongObj( result ));
+     }
+   }
+   return TCL_OK;
+ fail:
+   return TCL_ERROR;
+ }
+ 
+ 
+ SWIGINTERN int
+ _wrap_SpatialReference_SetOrthographic(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
+   OSRSpatialReferenceShadow *arg1 = (OSRSpatialReferenceShadow *) 0 ;
+   double arg2 ;
+   double arg3 ;
+   double arg4 ;
+   double arg5 ;
+   void *argp1 = 0 ;
+   int res1 = 0 ;
+   double val2 ;
+   int ecode2 = 0 ;
+   double val3 ;
+   int ecode3 = 0 ;
+   double val4 ;
+   int ecode4 = 0 ;
+   double val5 ;
+   int ecode5 = 0 ;
+   OGRErr result;
+   
+   if (SWIG_GetArgs(interp, objc, objv,"ooooo:osgeo::SpatialReference_SetOrthographic self clat clong fe fn ",(void *)0,(void *)0,(void *)0,(void *)0,(void *)0) == TCL_ERROR) SWIG_fail;
+   res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_OSRSpatialReferenceShadow, 0 |  0 );
+   if (!SWIG_IsOK(res1)) {
+     SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SpatialReference_SetOrthographic" "', argument " "1"" of type '" "OSRSpatialReferenceShadow *""'"); 
+   }
+   arg1 = reinterpret_cast< OSRSpatialReferenceShadow * >(argp1);
+   ecode2 = SWIG_AsVal_double SWIG_TCL_CALL_ARGS_2(objv[2], &val2);
+   if (!SWIG_IsOK(ecode2)) {
+     SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "SpatialReference_SetOrthographic" "', argument " "2"" of type '" "double""'");
+   } 
+   arg2 = static_cast< double >(val2);
+   ecode3 = SWIG_AsVal_double SWIG_TCL_CALL_ARGS_2(objv[3], &val3);
+   if (!SWIG_IsOK(ecode3)) {
+     SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "SpatialReference_SetOrthographic" "', argument " "3"" of type '" "double""'");
+   } 
+   arg3 = static_cast< double >(val3);
+   ecode4 = SWIG_AsVal_double SWIG_TCL_CALL_ARGS_2(objv[4], &val4);
+   if (!SWIG_IsOK(ecode4)) {
+     SWIG_exception_fail(SWIG_ArgError(ecode4), "in method '" "SpatialReference_SetOrthographic" "', argument " "4"" of type '" "double""'");
+   } 
+   arg4 = static_cast< double >(val4);
+   ecode5 = SWIG_AsVal_double SWIG_TCL_CALL_ARGS_2(objv[5], &val5);
+   if (!SWIG_IsOK(ecode5)) {
+     SWIG_exception_fail(SWIG_ArgError(ecode5), "in method '" "SpatialReference_SetOrthographic" "', argument " "5"" of type '" "double""'");
+   } 
+   arg5 = static_cast< double >(val5);
+   result = (OGRErr)OSRSpatialReferenceShadow_SetOrthographic(arg1,arg2,arg3,arg4,arg5);
+   {
+     /* %typemap(out) OGRErr */
+     if (result != 0) {
+       Tcl_SetResult(interp, (char*) OGRErrMessages(result), TCL_STATIC);
+       SWIG_fail;
+     }
+   }
+   {
+     /* %typemap(ret) OGRErr */
+     if (!strcmp(Tcl_GetStringResult(interp), "{}") || !strcmp(Tcl_GetStringResult(interp), "")) {
+       Tcl_SetObjResult(interp, Tcl_NewLongObj( result ));
+     }
+   }
+   return TCL_OK;
+ fail:
+   return TCL_ERROR;
+ }
+ 
+ 
+ SWIGINTERN int
+ _wrap_SpatialReference_SetPolyconic(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
+   OSRSpatialReferenceShadow *arg1 = (OSRSpatialReferenceShadow *) 0 ;
+   double arg2 ;
+   double arg3 ;
+   double arg4 ;
+   double arg5 ;
+   void *argp1 = 0 ;
+   int res1 = 0 ;
+   double val2 ;
+   int ecode2 = 0 ;
+   double val3 ;
+   int ecode3 = 0 ;
+   double val4 ;
+   int ecode4 = 0 ;
+   double val5 ;
+   int ecode5 = 0 ;
+   OGRErr result;
+   
+   if (SWIG_GetArgs(interp, objc, objv,"ooooo:osgeo::SpatialReference_SetPolyconic self clat clong fe fn ",(void *)0,(void *)0,(void *)0,(void *)0,(void *)0) == TCL_ERROR) SWIG_fail;
+   res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_OSRSpatialReferenceShadow, 0 |  0 );
+   if (!SWIG_IsOK(res1)) {
+     SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SpatialReference_SetPolyconic" "', argument " "1"" of type '" "OSRSpatialReferenceShadow *""'"); 
+   }
+   arg1 = reinterpret_cast< OSRSpatialReferenceShadow * >(argp1);
+   ecode2 = SWIG_AsVal_double SWIG_TCL_CALL_ARGS_2(objv[2], &val2);
+   if (!SWIG_IsOK(ecode2)) {
+     SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "SpatialReference_SetPolyconic" "', argument " "2"" of type '" "double""'");
+   } 
+   arg2 = static_cast< double >(val2);
+   ecode3 = SWIG_AsVal_double SWIG_TCL_CALL_ARGS_2(objv[3], &val3);
+   if (!SWIG_IsOK(ecode3)) {
+     SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "SpatialReference_SetPolyconic" "', argument " "3"" of type '" "double""'");
+   } 
+   arg3 = static_cast< double >(val3);
+   ecode4 = SWIG_AsVal_double SWIG_TCL_CALL_ARGS_2(objv[4], &val4);
+   if (!SWIG_IsOK(ecode4)) {
+     SWIG_exception_fail(SWIG_ArgError(ecode4), "in method '" "SpatialReference_SetPolyconic" "', argument " "4"" of type '" "double""'");
+   } 
+   arg4 = static_cast< double >(val4);
+   ecode5 = SWIG_AsVal_double SWIG_TCL_CALL_ARGS_2(objv[5], &val5);
+   if (!SWIG_IsOK(ecode5)) {
+     SWIG_exception_fail(SWIG_ArgError(ecode5), "in method '" "SpatialReference_SetPolyconic" "', argument " "5"" of type '" "double""'");
+   } 
+   arg5 = static_cast< double >(val5);
+   result = (OGRErr)OSRSpatialReferenceShadow_SetPolyconic(arg1,arg2,arg3,arg4,arg5);
+   {
+     /* %typemap(out) OGRErr */
+     if (result != 0) {
+       Tcl_SetResult(interp, (char*) OGRErrMessages(result), TCL_STATIC);
+       SWIG_fail;
+     }
+   }
+   {
+     /* %typemap(ret) OGRErr */
+     if (!strcmp(Tcl_GetStringResult(interp), "{}") || !strcmp(Tcl_GetStringResult(interp), "")) {
+       Tcl_SetObjResult(interp, Tcl_NewLongObj( result ));
+     }
+   }
+   return TCL_OK;
+ fail:
+   return TCL_ERROR;
+ }
+ 
+ 
+ SWIGINTERN int
+ _wrap_SpatialReference_SetPS(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
+   OSRSpatialReferenceShadow *arg1 = (OSRSpatialReferenceShadow *) 0 ;
+   double arg2 ;
+   double arg3 ;
+   double arg4 ;
+   double arg5 ;
+   double arg6 ;
+   void *argp1 = 0 ;
+   int res1 = 0 ;
+   double val2 ;
+   int ecode2 = 0 ;
+   double val3 ;
+   int ecode3 = 0 ;
+   double val4 ;
+   int ecode4 = 0 ;
+   double val5 ;
+   int ecode5 = 0 ;
+   double val6 ;
+   int ecode6 = 0 ;
+   OGRErr result;
+   
+   if (SWIG_GetArgs(interp, objc, objv,"oooooo:osgeo::SpatialReference_SetPS self clat clong scale fe fn ",(void *)0,(void *)0,(void *)0,(void *)0,(void *)0,(void *)0) == TCL_ERROR) SWIG_fail;
+   res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_OSRSpatialReferenceShadow, 0 |  0 );
+   if (!SWIG_IsOK(res1)) {
+     SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SpatialReference_SetPS" "', argument " "1"" of type '" "OSRSpatialReferenceShadow *""'"); 
+   }
+   arg1 = reinterpret_cast< OSRSpatialReferenceShadow * >(argp1);
+   ecode2 = SWIG_AsVal_double SWIG_TCL_CALL_ARGS_2(objv[2], &val2);
+   if (!SWIG_IsOK(ecode2)) {
+     SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "SpatialReference_SetPS" "', argument " "2"" of type '" "double""'");
+   } 
+   arg2 = static_cast< double >(val2);
+   ecode3 = SWIG_AsVal_double SWIG_TCL_CALL_ARGS_2(objv[3], &val3);
+   if (!SWIG_IsOK(ecode3)) {
+     SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "SpatialReference_SetPS" "', argument " "3"" of type '" "double""'");
+   } 
+   arg3 = static_cast< double >(val3);
+   ecode4 = SWIG_AsVal_double SWIG_TCL_CALL_ARGS_2(objv[4], &val4);
+   if (!SWIG_IsOK(ecode4)) {
+     SWIG_exception_fail(SWIG_ArgError(ecode4), "in method '" "SpatialReference_SetPS" "', argument " "4"" of type '" "double""'");
+   } 
+   arg4 = static_cast< double >(val4);
+   ecode5 = SWIG_AsVal_double SWIG_TCL_CALL_ARGS_2(objv[5], &val5);
+   if (!SWIG_IsOK(ecode5)) {
+     SWIG_exception_fail(SWIG_ArgError(ecode5), "in method '" "SpatialReference_SetPS" "', argument " "5"" of type '" "double""'");
+   } 
+   arg5 = static_cast< double >(val5);
+   ecode6 = SWIG_AsVal_double SWIG_TCL_CALL_ARGS_2(objv[6], &val6);
+   if (!SWIG_IsOK(ecode6)) {
+     SWIG_exception_fail(SWIG_ArgError(ecode6), "in method '" "SpatialReference_SetPS" "', argument " "6"" of type '" "double""'");
+   } 
+   arg6 = static_cast< double >(val6);
+   result = (OGRErr)OSRSpatialReferenceShadow_SetPS(arg1,arg2,arg3,arg4,arg5,arg6);
+   {
+     /* %typemap(out) OGRErr */
+     if (result != 0) {
+       Tcl_SetResult(interp, (char*) OGRErrMessages(result), TCL_STATIC);
+       SWIG_fail;
+     }
+   }
+   {
+     /* %typemap(ret) OGRErr */
+     if (!strcmp(Tcl_GetStringResult(interp), "{}") || !strcmp(Tcl_GetStringResult(interp), "")) {
+       Tcl_SetObjResult(interp, Tcl_NewLongObj( result ));
+     }
+   }
+   return TCL_OK;
+ fail:
+   return TCL_ERROR;
+ }
+ 
+ 
+ SWIGINTERN int
+ _wrap_SpatialReference_SetRobinson(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
+   OSRSpatialReferenceShadow *arg1 = (OSRSpatialReferenceShadow *) 0 ;
+   double arg2 ;
+   double arg3 ;
+   double arg4 ;
+   void *argp1 = 0 ;
+   int res1 = 0 ;
+   double val2 ;
+   int ecode2 = 0 ;
+   double val3 ;
+   int ecode3 = 0 ;
+   double val4 ;
+   int ecode4 = 0 ;
+   OGRErr result;
+   
+   if (SWIG_GetArgs(interp, objc, objv,"oooo:osgeo::SpatialReference_SetRobinson self clong fe fn ",(void *)0,(void *)0,(void *)0,(void *)0) == TCL_ERROR) SWIG_fail;
+   res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_OSRSpatialReferenceShadow, 0 |  0 );
+   if (!SWIG_IsOK(res1)) {
+     SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SpatialReference_SetRobinson" "', argument " "1"" of type '" "OSRSpatialReferenceShadow *""'"); 
+   }
+   arg1 = reinterpret_cast< OSRSpatialReferenceShadow * >(argp1);
+   ecode2 = SWIG_AsVal_double SWIG_TCL_CALL_ARGS_2(objv[2], &val2);
+   if (!SWIG_IsOK(ecode2)) {
+     SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "SpatialReference_SetRobinson" "', argument " "2"" of type '" "double""'");
+   } 
+   arg2 = static_cast< double >(val2);
+   ecode3 = SWIG_AsVal_double SWIG_TCL_CALL_ARGS_2(objv[3], &val3);
+   if (!SWIG_IsOK(ecode3)) {
+     SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "SpatialReference_SetRobinson" "', argument " "3"" of type '" "double""'");
+   } 
+   arg3 = static_cast< double >(val3);
+   ecode4 = SWIG_AsVal_double SWIG_TCL_CALL_ARGS_2(objv[4], &val4);
+   if (!SWIG_IsOK(ecode4)) {
+     SWIG_exception_fail(SWIG_ArgError(ecode4), "in method '" "SpatialReference_SetRobinson" "', argument " "4"" of type '" "double""'");
+   } 
+   arg4 = static_cast< double >(val4);
+   result = (OGRErr)OSRSpatialReferenceShadow_SetRobinson(arg1,arg2,arg3,arg4);
+   {
+     /* %typemap(out) OGRErr */
+     if (result != 0) {
+       Tcl_SetResult(interp, (char*) OGRErrMessages(result), TCL_STATIC);
+       SWIG_fail;
+     }
+   }
+   {
+     /* %typemap(ret) OGRErr */
+     if (!strcmp(Tcl_GetStringResult(interp), "{}") || !strcmp(Tcl_GetStringResult(interp), "")) {
+       Tcl_SetObjResult(interp, Tcl_NewLongObj( result ));
+     }
+   }
+   return TCL_OK;
+ fail:
+   return TCL_ERROR;
+ }
+ 
+ 
+ SWIGINTERN int
+ _wrap_SpatialReference_SetSinusoidal(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
+   OSRSpatialReferenceShadow *arg1 = (OSRSpatialReferenceShadow *) 0 ;
+   double arg2 ;
+   double arg3 ;
+   double arg4 ;
+   void *argp1 = 0 ;
+   int res1 = 0 ;
+   double val2 ;
+   int ecode2 = 0 ;
+   double val3 ;
+   int ecode3 = 0 ;
+   double val4 ;
+   int ecode4 = 0 ;
+   OGRErr result;
+   
+   if (SWIG_GetArgs(interp, objc, objv,"oooo:osgeo::SpatialReference_SetSinusoidal self clong fe fn ",(void *)0,(void *)0,(void *)0,(void *)0) == TCL_ERROR) SWIG_fail;
+   res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_OSRSpatialReferenceShadow, 0 |  0 );
+   if (!SWIG_IsOK(res1)) {
+     SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SpatialReference_SetSinusoidal" "', argument " "1"" of type '" "OSRSpatialReferenceShadow *""'"); 
+   }
+   arg1 = reinterpret_cast< OSRSpatialReferenceShadow * >(argp1);
+   ecode2 = SWIG_AsVal_double SWIG_TCL_CALL_ARGS_2(objv[2], &val2);
+   if (!SWIG_IsOK(ecode2)) {
+     SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "SpatialReference_SetSinusoidal" "', argument " "2"" of type '" "double""'");
+   } 
+   arg2 = static_cast< double >(val2);
+   ecode3 = SWIG_AsVal_double SWIG_TCL_CALL_ARGS_2(objv[3], &val3);
+   if (!SWIG_IsOK(ecode3)) {
+     SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "SpatialReference_SetSinusoidal" "', argument " "3"" of type '" "double""'");
+   } 
+   arg3 = static_cast< double >(val3);
+   ecode4 = SWIG_AsVal_double SWIG_TCL_CALL_ARGS_2(objv[4], &val4);
+   if (!SWIG_IsOK(ecode4)) {
+     SWIG_exception_fail(SWIG_ArgError(ecode4), "in method '" "SpatialReference_SetSinusoidal" "', argument " "4"" of type '" "double""'");
+   } 
+   arg4 = static_cast< double >(val4);
+   result = (OGRErr)OSRSpatialReferenceShadow_SetSinusoidal(arg1,arg2,arg3,arg4);
+   {
+     /* %typemap(out) OGRErr */
+     if (result != 0) {
+       Tcl_SetResult(interp, (char*) OGRErrMessages(result), TCL_STATIC);
+       SWIG_fail;
+     }
+   }
+   {
+     /* %typemap(ret) OGRErr */
+     if (!strcmp(Tcl_GetStringResult(interp), "{}") || !strcmp(Tcl_GetStringResult(interp), "")) {
+       Tcl_SetObjResult(interp, Tcl_NewLongObj( result ));
+     }
+   }
+   return TCL_OK;
+ fail:
+   return TCL_ERROR;
+ }
+ 
+ 
+ SWIGINTERN int
+ _wrap_SpatialReference_SetStereographic(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
+   OSRSpatialReferenceShadow *arg1 = (OSRSpatialReferenceShadow *) 0 ;
+   double arg2 ;
+   double arg3 ;
+   double arg4 ;
+   double arg5 ;
+   double arg6 ;
+   void *argp1 = 0 ;
+   int res1 = 0 ;
+   double val2 ;
+   int ecode2 = 0 ;
+   double val3 ;
+   int ecode3 = 0 ;
+   double val4 ;
+   int ecode4 = 0 ;
+   double val5 ;
+   int ecode5 = 0 ;
+   double val6 ;
+   int ecode6 = 0 ;
+   OGRErr result;
+   
+   if (SWIG_GetArgs(interp, objc, objv,"oooooo:osgeo::SpatialReference_SetStereographic self clat clong scale fe fn ",(void *)0,(void *)0,(void *)0,(void *)0,(void *)0,(void *)0) == TCL_ERROR) SWIG_fail;
+   res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_OSRSpatialReferenceShadow, 0 |  0 );
+   if (!SWIG_IsOK(res1)) {
+     SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SpatialReference_SetStereographic" "', argument " "1"" of type '" "OSRSpatialReferenceShadow *""'"); 
+   }
+   arg1 = reinterpret_cast< OSRSpatialReferenceShadow * >(argp1);
+   ecode2 = SWIG_AsVal_double SWIG_TCL_CALL_ARGS_2(objv[2], &val2);
+   if (!SWIG_IsOK(ecode2)) {
+     SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "SpatialReference_SetStereographic" "', argument " "2"" of type '" "double""'");
+   } 
+   arg2 = static_cast< double >(val2);
+   ecode3 = SWIG_AsVal_double SWIG_TCL_CALL_ARGS_2(objv[3], &val3);
+   if (!SWIG_IsOK(ecode3)) {
+     SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "SpatialReference_SetStereographic" "', argument " "3"" of type '" "double""'");
+   } 
+   arg3 = static_cast< double >(val3);
+   ecode4 = SWIG_AsVal_double SWIG_TCL_CALL_ARGS_2(objv[4], &val4);
+   if (!SWIG_IsOK(ecode4)) {
+     SWIG_exception_fail(SWIG_ArgError(ecode4), "in method '" "SpatialReference_SetStereographic" "', argument " "4"" of type '" "double""'");
+   } 
+   arg4 = static_cast< double >(val4);
+   ecode5 = SWIG_AsVal_double SWIG_TCL_CALL_ARGS_2(objv[5], &val5);
+   if (!SWIG_IsOK(ecode5)) {
+     SWIG_exception_fail(SWIG_ArgError(ecode5), "in method '" "SpatialReference_SetStereographic" "', argument " "5"" of type '" "double""'");
+   } 
+   arg5 = static_cast< double >(val5);
+   ecode6 = SWIG_AsVal_double SWIG_TCL_CALL_ARGS_2(objv[6], &val6);
+   if (!SWIG_IsOK(ecode6)) {
+     SWIG_exception_fail(SWIG_ArgError(ecode6), "in method '" "SpatialReference_SetStereographic" "', argument " "6"" of type '" "double""'");
+   } 
+   arg6 = static_cast< double >(val6);
+   result = (OGRErr)OSRSpatialReferenceShadow_SetStereographic(arg1,arg2,arg3,arg4,arg5,arg6);
+   {
+     /* %typemap(out) OGRErr */
+     if (result != 0) {
+       Tcl_SetResult(interp, (char*) OGRErrMessages(result), TCL_STATIC);
+       SWIG_fail;
+     }
+   }
+   {
+     /* %typemap(ret) OGRErr */
+     if (!strcmp(Tcl_GetStringResult(interp), "{}") || !strcmp(Tcl_GetStringResult(interp), "")) {
+       Tcl_SetObjResult(interp, Tcl_NewLongObj( result ));
+     }
+   }
+   return TCL_OK;
+ fail:
+   return TCL_ERROR;
+ }
+ 
+ 
+ SWIGINTERN int
+ _wrap_SpatialReference_SetSOC(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
+   OSRSpatialReferenceShadow *arg1 = (OSRSpatialReferenceShadow *) 0 ;
+   double arg2 ;
+   double arg3 ;
+   double arg4 ;
+   double arg5 ;
+   void *argp1 = 0 ;
+   int res1 = 0 ;
+   double val2 ;
+   int ecode2 = 0 ;
+   double val3 ;
+   int ecode3 = 0 ;
+   double val4 ;
+   int ecode4 = 0 ;
+   double val5 ;
+   int ecode5 = 0 ;
+   OGRErr result;
+   
+   if (SWIG_GetArgs(interp, objc, objv,"ooooo:osgeo::SpatialReference_SetSOC self latitudeoforigin cm fe fn ",(void *)0,(void *)0,(void *)0,(void *)0,(void *)0) == TCL_ERROR) SWIG_fail;
+   res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_OSRSpatialReferenceShadow, 0 |  0 );
+   if (!SWIG_IsOK(res1)) {
+     SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SpatialReference_SetSOC" "', argument " "1"" of type '" "OSRSpatialReferenceShadow *""'"); 
+   }
+   arg1 = reinterpret_cast< OSRSpatialReferenceShadow * >(argp1);
+   ecode2 = SWIG_AsVal_double SWIG_TCL_CALL_ARGS_2(objv[2], &val2);
+   if (!SWIG_IsOK(ecode2)) {
+     SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "SpatialReference_SetSOC" "', argument " "2"" of type '" "double""'");
+   } 
+   arg2 = static_cast< double >(val2);
+   ecode3 = SWIG_AsVal_double SWIG_TCL_CALL_ARGS_2(objv[3], &val3);
+   if (!SWIG_IsOK(ecode3)) {
+     SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "SpatialReference_SetSOC" "', argument " "3"" of type '" "double""'");
+   } 
+   arg3 = static_cast< double >(val3);
+   ecode4 = SWIG_AsVal_double SWIG_TCL_CALL_ARGS_2(objv[4], &val4);
+   if (!SWIG_IsOK(ecode4)) {
+     SWIG_exception_fail(SWIG_ArgError(ecode4), "in method '" "SpatialReference_SetSOC" "', argument " "4"" of type '" "double""'");
+   } 
+   arg4 = static_cast< double >(val4);
+   ecode5 = SWIG_AsVal_double SWIG_TCL_CALL_ARGS_2(objv[5], &val5);
+   if (!SWIG_IsOK(ecode5)) {
+     SWIG_exception_fail(SWIG_ArgError(ecode5), "in method '" "SpatialReference_SetSOC" "', argument " "5"" of type '" "double""'");
+   } 
+   arg5 = static_cast< double >(val5);
+   result = (OGRErr)OSRSpatialReferenceShadow_SetSOC(arg1,arg2,arg3,arg4,arg5);
+   {
+     /* %typemap(out) OGRErr */
+     if (result != 0) {
+       Tcl_SetResult(interp, (char*) OGRErrMessages(result), TCL_STATIC);
+       SWIG_fail;
+     }
+   }
+   {
+     /* %typemap(ret) OGRErr */
+     if (!strcmp(Tcl_GetStringResult(interp), "{}") || !strcmp(Tcl_GetStringResult(interp), "")) {
+       Tcl_SetObjResult(interp, Tcl_NewLongObj( result ));
+     }
+   }
+   return TCL_OK;
+ fail:
+   return TCL_ERROR;
+ }
+ 
+ 
+ SWIGINTERN int
+ _wrap_SpatialReference_SetTM(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
+   OSRSpatialReferenceShadow *arg1 = (OSRSpatialReferenceShadow *) 0 ;
+   double arg2 ;
+   double arg3 ;
+   double arg4 ;
+   double arg5 ;
+   double arg6 ;
+   void *argp1 = 0 ;
+   int res1 = 0 ;
+   double val2 ;
+   int ecode2 = 0 ;
+   double val3 ;
+   int ecode3 = 0 ;
+   double val4 ;
+   int ecode4 = 0 ;
+   double val5 ;
+   int ecode5 = 0 ;
+   double val6 ;
+   int ecode6 = 0 ;
+   OGRErr result;
+   
+   if (SWIG_GetArgs(interp, objc, objv,"oooooo:osgeo::SpatialReference_SetTM self clat clong scale fe fn ",(void *)0,(void *)0,(void *)0,(void *)0,(void *)0,(void *)0) == TCL_ERROR) SWIG_fail;
+   res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_OSRSpatialReferenceShadow, 0 |  0 );
+   if (!SWIG_IsOK(res1)) {
+     SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SpatialReference_SetTM" "', argument " "1"" of type '" "OSRSpatialReferenceShadow *""'"); 
+   }
+   arg1 = reinterpret_cast< OSRSpatialReferenceShadow * >(argp1);
+   ecode2 = SWIG_AsVal_double SWIG_TCL_CALL_ARGS_2(objv[2], &val2);
+   if (!SWIG_IsOK(ecode2)) {
+     SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "SpatialReference_SetTM" "', argument " "2"" of type '" "double""'");
+   } 
+   arg2 = static_cast< double >(val2);
+   ecode3 = SWIG_AsVal_double SWIG_TCL_CALL_ARGS_2(objv[3], &val3);
+   if (!SWIG_IsOK(ecode3)) {
+     SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "SpatialReference_SetTM" "', argument " "3"" of type '" "double""'");
+   } 
+   arg3 = static_cast< double >(val3);
+   ecode4 = SWIG_AsVal_double SWIG_TCL_CALL_ARGS_2(objv[4], &val4);
+   if (!SWIG_IsOK(ecode4)) {
+     SWIG_exception_fail(SWIG_ArgError(ecode4), "in method '" "SpatialReference_SetTM" "', argument " "4"" of type '" "double""'");
+   } 
+   arg4 = static_cast< double >(val4);
+   ecode5 = SWIG_AsVal_double SWIG_TCL_CALL_ARGS_2(objv[5], &val5);
+   if (!SWIG_IsOK(ecode5)) {
+     SWIG_exception_fail(SWIG_ArgError(ecode5), "in method '" "SpatialReference_SetTM" "', argument " "5"" of type '" "double""'");
+   } 
+   arg5 = static_cast< double >(val5);
+   ecode6 = SWIG_AsVal_double SWIG_TCL_CALL_ARGS_2(objv[6], &val6);
+   if (!SWIG_IsOK(ecode6)) {
+     SWIG_exception_fail(SWIG_ArgError(ecode6), "in method '" "SpatialReference_SetTM" "', argument " "6"" of type '" "double""'");
+   } 
+   arg6 = static_cast< double >(val6);
+   result = (OGRErr)OSRSpatialReferenceShadow_SetTM(arg1,arg2,arg3,arg4,arg5,arg6);
+   {
+     /* %typemap(out) OGRErr */
+     if (result != 0) {
+       Tcl_SetResult(interp, (char*) OGRErrMessages(result), TCL_STATIC);
+       SWIG_fail;
+     }
+   }
+   {
+     /* %typemap(ret) OGRErr */
+     if (!strcmp(Tcl_GetStringResult(interp), "{}") || !strcmp(Tcl_GetStringResult(interp), "")) {
+       Tcl_SetObjResult(interp, Tcl_NewLongObj( result ));
+     }
+   }
+   return TCL_OK;
+ fail:
+   return TCL_ERROR;
+ }
+ 
+ 
+ SWIGINTERN int
+ _wrap_SpatialReference_SetTMVariant(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
+   OSRSpatialReferenceShadow *arg1 = (OSRSpatialReferenceShadow *) 0 ;
+   char *arg2 = (char *) 0 ;
+   double arg3 ;
+   double arg4 ;
+   double arg5 ;
+   double arg6 ;
+   double arg7 ;
+   void *argp1 = 0 ;
+   int res1 = 0 ;
+   int res2 ;
+   char *buf2 = 0 ;
+   int alloc2 = 0 ;
+   double val3 ;
+   int ecode3 = 0 ;
+   double val4 ;
+   int ecode4 = 0 ;
+   double val5 ;
+   int ecode5 = 0 ;
+   double val6 ;
+   int ecode6 = 0 ;
+   double val7 ;
+   int ecode7 = 0 ;
+   OGRErr result;
+   
+   if (SWIG_GetArgs(interp, objc, objv,"ooooooo:osgeo::SpatialReference_SetTMVariant self pszVariantName clat clong scale fe fn ",(void *)0,(void *)0,(void *)0,(void *)0,(void *)0,(void *)0,(void *)0) == TCL_ERROR) SWIG_fail;
+   res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_OSRSpatialReferenceShadow, 0 |  0 );
+   if (!SWIG_IsOK(res1)) {
+     SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SpatialReference_SetTMVariant" "', argument " "1"" of type '" "OSRSpatialReferenceShadow *""'"); 
+   }
+   arg1 = reinterpret_cast< OSRSpatialReferenceShadow * >(argp1);
+   res2 = SWIG_AsCharPtrAndSize(objv[2], &buf2, NULL, &alloc2);
+   if (!SWIG_IsOK(res2)) {
+     SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "SpatialReference_SetTMVariant" "', argument " "2"" of type '" "char const *""'");
+   }
+   arg2 = reinterpret_cast< char * >(buf2);
+   ecode3 = SWIG_AsVal_double SWIG_TCL_CALL_ARGS_2(objv[3], &val3);
+   if (!SWIG_IsOK(ecode3)) {
+     SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "SpatialReference_SetTMVariant" "', argument " "3"" of type '" "double""'");
+   } 
+   arg3 = static_cast< double >(val3);
+   ecode4 = SWIG_AsVal_double SWIG_TCL_CALL_ARGS_2(objv[4], &val4);
+   if (!SWIG_IsOK(ecode4)) {
+     SWIG_exception_fail(SWIG_ArgError(ecode4), "in method '" "SpatialReference_SetTMVariant" "', argument " "4"" of type '" "double""'");
+   } 
+   arg4 = static_cast< double >(val4);
+   ecode5 = SWIG_AsVal_double SWIG_TCL_CALL_ARGS_2(objv[5], &val5);
+   if (!SWIG_IsOK(ecode5)) {
+     SWIG_exception_fail(SWIG_ArgError(ecode5), "in method '" "SpatialReference_SetTMVariant" "', argument " "5"" of type '" "double""'");
+   } 
+   arg5 = static_cast< double >(val5);
+   ecode6 = SWIG_AsVal_double SWIG_TCL_CALL_ARGS_2(objv[6], &val6);
+   if (!SWIG_IsOK(ecode6)) {
+     SWIG_exception_fail(SWIG_ArgError(ecode6), "in method '" "SpatialReference_SetTMVariant" "', argument " "6"" of type '" "double""'");
+   } 
+   arg6 = static_cast< double >(val6);
+   ecode7 = SWIG_AsVal_double SWIG_TCL_CALL_ARGS_2(objv[7], &val7);
+   if (!SWIG_IsOK(ecode7)) {
+     SWIG_exception_fail(SWIG_ArgError(ecode7), "in method '" "SpatialReference_SetTMVariant" "', argument " "7"" of type '" "double""'");
+   } 
+   arg7 = static_cast< double >(val7);
+   result = (OGRErr)OSRSpatialReferenceShadow_SetTMVariant(arg1,(char const *)arg2,arg3,arg4,arg5,arg6,arg7);
+   {
+     /* %typemap(out) OGRErr */
+     if (result != 0) {
+       Tcl_SetResult(interp, (char*) OGRErrMessages(result), TCL_STATIC);
+       SWIG_fail;
+     }
+   }
+   if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
+   {
+     /* %typemap(ret) OGRErr */
+     if (!strcmp(Tcl_GetStringResult(interp), "{}") || !strcmp(Tcl_GetStringResult(interp), "")) {
+       Tcl_SetObjResult(interp, Tcl_NewLongObj( result ));
+     }
+   }
+   return TCL_OK;
+ fail:
+   if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
+   return TCL_ERROR;
+ }
+ 
+ 
+ SWIGINTERN int
+ _wrap_SpatialReference_SetTMG(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
+   OSRSpatialReferenceShadow *arg1 = (OSRSpatialReferenceShadow *) 0 ;
+   double arg2 ;
+   double arg3 ;
+   double arg4 ;
+   double arg5 ;
+   void *argp1 = 0 ;
+   int res1 = 0 ;
+   double val2 ;
+   int ecode2 = 0 ;
+   double val3 ;
+   int ecode3 = 0 ;
+   double val4 ;
+   int ecode4 = 0 ;
+   double val5 ;
+   int ecode5 = 0 ;
+   OGRErr result;
+   
+   if (SWIG_GetArgs(interp, objc, objv,"ooooo:osgeo::SpatialReference_SetTMG self clat clong fe fn ",(void *)0,(void *)0,(void *)0,(void *)0,(void *)0) == TCL_ERROR) SWIG_fail;
+   res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_OSRSpatialReferenceShadow, 0 |  0 );
+   if (!SWIG_IsOK(res1)) {
+     SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SpatialReference_SetTMG" "', argument " "1"" of type '" "OSRSpatialReferenceShadow *""'"); 
+   }
+   arg1 = reinterpret_cast< OSRSpatialReferenceShadow * >(argp1);
+   ecode2 = SWIG_AsVal_double SWIG_TCL_CALL_ARGS_2(objv[2], &val2);
+   if (!SWIG_IsOK(ecode2)) {
+     SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "SpatialReference_SetTMG" "', argument " "2"" of type '" "double""'");
+   } 
+   arg2 = static_cast< double >(val2);
+   ecode3 = SWIG_AsVal_double SWIG_TCL_CALL_ARGS_2(objv[3], &val3);
+   if (!SWIG_IsOK(ecode3)) {
+     SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "SpatialReference_SetTMG" "', argument " "3"" of type '" "double""'");
+   } 
+   arg3 = static_cast< double >(val3);
+   ecode4 = SWIG_AsVal_double SWIG_TCL_CALL_ARGS_2(objv[4], &val4);
+   if (!SWIG_IsOK(ecode4)) {
+     SWIG_exception_fail(SWIG_ArgError(ecode4), "in method '" "SpatialReference_SetTMG" "', argument " "4"" of type '" "double""'");
+   } 
+   arg4 = static_cast< double >(val4);
+   ecode5 = SWIG_AsVal_double SWIG_TCL_CALL_ARGS_2(objv[5], &val5);
+   if (!SWIG_IsOK(ecode5)) {
+     SWIG_exception_fail(SWIG_ArgError(ecode5), "in method '" "SpatialReference_SetTMG" "', argument " "5"" of type '" "double""'");
+   } 
+   arg5 = static_cast< double >(val5);
+   result = (OGRErr)OSRSpatialReferenceShadow_SetTMG(arg1,arg2,arg3,arg4,arg5);
+   {
+     /* %typemap(out) OGRErr */
+     if (result != 0) {
+       Tcl_SetResult(interp, (char*) OGRErrMessages(result), TCL_STATIC);
+       SWIG_fail;
+     }
+   }
+   {
+     /* %typemap(ret) OGRErr */
+     if (!strcmp(Tcl_GetStringResult(interp), "{}") || !strcmp(Tcl_GetStringResult(interp), "")) {
+       Tcl_SetObjResult(interp, Tcl_NewLongObj( result ));
+     }
+   }
+   return TCL_OK;
+ fail:
+   return TCL_ERROR;
+ }
+ 
+ 
+ SWIGINTERN int
+ _wrap_SpatialReference_SetTMSO(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
+   OSRSpatialReferenceShadow *arg1 = (OSRSpatialReferenceShadow *) 0 ;
+   double arg2 ;
+   double arg3 ;
+   double arg4 ;
+   double arg5 ;
+   double arg6 ;
+   void *argp1 = 0 ;
+   int res1 = 0 ;
+   double val2 ;
+   int ecode2 = 0 ;
+   double val3 ;
+   int ecode3 = 0 ;
+   double val4 ;
+   int ecode4 = 0 ;
+   double val5 ;
+   int ecode5 = 0 ;
+   double val6 ;
+   int ecode6 = 0 ;
+   OGRErr result;
+   
+   if (SWIG_GetArgs(interp, objc, objv,"oooooo:osgeo::SpatialReference_SetTMSO self clat clong scale fe fn ",(void *)0,(void *)0,(void *)0,(void *)0,(void *)0,(void *)0) == TCL_ERROR) SWIG_fail;
+   res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_OSRSpatialReferenceShadow, 0 |  0 );
+   if (!SWIG_IsOK(res1)) {
+     SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SpatialReference_SetTMSO" "', argument " "1"" of type '" "OSRSpatialReferenceShadow *""'"); 
+   }
+   arg1 = reinterpret_cast< OSRSpatialReferenceShadow * >(argp1);
+   ecode2 = SWIG_AsVal_double SWIG_TCL_CALL_ARGS_2(objv[2], &val2);
+   if (!SWIG_IsOK(ecode2)) {
+     SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "SpatialReference_SetTMSO" "', argument " "2"" of type '" "double""'");
+   } 
+   arg2 = static_cast< double >(val2);
+   ecode3 = SWIG_AsVal_double SWIG_TCL_CALL_ARGS_2(objv[3], &val3);
+   if (!SWIG_IsOK(ecode3)) {
+     SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "SpatialReference_SetTMSO" "', argument " "3"" of type '" "double""'");
+   } 
+   arg3 = static_cast< double >(val3);
+   ecode4 = SWIG_AsVal_double SWIG_TCL_CALL_ARGS_2(objv[4], &val4);
+   if (!SWIG_IsOK(ecode4)) {
+     SWIG_exception_fail(SWIG_ArgError(ecode4), "in method '" "SpatialReference_SetTMSO" "', argument " "4"" of type '" "double""'");
+   } 
+   arg4 = static_cast< double >(val4);
+   ecode5 = SWIG_AsVal_double SWIG_TCL_CALL_ARGS_2(objv[5], &val5);
+   if (!SWIG_IsOK(ecode5)) {
+     SWIG_exception_fail(SWIG_ArgError(ecode5), "in method '" "SpatialReference_SetTMSO" "', argument " "5"" of type '" "double""'");
+   } 
+   arg5 = static_cast< double >(val5);
+   ecode6 = SWIG_AsVal_double SWIG_TCL_CALL_ARGS_2(objv[6], &val6);
+   if (!SWIG_IsOK(ecode6)) {
+     SWIG_exception_fail(SWIG_ArgError(ecode6), "in method '" "SpatialReference_SetTMSO" "', argument " "6"" of type '" "double""'");
+   } 
+   arg6 = static_cast< double >(val6);
+   result = (OGRErr)OSRSpatialReferenceShadow_SetTMSO(arg1,arg2,arg3,arg4,arg5,arg6);
+   {
+     /* %typemap(out) OGRErr */
+     if (result != 0) {
+       Tcl_SetResult(interp, (char*) OGRErrMessages(result), TCL_STATIC);
+       SWIG_fail;
+     }
+   }
+   {
+     /* %typemap(ret) OGRErr */
+     if (!strcmp(Tcl_GetStringResult(interp), "{}") || !strcmp(Tcl_GetStringResult(interp), "")) {
+       Tcl_SetObjResult(interp, Tcl_NewLongObj( result ));
+     }
+   }
+   return TCL_OK;
+ fail:
+   return TCL_ERROR;
+ }
+ 
+ 
+ SWIGINTERN int
+ _wrap_SpatialReference_SetVDG(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
+   OSRSpatialReferenceShadow *arg1 = (OSRSpatialReferenceShadow *) 0 ;
+   double arg2 ;
+   double arg3 ;
+   double arg4 ;
+   void *argp1 = 0 ;
+   int res1 = 0 ;
+   double val2 ;
+   int ecode2 = 0 ;
+   double val3 ;
+   int ecode3 = 0 ;
+   double val4 ;
+   int ecode4 = 0 ;
+   OGRErr result;
+   
+   if (SWIG_GetArgs(interp, objc, objv,"oooo:osgeo::SpatialReference_SetVDG self clong fe fn ",(void *)0,(void *)0,(void *)0,(void *)0) == TCL_ERROR) SWIG_fail;
+   res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_OSRSpatialReferenceShadow, 0 |  0 );
+   if (!SWIG_IsOK(res1)) {
+     SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SpatialReference_SetVDG" "', argument " "1"" of type '" "OSRSpatialReferenceShadow *""'"); 
+   }
+   arg1 = reinterpret_cast< OSRSpatialReferenceShadow * >(argp1);
+   ecode2 = SWIG_AsVal_double SWIG_TCL_CALL_ARGS_2(objv[2], &val2);
+   if (!SWIG_IsOK(ecode2)) {
+     SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "SpatialReference_SetVDG" "', argument " "2"" of type '" "double""'");
+   } 
+   arg2 = static_cast< double >(val2);
+   ecode3 = SWIG_AsVal_double SWIG_TCL_CALL_ARGS_2(objv[3], &val3);
+   if (!SWIG_IsOK(ecode3)) {
+     SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "SpatialReference_SetVDG" "', argument " "3"" of type '" "double""'");
+   } 
+   arg3 = static_cast< double >(val3);
+   ecode4 = SWIG_AsVal_double SWIG_TCL_CALL_ARGS_2(objv[4], &val4);
+   if (!SWIG_IsOK(ecode4)) {
+     SWIG_exception_fail(SWIG_ArgError(ecode4), "in method '" "SpatialReference_SetVDG" "', argument " "4"" of type '" "double""'");
+   } 
+   arg4 = static_cast< double >(val4);
+   result = (OGRErr)OSRSpatialReferenceShadow_SetVDG(arg1,arg2,arg3,arg4);
+   {
+     /* %typemap(out) OGRErr */
+     if (result != 0) {
+       Tcl_SetResult(interp, (char*) OGRErrMessages(result), TCL_STATIC);
+       SWIG_fail;
+     }
+   }
+   {
+     /* %typemap(ret) OGRErr */
+     if (!strcmp(Tcl_GetStringResult(interp), "{}") || !strcmp(Tcl_GetStringResult(interp), "")) {
+       Tcl_SetObjResult(interp, Tcl_NewLongObj( result ));
+     }
+   }
+   return TCL_OK;
+ fail:
+   return TCL_ERROR;
+ }
+ 
+ 
+ SWIGINTERN int
+ _wrap_SpatialReference_SetWellKnownGeogCS(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
+   OSRSpatialReferenceShadow *arg1 = (OSRSpatialReferenceShadow *) 0 ;
+   char *arg2 = (char *) 0 ;
+   void *argp1 = 0 ;
+   int res1 = 0 ;
+   int res2 ;
+   char *buf2 = 0 ;
+   int alloc2 = 0 ;
+   OGRErr result;
+   
+   if (SWIG_GetArgs(interp, objc, objv,"oo:osgeo::SpatialReference_SetWellKnownGeogCS self name ",(void *)0,(void *)0) == TCL_ERROR) SWIG_fail;
+   res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_OSRSpatialReferenceShadow, 0 |  0 );
+   if (!SWIG_IsOK(res1)) {
+     SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SpatialReference_SetWellKnownGeogCS" "', argument " "1"" of type '" "OSRSpatialReferenceShadow *""'"); 
+   }
+   arg1 = reinterpret_cast< OSRSpatialReferenceShadow * >(argp1);
+   res2 = SWIG_AsCharPtrAndSize(objv[2], &buf2, NULL, &alloc2);
+   if (!SWIG_IsOK(res2)) {
+     SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "SpatialReference_SetWellKnownGeogCS" "', argument " "2"" of type '" "char const *""'");
+   }
+   arg2 = reinterpret_cast< char * >(buf2);
+   result = (OGRErr)OSRSpatialReferenceShadow_SetWellKnownGeogCS(arg1,(char const *)arg2);
+   {
+     /* %typemap(out) OGRErr */
+     if (result != 0) {
+       Tcl_SetResult(interp, (char*) OGRErrMessages(result), TCL_STATIC);
+       SWIG_fail;
+     }
+   }
+   if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
+   {
+     /* %typemap(ret) OGRErr */
+     if (!strcmp(Tcl_GetStringResult(interp), "{}") || !strcmp(Tcl_GetStringResult(interp), "")) {
+       Tcl_SetObjResult(interp, Tcl_NewLongObj( result ));
+     }
+   }
+   return TCL_OK;
+ fail:
+   if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
+   return TCL_ERROR;
+ }
+ 
+ 
+ SWIGINTERN int
+ _wrap_SpatialReference_SetFromUserInput(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
+   OSRSpatialReferenceShadow *arg1 = (OSRSpatialReferenceShadow *) 0 ;
+   char *arg2 = (char *) 0 ;
+   void *argp1 = 0 ;
+   int res1 = 0 ;
+   int res2 ;
+   char *buf2 = 0 ;
+   int alloc2 = 0 ;
+   OGRErr result;
+   
+   if (SWIG_GetArgs(interp, objc, objv,"oo:osgeo::SpatialReference_SetFromUserInput self name ",(void *)0,(void *)0) == TCL_ERROR) SWIG_fail;
+   res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_OSRSpatialReferenceShadow, 0 |  0 );
+   if (!SWIG_IsOK(res1)) {
+     SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SpatialReference_SetFromUserInput" "', argument " "1"" of type '" "OSRSpatialReferenceShadow *""'"); 
+   }
+   arg1 = reinterpret_cast< OSRSpatialReferenceShadow * >(argp1);
+   res2 = SWIG_AsCharPtrAndSize(objv[2], &buf2, NULL, &alloc2);
+   if (!SWIG_IsOK(res2)) {
+     SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "SpatialReference_SetFromUserInput" "', argument " "2"" of type '" "char const *""'");
+   }
+   arg2 = reinterpret_cast< char * >(buf2);
+   result = (OGRErr)OSRSpatialReferenceShadow_SetFromUserInput(arg1,(char const *)arg2);
+   {
+     /* %typemap(out) OGRErr */
+     if (result != 0) {
+       Tcl_SetResult(interp, (char*) OGRErrMessages(result), TCL_STATIC);
+       SWIG_fail;
+     }
+   }
+   if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
+   {
+     /* %typemap(ret) OGRErr */
+     if (!strcmp(Tcl_GetStringResult(interp), "{}") || !strcmp(Tcl_GetStringResult(interp), "")) {
+       Tcl_SetObjResult(interp, Tcl_NewLongObj( result ));
+     }
+   }
+   return TCL_OK;
+ fail:
+   if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
+   return TCL_ERROR;
+ }
+ 
+ 
+ SWIGINTERN int
+ _wrap_SpatialReference_CopyGeogCSFrom(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
+   OSRSpatialReferenceShadow *arg1 = (OSRSpatialReferenceShadow *) 0 ;
+   OSRSpatialReferenceShadow *arg2 = (OSRSpatialReferenceShadow *) 0 ;
+   void *argp1 = 0 ;
+   int res1 = 0 ;
+   void *argp2 = 0 ;
+   int res2 = 0 ;
+   OGRErr result;
+   
+   if (SWIG_GetArgs(interp, objc, objv,"oo:osgeo::SpatialReference_CopyGeogCSFrom self rhs ",(void *)0,(void *)0) == TCL_ERROR) SWIG_fail;
+   res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_OSRSpatialReferenceShadow, 0 |  0 );
+   if (!SWIG_IsOK(res1)) {
+     SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SpatialReference_CopyGeogCSFrom" "', argument " "1"" of type '" "OSRSpatialReferenceShadow *""'"); 
+   }
+   arg1 = reinterpret_cast< OSRSpatialReferenceShadow * >(argp1);
+   res2 = SWIG_ConvertPtr(objv[2], &argp2,SWIGTYPE_p_OSRSpatialReferenceShadow, 0 |  0 );
+   if (!SWIG_IsOK(res2)) {
+     SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "SpatialReference_CopyGeogCSFrom" "', argument " "2"" of type '" "OSRSpatialReferenceShadow *""'"); 
+   }
+   arg2 = reinterpret_cast< OSRSpatialReferenceShadow * >(argp2);
+   result = (OGRErr)OSRSpatialReferenceShadow_CopyGeogCSFrom(arg1,arg2);
+   {
+     /* %typemap(out) OGRErr */
+     if (result != 0) {
+       Tcl_SetResult(interp, (char*) OGRErrMessages(result), TCL_STATIC);
+       SWIG_fail;
+     }
+   }
+   {
+     /* %typemap(ret) OGRErr */
+     if (!strcmp(Tcl_GetStringResult(interp), "{}") || !strcmp(Tcl_GetStringResult(interp), "")) {
+       Tcl_SetObjResult(interp, Tcl_NewLongObj( result ));
+     }
+   }
+   return TCL_OK;
+ fail:
+   return TCL_ERROR;
+ }
+ 
+ 
+ SWIGINTERN int
+ _wrap_SpatialReference_SetTOWGS84(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
+   OSRSpatialReferenceShadow *arg1 = (OSRSpatialReferenceShadow *) 0 ;
+   double arg2 ;
+   double arg3 ;
+   double arg4 ;
+   double arg5 = (double) 0.0 ;
+   double arg6 = (double) 0.0 ;
+   double arg7 = (double) 0.0 ;
+   double arg8 = (double) 0.0 ;
+   void *argp1 = 0 ;
+   int res1 = 0 ;
+   double val2 ;
+   int ecode2 = 0 ;
+   double val3 ;
+   int ecode3 = 0 ;
+   double val4 ;
+   int ecode4 = 0 ;
+   double val5 ;
+   int ecode5 = 0 ;
+   double val6 ;
+   int ecode6 = 0 ;
+   double val7 ;
+   int ecode7 = 0 ;
+   double val8 ;
+   int ecode8 = 0 ;
+   OGRErr result;
+   
+   if (SWIG_GetArgs(interp, objc, objv,"oooo|oooo:osgeo::SpatialReference_SetTOWGS84 self p1 p2 p3 ?p4? ?p5? ?p6? ?p7? ",(void *)0,(void *)0,(void *)0,(void *)0,(void *)0,(void *)0,(void *)0,(void *)0) == TCL_ERROR) SWIG_fail;
+   res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_OSRSpatialReferenceShadow, 0 |  0 );
+   if (!SWIG_IsOK(res1)) {
+     SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SpatialReference_SetTOWGS84" "', argument " "1"" of type '" "OSRSpatialReferenceShadow *""'"); 
+   }
+   arg1 = reinterpret_cast< OSRSpatialReferenceShadow * >(argp1);
+   ecode2 = SWIG_AsVal_double SWIG_TCL_CALL_ARGS_2(objv[2], &val2);
+   if (!SWIG_IsOK(ecode2)) {
+     SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "SpatialReference_SetTOWGS84" "', argument " "2"" of type '" "double""'");
+   } 
+   arg2 = static_cast< double >(val2);
+   ecode3 = SWIG_AsVal_double SWIG_TCL_CALL_ARGS_2(objv[3], &val3);
+   if (!SWIG_IsOK(ecode3)) {
+     SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "SpatialReference_SetTOWGS84" "', argument " "3"" of type '" "double""'");
+   } 
+   arg3 = static_cast< double >(val3);
+   ecode4 = SWIG_AsVal_double SWIG_TCL_CALL_ARGS_2(objv[4], &val4);
+   if (!SWIG_IsOK(ecode4)) {
+     SWIG_exception_fail(SWIG_ArgError(ecode4), "in method '" "SpatialReference_SetTOWGS84" "', argument " "4"" of type '" "double""'");
+   } 
+   arg4 = static_cast< double >(val4);
+   if (objc > 5) {
+     ecode5 = SWIG_AsVal_double SWIG_TCL_CALL_ARGS_2(objv[5], &val5);
+     if (!SWIG_IsOK(ecode5)) {
+       SWIG_exception_fail(SWIG_ArgError(ecode5), "in method '" "SpatialReference_SetTOWGS84" "', argument " "5"" of type '" "double""'");
+     } 
+     arg5 = static_cast< double >(val5);
+   }
+   if (objc > 6) {
+     ecode6 = SWIG_AsVal_double SWIG_TCL_CALL_ARGS_2(objv[6], &val6);
+     if (!SWIG_IsOK(ecode6)) {
+       SWIG_exception_fail(SWIG_ArgError(ecode6), "in method '" "SpatialReference_SetTOWGS84" "', argument " "6"" of type '" "double""'");
+     } 
+     arg6 = static_cast< double >(val6);
+   }
+   if (objc > 7) {
+     ecode7 = SWIG_AsVal_double SWIG_TCL_CALL_ARGS_2(objv[7], &val7);
+     if (!SWIG_IsOK(ecode7)) {
+       SWIG_exception_fail(SWIG_ArgError(ecode7), "in method '" "SpatialReference_SetTOWGS84" "', argument " "7"" of type '" "double""'");
+     } 
+     arg7 = static_cast< double >(val7);
+   }
+   if (objc > 8) {
+     ecode8 = SWIG_AsVal_double SWIG_TCL_CALL_ARGS_2(objv[8], &val8);
+     if (!SWIG_IsOK(ecode8)) {
+       SWIG_exception_fail(SWIG_ArgError(ecode8), "in method '" "SpatialReference_SetTOWGS84" "', argument " "8"" of type '" "double""'");
+     } 
+     arg8 = static_cast< double >(val8);
+   }
+   result = (OGRErr)OSRSpatialReferenceShadow_SetTOWGS84(arg1,arg2,arg3,arg4,arg5,arg6,arg7,arg8);
+   {
+     /* %typemap(out) OGRErr */
+     if (result != 0) {
+       Tcl_SetResult(interp, (char*) OGRErrMessages(result), TCL_STATIC);
+       SWIG_fail;
+     }
+   }
+   {
+     /* %typemap(ret) OGRErr */
+     if (!strcmp(Tcl_GetStringResult(interp), "{}") || !strcmp(Tcl_GetStringResult(interp), "")) {
+       Tcl_SetObjResult(interp, Tcl_NewLongObj( result ));
+     }
+   }
+   return TCL_OK;
+ fail:
+   return TCL_ERROR;
+ }
+ 
+ 
+ SWIGINTERN int
+ _wrap_SpatialReference_GetTOWGS84(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
+   OSRSpatialReferenceShadow *arg1 = (OSRSpatialReferenceShadow *) 0 ;
+   double *arg2 ;
+   void *argp1 = 0 ;
+   int res1 = 0 ;
+   double argout2[7] ;
+   OGRErr result;
+   
+   {
+     /* %typemap(in,numinputs=0) (double argout2[ANY]) */
+     arg2 = argout2;
+   }
+   if (SWIG_GetArgs(interp, objc, objv,"o:osgeo::SpatialReference_GetTOWGS84 self ",(void *)0) == TCL_ERROR) SWIG_fail;
+   res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_OSRSpatialReferenceShadow, 0 |  0 );
+   if (!SWIG_IsOK(res1)) {
+     SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SpatialReference_GetTOWGS84" "', argument " "1"" of type '" "OSRSpatialReferenceShadow *""'"); 
+   }
+   arg1 = reinterpret_cast< OSRSpatialReferenceShadow * >(argp1);
+   result = (OGRErr)OSRSpatialReferenceShadow_GetTOWGS84(arg1,arg2);
+   {
+     /* %typemap(out) OGRErr */
+     if (result != 0) {
+       Tcl_SetResult(interp, (char*) OGRErrMessages(result), TCL_STATIC);
+       SWIG_fail;
+     }
+   }
+   {
+     /* %typemap(argout) (double argout[ANY]) */
+     Tcl_Obj *out = CreateListFromDoubleArray( interp, arg2, 7 );
+     if (out == NULL) SWIG_fail;
+     Tcl_ListObjAppendElement(interp,Tcl_GetObjResult(interp),out);
+   }
+   {
+     /* %typemap(ret) OGRErr */
+     if (!strcmp(Tcl_GetStringResult(interp), "{}") || !strcmp(Tcl_GetStringResult(interp), "")) {
+       Tcl_SetObjResult(interp, Tcl_NewLongObj( result ));
+     }
+   }
+   return TCL_OK;
+ fail:
+   return TCL_ERROR;
+ }
+ 
+ 
+ SWIGINTERN int
+ _wrap_SpatialReference_SetLocalCS(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
+   OSRSpatialReferenceShadow *arg1 = (OSRSpatialReferenceShadow *) 0 ;
+   char *arg2 = (char *) 0 ;
+   void *argp1 = 0 ;
+   int res1 = 0 ;
+   int res2 ;
+   char *buf2 = 0 ;
+   int alloc2 = 0 ;
+   OGRErr result;
+   
+   if (SWIG_GetArgs(interp, objc, objv,"oo:osgeo::SpatialReference_SetLocalCS self pszName ",(void *)0,(void *)0) == TCL_ERROR) SWIG_fail;
+   res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_OSRSpatialReferenceShadow, 0 |  0 );
+   if (!SWIG_IsOK(res1)) {
+     SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SpatialReference_SetLocalCS" "', argument " "1"" of type '" "OSRSpatialReferenceShadow *""'"); 
+   }
+   arg1 = reinterpret_cast< OSRSpatialReferenceShadow * >(argp1);
+   res2 = SWIG_AsCharPtrAndSize(objv[2], &buf2, NULL, &alloc2);
+   if (!SWIG_IsOK(res2)) {
+     SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "SpatialReference_SetLocalCS" "', argument " "2"" of type '" "char const *""'");
+   }
+   arg2 = reinterpret_cast< char * >(buf2);
+   result = (OGRErr)OSRSpatialReferenceShadow_SetLocalCS(arg1,(char const *)arg2);
+   {
+     /* %typemap(out) OGRErr */
+     if (result != 0) {
+       Tcl_SetResult(interp, (char*) OGRErrMessages(result), TCL_STATIC);
+       SWIG_fail;
+     }
+   }
+   if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
+   {
+     /* %typemap(ret) OGRErr */
+     if (!strcmp(Tcl_GetStringResult(interp), "{}") || !strcmp(Tcl_GetStringResult(interp), "")) {
+       Tcl_SetObjResult(interp, Tcl_NewLongObj( result ));
+     }
+   }
+   return TCL_OK;
+ fail:
+   if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
+   return TCL_ERROR;
+ }
+ 
+ 
+ SWIGINTERN int
+ _wrap_SpatialReference_SetGeogCS(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
+   OSRSpatialReferenceShadow *arg1 = (OSRSpatialReferenceShadow *) 0 ;
+   char *arg2 = (char *) 0 ;
+   char *arg3 = (char *) 0 ;
+   char *arg4 = (char *) 0 ;
+   double arg5 ;
+   double arg6 ;
+   char *arg7 = (char *) "Greenwich" ;
+   double arg8 = (double) 0.0 ;
+   char *arg9 = (char *) "degree" ;
+   double arg10 = (double) 0.0174532925199433 ;
+   void *argp1 = 0 ;
+   int res1 = 0 ;
+   int res2 ;
+   char *buf2 = 0 ;
+   int alloc2 = 0 ;
+   int res3 ;
+   char *buf3 = 0 ;
+   int alloc3 = 0 ;
+   int res4 ;
+   char *buf4 = 0 ;
+   int alloc4 = 0 ;
+   double val5 ;
+   int ecode5 = 0 ;
+   double val6 ;
+   int ecode6 = 0 ;
+   int res7 ;
+   char *buf7 = 0 ;
+   int alloc7 = 0 ;
+   double val8 ;
+   int ecode8 = 0 ;
+   int res9 ;
+   char *buf9 = 0 ;
+   int alloc9 = 0 ;
+   double val10 ;
+   int ecode10 = 0 ;
+   OGRErr result;
+   
+   if (SWIG_GetArgs(interp, objc, objv,"oooooo|oooo:osgeo::SpatialReference_SetGeogCS self pszGeogName pszDatumName pszEllipsoidName dfSemiMajor dfInvFlattening ?pszPMName? ?dfPMOffset? ?pszUnits? ?dfConvertToRadians? ",(void *)0,(void *)0,(void *)0,(void *)0,(void *)0,(void *)0,(void *)0,(void *)0,(void *)0,(void *)0) == TCL_ERROR) SWIG_fail;
+   res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_OSRSpatialReferenceShadow, 0 |  0 );
+   if (!SWIG_IsOK(res1)) {
+     SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SpatialReference_SetGeogCS" "', argument " "1"" of type '" "OSRSpatialReferenceShadow *""'"); 
+   }
+   arg1 = reinterpret_cast< OSRSpatialReferenceShadow * >(argp1);
+   res2 = SWIG_AsCharPtrAndSize(objv[2], &buf2, NULL, &alloc2);
+   if (!SWIG_IsOK(res2)) {
+     SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "SpatialReference_SetGeogCS" "', argument " "2"" of type '" "char const *""'");
+   }
+   arg2 = reinterpret_cast< char * >(buf2);
+   res3 = SWIG_AsCharPtrAndSize(objv[3], &buf3, NULL, &alloc3);
+   if (!SWIG_IsOK(res3)) {
+     SWIG_exception_fail(SWIG_ArgError(res3), "in method '" "SpatialReference_SetGeogCS" "', argument " "3"" of type '" "char const *""'");
+   }
+   arg3 = reinterpret_cast< char * >(buf3);
+   res4 = SWIG_AsCharPtrAndSize(objv[4], &buf4, NULL, &alloc4);
+   if (!SWIG_IsOK(res4)) {
+     SWIG_exception_fail(SWIG_ArgError(res4), "in method '" "SpatialReference_SetGeogCS" "', argument " "4"" of type '" "char const *""'");
+   }
+   arg4 = reinterpret_cast< char * >(buf4);
+   ecode5 = SWIG_AsVal_double SWIG_TCL_CALL_ARGS_2(objv[5], &val5);
+   if (!SWIG_IsOK(ecode5)) {
+     SWIG_exception_fail(SWIG_ArgError(ecode5), "in method '" "SpatialReference_SetGeogCS" "', argument " "5"" of type '" "double""'");
+   } 
+   arg5 = static_cast< double >(val5);
+   ecode6 = SWIG_AsVal_double SWIG_TCL_CALL_ARGS_2(objv[6], &val6);
+   if (!SWIG_IsOK(ecode6)) {
+     SWIG_exception_fail(SWIG_ArgError(ecode6), "in method '" "SpatialReference_SetGeogCS" "', argument " "6"" of type '" "double""'");
+   } 
+   arg6 = static_cast< double >(val6);
+   if (objc > 7) {
+     res7 = SWIG_AsCharPtrAndSize(objv[7], &buf7, NULL, &alloc7);
+     if (!SWIG_IsOK(res7)) {
+       SWIG_exception_fail(SWIG_ArgError(res7), "in method '" "SpatialReference_SetGeogCS" "', argument " "7"" of type '" "char const *""'");
+     }
+     arg7 = reinterpret_cast< char * >(buf7);
+   }
+   if (objc > 8) {
+     ecode8 = SWIG_AsVal_double SWIG_TCL_CALL_ARGS_2(objv[8], &val8);
+     if (!SWIG_IsOK(ecode8)) {
+       SWIG_exception_fail(SWIG_ArgError(ecode8), "in method '" "SpatialReference_SetGeogCS" "', argument " "8"" of type '" "double""'");
+     } 
+     arg8 = static_cast< double >(val8);
+   }
+   if (objc > 9) {
+     res9 = SWIG_AsCharPtrAndSize(objv[9], &buf9, NULL, &alloc9);
+     if (!SWIG_IsOK(res9)) {
+       SWIG_exception_fail(SWIG_ArgError(res9), "in method '" "SpatialReference_SetGeogCS" "', argument " "9"" of type '" "char const *""'");
+     }
+     arg9 = reinterpret_cast< char * >(buf9);
+   }
+   if (objc > 10) {
+     ecode10 = SWIG_AsVal_double SWIG_TCL_CALL_ARGS_2(objv[10], &val10);
+     if (!SWIG_IsOK(ecode10)) {
+       SWIG_exception_fail(SWIG_ArgError(ecode10), "in method '" "SpatialReference_SetGeogCS" "', argument " "10"" of type '" "double""'");
+     } 
+     arg10 = static_cast< double >(val10);
+   }
+   result = (OGRErr)OSRSpatialReferenceShadow_SetGeogCS(arg1,(char const *)arg2,(char const *)arg3,(char const *)arg4,arg5,arg6,(char const *)arg7,arg8,(char const *)arg9,arg10);
+   {
+     /* %typemap(out) OGRErr */
+     if (result != 0) {
+       Tcl_SetResult(interp, (char*) OGRErrMessages(result), TCL_STATIC);
+       SWIG_fail;
+     }
+   }
+   if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
+   if (alloc3 == SWIG_NEWOBJ) delete[] buf3;
+   if (alloc4 == SWIG_NEWOBJ) delete[] buf4;
+   if (alloc7 == SWIG_NEWOBJ) delete[] buf7;
+   if (alloc9 == SWIG_NEWOBJ) delete[] buf9;
+   {
+     /* %typemap(ret) OGRErr */
+     if (!strcmp(Tcl_GetStringResult(interp), "{}") || !strcmp(Tcl_GetStringResult(interp), "")) {
+       Tcl_SetObjResult(interp, Tcl_NewLongObj( result ));
+     }
+   }
+   return TCL_OK;
+ fail:
+   if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
+   if (alloc3 == SWIG_NEWOBJ) delete[] buf3;
+   if (alloc4 == SWIG_NEWOBJ) delete[] buf4;
+   if (alloc7 == SWIG_NEWOBJ) delete[] buf7;
+   if (alloc9 == SWIG_NEWOBJ) delete[] buf9;
+   return TCL_ERROR;
+ }
+ 
+ 
+ SWIGINTERN int
+ _wrap_SpatialReference_SetProjCS(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
+   OSRSpatialReferenceShadow *arg1 = (OSRSpatialReferenceShadow *) 0 ;
+   char *arg2 = (char *) "unnamed" ;
+   void *argp1 = 0 ;
+   int res1 = 0 ;
+   int res2 ;
+   char *buf2 = 0 ;
+   int alloc2 = 0 ;
+   OGRErr result;
+   
+   if (SWIG_GetArgs(interp, objc, objv,"o|o:osgeo::SpatialReference_SetProjCS self ?name? ",(void *)0,(void *)0) == TCL_ERROR) SWIG_fail;
+   res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_OSRSpatialReferenceShadow, 0 |  0 );
+   if (!SWIG_IsOK(res1)) {
+     SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SpatialReference_SetProjCS" "', argument " "1"" of type '" "OSRSpatialReferenceShadow *""'"); 
+   }
+   arg1 = reinterpret_cast< OSRSpatialReferenceShadow * >(argp1);
+   if (objc > 2) {
+     res2 = SWIG_AsCharPtrAndSize(objv[2], &buf2, NULL, &alloc2);
+     if (!SWIG_IsOK(res2)) {
+       SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "SpatialReference_SetProjCS" "', argument " "2"" of type '" "char const *""'");
+     }
+     arg2 = reinterpret_cast< char * >(buf2);
+   }
+   result = (OGRErr)OSRSpatialReferenceShadow_SetProjCS(arg1,(char const *)arg2);
+   {
+     /* %typemap(out) OGRErr */
+     if (result != 0) {
+       Tcl_SetResult(interp, (char*) OGRErrMessages(result), TCL_STATIC);
+       SWIG_fail;
+     }
+   }
+   if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
+   {
+     /* %typemap(ret) OGRErr */
+     if (!strcmp(Tcl_GetStringResult(interp), "{}") || !strcmp(Tcl_GetStringResult(interp), "")) {
+       Tcl_SetObjResult(interp, Tcl_NewLongObj( result ));
+     }
+   }
+   return TCL_OK;
+ fail:
+   if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
+   return TCL_ERROR;
+ }
+ 
+ 
+ SWIGINTERN int
+ _wrap_SpatialReference_ImportFromWkt(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
+   OSRSpatialReferenceShadow *arg1 = (OSRSpatialReferenceShadow *) 0 ;
+   char **arg2 = (char **) 0 ;
+   void *argp1 = 0 ;
+   int res1 = 0 ;
+   char *val2 ;
+   OGRErr result;
+   
+   if (SWIG_GetArgs(interp, objc, objv,"oo:osgeo::SpatialReference_ImportFromWkt self ppszInput ",(void *)0,(void *)0) == TCL_ERROR) SWIG_fail;
+   res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_OSRSpatialReferenceShadow, 0 |  0 );
+   if (!SWIG_IsOK(res1)) {
+     SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SpatialReference_ImportFromWkt" "', argument " "1"" of type '" "OSRSpatialReferenceShadow *""'"); 
+   }
+   arg1 = reinterpret_cast< OSRSpatialReferenceShadow * >(argp1);
+   {
+     /* %typemap(in) (char **ignorechange) */
+     val2 = Tcl_GetString(objv[2]);
+     arg2 = &val2;
+   }
+   result = (OGRErr)OSRSpatialReferenceShadow_ImportFromWkt(arg1,arg2);
+   {
+     /* %typemap(out) OGRErr */
+     if (result != 0) {
+       Tcl_SetResult(interp, (char*) OGRErrMessages(result), TCL_STATIC);
+       SWIG_fail;
+     }
+   }
+   {
+     /* %typemap(ret) OGRErr */
+     if (!strcmp(Tcl_GetStringResult(interp), "{}") || !strcmp(Tcl_GetStringResult(interp), "")) {
+       Tcl_SetObjResult(interp, Tcl_NewLongObj( result ));
+     }
+   }
+   return TCL_OK;
+ fail:
+   return TCL_ERROR;
+ }
+ 
+ 
+ SWIGINTERN int
+ _wrap_SpatialReference_ImportFromProj4(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
+   OSRSpatialReferenceShadow *arg1 = (OSRSpatialReferenceShadow *) 0 ;
+   char *arg2 = (char *) 0 ;
+   void *argp1 = 0 ;
+   int res1 = 0 ;
+   int res2 ;
+   char *buf2 = 0 ;
+   int alloc2 = 0 ;
+   OGRErr result;
+   
+   if (SWIG_GetArgs(interp, objc, objv,"oo:osgeo::SpatialReference_ImportFromProj4 self ppszInput ",(void *)0,(void *)0) == TCL_ERROR) SWIG_fail;
+   res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_OSRSpatialReferenceShadow, 0 |  0 );
+   if (!SWIG_IsOK(res1)) {
+     SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SpatialReference_ImportFromProj4" "', argument " "1"" of type '" "OSRSpatialReferenceShadow *""'"); 
+   }
+   arg1 = reinterpret_cast< OSRSpatialReferenceShadow * >(argp1);
+   res2 = SWIG_AsCharPtrAndSize(objv[2], &buf2, NULL, &alloc2);
+   if (!SWIG_IsOK(res2)) {
+     SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "SpatialReference_ImportFromProj4" "', argument " "2"" of type '" "char *""'");
+   }
+   arg2 = reinterpret_cast< char * >(buf2);
+   result = (OGRErr)OSRSpatialReferenceShadow_ImportFromProj4(arg1,arg2);
+   {
+     /* %typemap(out) OGRErr */
+     if (result != 0) {
+       Tcl_SetResult(interp, (char*) OGRErrMessages(result), TCL_STATIC);
+       SWIG_fail;
+     }
+   }
+   if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
+   {
+     /* %typemap(ret) OGRErr */
+     if (!strcmp(Tcl_GetStringResult(interp), "{}") || !strcmp(Tcl_GetStringResult(interp), "")) {
+       Tcl_SetObjResult(interp, Tcl_NewLongObj( result ));
+     }
+   }
+   return TCL_OK;
+ fail:
+   if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
+   return TCL_ERROR;
+ }
+ 
+ 
+ SWIGINTERN int
+ _wrap_SpatialReference_ImportFromUrl(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
+   OSRSpatialReferenceShadow *arg1 = (OSRSpatialReferenceShadow *) 0 ;
+   char *arg2 = (char *) 0 ;
+   void *argp1 = 0 ;
+   int res1 = 0 ;
+   int res2 ;
+   char *buf2 = 0 ;
+   int alloc2 = 0 ;
+   OGRErr result;
+   
+   if (SWIG_GetArgs(interp, objc, objv,"oo:osgeo::SpatialReference_ImportFromUrl self url ",(void *)0,(void *)0) == TCL_ERROR) SWIG_fail;
+   res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_OSRSpatialReferenceShadow, 0 |  0 );
+   if (!SWIG_IsOK(res1)) {
+     SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SpatialReference_ImportFromUrl" "', argument " "1"" of type '" "OSRSpatialReferenceShadow *""'"); 
+   }
+   arg1 = reinterpret_cast< OSRSpatialReferenceShadow * >(argp1);
+   res2 = SWIG_AsCharPtrAndSize(objv[2], &buf2, NULL, &alloc2);
+   if (!SWIG_IsOK(res2)) {
+     SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "SpatialReference_ImportFromUrl" "', argument " "2"" of type '" "char *""'");
+   }
+   arg2 = reinterpret_cast< char * >(buf2);
+   result = (OGRErr)OSRSpatialReferenceShadow_ImportFromUrl(arg1,arg2);
+   {
+     /* %typemap(out) OGRErr */
+     if (result != 0) {
+       Tcl_SetResult(interp, (char*) OGRErrMessages(result), TCL_STATIC);
+       SWIG_fail;
+     }
+   }
+   if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
+   {
+     /* %typemap(ret) OGRErr */
+     if (!strcmp(Tcl_GetStringResult(interp), "{}") || !strcmp(Tcl_GetStringResult(interp), "")) {
+       Tcl_SetObjResult(interp, Tcl_NewLongObj( result ));
+     }
+   }
+   return TCL_OK;
+ fail:
+   if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
+   return TCL_ERROR;
+ }
+ 
+ 
+ SWIGINTERN int
+ _wrap_SpatialReference_ImportFromESRI(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
+   OSRSpatialReferenceShadow *arg1 = (OSRSpatialReferenceShadow *) 0 ;
+   char **arg2 = (char **) 0 ;
+   void *argp1 = 0 ;
+   int res1 = 0 ;
+   OGRErr result;
+   
+   if (SWIG_GetArgs(interp, objc, objv,"oo:osgeo::SpatialReference_ImportFromESRI self ppszInput ",(void *)0,(void *)0) == TCL_ERROR) SWIG_fail;
+   res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_OSRSpatialReferenceShadow, 0 |  0 );
+   if (!SWIG_IsOK(res1)) {
+     SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SpatialReference_ImportFromESRI" "', argument " "1"" of type '" "OSRSpatialReferenceShadow *""'"); 
+   }
+   arg1 = reinterpret_cast< OSRSpatialReferenceShadow * >(argp1);
+   {
+     /* %typemap(in) char **options */
+     int size;
+     if (Tcl_ListObjLength(interp, objv[2], &size) != TCL_OK) {
+       /* Error msg in interp result */
+       SWIG_fail;
+     }
+     if ( !size ) {
+       Tcl_SetResult(interp, (char*) "Input list mustn't be empty", TCL_STATIC);
+       SWIG_fail;
+     }
+     
+     for (int i = 0; i < size; i++) {
+       Tcl_Obj **o = NULL;
+       /* The reference count for the list element is not incremented with the following */
+       if (Tcl_ListObjIndex(interp, objv[2], i, o) != TCL_OK) {
+         /* Error msg in interp result */
+         SWIG_fail;
+       }
+       char *pszItem = Tcl_GetString(*o);
+       arg2 = CSLAddString( arg2, pszItem );
+     }
+   }
+   result = (OGRErr)OSRSpatialReferenceShadow_ImportFromESRI(arg1,arg2);
+   {
+     /* %typemap(out) OGRErr */
+     if (result != 0) {
+       Tcl_SetResult(interp, (char*) OGRErrMessages(result), TCL_STATIC);
+       SWIG_fail;
+     }
+   }
+   {
+     /* %typemap(freearg) char **options */
+     CSLDestroy( arg2 );
+   }
+   {
+     /* %typemap(ret) OGRErr */
+     if (!strcmp(Tcl_GetStringResult(interp), "{}") || !strcmp(Tcl_GetStringResult(interp), "")) {
+       Tcl_SetObjResult(interp, Tcl_NewLongObj( result ));
+     }
+   }
+   return TCL_OK;
+ fail:
+   {
+     /* %typemap(freearg) char **options */
+     CSLDestroy( arg2 );
+   }
+   return TCL_ERROR;
+ }
+ 
+ 
+ SWIGINTERN int
+ _wrap_SpatialReference_ImportFromEPSG(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
+   OSRSpatialReferenceShadow *arg1 = (OSRSpatialReferenceShadow *) 0 ;
+   int arg2 ;
+   void *argp1 = 0 ;
+   int res1 = 0 ;
+   int val2 ;
+   int ecode2 = 0 ;
+   OGRErr result;
+   
+   if (SWIG_GetArgs(interp, objc, objv,"oo:osgeo::SpatialReference_ImportFromEPSG self arg ",(void *)0,(void *)0) == TCL_ERROR) SWIG_fail;
+   res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_OSRSpatialReferenceShadow, 0 |  0 );
+   if (!SWIG_IsOK(res1)) {
+     SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SpatialReference_ImportFromEPSG" "', argument " "1"" of type '" "OSRSpatialReferenceShadow *""'"); 
+   }
+   arg1 = reinterpret_cast< OSRSpatialReferenceShadow * >(argp1);
+   ecode2 = SWIG_AsVal_int SWIG_TCL_CALL_ARGS_2(objv[2], &val2);
+   if (!SWIG_IsOK(ecode2)) {
+     SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "SpatialReference_ImportFromEPSG" "', argument " "2"" of type '" "int""'");
+   } 
+   arg2 = static_cast< int >(val2);
+   result = (OGRErr)OSRSpatialReferenceShadow_ImportFromEPSG(arg1,arg2);
+   {
+     /* %typemap(out) OGRErr */
+     if (result != 0) {
+       Tcl_SetResult(interp, (char*) OGRErrMessages(result), TCL_STATIC);
+       SWIG_fail;
+     }
+   }
+   {
+     /* %typemap(ret) OGRErr */
+     if (!strcmp(Tcl_GetStringResult(interp), "{}") || !strcmp(Tcl_GetStringResult(interp), "")) {
+       Tcl_SetObjResult(interp, Tcl_NewLongObj( result ));
+     }
+   }
+   return TCL_OK;
+ fail:
+   return TCL_ERROR;
+ }
+ 
+ 
+ SWIGINTERN int
+ _wrap_SpatialReference_ImportFromPCI(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
+   OSRSpatialReferenceShadow *arg1 = (OSRSpatialReferenceShadow *) 0 ;
+   char *arg2 = (char *) 0 ;
+   char *arg3 = (char *) "METRE" ;
+   double *arg4 = (double *) (double *)0 ;
+   void *argp1 = 0 ;
+   int res1 = 0 ;
+   int res2 ;
+   char *buf2 = 0 ;
+   int alloc2 = 0 ;
+   int res3 ;
+   char *buf3 = 0 ;
+   int alloc3 = 0 ;
+   double argin4[17] ;
+   OGRErr result;
+   
+   if (SWIG_GetArgs(interp, objc, objv,"oo|oo:osgeo::SpatialReference_ImportFromPCI self proj ?units? ?argin? ",(void *)0,(void *)0,(void *)0,(void *)0) == TCL_ERROR) SWIG_fail;
+   res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_OSRSpatialReferenceShadow, 0 |  0 );
+   if (!SWIG_IsOK(res1)) {
+     SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SpatialReference_ImportFromPCI" "', argument " "1"" of type '" "OSRSpatialReferenceShadow *""'"); 
+   }
+   arg1 = reinterpret_cast< OSRSpatialReferenceShadow * >(argp1);
+   res2 = SWIG_AsCharPtrAndSize(objv[2], &buf2, NULL, &alloc2);
+   if (!SWIG_IsOK(res2)) {
+     SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "SpatialReference_ImportFromPCI" "', argument " "2"" of type '" "char const *""'");
+   }
+   arg2 = reinterpret_cast< char * >(buf2);
+   if (objc > 3) {
+     res3 = SWIG_AsCharPtrAndSize(objv[3], &buf3, NULL, &alloc3);
+     if (!SWIG_IsOK(res3)) {
+       SWIG_exception_fail(SWIG_ArgError(res3), "in method '" "SpatialReference_ImportFromPCI" "', argument " "3"" of type '" "char const *""'");
+     }
+     arg3 = reinterpret_cast< char * >(buf3);
+   }
+   if (objc > 4) {
+     {
+       /* %typemap(in) (double argin4[ANY]) */
+       arg4 = argin4;
+       int lst_size;
+       /* The following also checks if input is a list */
+       if (Tcl_ListObjLength(interp, objv[4], &lst_size) != TCL_OK) {
+         /* Error msg in interp result */
+         SWIG_fail;
+       }
+       if ( lst_size != 17 ) {
+         Tcl_SetResult(interp, (char*) "List must have length ##size", TCL_STATIC);
+         SWIG_fail;
+       }
+       for (unsigned int i=0; i<17; i++) {
+         Tcl_Obj **o = NULL;
+         if (Tcl_ListObjIndex(interp, objv[4], i, o) != TCL_OK) {
+           /* ref count is not incremented */
+           /* Error msg in interp result */
+           SWIG_fail;
+         }
+         
+         double val;
+         if (Tcl_GetDoubleFromObj(interp, *o, &val ) != TCL_OK) {
+           /* Error msg in interp result */
+           SWIG_fail;
+         }
+         arg4[i] = val;
+       }
+     }
+   }
+   result = (OGRErr)OSRSpatialReferenceShadow_ImportFromPCI(arg1,(char const *)arg2,(char const *)arg3,arg4);
+   {
+     /* %typemap(out) OGRErr */
+     if (result != 0) {
+       Tcl_SetResult(interp, (char*) OGRErrMessages(result), TCL_STATIC);
+       SWIG_fail;
+     }
+   }
+   if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
+   if (alloc3 == SWIG_NEWOBJ) delete[] buf3;
+   {
+     /* %typemap(ret) OGRErr */
+     if (!strcmp(Tcl_GetStringResult(interp), "{}") || !strcmp(Tcl_GetStringResult(interp), "")) {
+       Tcl_SetObjResult(interp, Tcl_NewLongObj( result ));
+     }
+   }
+   return TCL_OK;
+ fail:
+   if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
+   if (alloc3 == SWIG_NEWOBJ) delete[] buf3;
+   return TCL_ERROR;
+ }
+ 
+ 
+ SWIGINTERN int
+ _wrap_SpatialReference_ImportFromUSGS(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
+   OSRSpatialReferenceShadow *arg1 = (OSRSpatialReferenceShadow *) 0 ;
+   long arg2 ;
+   long arg3 = (long) 0 ;
+   double *arg4 = (double *) (double *)0 ;
+   long arg5 = (long) 0 ;
+   void *argp1 = 0 ;
+   int res1 = 0 ;
+   long val2 ;
+   int ecode2 = 0 ;
+   long val3 ;
+   int ecode3 = 0 ;
+   double argin4[15] ;
+   long val5 ;
+   int ecode5 = 0 ;
+   OGRErr result;
+   
+   if (SWIG_GetArgs(interp, objc, objv,"oo|ooo:osgeo::SpatialReference_ImportFromUSGS self proj_code ?zone? ?argin? ?datum_code? ",(void *)0,(void *)0,(void *)0,(void *)0,(void *)0) == TCL_ERROR) SWIG_fail;
+   res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_OSRSpatialReferenceShadow, 0 |  0 );
+   if (!SWIG_IsOK(res1)) {
+     SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SpatialReference_ImportFromUSGS" "', argument " "1"" of type '" "OSRSpatialReferenceShadow *""'"); 
+   }
+   arg1 = reinterpret_cast< OSRSpatialReferenceShadow * >(argp1);
+   ecode2 = SWIG_AsVal_long SWIG_TCL_CALL_ARGS_2(objv[2], &val2);
+   if (!SWIG_IsOK(ecode2)) {
+     SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "SpatialReference_ImportFromUSGS" "', argument " "2"" of type '" "long""'");
+   } 
+   arg2 = static_cast< long >(val2);
+   if (objc > 3) {
+     ecode3 = SWIG_AsVal_long SWIG_TCL_CALL_ARGS_2(objv[3], &val3);
+     if (!SWIG_IsOK(ecode3)) {
+       SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "SpatialReference_ImportFromUSGS" "', argument " "3"" of type '" "long""'");
+     } 
+     arg3 = static_cast< long >(val3);
+   }
+   if (objc > 4) {
+     {
+       /* %typemap(in) (double argin4[ANY]) */
+       arg4 = argin4;
+       int lst_size;
+       /* The following also checks if input is a list */
+       if (Tcl_ListObjLength(interp, objv[4], &lst_size) != TCL_OK) {
+         /* Error msg in interp result */
+         SWIG_fail;
+       }
+       if ( lst_size != 15 ) {
+         Tcl_SetResult(interp, (char*) "List must have length ##size", TCL_STATIC);
+         SWIG_fail;
+       }
+       for (unsigned int i=0; i<15; i++) {
+         Tcl_Obj **o = NULL;
+         if (Tcl_ListObjIndex(interp, objv[4], i, o) != TCL_OK) {
+           /* ref count is not incremented */
+           /* Error msg in interp result */
+           SWIG_fail;
+         }
+         
+         double val;
+         if (Tcl_GetDoubleFromObj(interp, *o, &val ) != TCL_OK) {
+           /* Error msg in interp result */
+           SWIG_fail;
+         }
+         arg4[i] = val;
+       }
+     }
+   }
+   if (objc > 5) {
+     ecode5 = SWIG_AsVal_long SWIG_TCL_CALL_ARGS_2(objv[5], &val5);
+     if (!SWIG_IsOK(ecode5)) {
+       SWIG_exception_fail(SWIG_ArgError(ecode5), "in method '" "SpatialReference_ImportFromUSGS" "', argument " "5"" of type '" "long""'");
+     } 
+     arg5 = static_cast< long >(val5);
+   }
+   result = (OGRErr)OSRSpatialReferenceShadow_ImportFromUSGS(arg1,arg2,arg3,arg4,arg5);
+   {
+     /* %typemap(out) OGRErr */
+     if (result != 0) {
+       Tcl_SetResult(interp, (char*) OGRErrMessages(result), TCL_STATIC);
+       SWIG_fail;
+     }
+   }
+   {
+     /* %typemap(ret) OGRErr */
+     if (!strcmp(Tcl_GetStringResult(interp), "{}") || !strcmp(Tcl_GetStringResult(interp), "")) {
+       Tcl_SetObjResult(interp, Tcl_NewLongObj( result ));
+     }
+   }
+   return TCL_OK;
+ fail:
+   return TCL_ERROR;
+ }
+ 
+ 
+ SWIGINTERN int
+ _wrap_SpatialReference_ImportFromXML(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
+   OSRSpatialReferenceShadow *arg1 = (OSRSpatialReferenceShadow *) 0 ;
+   char *arg2 = (char *) 0 ;
+   void *argp1 = 0 ;
+   int res1 = 0 ;
+   int res2 ;
+   char *buf2 = 0 ;
+   int alloc2 = 0 ;
+   OGRErr result;
+   
+   if (SWIG_GetArgs(interp, objc, objv,"oo:osgeo::SpatialReference_ImportFromXML self xmlString ",(void *)0,(void *)0) == TCL_ERROR) SWIG_fail;
+   res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_OSRSpatialReferenceShadow, 0 |  0 );
+   if (!SWIG_IsOK(res1)) {
+     SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SpatialReference_ImportFromXML" "', argument " "1"" of type '" "OSRSpatialReferenceShadow *""'"); 
+   }
+   arg1 = reinterpret_cast< OSRSpatialReferenceShadow * >(argp1);
+   res2 = SWIG_AsCharPtrAndSize(objv[2], &buf2, NULL, &alloc2);
+   if (!SWIG_IsOK(res2)) {
+     SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "SpatialReference_ImportFromXML" "', argument " "2"" of type '" "char const *""'");
+   }
+   arg2 = reinterpret_cast< char * >(buf2);
+   result = (OGRErr)OSRSpatialReferenceShadow_ImportFromXML(arg1,(char const *)arg2);
+   {
+     /* %typemap(out) OGRErr */
+     if (result != 0) {
+       Tcl_SetResult(interp, (char*) OGRErrMessages(result), TCL_STATIC);
+       SWIG_fail;
+     }
+   }
+   if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
+   {
+     /* %typemap(ret) OGRErr */
+     if (!strcmp(Tcl_GetStringResult(interp), "{}") || !strcmp(Tcl_GetStringResult(interp), "")) {
+       Tcl_SetObjResult(interp, Tcl_NewLongObj( result ));
+     }
+   }
+   return TCL_OK;
+ fail:
+   if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
+   return TCL_ERROR;
+ }
+ 
+ 
+ SWIGINTERN int
+ _wrap_SpatialReference_ImportFromMICoordSys(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
+   OSRSpatialReferenceShadow *arg1 = (OSRSpatialReferenceShadow *) 0 ;
+   char *arg2 = (char *) 0 ;
+   void *argp1 = 0 ;
+   int res1 = 0 ;
+   int res2 ;
+   char *buf2 = 0 ;
+   int alloc2 = 0 ;
+   OGRErr result;
+   
+   if (SWIG_GetArgs(interp, objc, objv,"oo:osgeo::SpatialReference_ImportFromMICoordSys self pszCoordSys ",(void *)0,(void *)0) == TCL_ERROR) SWIG_fail;
+   res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_OSRSpatialReferenceShadow, 0 |  0 );
+   if (!SWIG_IsOK(res1)) {
+     SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SpatialReference_ImportFromMICoordSys" "', argument " "1"" of type '" "OSRSpatialReferenceShadow *""'"); 
+   }
+   arg1 = reinterpret_cast< OSRSpatialReferenceShadow * >(argp1);
+   res2 = SWIG_AsCharPtrAndSize(objv[2], &buf2, NULL, &alloc2);
+   if (!SWIG_IsOK(res2)) {
+     SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "SpatialReference_ImportFromMICoordSys" "', argument " "2"" of type '" "char const *""'");
+   }
+   arg2 = reinterpret_cast< char * >(buf2);
+   result = (OGRErr)OSRSpatialReferenceShadow_ImportFromMICoordSys(arg1,(char const *)arg2);
+   {
+     /* %typemap(out) OGRErr */
+     if (result != 0) {
+       Tcl_SetResult(interp, (char*) OGRErrMessages(result), TCL_STATIC);
+       SWIG_fail;
+     }
+   }
+   if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
+   {
+     /* %typemap(ret) OGRErr */
+     if (!strcmp(Tcl_GetStringResult(interp), "{}") || !strcmp(Tcl_GetStringResult(interp), "")) {
+       Tcl_SetObjResult(interp, Tcl_NewLongObj( result ));
+     }
+   }
+   return TCL_OK;
+ fail:
+   if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
+   return TCL_ERROR;
+ }
+ 
+ 
+ SWIGINTERN int
+ _wrap_SpatialReference_ExportToWkt(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
+   OSRSpatialReferenceShadow *arg1 = (OSRSpatialReferenceShadow *) 0 ;
+   char **arg2 = (char **) 0 ;
+   void *argp1 = 0 ;
+   int res1 = 0 ;
+   char *argout2 = 0 ;
+   OGRErr result;
+   
+   {
+     /* %typemap(in,numinputs=0) (char **argout2) */
+     arg2 = &argout2;
+   }
+   if (SWIG_GetArgs(interp, objc, objv,"o:osgeo::SpatialReference_ExportToWkt self ",(void *)0) == TCL_ERROR) SWIG_fail;
+   res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_OSRSpatialReferenceShadow, 0 |  0 );
+   if (!SWIG_IsOK(res1)) {
+     SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SpatialReference_ExportToWkt" "', argument " "1"" of type '" "OSRSpatialReferenceShadow *""'"); 
+   }
+   arg1 = reinterpret_cast< OSRSpatialReferenceShadow * >(argp1);
+   result = (OGRErr)OSRSpatialReferenceShadow_ExportToWkt(arg1,arg2);
+   {
+     /* %typemap(out) OGRErr */
+     if (result != 0) {
+       Tcl_SetResult(interp, (char*) OGRErrMessages(result), TCL_STATIC);
+       SWIG_fail;
+     }
+   }
+   {
+     /* %typemap(argout) (char **argout) */
+     Tcl_Obj *o;
+     if ( arg2 ) {
+       o = Tcl_NewStringObj( *arg2, -1 );
+     } else {
+       o = Tcl_NewObj();
+     }
+     Tcl_ListObjAppendElement(interp,Tcl_GetObjResult(interp),o);
+   }
+   {
+     /* %typemap(ret) OGRErr */
+     if (!strcmp(Tcl_GetStringResult(interp), "{}") || !strcmp(Tcl_GetStringResult(interp), "")) {
+       Tcl_SetObjResult(interp, Tcl_NewLongObj( result ));
+     }
+   }
+   return TCL_OK;
+ fail:
+   return TCL_ERROR;
+ }
+ 
+ 
+ SWIGINTERN int
+ _wrap_SpatialReference_ExportToPrettyWkt(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
+   OSRSpatialReferenceShadow *arg1 = (OSRSpatialReferenceShadow *) 0 ;
+   char **arg2 = (char **) 0 ;
+   int arg3 = (int) 0 ;
+   void *argp1 = 0 ;
+   int res1 = 0 ;
+   char *argout2 = 0 ;
+   int val3 ;
+   int ecode3 = 0 ;
+   OGRErr result;
+   
+   {
+     /* %typemap(in,numinputs=0) (char **argout2) */
+     arg2 = &argout2;
+   }
+   if (SWIG_GetArgs(interp, objc, objv,"o|o:osgeo::SpatialReference_ExportToPrettyWkt self ?simplify? ",(void *)0,(void *)0) == TCL_ERROR) SWIG_fail;
+   res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_OSRSpatialReferenceShadow, 0 |  0 );
+   if (!SWIG_IsOK(res1)) {
+     SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SpatialReference_ExportToPrettyWkt" "', argument " "1"" of type '" "OSRSpatialReferenceShadow *""'"); 
+   }
+   arg1 = reinterpret_cast< OSRSpatialReferenceShadow * >(argp1);
+   if (objc > 2) {
+     ecode3 = SWIG_AsVal_int SWIG_TCL_CALL_ARGS_2(objv[2], &val3);
+     if (!SWIG_IsOK(ecode3)) {
+       SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "SpatialReference_ExportToPrettyWkt" "', argument " "3"" of type '" "int""'");
+     } 
+     arg3 = static_cast< int >(val3);
+   }
+   result = (OGRErr)OSRSpatialReferenceShadow_ExportToPrettyWkt(arg1,arg2,arg3);
+   {
+     /* %typemap(out) OGRErr */
+     if (result != 0) {
+       Tcl_SetResult(interp, (char*) OGRErrMessages(result), TCL_STATIC);
+       SWIG_fail;
+     }
+   }
+   {
+     /* %typemap(argout) (char **argout) */
+     Tcl_Obj *o;
+     if ( arg2 ) {
+       o = Tcl_NewStringObj( *arg2, -1 );
+     } else {
+       o = Tcl_NewObj();
+     }
+     Tcl_ListObjAppendElement(interp,Tcl_GetObjResult(interp),o);
+   }
+   {
+     /* %typemap(ret) OGRErr */
+     if (!strcmp(Tcl_GetStringResult(interp), "{}") || !strcmp(Tcl_GetStringResult(interp), "")) {
+       Tcl_SetObjResult(interp, Tcl_NewLongObj( result ));
+     }
+   }
+   return TCL_OK;
+ fail:
+   return TCL_ERROR;
+ }
+ 
+ 
+ SWIGINTERN int
+ _wrap_SpatialReference_ExportToProj4(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
+   OSRSpatialReferenceShadow *arg1 = (OSRSpatialReferenceShadow *) 0 ;
+   char **arg2 = (char **) 0 ;
+   void *argp1 = 0 ;
+   int res1 = 0 ;
+   char *argout2 = 0 ;
+   OGRErr result;
+   
+   {
+     /* %typemap(in,numinputs=0) (char **argout2) */
+     arg2 = &argout2;
+   }
+   if (SWIG_GetArgs(interp, objc, objv,"o:osgeo::SpatialReference_ExportToProj4 self ",(void *)0) == TCL_ERROR) SWIG_fail;
+   res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_OSRSpatialReferenceShadow, 0 |  0 );
+   if (!SWIG_IsOK(res1)) {
+     SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SpatialReference_ExportToProj4" "', argument " "1"" of type '" "OSRSpatialReferenceShadow *""'"); 
+   }
+   arg1 = reinterpret_cast< OSRSpatialReferenceShadow * >(argp1);
+   result = (OGRErr)OSRSpatialReferenceShadow_ExportToProj4(arg1,arg2);
+   {
+     /* %typemap(out) OGRErr */
+     if (result != 0) {
+       Tcl_SetResult(interp, (char*) OGRErrMessages(result), TCL_STATIC);
+       SWIG_fail;
+     }
+   }
+   {
+     /* %typemap(argout) (char **argout) */
+     Tcl_Obj *o;
+     if ( arg2 ) {
+       o = Tcl_NewStringObj( *arg2, -1 );
+     } else {
+       o = Tcl_NewObj();
+     }
+     Tcl_ListObjAppendElement(interp,Tcl_GetObjResult(interp),o);
+   }
+   {
+     /* %typemap(ret) OGRErr */
+     if (!strcmp(Tcl_GetStringResult(interp), "{}") || !strcmp(Tcl_GetStringResult(interp), "")) {
+       Tcl_SetObjResult(interp, Tcl_NewLongObj( result ));
+     }
+   }
+   return TCL_OK;
+ fail:
+   return TCL_ERROR;
+ }
+ 
+ 
+ SWIGINTERN int
+ _wrap_SpatialReference_ExportToPCI(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
+   OSRSpatialReferenceShadow *arg1 = (OSRSpatialReferenceShadow *) 0 ;
+   char **arg2 = (char **) 0 ;
+   char **arg3 = (char **) 0 ;
+   double **arg4 ;
+   void *argp1 = 0 ;
+   int res1 = 0 ;
+   char *argout2 = 0 ;
+   char *argout3 = 0 ;
+   double *argout4 ;
+   OGRErr result;
+   
+   {
+     /* %typemap(in,numinputs=0) (char **argout2) */
+     arg2 = &argout2;
+   }
+   {
+     /* %typemap(in,numinputs=0) (char **argout3) */
+     arg3 = &argout3;
+   }
+   {
+     /* %typemap(in,numinputs=0) (double *argout4[ANY]) */
+     arg4 = &argout4;
+   }
+   if (SWIG_GetArgs(interp, objc, objv,"o:osgeo::SpatialReference_ExportToPCI self ",(void *)0) == TCL_ERROR) SWIG_fail;
+   res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_OSRSpatialReferenceShadow, 0 |  0 );
+   if (!SWIG_IsOK(res1)) {
+     SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SpatialReference_ExportToPCI" "', argument " "1"" of type '" "OSRSpatialReferenceShadow *""'"); 
+   }
+   arg1 = reinterpret_cast< OSRSpatialReferenceShadow * >(argp1);
+   result = (OGRErr)OSRSpatialReferenceShadow_ExportToPCI(arg1,arg2,arg3,arg4);
+   {
+     /* %typemap(out) OGRErr */
+     if (result != 0) {
+       Tcl_SetResult(interp, (char*) OGRErrMessages(result), TCL_STATIC);
+       SWIG_fail;
+     }
+   }
+   {
+     /* %typemap(argout) (char **argout) */
+     Tcl_Obj *o;
+     if ( arg2 ) {
+       o = Tcl_NewStringObj( *arg2, -1 );
+     } else {
+       o = Tcl_NewObj();
+     }
+     Tcl_ListObjAppendElement(interp,Tcl_GetObjResult(interp),o);
+   }
+   {
+     /* %typemap(argout) (char **argout) */
+     Tcl_Obj *o;
+     if ( arg3 ) {
+       o = Tcl_NewStringObj( *arg3, -1 );
+     } else {
+       o = Tcl_NewObj();
+     }
+     Tcl_ListObjAppendElement(interp,Tcl_GetObjResult(interp),o);
+   }
+   {
+     /* %typemap(argout) (double *argout[ANY]) */
+     Tcl_Obj *out = CreateListFromDoubleArray( interp, *arg4, 17 );
+     if (out == NULL) SWIG_fail;
+     Tcl_ListObjAppendElement(interp,Tcl_GetObjResult(interp),out);
+   }
+   {
+     /* %typemap(ret) OGRErr */
+     if (!strcmp(Tcl_GetStringResult(interp), "{}") || !strcmp(Tcl_GetStringResult(interp), "")) {
+       Tcl_SetObjResult(interp, Tcl_NewLongObj( result ));
+     }
+   }
+   return TCL_OK;
+ fail:
+   return TCL_ERROR;
+ }
+ 
+ 
+ SWIGINTERN int
+ _wrap_SpatialReference_ExportToUSGS(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
+   OSRSpatialReferenceShadow *arg1 = (OSRSpatialReferenceShadow *) 0 ;
+   long *arg2 = (long *) 0 ;
+   long *arg3 = (long *) 0 ;
+   double **arg4 ;
+   long *arg5 = (long *) 0 ;
+   void *argp1 = 0 ;
+   int res1 = 0 ;
+   long temp2 ;
+   int res2 = SWIG_TMPOBJ ;
+   long temp3 ;
+   int res3 = SWIG_TMPOBJ ;
+   double *argout4 ;
+   long temp5 ;
+   int res5 = SWIG_TMPOBJ ;
+   OGRErr result;
+   
+   arg2 = &temp2;
+   arg3 = &temp3;
+   {
+     /* %typemap(in,numinputs=0) (double *argout4[ANY]) */
+     arg4 = &argout4;
+   }
+   arg5 = &temp5;
+   if (SWIG_GetArgs(interp, objc, objv,"o:osgeo::SpatialReference_ExportToUSGS self ",(void *)0) == TCL_ERROR) SWIG_fail;
+   res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_OSRSpatialReferenceShadow, 0 |  0 );
+   if (!SWIG_IsOK(res1)) {
+     SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SpatialReference_ExportToUSGS" "', argument " "1"" of type '" "OSRSpatialReferenceShadow *""'"); 
+   }
+   arg1 = reinterpret_cast< OSRSpatialReferenceShadow * >(argp1);
+   result = (OGRErr)OSRSpatialReferenceShadow_ExportToUSGS(arg1,arg2,arg3,arg4,arg5);
+   {
+     /* %typemap(out) OGRErr */
+     if (result != 0) {
+       Tcl_SetResult(interp, (char*) OGRErrMessages(result), TCL_STATIC);
+       SWIG_fail;
+     }
+   }
+   if (SWIG_IsTmpObj(res2)) {
+     Tcl_ListObjAppendElement(interp,Tcl_GetObjResult(interp),SWIG_From_long((*arg2)));
+   } else {
+     int new_flags = SWIG_IsNewObj(res2) ? (SWIG_POINTER_OWN |  0 ) :  0 ;
+     Tcl_ListObjAppendElement(interp,Tcl_GetObjResult(interp),SWIG_NewPointerObj((void*)(arg2), SWIGTYPE_p_long, new_flags));
+   }
+   if (SWIG_IsTmpObj(res3)) {
+     Tcl_ListObjAppendElement(interp,Tcl_GetObjResult(interp),SWIG_From_long((*arg3)));
+   } else {
+     int new_flags = SWIG_IsNewObj(res3) ? (SWIG_POINTER_OWN |  0 ) :  0 ;
+     Tcl_ListObjAppendElement(interp,Tcl_GetObjResult(interp),SWIG_NewPointerObj((void*)(arg3), SWIGTYPE_p_long, new_flags));
+   }
+   {
+     /* %typemap(argout) (double *argout[ANY]) */
+     Tcl_Obj *out = CreateListFromDoubleArray( interp, *arg4, 15 );
+     if (out == NULL) SWIG_fail;
+     Tcl_ListObjAppendElement(interp,Tcl_GetObjResult(interp),out);
+   }
+   if (SWIG_IsTmpObj(res5)) {
+     Tcl_ListObjAppendElement(interp,Tcl_GetObjResult(interp),SWIG_From_long((*arg5)));
+   } else {
+     int new_flags = SWIG_IsNewObj(res5) ? (SWIG_POINTER_OWN |  0 ) :  0 ;
+     Tcl_ListObjAppendElement(interp,Tcl_GetObjResult(interp),SWIG_NewPointerObj((void*)(arg5), SWIGTYPE_p_long, new_flags));
+   }
+   {
+     /* %typemap(ret) OGRErr */
+     if (!strcmp(Tcl_GetStringResult(interp), "{}") || !strcmp(Tcl_GetStringResult(interp), "")) {
+       Tcl_SetObjResult(interp, Tcl_NewLongObj( result ));
+     }
+   }
+   return TCL_OK;
+ fail:
+   return TCL_ERROR;
+ }
+ 
+ 
+ SWIGINTERN int
+ _wrap_SpatialReference_ExportToXML(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
+   OSRSpatialReferenceShadow *arg1 = (OSRSpatialReferenceShadow *) 0 ;
+   char **arg2 = (char **) 0 ;
+   char *arg3 = (char *) "" ;
+   void *argp1 = 0 ;
+   int res1 = 0 ;
+   char *argout2 = 0 ;
+   int res3 ;
+   char *buf3 = 0 ;
+   int alloc3 = 0 ;
+   OGRErr result;
+   
+   {
+     /* %typemap(in,numinputs=0) (char **argout2) */
+     arg2 = &argout2;
+   }
+   if (SWIG_GetArgs(interp, objc, objv,"o|o:osgeo::SpatialReference_ExportToXML self ?dialect? ",(void *)0,(void *)0) == TCL_ERROR) SWIG_fail;
+   res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_OSRSpatialReferenceShadow, 0 |  0 );
+   if (!SWIG_IsOK(res1)) {
+     SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SpatialReference_ExportToXML" "', argument " "1"" of type '" "OSRSpatialReferenceShadow *""'"); 
+   }
+   arg1 = reinterpret_cast< OSRSpatialReferenceShadow * >(argp1);
+   if (objc > 2) {
+     res3 = SWIG_AsCharPtrAndSize(objv[2], &buf3, NULL, &alloc3);
+     if (!SWIG_IsOK(res3)) {
+       SWIG_exception_fail(SWIG_ArgError(res3), "in method '" "SpatialReference_ExportToXML" "', argument " "3"" of type '" "char const *""'");
+     }
+     arg3 = reinterpret_cast< char * >(buf3);
+   }
+   result = (OGRErr)OSRSpatialReferenceShadow_ExportToXML(arg1,arg2,(char const *)arg3);
+   {
+     /* %typemap(out) OGRErr */
+     if (result != 0) {
+       Tcl_SetResult(interp, (char*) OGRErrMessages(result), TCL_STATIC);
+       SWIG_fail;
+     }
+   }
+   {
+     /* %typemap(argout) (char **argout) */
+     Tcl_Obj *o;
+     if ( arg2 ) {
+       o = Tcl_NewStringObj( *arg2, -1 );
+     } else {
+       o = Tcl_NewObj();
+     }
+     Tcl_ListObjAppendElement(interp,Tcl_GetObjResult(interp),o);
+   }
+   if (alloc3 == SWIG_NEWOBJ) delete[] buf3;
+   {
+     /* %typemap(ret) OGRErr */
+     if (!strcmp(Tcl_GetStringResult(interp), "{}") || !strcmp(Tcl_GetStringResult(interp), "")) {
+       Tcl_SetObjResult(interp, Tcl_NewLongObj( result ));
+     }
+   }
+   return TCL_OK;
+ fail:
+   if (alloc3 == SWIG_NEWOBJ) delete[] buf3;
+   return TCL_ERROR;
+ }
+ 
+ 
+ SWIGINTERN int
+ _wrap_SpatialReference_ExportToMICoordSys(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
+   OSRSpatialReferenceShadow *arg1 = (OSRSpatialReferenceShadow *) 0 ;
+   char **arg2 = (char **) 0 ;
+   void *argp1 = 0 ;
+   int res1 = 0 ;
+   char *argout2 = 0 ;
+   OGRErr result;
+   
+   {
+     /* %typemap(in,numinputs=0) (char **argout2) */
+     arg2 = &argout2;
+   }
+   if (SWIG_GetArgs(interp, objc, objv,"o:osgeo::SpatialReference_ExportToMICoordSys self ",(void *)0) == TCL_ERROR) SWIG_fail;
+   res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_OSRSpatialReferenceShadow, 0 |  0 );
+   if (!SWIG_IsOK(res1)) {
+     SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SpatialReference_ExportToMICoordSys" "', argument " "1"" of type '" "OSRSpatialReferenceShadow *""'"); 
+   }
+   arg1 = reinterpret_cast< OSRSpatialReferenceShadow * >(argp1);
+   result = (OGRErr)OSRSpatialReferenceShadow_ExportToMICoordSys(arg1,arg2);
+   {
+     /* %typemap(out) OGRErr */
+     if (result != 0) {
+       Tcl_SetResult(interp, (char*) OGRErrMessages(result), TCL_STATIC);
+       SWIG_fail;
+     }
+   }
+   {
+     /* %typemap(argout) (char **argout) */
+     Tcl_Obj *o;
+     if ( arg2 ) {
+       o = Tcl_NewStringObj( *arg2, -1 );
+     } else {
+       o = Tcl_NewObj();
+     }
+     Tcl_ListObjAppendElement(interp,Tcl_GetObjResult(interp),o);
+   }
+   {
+     /* %typemap(ret) OGRErr */
+     if (!strcmp(Tcl_GetStringResult(interp), "{}") || !strcmp(Tcl_GetStringResult(interp), "")) {
+       Tcl_SetObjResult(interp, Tcl_NewLongObj( result ));
+     }
+   }
+   return TCL_OK;
+ fail:
+   return TCL_ERROR;
+ }
+ 
+ 
+ SWIGINTERN int
+ _wrap_SpatialReference_CloneGeogCS(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
+   OSRSpatialReferenceShadow *arg1 = (OSRSpatialReferenceShadow *) 0 ;
+   void *argp1 = 0 ;
+   int res1 = 0 ;
+   OSRSpatialReferenceShadow *result = 0 ;
+   
+   if (SWIG_GetArgs(interp, objc, objv,"o:osgeo::SpatialReference_CloneGeogCS self ",(void *)0) == TCL_ERROR) SWIG_fail;
+   res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_OSRSpatialReferenceShadow, 0 |  0 );
+   if (!SWIG_IsOK(res1)) {
+     SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SpatialReference_CloneGeogCS" "', argument " "1"" of type '" "OSRSpatialReferenceShadow *""'"); 
+   }
+   arg1 = reinterpret_cast< OSRSpatialReferenceShadow * >(argp1);
+   result = (OSRSpatialReferenceShadow *)OSRSpatialReferenceShadow_CloneGeogCS(arg1);
+   Tcl_SetObjResult(interp, SWIG_NewInstanceObj( SWIG_as_voidptr(result), SWIGTYPE_p_OSRSpatialReferenceShadow,0));
+   return TCL_OK;
+ fail:
+   return TCL_ERROR;
+ }
+ 
+ 
+ SWIGINTERN int
+ _wrap_SpatialReference_Validate(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
+   OSRSpatialReferenceShadow *arg1 = (OSRSpatialReferenceShadow *) 0 ;
+   void *argp1 = 0 ;
+   int res1 = 0 ;
+   OGRErr result;
+   
+   if (SWIG_GetArgs(interp, objc, objv,"o:osgeo::SpatialReference_Validate self ",(void *)0) == TCL_ERROR) SWIG_fail;
+   res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_OSRSpatialReferenceShadow, 0 |  0 );
+   if (!SWIG_IsOK(res1)) {
+     SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SpatialReference_Validate" "', argument " "1"" of type '" "OSRSpatialReferenceShadow *""'"); 
+   }
+   arg1 = reinterpret_cast< OSRSpatialReferenceShadow * >(argp1);
+   result = (OGRErr)OSRSpatialReferenceShadow_Validate(arg1);
+   {
+     /* %typemap(out) OGRErr */
+     if (result != 0) {
+       Tcl_SetResult(interp, (char*) OGRErrMessages(result), TCL_STATIC);
+       SWIG_fail;
+     }
+   }
+   {
+     /* %typemap(ret) OGRErr */
+     if (!strcmp(Tcl_GetStringResult(interp), "{}") || !strcmp(Tcl_GetStringResult(interp), "")) {
+       Tcl_SetObjResult(interp, Tcl_NewLongObj( result ));
+     }
+   }
+   return TCL_OK;
+ fail:
+   return TCL_ERROR;
+ }
+ 
+ 
+ SWIGINTERN int
+ _wrap_SpatialReference_StripCTParms(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
+   OSRSpatialReferenceShadow *arg1 = (OSRSpatialReferenceShadow *) 0 ;
+   void *argp1 = 0 ;
+   int res1 = 0 ;
+   OGRErr result;
+   
+   if (SWIG_GetArgs(interp, objc, objv,"o:osgeo::SpatialReference_StripCTParms self ",(void *)0) == TCL_ERROR) SWIG_fail;
+   res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_OSRSpatialReferenceShadow, 0 |  0 );
+   if (!SWIG_IsOK(res1)) {
+     SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SpatialReference_StripCTParms" "', argument " "1"" of type '" "OSRSpatialReferenceShadow *""'"); 
+   }
+   arg1 = reinterpret_cast< OSRSpatialReferenceShadow * >(argp1);
+   result = (OGRErr)OSRSpatialReferenceShadow_StripCTParms(arg1);
+   {
+     /* %typemap(out) OGRErr */
+     if (result != 0) {
+       Tcl_SetResult(interp, (char*) OGRErrMessages(result), TCL_STATIC);
+       SWIG_fail;
+     }
+   }
+   {
+     /* %typemap(ret) OGRErr */
+     if (!strcmp(Tcl_GetStringResult(interp), "{}") || !strcmp(Tcl_GetStringResult(interp), "")) {
+       Tcl_SetObjResult(interp, Tcl_NewLongObj( result ));
+     }
+   }
+   return TCL_OK;
+ fail:
+   return TCL_ERROR;
+ }
+ 
+ 
+ SWIGINTERN int
+ _wrap_SpatialReference_FixupOrdering(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
+   OSRSpatialReferenceShadow *arg1 = (OSRSpatialReferenceShadow *) 0 ;
+   void *argp1 = 0 ;
+   int res1 = 0 ;
+   OGRErr result;
+   
+   if (SWIG_GetArgs(interp, objc, objv,"o:osgeo::SpatialReference_FixupOrdering self ",(void *)0) == TCL_ERROR) SWIG_fail;
+   res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_OSRSpatialReferenceShadow, 0 |  0 );
+   if (!SWIG_IsOK(res1)) {
+     SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SpatialReference_FixupOrdering" "', argument " "1"" of type '" "OSRSpatialReferenceShadow *""'"); 
+   }
+   arg1 = reinterpret_cast< OSRSpatialReferenceShadow * >(argp1);
+   result = (OGRErr)OSRSpatialReferenceShadow_FixupOrdering(arg1);
+   {
+     /* %typemap(out) OGRErr */
+     if (result != 0) {
+       Tcl_SetResult(interp, (char*) OGRErrMessages(result), TCL_STATIC);
+       SWIG_fail;
+     }
+   }
+   {
+     /* %typemap(ret) OGRErr */
+     if (!strcmp(Tcl_GetStringResult(interp), "{}") || !strcmp(Tcl_GetStringResult(interp), "")) {
+       Tcl_SetObjResult(interp, Tcl_NewLongObj( result ));
+     }
+   }
+   return TCL_OK;
+ fail:
+   return TCL_ERROR;
+ }
+ 
+ 
+ SWIGINTERN int
+ _wrap_SpatialReference_Fixup(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
+   OSRSpatialReferenceShadow *arg1 = (OSRSpatialReferenceShadow *) 0 ;
+   void *argp1 = 0 ;
+   int res1 = 0 ;
+   OGRErr result;
+   
+   if (SWIG_GetArgs(interp, objc, objv,"o:osgeo::SpatialReference_Fixup self ",(void *)0) == TCL_ERROR) SWIG_fail;
+   res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_OSRSpatialReferenceShadow, 0 |  0 );
+   if (!SWIG_IsOK(res1)) {
+     SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SpatialReference_Fixup" "', argument " "1"" of type '" "OSRSpatialReferenceShadow *""'"); 
+   }
+   arg1 = reinterpret_cast< OSRSpatialReferenceShadow * >(argp1);
+   result = (OGRErr)OSRSpatialReferenceShadow_Fixup(arg1);
+   {
+     /* %typemap(out) OGRErr */
+     if (result != 0) {
+       Tcl_SetResult(interp, (char*) OGRErrMessages(result), TCL_STATIC);
+       SWIG_fail;
+     }
+   }
+   {
+     /* %typemap(ret) OGRErr */
+     if (!strcmp(Tcl_GetStringResult(interp), "{}") || !strcmp(Tcl_GetStringResult(interp), "")) {
+       Tcl_SetObjResult(interp, Tcl_NewLongObj( result ));
+     }
+   }
+   return TCL_OK;
+ fail:
+   return TCL_ERROR;
+ }
+ 
+ 
+ SWIGINTERN int
+ _wrap_SpatialReference_MorphToESRI(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
+   OSRSpatialReferenceShadow *arg1 = (OSRSpatialReferenceShadow *) 0 ;
+   void *argp1 = 0 ;
+   int res1 = 0 ;
+   OGRErr result;
+   
+   if (SWIG_GetArgs(interp, objc, objv,"o:osgeo::SpatialReference_MorphToESRI self ",(void *)0) == TCL_ERROR) SWIG_fail;
+   res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_OSRSpatialReferenceShadow, 0 |  0 );
+   if (!SWIG_IsOK(res1)) {
+     SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SpatialReference_MorphToESRI" "', argument " "1"" of type '" "OSRSpatialReferenceShadow *""'"); 
+   }
+   arg1 = reinterpret_cast< OSRSpatialReferenceShadow * >(argp1);
+   result = (OGRErr)OSRSpatialReferenceShadow_MorphToESRI(arg1);
+   {
+     /* %typemap(out) OGRErr */
+     if (result != 0) {
+       Tcl_SetResult(interp, (char*) OGRErrMessages(result), TCL_STATIC);
+       SWIG_fail;
+     }
+   }
+   {
+     /* %typemap(ret) OGRErr */
+     if (!strcmp(Tcl_GetStringResult(interp), "{}") || !strcmp(Tcl_GetStringResult(interp), "")) {
+       Tcl_SetObjResult(interp, Tcl_NewLongObj( result ));
+     }
+   }
+   return TCL_OK;
+ fail:
+   return TCL_ERROR;
+ }
+ 
+ 
+ SWIGINTERN int
+ _wrap_SpatialReference_MorphFromESRI(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
+   OSRSpatialReferenceShadow *arg1 = (OSRSpatialReferenceShadow *) 0 ;
+   void *argp1 = 0 ;
+   int res1 = 0 ;
+   OGRErr result;
+   
+   if (SWIG_GetArgs(interp, objc, objv,"o:osgeo::SpatialReference_MorphFromESRI self ",(void *)0) == TCL_ERROR) SWIG_fail;
+   res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_OSRSpatialReferenceShadow, 0 |  0 );
+   if (!SWIG_IsOK(res1)) {
+     SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SpatialReference_MorphFromESRI" "', argument " "1"" of type '" "OSRSpatialReferenceShadow *""'"); 
+   }
+   arg1 = reinterpret_cast< OSRSpatialReferenceShadow * >(argp1);
+   result = (OGRErr)OSRSpatialReferenceShadow_MorphFromESRI(arg1);
+   {
+     /* %typemap(out) OGRErr */
+     if (result != 0) {
+       Tcl_SetResult(interp, (char*) OGRErrMessages(result), TCL_STATIC);
+       SWIG_fail;
+     }
+   }
+   {
+     /* %typemap(ret) OGRErr */
+     if (!strcmp(Tcl_GetStringResult(interp), "{}") || !strcmp(Tcl_GetStringResult(interp), "")) {
+       Tcl_SetObjResult(interp, Tcl_NewLongObj( result ));
+     }
+   }
+   return TCL_OK;
+ fail:
+   return TCL_ERROR;
+ }
+ 
+ 
+ SWIGINTERN void swig_delete_SpatialReference(void *obj) {
+ OSRSpatialReferenceShadow *arg1 = (OSRSpatialReferenceShadow *) obj;
+ delete_OSRSpatialReferenceShadow(arg1);
+ }
+ static swig_method swig_OSRSpatialReferenceShadow_methods[] = {
+     {"__str__", _wrap_SpatialReference___str__}, 
+     {"IsSame", _wrap_SpatialReference_IsSame}, 
+     {"IsSameGeogCS", _wrap_SpatialReference_IsSameGeogCS}, 
+     {"IsGeographic", _wrap_SpatialReference_IsGeographic}, 
+     {"IsProjected", _wrap_SpatialReference_IsProjected}, 
+     {"IsLocal", _wrap_SpatialReference_IsLocal}, 
+     {"SetAuthority", _wrap_SpatialReference_SetAuthority}, 
+     {"GetAttrValue", _wrap_SpatialReference_GetAttrValue}, 
+     {"SetAttrValue", _wrap_SpatialReference_SetAttrValue}, 
+     {"SetAngularUnits", _wrap_SpatialReference_SetAngularUnits}, 
+     {"GetAngularUnits", _wrap_SpatialReference_GetAngularUnits}, 
+     {"SetLinearUnits", _wrap_SpatialReference_SetLinearUnits}, 
+     {"SetLinearUnitsAndUpdateParameters", _wrap_SpatialReference_SetLinearUnitsAndUpdateParameters}, 
+     {"GetLinearUnits", _wrap_SpatialReference_GetLinearUnits}, 
+     {"GetLinearUnitsName", _wrap_SpatialReference_GetLinearUnitsName}, 
+     {"GetAuthorityCode", _wrap_SpatialReference_GetAuthorityCode}, 
+     {"GetAuthorityName", _wrap_SpatialReference_GetAuthorityName}, 
+     {"SetUTM", _wrap_SpatialReference_SetUTM}, 
+     {"SetStatePlane", _wrap_SpatialReference_SetStatePlane}, 
+     {"AutoIdentifyEPSG", _wrap_SpatialReference_AutoIdentifyEPSG}, 
+     {"SetProjection", _wrap_SpatialReference_SetProjection}, 
+     {"SetProjParm", _wrap_SpatialReference_SetProjParm}, 
+     {"GetProjParm", _wrap_SpatialReference_GetProjParm}, 
+     {"SetNormProjParm", _wrap_SpatialReference_SetNormProjParm}, 
+     {"GetNormProjParm", _wrap_SpatialReference_GetNormProjParm}, 
+     {"SetACEA", _wrap_SpatialReference_SetACEA}, 
+     {"SetAE", _wrap_SpatialReference_SetAE}, 
+     {"SetBonne", _wrap_SpatialReference_SetBonne}, 
+     {"SetCEA", _wrap_SpatialReference_SetCEA}, 
+     {"SetCS", _wrap_SpatialReference_SetCS}, 
+     {"SetEC", _wrap_SpatialReference_SetEC}, 
+     {"SetEckertIV", _wrap_SpatialReference_SetEckertIV}, 
+     {"SetEckertVI", _wrap_SpatialReference_SetEckertVI}, 
+     {"SetEquirectangular", _wrap_SpatialReference_SetEquirectangular}, 
+     {"SetEquirectangular2", _wrap_SpatialReference_SetEquirectangular2}, 
+     {"SetGaussSchreiberTMercator", _wrap_SpatialReference_SetGaussSchreiberTMercator}, 
+     {"SetGS", _wrap_SpatialReference_SetGS}, 
+     {"SetGH", _wrap_SpatialReference_SetGH}, 
+     {"SetGEOS", _wrap_SpatialReference_SetGEOS}, 
+     {"SetGnomonic", _wrap_SpatialReference_SetGnomonic}, 
+     {"SetHOM", _wrap_SpatialReference_SetHOM}, 
+     {"SetHOM2PNO", _wrap_SpatialReference_SetHOM2PNO}, 
+     {"SetKrovak", _wrap_SpatialReference_SetKrovak}, 
+     {"SetLAEA", _wrap_SpatialReference_SetLAEA}, 
+     {"SetLCC", _wrap_SpatialReference_SetLCC}, 
+     {"SetLCC1SP", _wrap_SpatialReference_SetLCC1SP}, 
+     {"SetLCCB", _wrap_SpatialReference_SetLCCB}, 
+     {"SetMC", _wrap_SpatialReference_SetMC}, 
+     {"SetMercator", _wrap_SpatialReference_SetMercator}, 
+     {"SetMollweide", _wrap_SpatialReference_SetMollweide}, 
+     {"SetNZMG", _wrap_SpatialReference_SetNZMG}, 
+     {"SetOS", _wrap_SpatialReference_SetOS}, 
+     {"SetOrthographic", _wrap_SpatialReference_SetOrthographic}, 
+     {"SetPolyconic", _wrap_SpatialReference_SetPolyconic}, 
+     {"SetPS", _wrap_SpatialReference_SetPS}, 
+     {"SetRobinson", _wrap_SpatialReference_SetRobinson}, 
+     {"SetSinusoidal", _wrap_SpatialReference_SetSinusoidal}, 
+     {"SetStereographic", _wrap_SpatialReference_SetStereographic}, 
+     {"SetSOC", _wrap_SpatialReference_SetSOC}, 
+     {"SetTM", _wrap_SpatialReference_SetTM}, 
+     {"SetTMVariant", _wrap_SpatialReference_SetTMVariant}, 
+     {"SetTMG", _wrap_SpatialReference_SetTMG}, 
+     {"SetTMSO", _wrap_SpatialReference_SetTMSO}, 
+     {"SetVDG", _wrap_SpatialReference_SetVDG}, 
+     {"SetWellKnownGeogCS", _wrap_SpatialReference_SetWellKnownGeogCS}, 
+     {"SetFromUserInput", _wrap_SpatialReference_SetFromUserInput}, 
+     {"CopyGeogCSFrom", _wrap_SpatialReference_CopyGeogCSFrom}, 
+     {"SetTOWGS84", _wrap_SpatialReference_SetTOWGS84}, 
+     {"GetTOWGS84", _wrap_SpatialReference_GetTOWGS84}, 
+     {"SetLocalCS", _wrap_SpatialReference_SetLocalCS}, 
+     {"SetGeogCS", _wrap_SpatialReference_SetGeogCS}, 
+     {"SetProjCS", _wrap_SpatialReference_SetProjCS}, 
+     {"ImportFromWkt", _wrap_SpatialReference_ImportFromWkt}, 
+     {"ImportFromProj4", _wrap_SpatialReference_ImportFromProj4}, 
+     {"ImportFromUrl", _wrap_SpatialReference_ImportFromUrl}, 
+     {"ImportFromESRI", _wrap_SpatialReference_ImportFromESRI}, 
+     {"ImportFromEPSG", _wrap_SpatialReference_ImportFromEPSG}, 
+     {"ImportFromPCI", _wrap_SpatialReference_ImportFromPCI}, 
+     {"ImportFromUSGS", _wrap_SpatialReference_ImportFromUSGS}, 
+     {"ImportFromXML", _wrap_SpatialReference_ImportFromXML}, 
+     {"ImportFromMICoordSys", _wrap_SpatialReference_ImportFromMICoordSys}, 
+     {"ExportToWkt", _wrap_SpatialReference_ExportToWkt}, 
+     {"ExportToPrettyWkt", _wrap_SpatialReference_ExportToPrettyWkt}, 
+     {"ExportToProj4", _wrap_SpatialReference_ExportToProj4}, 
+     {"ExportToPCI", _wrap_SpatialReference_ExportToPCI}, 
+     {"ExportToUSGS", _wrap_SpatialReference_ExportToUSGS}, 
+     {"ExportToXML", _wrap_SpatialReference_ExportToXML}, 
+     {"ExportToMICoordSys", _wrap_SpatialReference_ExportToMICoordSys}, 
+     {"CloneGeogCS", _wrap_SpatialReference_CloneGeogCS}, 
+     {"Validate", _wrap_SpatialReference_Validate}, 
+     {"StripCTParms", _wrap_SpatialReference_StripCTParms}, 
+     {"FixupOrdering", _wrap_SpatialReference_FixupOrdering}, 
+     {"Fixup", _wrap_SpatialReference_Fixup}, 
+     {"MorphToESRI", _wrap_SpatialReference_MorphToESRI}, 
+     {"MorphFromESRI", _wrap_SpatialReference_MorphFromESRI}, 
+     {0,0}
+ };
+ static swig_attribute swig_OSRSpatialReferenceShadow_attributes[] = {
+     {0,0,0}
+ };
+ static swig_class *swig_OSRSpatialReferenceShadow_bases[] = {0};
+ static const char * swig_OSRSpatialReferenceShadow_base_names[] = {0};
+ static swig_class _wrap_class_OSRSpatialReferenceShadow = { "SpatialReference", &SWIGTYPE_p_OSRSpatialReferenceShadow,_wrap_new_SpatialReference, swig_delete_SpatialReference, swig_OSRSpatialReferenceShadow_methods, swig_OSRSpatialReferenceShadow_attributes, swig_OSRSpatialReferenceShadow_bases,swig_OSRSpatialReferenceShadow_base_names, &swig_module };
+ SWIGINTERN int
+ _wrap_new_CoordinateTransformation(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
+   OSRSpatialReferenceShadow *arg1 = (OSRSpatialReferenceShadow *) 0 ;
+   OSRSpatialReferenceShadow *arg2 = (OSRSpatialReferenceShadow *) 0 ;
+   void *argp1 = 0 ;
+   int res1 = 0 ;
+   void *argp2 = 0 ;
+   int res2 = 0 ;
+   OSRCoordinateTransformationShadow *result = 0 ;
+   
+   if (SWIG_GetArgs(interp, objc, objv,"oo:osgeo::new_CoordinateTransformation src dst ",(void *)0,(void *)0) == TCL_ERROR) SWIG_fail;
+   res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_OSRSpatialReferenceShadow, 0 |  0 );
+   if (!SWIG_IsOK(res1)) {
+     SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "new_CoordinateTransformation" "', argument " "1"" of type '" "OSRSpatialReferenceShadow *""'"); 
+   }
+   arg1 = reinterpret_cast< OSRSpatialReferenceShadow * >(argp1);
+   res2 = SWIG_ConvertPtr(objv[2], &argp2,SWIGTYPE_p_OSRSpatialReferenceShadow, 0 |  0 );
+   if (!SWIG_IsOK(res2)) {
+     SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "new_CoordinateTransformation" "', argument " "2"" of type '" "OSRSpatialReferenceShadow *""'"); 
+   }
+   arg2 = reinterpret_cast< OSRSpatialReferenceShadow * >(argp2);
+   result = (OSRCoordinateTransformationShadow *)new_OSRCoordinateTransformationShadow(arg1,arg2);
+   Tcl_SetObjResult(interp, SWIG_NewInstanceObj( SWIG_as_voidptr(result), SWIGTYPE_p_OSRCoordinateTransformationShadow,0));
+   return TCL_OK;
+ fail:
+   return TCL_ERROR;
+ }
+ 
+ 
+ SWIGINTERN int
+ _wrap_delete_CoordinateTransformation(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
+   OSRCoordinateTransformationShadow *arg1 = (OSRCoordinateTransformationShadow *) 0 ;
+   void *argp1 = 0 ;
+   int res1 = 0 ;
+   
+   if (SWIG_GetArgs(interp, objc, objv,"o:osgeo::delete_CoordinateTransformation self ",(void *)0) == TCL_ERROR) SWIG_fail;
+   res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_OSRCoordinateTransformationShadow, SWIG_POINTER_DISOWN |  0 );
+   if (!SWIG_IsOK(res1)) {
+     SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "delete_CoordinateTransformation" "', argument " "1"" of type '" "OSRCoordinateTransformationShadow *""'"); 
+   }
+   arg1 = reinterpret_cast< OSRCoordinateTransformationShadow * >(argp1);
+   delete_OSRCoordinateTransformationShadow(arg1);
+   
+   return TCL_OK;
+ fail:
+   return TCL_ERROR;
+ }
+ 
+ 
+ SWIGINTERN int
+ _wrap_CoordinateTransformation_TransformPoint__SWIG_0(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
+   OSRCoordinateTransformationShadow *arg1 = (OSRCoordinateTransformationShadow *) 0 ;
+   double *arg2 ;
+   void *argp1 = 0 ;
+   int res1 = 0 ;
+   double argin2[3] ;
+   
+   if (SWIG_GetArgs(interp, objc, objv,"oo:osgeo::CoordinateTransformation_TransformPoint self inout ",(void *)0,(void *)0) == TCL_ERROR) SWIG_fail;
+   res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_OSRCoordinateTransformationShadow, 0 |  0 );
+   if (!SWIG_IsOK(res1)) {
+     SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CoordinateTransformation_TransformPoint" "', argument " "1"" of type '" "OSRCoordinateTransformationShadow *""'"); 
+   }
+   arg1 = reinterpret_cast< OSRCoordinateTransformationShadow * >(argp1);
+   {
+     /* %typemap(in) (double argin2[ANY]) */
+     arg2 = argin2;
+     int lst_size;
+     /* The following also checks if input is a list */
+     if (Tcl_ListObjLength(interp, objv[2], &lst_size) != TCL_OK) {
+       /* Error msg in interp result */
+       SWIG_fail;
+     }
+     if ( lst_size != 3 ) {
+       Tcl_SetResult(interp, (char*) "List must have length ##size", TCL_STATIC);
+       SWIG_fail;
+     }
+     for (unsigned int i=0; i<3; i++) {
+       Tcl_Obj **o = NULL;
+       if (Tcl_ListObjIndex(interp, objv[2], i, o) != TCL_OK) {
+         /* ref count is not incremented */
+         /* Error msg in interp result */
+         SWIG_fail;
+       }
+       
+       double val;
+       if (Tcl_GetDoubleFromObj(interp, *o, &val ) != TCL_OK) {
+         /* Error msg in interp result */
+         SWIG_fail;
+       }
+       arg2[i] = val;
+     }
+   }
+   OSRCoordinateTransformationShadow_TransformPoint__SWIG_0(arg1,arg2);
+   
+   {
+     /* %typemap(argout) (double argout[ANY]) */
+     Tcl_Obj *out = CreateListFromDoubleArray( interp, arg2, 3 );
+     if (out == NULL) SWIG_fail;
+     Tcl_ListObjAppendElement(interp,Tcl_GetObjResult(interp),out);
+   }
+   return TCL_OK;
+ fail:
+   return TCL_ERROR;
+ }
+ 
+ 
+ SWIGINTERN int
+ _wrap_CoordinateTransformation_TransformPoint__SWIG_1(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
+   OSRCoordinateTransformationShadow *arg1 = (OSRCoordinateTransformationShadow *) 0 ;
+   double *arg2 ;
+   double arg3 ;
+   double arg4 ;
+   double arg5 = (double) 0.0 ;
+   void *argp1 = 0 ;
+   int res1 = 0 ;
+   double argout2[3] ;
+   double val3 ;
+   int ecode3 = 0 ;
+   double val4 ;
+   int ecode4 = 0 ;
+   double val5 ;
+   int ecode5 = 0 ;
+   
+   {
+     /* %typemap(in,numinputs=0) (double argout2[ANY]) */
+     arg2 = argout2;
+   }
+   if (SWIG_GetArgs(interp, objc, objv,"ooo|o:osgeo::CoordinateTransformation_TransformPoint self x y ?z? ",(void *)0,(void *)0,(void *)0,(void *)0) == TCL_ERROR) SWIG_fail;
+   res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_OSRCoordinateTransformationShadow, 0 |  0 );
+   if (!SWIG_IsOK(res1)) {
+     SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CoordinateTransformation_TransformPoint" "', argument " "1"" of type '" "OSRCoordinateTransformationShadow *""'"); 
+   }
+   arg1 = reinterpret_cast< OSRCoordinateTransformationShadow * >(argp1);
+   ecode3 = SWIG_AsVal_double SWIG_TCL_CALL_ARGS_2(objv[2], &val3);
+   if (!SWIG_IsOK(ecode3)) {
+     SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "CoordinateTransformation_TransformPoint" "', argument " "3"" of type '" "double""'");
+   } 
+   arg3 = static_cast< double >(val3);
+   ecode4 = SWIG_AsVal_double SWIG_TCL_CALL_ARGS_2(objv[3], &val4);
+   if (!SWIG_IsOK(ecode4)) {
+     SWIG_exception_fail(SWIG_ArgError(ecode4), "in method '" "CoordinateTransformation_TransformPoint" "', argument " "4"" of type '" "double""'");
+   } 
+   arg4 = static_cast< double >(val4);
+   if (objc > 4) {
+     ecode5 = SWIG_AsVal_double SWIG_TCL_CALL_ARGS_2(objv[4], &val5);
+     if (!SWIG_IsOK(ecode5)) {
+       SWIG_exception_fail(SWIG_ArgError(ecode5), "in method '" "CoordinateTransformation_TransformPoint" "', argument " "5"" of type '" "double""'");
+     } 
+     arg5 = static_cast< double >(val5);
+   }
+   OSRCoordinateTransformationShadow_TransformPoint__SWIG_1(arg1,arg2,arg3,arg4,arg5);
+   
+   {
+     /* %typemap(argout) (double argout[ANY]) */
+     Tcl_Obj *out = CreateListFromDoubleArray( interp, arg2, 3 );
+     if (out == NULL) SWIG_fail;
+     Tcl_ListObjAppendElement(interp,Tcl_GetObjResult(interp),out);
+   }
+   return TCL_OK;
+ fail:
+   return TCL_ERROR;
+ }
+ 
+ 
+ SWIGINTERN int
+ _wrap_CoordinateTransformation_TransformPoint(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
+   Tcl_Obj *CONST *argv = objv+1;
+   int argc = objc-1;
+   if (argc == 2) {
+     int _v;
+     void *vptr = 0;
+     int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_OSRCoordinateTransformationShadow, 0);
+     _v = SWIG_CheckState(res);
+     if (_v) {
+       void *vptr = 0;
+       int res = SWIG_ConvertPtr(argv[1], &vptr, SWIGTYPE_p_double, 0);
+       _v = SWIG_CheckState(res);
+       if (_v) {
+         return _wrap_CoordinateTransformation_TransformPoint__SWIG_0(clientData, interp, objc, argv - 1);
+       }
+     }
+   }
+   if ((argc >= 3) && (argc <= 4)) {
+     int _v;
+     void *vptr = 0;
+     int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_OSRCoordinateTransformationShadow, 0);
+     _v = SWIG_CheckState(res);
+     if (_v) {
+       {
+         int res = SWIG_AsVal_double SWIG_TCL_CALL_ARGS_2(argv[1], NULL);
+         _v = SWIG_CheckState(res);
+       }
+       if (_v) {
+         {
+           int res = SWIG_AsVal_double SWIG_TCL_CALL_ARGS_2(argv[2], NULL);
+           _v = SWIG_CheckState(res);
+         }
+         if (_v) {
+           if (argc <= 3) {
+             return _wrap_CoordinateTransformation_TransformPoint__SWIG_1(clientData, interp, objc, argv - 1);
+           }
+           {
+             int res = SWIG_AsVal_double SWIG_TCL_CALL_ARGS_2(argv[3], NULL);
+             _v = SWIG_CheckState(res);
+           }
+           if (_v) {
+             return _wrap_CoordinateTransformation_TransformPoint__SWIG_1(clientData, interp, objc, argv - 1);
+           }
+         }
+       }
+     }
+   }
+   
+   Tcl_SetResult(interp,(char *) "No matching function for overloaded 'CoordinateTransformation_TransformPoint'", TCL_STATIC);
+   return TCL_ERROR;
+ }
+ 
+ 
+ SWIGINTERN int
+ _wrap_CoordinateTransformation_TransformPoints(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
+   OSRCoordinateTransformationShadow *arg1 = (OSRCoordinateTransformationShadow *) 0 ;
+   int arg2 ;
+   double *arg3 = (double *) 0 ;
+   double *arg4 = (double *) 0 ;
+   double *arg5 = (double *) 0 ;
+   void *argp1 = 0 ;
+   int res1 = 0 ;
+   
+   if (SWIG_GetArgs(interp, objc, objv,"oo:osgeo::CoordinateTransformation_TransformPoints self nCount ?x? ?y? ?z? ",(void *)0,(void *)0) == TCL_ERROR) SWIG_fail;
+   res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_OSRCoordinateTransformationShadow, 0 |  0 );
+   if (!SWIG_IsOK(res1)) {
+     SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CoordinateTransformation_TransformPoints" "', argument " "1"" of type '" "OSRCoordinateTransformationShadow *""'"); 
+   }
+   arg1 = reinterpret_cast< OSRCoordinateTransformationShadow * >(argp1);
+   {
+     /*  typemap(in,numinputs=1) (int nCount, double *x, double *y, double *z) */
+     if (Tcl_ListObjLength(interp, objv[2], &arg2) != TCL_OK) {
+       /* Error msg in interp result */
+       SWIG_fail;
+     }
+     if ( !arg2 ) {
+       Tcl_SetResult(interp, (char*) "Input list mustn't be empty", TCL_STATIC);
+       SWIG_fail;
+     }
+     arg3 = (double*) CPLMalloc(arg2*sizeof(double));
+     arg4 = (double*) CPLMalloc(arg2*sizeof(double));
+     arg5 = (double*) CPLMalloc(arg2*sizeof(double));
+     
+     for( int i = 0; i<arg2; i++ ) {
+       Tcl_Obj **o = NULL;
+       if (Tcl_ListObjIndex(interp, objv[2], i, o) != TCL_OK) {
+         /* ref count is not incremented */
+         /* Error msg in interp result */
+         SWIG_fail;
+       }
+       
+       int size;
+       if (Tcl_ListObjLength(interp, *o, &size) != TCL_OK) {
+         /* Error msg in interp result */
+         SWIG_fail;
+       }
+       if ( size < 2 || size > 3 ) {
+         Tcl_SetResult(interp, (char*) "Not a list of 2 or 3 doubles", TCL_STATIC);
+         SWIG_fail;
+       }
+       
+       double x, y, z = 0;
+       Tcl_Obj **o2 = NULL;
+       if (Tcl_ListObjIndex(interp, *o, 0, o2) != TCL_OK) {
+         /* ref count is not incremented */
+         /* Error msg in interp result */
+         SWIG_fail;
+       }
+       if (Tcl_GetDoubleFromObj(interp, *o2, &x ) != TCL_OK) {
+         /* Error msg in interp result */
+         SWIG_fail;
+       }
+       
+       if (Tcl_ListObjIndex(interp, *o, 1, o2) != TCL_OK) {
+         /* ref count is not incremented */
+         /* Error msg in interp result */
+         SWIG_fail;
+       }
+       if (Tcl_GetDoubleFromObj(interp, *o2, &y ) != TCL_OK) {
+         /* Error msg in interp result */
+         SWIG_fail;
+       }
+       
+       if (size == 3) {
+         if (Tcl_ListObjIndex(interp, *o, 2, o2) != TCL_OK) {
+           /* ref count is not incremented */
+           /* Error msg in interp result */
+           SWIG_fail;
+         }
+         if (Tcl_GetDoubleFromObj(interp, *o2, &z ) != TCL_OK) {
+           /* Error msg in interp result */
+           SWIG_fail;
+         }
+       }
+       
+       (arg3)[i] = x;
+       (arg4)[i] = y;
+       (arg5)[i] = z;
+     }
+   }
+   OSRCoordinateTransformationShadow_TransformPoints(arg1,arg2,arg3,arg4,arg5);
+   
+   {
+     /* %typemap(argout)  (int nCount, double *x, double *y, double *z) */
+     Tcl_Obj *out = Tcl_NewListObj(0, NULL);
+     for( int i=0; i< arg2; i++ ) {
+       Tcl_Obj *tuple = Tcl_NewListObj(0, NULL);
+       Tcl_Obj *val = Tcl_NewDoubleObj((arg3)[i] );
+       if (Tcl_ListObjAppendElement(interp, tuple, val) != TCL_OK) {
+         Tcl_DecrRefCount(val);
+         Tcl_DecrRefCount(tuple);
+         Tcl_DecrRefCount(out);
+         /* Error msg in interp result */
+         SWIG_fail;
+       }
+       val = Tcl_NewDoubleObj((arg4)[i] );
+       if (Tcl_ListObjAppendElement(interp, tuple, val) != TCL_OK) {
+         Tcl_DecrRefCount(val);
+         Tcl_DecrRefCount(tuple);
+         Tcl_DecrRefCount(out);
+         /* Error msg in interp result */
+         SWIG_fail;
+       }
+       val = Tcl_NewDoubleObj((arg5)[i] );
+       if (Tcl_ListObjAppendElement(interp, tuple, val) != TCL_OK) {
+         Tcl_DecrRefCount(val);
+         Tcl_DecrRefCount(tuple);
+         Tcl_DecrRefCount(out);
+         /* Error msg in interp result */
+         SWIG_fail;
+       }
+       if (Tcl_ListObjAppendElement(interp, out, tuple) != TCL_OK) {
+         Tcl_DecrRefCount(tuple);
+         Tcl_DecrRefCount(out);
+         /* Error msg in interp result */
+         SWIG_fail;
+       }
+     }
+     Tcl_SetObjResult(interp, out);
+   }
+   {
+     /* %typemap(freearg)  (int nCount, double *x, double *y, double *z) */
+     CPLFree(arg3);
+     CPLFree(arg4);
+     CPLFree(arg5);
+   }
+   return TCL_OK;
+ fail:
+   {
+     /* %typemap(freearg)  (int nCount, double *x, double *y, double *z) */
+     CPLFree(arg3);
+     CPLFree(arg4);
+     CPLFree(arg5);
+   }
+   return TCL_ERROR;
+ }
+ 
+ 
+ SWIGINTERN void swig_delete_CoordinateTransformation(void *obj) {
+ OSRCoordinateTransformationShadow *arg1 = (OSRCoordinateTransformationShadow *) obj;
+ delete_OSRCoordinateTransformationShadow(arg1);
+ }
+ static swig_method swig_OSRCoordinateTransformationShadow_methods[] = {
+     {"TransformPoint", _wrap_CoordinateTransformation_TransformPoint}, 
+     {"TransformPoints", _wrap_CoordinateTransformation_TransformPoints}, 
+     {0,0}
+ };
+ static swig_attribute swig_OSRCoordinateTransformationShadow_attributes[] = {
+     {0,0,0}
+ };
+ static swig_class *swig_OSRCoordinateTransformationShadow_bases[] = {0};
+ static const char * swig_OSRCoordinateTransformationShadow_base_names[] = {0};
+ static swig_class _wrap_class_OSRCoordinateTransformationShadow = { "CoordinateTransformation", &SWIGTYPE_p_OSRCoordinateTransformationShadow,_wrap_new_CoordinateTransformation, swig_delete_CoordinateTransformation, swig_OSRCoordinateTransformationShadow_methods, swig_OSRCoordinateTransformationShadow_attributes, swig_OSRCoordinateTransformationShadow_bases,swig_OSRCoordinateTransformationShadow_base_names, &swig_module };
+ 
+ static swig_command_info swig_commands[] = {
+     { SWIG_prefix "GetWellKnownGeogCSAsWKT", (swig_wrapper_func) _wrap_GetWellKnownGeogCSAsWKT, NULL},
+     { SWIG_prefix "GetUserInputAsWKT", (swig_wrapper_func) _wrap_GetUserInputAsWKT, NULL},
+     { SWIG_prefix "GetProjectionMethods", (swig_wrapper_func) _wrap_GetProjectionMethods, NULL},
+     { SWIG_prefix "GetProjectionMethodParameterList", (swig_wrapper_func) _wrap_GetProjectionMethodParameterList, NULL},
+     { SWIG_prefix "GetProjectionMethodParamInfo", (swig_wrapper_func) _wrap_GetProjectionMethodParamInfo, NULL},
+     { SWIG_prefix "new_SpatialReference", (swig_wrapper_func) _wrap_new_SpatialReference, NULL},
+     { SWIG_prefix "delete_SpatialReference", (swig_wrapper_func) _wrap_delete_SpatialReference, NULL},
+     { SWIG_prefix "SpatialReference___str__", (swig_wrapper_func) _wrap_SpatialReference___str__, NULL},
+     { SWIG_prefix "SpatialReference_IsSame", (swig_wrapper_func) _wrap_SpatialReference_IsSame, NULL},
+     { SWIG_prefix "SpatialReference_IsSameGeogCS", (swig_wrapper_func) _wrap_SpatialReference_IsSameGeogCS, NULL},
+     { SWIG_prefix "SpatialReference_IsGeographic", (swig_wrapper_func) _wrap_SpatialReference_IsGeographic, NULL},
+     { SWIG_prefix "SpatialReference_IsProjected", (swig_wrapper_func) _wrap_SpatialReference_IsProjected, NULL},
+     { SWIG_prefix "SpatialReference_IsLocal", (swig_wrapper_func) _wrap_SpatialReference_IsLocal, NULL},
+     { SWIG_prefix "SpatialReference_SetAuthority", (swig_wrapper_func) _wrap_SpatialReference_SetAuthority, NULL},
+     { SWIG_prefix "SpatialReference_GetAttrValue", (swig_wrapper_func) _wrap_SpatialReference_GetAttrValue, NULL},
+     { SWIG_prefix "SpatialReference_SetAttrValue", (swig_wrapper_func) _wrap_SpatialReference_SetAttrValue, NULL},
+     { SWIG_prefix "SpatialReference_SetAngularUnits", (swig_wrapper_func) _wrap_SpatialReference_SetAngularUnits, NULL},
+     { SWIG_prefix "SpatialReference_GetAngularUnits", (swig_wrapper_func) _wrap_SpatialReference_GetAngularUnits, NULL},
+     { SWIG_prefix "SpatialReference_SetLinearUnits", (swig_wrapper_func) _wrap_SpatialReference_SetLinearUnits, NULL},
+     { SWIG_prefix "SpatialReference_SetLinearUnitsAndUpdateParameters", (swig_wrapper_func) _wrap_SpatialReference_SetLinearUnitsAndUpdateParameters, NULL},
+     { SWIG_prefix "SpatialReference_GetLinearUnits", (swig_wrapper_func) _wrap_SpatialReference_GetLinearUnits, NULL},
+     { SWIG_prefix "SpatialReference_GetLinearUnitsName", (swig_wrapper_func) _wrap_SpatialReference_GetLinearUnitsName, NULL},
+     { SWIG_prefix "SpatialReference_GetAuthorityCode", (swig_wrapper_func) _wrap_SpatialReference_GetAuthorityCode, NULL},
+     { SWIG_prefix "SpatialReference_GetAuthorityName", (swig_wrapper_func) _wrap_SpatialReference_GetAuthorityName, NULL},
+     { SWIG_prefix "SpatialReference_SetUTM", (swig_wrapper_func) _wrap_SpatialReference_SetUTM, NULL},
+     { SWIG_prefix "SpatialReference_SetStatePlane", (swig_wrapper_func) _wrap_SpatialReference_SetStatePlane, NULL},
+     { SWIG_prefix "SpatialReference_AutoIdentifyEPSG", (swig_wrapper_func) _wrap_SpatialReference_AutoIdentifyEPSG, NULL},
+     { SWIG_prefix "SpatialReference_SetProjection", (swig_wrapper_func) _wrap_SpatialReference_SetProjection, NULL},
+     { SWIG_prefix "SpatialReference_SetProjParm", (swig_wrapper_func) _wrap_SpatialReference_SetProjParm, NULL},
+     { SWIG_prefix "SpatialReference_GetProjParm", (swig_wrapper_func) _wrap_SpatialReference_GetProjParm, NULL},
+     { SWIG_prefix "SpatialReference_SetNormProjParm", (swig_wrapper_func) _wrap_SpatialReference_SetNormProjParm, NULL},
+     { SWIG_prefix "SpatialReference_GetNormProjParm", (swig_wrapper_func) _wrap_SpatialReference_GetNormProjParm, NULL},
+     { SWIG_prefix "SpatialReference_SetACEA", (swig_wrapper_func) _wrap_SpatialReference_SetACEA, NULL},
+     { SWIG_prefix "SpatialReference_SetAE", (swig_wrapper_func) _wrap_SpatialReference_SetAE, NULL},
+     { SWIG_prefix "SpatialReference_SetBonne", (swig_wrapper_func) _wrap_SpatialReference_SetBonne, NULL},
+     { SWIG_prefix "SpatialReference_SetCEA", (swig_wrapper_func) _wrap_SpatialReference_SetCEA, NULL},
+     { SWIG_prefix "SpatialReference_SetCS", (swig_wrapper_func) _wrap_SpatialReference_SetCS, NULL},
+     { SWIG_prefix "SpatialReference_SetEC", (swig_wrapper_func) _wrap_SpatialReference_SetEC, NULL},
+     { SWIG_prefix "SpatialReference_SetEckertIV", (swig_wrapper_func) _wrap_SpatialReference_SetEckertIV, NULL},
+     { SWIG_prefix "SpatialReference_SetEckertVI", (swig_wrapper_func) _wrap_SpatialReference_SetEckertVI, NULL},
+     { SWIG_prefix "SpatialReference_SetEquirectangular", (swig_wrapper_func) _wrap_SpatialReference_SetEquirectangular, NULL},
+     { SWIG_prefix "SpatialReference_SetEquirectangular2", (swig_wrapper_func) _wrap_SpatialReference_SetEquirectangular2, NULL},
+     { SWIG_prefix "SpatialReference_SetGaussSchreiberTMercator", (swig_wrapper_func) _wrap_SpatialReference_SetGaussSchreiberTMercator, NULL},
+     { SWIG_prefix "SpatialReference_SetGS", (swig_wrapper_func) _wrap_SpatialReference_SetGS, NULL},
+     { SWIG_prefix "SpatialReference_SetGH", (swig_wrapper_func) _wrap_SpatialReference_SetGH, NULL},
+     { SWIG_prefix "SpatialReference_SetGEOS", (swig_wrapper_func) _wrap_SpatialReference_SetGEOS, NULL},
+     { SWIG_prefix "SpatialReference_SetGnomonic", (swig_wrapper_func) _wrap_SpatialReference_SetGnomonic, NULL},
+     { SWIG_prefix "SpatialReference_SetHOM", (swig_wrapper_func) _wrap_SpatialReference_SetHOM, NULL},
+     { SWIG_prefix "SpatialReference_SetHOM2PNO", (swig_wrapper_func) _wrap_SpatialReference_SetHOM2PNO, NULL},
+     { SWIG_prefix "SpatialReference_SetKrovak", (swig_wrapper_func) _wrap_SpatialReference_SetKrovak, NULL},
+     { SWIG_prefix "SpatialReference_SetLAEA", (swig_wrapper_func) _wrap_SpatialReference_SetLAEA, NULL},
+     { SWIG_prefix "SpatialReference_SetLCC", (swig_wrapper_func) _wrap_SpatialReference_SetLCC, NULL},
+     { SWIG_prefix "SpatialReference_SetLCC1SP", (swig_wrapper_func) _wrap_SpatialReference_SetLCC1SP, NULL},
+     { SWIG_prefix "SpatialReference_SetLCCB", (swig_wrapper_func) _wrap_SpatialReference_SetLCCB, NULL},
+     { SWIG_prefix "SpatialReference_SetMC", (swig_wrapper_func) _wrap_SpatialReference_SetMC, NULL},
+     { SWIG_prefix "SpatialReference_SetMercator", (swig_wrapper_func) _wrap_SpatialReference_SetMercator, NULL},
+     { SWIG_prefix "SpatialReference_SetMollweide", (swig_wrapper_func) _wrap_SpatialReference_SetMollweide, NULL},
+     { SWIG_prefix "SpatialReference_SetNZMG", (swig_wrapper_func) _wrap_SpatialReference_SetNZMG, NULL},
+     { SWIG_prefix "SpatialReference_SetOS", (swig_wrapper_func) _wrap_SpatialReference_SetOS, NULL},
+     { SWIG_prefix "SpatialReference_SetOrthographic", (swig_wrapper_func) _wrap_SpatialReference_SetOrthographic, NULL},
+     { SWIG_prefix "SpatialReference_SetPolyconic", (swig_wrapper_func) _wrap_SpatialReference_SetPolyconic, NULL},
+     { SWIG_prefix "SpatialReference_SetPS", (swig_wrapper_func) _wrap_SpatialReference_SetPS, NULL},
+     { SWIG_prefix "SpatialReference_SetRobinson", (swig_wrapper_func) _wrap_SpatialReference_SetRobinson, NULL},
+     { SWIG_prefix "SpatialReference_SetSinusoidal", (swig_wrapper_func) _wrap_SpatialReference_SetSinusoidal, NULL},
+     { SWIG_prefix "SpatialReference_SetStereographic", (swig_wrapper_func) _wrap_SpatialReference_SetStereographic, NULL},
+     { SWIG_prefix "SpatialReference_SetSOC", (swig_wrapper_func) _wrap_SpatialReference_SetSOC, NULL},
+     { SWIG_prefix "SpatialReference_SetTM", (swig_wrapper_func) _wrap_SpatialReference_SetTM, NULL},
+     { SWIG_prefix "SpatialReference_SetTMVariant", (swig_wrapper_func) _wrap_SpatialReference_SetTMVariant, NULL},
+     { SWIG_prefix "SpatialReference_SetTMG", (swig_wrapper_func) _wrap_SpatialReference_SetTMG, NULL},
+     { SWIG_prefix "SpatialReference_SetTMSO", (swig_wrapper_func) _wrap_SpatialReference_SetTMSO, NULL},
+     { SWIG_prefix "SpatialReference_SetVDG", (swig_wrapper_func) _wrap_SpatialReference_SetVDG, NULL},
+     { SWIG_prefix "SpatialReference_SetWellKnownGeogCS", (swig_wrapper_func) _wrap_SpatialReference_SetWellKnownGeogCS, NULL},
+     { SWIG_prefix "SpatialReference_SetFromUserInput", (swig_wrapper_func) _wrap_SpatialReference_SetFromUserInput, NULL},
+     { SWIG_prefix "SpatialReference_CopyGeogCSFrom", (swig_wrapper_func) _wrap_SpatialReference_CopyGeogCSFrom, NULL},
+     { SWIG_prefix "SpatialReference_SetTOWGS84", (swig_wrapper_func) _wrap_SpatialReference_SetTOWGS84, NULL},
+     { SWIG_prefix "SpatialReference_GetTOWGS84", (swig_wrapper_func) _wrap_SpatialReference_GetTOWGS84, NULL},
+     { SWIG_prefix "SpatialReference_SetLocalCS", (swig_wrapper_func) _wrap_SpatialReference_SetLocalCS, NULL},
+     { SWIG_prefix "SpatialReference_SetGeogCS", (swig_wrapper_func) _wrap_SpatialReference_SetGeogCS, NULL},
+     { SWIG_prefix "SpatialReference_SetProjCS", (swig_wrapper_func) _wrap_SpatialReference_SetProjCS, NULL},
+     { SWIG_prefix "SpatialReference_ImportFromWkt", (swig_wrapper_func) _wrap_SpatialReference_ImportFromWkt, NULL},
+     { SWIG_prefix "SpatialReference_ImportFromProj4", (swig_wrapper_func) _wrap_SpatialReference_ImportFromProj4, NULL},
+     { SWIG_prefix "SpatialReference_ImportFromUrl", (swig_wrapper_func) _wrap_SpatialReference_ImportFromUrl, NULL},
+     { SWIG_prefix "SpatialReference_ImportFromESRI", (swig_wrapper_func) _wrap_SpatialReference_ImportFromESRI, NULL},
+     { SWIG_prefix "SpatialReference_ImportFromEPSG", (swig_wrapper_func) _wrap_SpatialReference_ImportFromEPSG, NULL},
+     { SWIG_prefix "SpatialReference_ImportFromPCI", (swig_wrapper_func) _wrap_SpatialReference_ImportFromPCI, NULL},
+     { SWIG_prefix "SpatialReference_ImportFromUSGS", (swig_wrapper_func) _wrap_SpatialReference_ImportFromUSGS, NULL},
+     { SWIG_prefix "SpatialReference_ImportFromXML", (swig_wrapper_func) _wrap_SpatialReference_ImportFromXML, NULL},
+     { SWIG_prefix "SpatialReference_ImportFromMICoordSys", (swig_wrapper_func) _wrap_SpatialReference_ImportFromMICoordSys, NULL},
+     { SWIG_prefix "SpatialReference_ExportToWkt", (swig_wrapper_func) _wrap_SpatialReference_ExportToWkt, NULL},
+     { SWIG_prefix "SpatialReference_ExportToPrettyWkt", (swig_wrapper_func) _wrap_SpatialReference_ExportToPrettyWkt, NULL},
+     { SWIG_prefix "SpatialReference_ExportToProj4", (swig_wrapper_func) _wrap_SpatialReference_ExportToProj4, NULL},
+     { SWIG_prefix "SpatialReference_ExportToPCI", (swig_wrapper_func) _wrap_SpatialReference_ExportToPCI, NULL},
+     { SWIG_prefix "SpatialReference_ExportToUSGS", (swig_wrapper_func) _wrap_SpatialReference_ExportToUSGS, NULL},
+     { SWIG_prefix "SpatialReference_ExportToXML", (swig_wrapper_func) _wrap_SpatialReference_ExportToXML, NULL},
+     { SWIG_prefix "SpatialReference_ExportToMICoordSys", (swig_wrapper_func) _wrap_SpatialReference_ExportToMICoordSys, NULL},
+     { SWIG_prefix "SpatialReference_CloneGeogCS", (swig_wrapper_func) _wrap_SpatialReference_CloneGeogCS, NULL},
+     { SWIG_prefix "SpatialReference_Validate", (swig_wrapper_func) _wrap_SpatialReference_Validate, NULL},
+     { SWIG_prefix "SpatialReference_StripCTParms", (swig_wrapper_func) _wrap_SpatialReference_StripCTParms, NULL},
+     { SWIG_prefix "SpatialReference_FixupOrdering", (swig_wrapper_func) _wrap_SpatialReference_FixupOrdering, NULL},
+     { SWIG_prefix "SpatialReference_Fixup", (swig_wrapper_func) _wrap_SpatialReference_Fixup, NULL},
+     { SWIG_prefix "SpatialReference_MorphToESRI", (swig_wrapper_func) _wrap_SpatialReference_MorphToESRI, NULL},
+     { SWIG_prefix "SpatialReference_MorphFromESRI", (swig_wrapper_func) _wrap_SpatialReference_MorphFromESRI, NULL},
+     { SWIG_prefix "SpatialReference", (swig_wrapper_func) SWIG_ObjectConstructor, (ClientData)&_wrap_class_OSRSpatialReferenceShadow},
+     { SWIG_prefix "new_CoordinateTransformation", (swig_wrapper_func) _wrap_new_CoordinateTransformation, NULL},
+     { SWIG_prefix "delete_CoordinateTransformation", (swig_wrapper_func) _wrap_delete_CoordinateTransformation, NULL},
+     { SWIG_prefix "CoordinateTransformation_TransformPoint", (swig_wrapper_func) _wrap_CoordinateTransformation_TransformPoint, NULL},
+     { SWIG_prefix "CoordinateTransformation_TransformPoints", (swig_wrapper_func) _wrap_CoordinateTransformation_TransformPoints, NULL},
+     { SWIG_prefix "CoordinateTransformation", (swig_wrapper_func) SWIG_ObjectConstructor, (ClientData)&_wrap_class_OSRCoordinateTransformationShadow},
+     {0, 0, 0}
+ };
+ 
+ static swig_var_info swig_variables[] = {
+     {0,0,0,0}
+ };
+ 
+ static swig_const_info swig_constants[] = {
+     {0,0,0,0,0,0}
+ };
+ 
+ /* -------- TYPE CONVERSION AND EQUIVALENCE RULES (BEGIN) -------- */
+ 
+ static swig_type_info _swigt__p_OSRCoordinateTransformationShadow = {"_p_OSRCoordinateTransformationShadow", "OSRCoordinateTransformationShadow *", 0, 0, (void*)&_wrap_class_OSRCoordinateTransformationShadow, 0};
+ static swig_type_info _swigt__p_OSRSpatialReferenceShadow = {"_p_OSRSpatialReferenceShadow", "OSRSpatialReferenceShadow *", 0, 0, (void*)&_wrap_class_OSRSpatialReferenceShadow, 0};
+ static swig_type_info _swigt__p_char = {"_p_char", "char *", 0, 0, (void*)0, 0};
+ static swig_type_info _swigt__p_double = {"_p_double", "double *", 0, 0, (void*)0, 0};
+ static swig_type_info _swigt__p_int = {"_p_int", "int *|OGRErr *", 0, 0, (void*)0, 0};
+ static swig_type_info _swigt__p_long = {"_p_long", "long *", 0, 0, (void*)0, 0};
+ static swig_type_info _swigt__p_p_char = {"_p_p_char", "char **", 0, 0, (void*)0, 0};
+ static swig_type_info _swigt__p_p_double = {"_p_p_double", "double **", 0, 0, (void*)0, 0};
+ 
+ static swig_type_info *swig_type_initial[] = {
+   &_swigt__p_OSRCoordinateTransformationShadow,
+   &_swigt__p_OSRSpatialReferenceShadow,
+   &_swigt__p_char,
+   &_swigt__p_double,
+   &_swigt__p_int,
+   &_swigt__p_long,
+   &_swigt__p_p_char,
+   &_swigt__p_p_double,
+ };
+ 
+ static swig_cast_info _swigc__p_OSRCoordinateTransformationShadow[] = {  {&_swigt__p_OSRCoordinateTransformationShadow, 0, 0, 0},{0, 0, 0, 0}};
+ static swig_cast_info _swigc__p_OSRSpatialReferenceShadow[] = {  {&_swigt__p_OSRSpatialReferenceShadow, 0, 0, 0},{0, 0, 0, 0}};
+ static swig_cast_info _swigc__p_char[] = {  {&_swigt__p_char, 0, 0, 0},{0, 0, 0, 0}};
+ static swig_cast_info _swigc__p_double[] = {  {&_swigt__p_double, 0, 0, 0},{0, 0, 0, 0}};
+ static swig_cast_info _swigc__p_int[] = {  {&_swigt__p_int, 0, 0, 0},{0, 0, 0, 0}};
+ static swig_cast_info _swigc__p_long[] = {  {&_swigt__p_long, 0, 0, 0},{0, 0, 0, 0}};
+ static swig_cast_info _swigc__p_p_char[] = {  {&_swigt__p_p_char, 0, 0, 0},{0, 0, 0, 0}};
+ static swig_cast_info _swigc__p_p_double[] = {  {&_swigt__p_p_double, 0, 0, 0},{0, 0, 0, 0}};
+ 
+ static swig_cast_info *swig_cast_initial[] = {
+   _swigc__p_OSRCoordinateTransformationShadow,
+   _swigc__p_OSRSpatialReferenceShadow,
+   _swigc__p_char,
+   _swigc__p_double,
+   _swigc__p_int,
+   _swigc__p_long,
+   _swigc__p_p_char,
+   _swigc__p_p_double,
+ };
+ 
+ 
+ /* -------- TYPE CONVERSION AND EQUIVALENCE RULES (END) -------- */
+ 
+ #ifdef __cplusplus
+ }
+ #endif
+ /* -----------------------------------------------------------------------------
+  * Type initialization:
+  * This problem is tough by the requirement that no dynamic 
+  * memory is used. Also, since swig_type_info structures store pointers to 
+  * swig_cast_info structures and swig_cast_info structures store pointers back
+  * to swig_type_info structures, we need some lookup code at initialization. 
+  * The idea is that swig generates all the structures that are needed. 
+  * The runtime then collects these partially filled structures. 
+  * The SWIG_InitializeModule function takes these initial arrays out of 
+  * swig_module, and does all the lookup, filling in the swig_module.types
+  * array with the correct data and linking the correct swig_cast_info
+  * structures together.
+  *
+  * The generated swig_type_info structures are assigned staticly to an initial 
+  * array. We just loop through that array, and handle each type individually.
+  * First we lookup if this type has been already loaded, and if so, use the
+  * loaded structure instead of the generated one. Then we have to fill in the
+  * cast linked list. The cast data is initially stored in something like a
+  * two-dimensional array. Each row corresponds to a type (there are the same
+  * number of rows as there are in the swig_type_initial array). Each entry in
+  * a column is one of the swig_cast_info structures for that type.
+  * The cast_initial array is actually an array of arrays, because each row has
+  * a variable number of columns. So to actually build the cast linked list,
+  * we find the array of casts associated with the type, and loop through it 
+  * adding the casts to the list. The one last trick we need to do is making
+  * sure the type pointer in the swig_cast_info struct is correct.
+  *
+  * First off, we lookup the cast->type name to see if it is already loaded. 
+  * There are three cases to handle:
+  *  1) If the cast->type has already been loaded AND the type we are adding
+  *     casting info to has not been loaded (it is in this module), THEN we
+  *     replace the cast->type pointer with the type pointer that has already
+  *     been loaded.
+  *  2) If BOTH types (the one we are adding casting info to, and the 
+  *     cast->type) are loaded, THEN the cast info has already been loaded by
+  *     the previous module so we just ignore it.
+  *  3) Finally, if cast->type has not already been loaded, then we add that
+  *     swig_cast_info to the linked list (because the cast->type) pointer will
+  *     be correct.
+  * ----------------------------------------------------------------------------- */
+ 
+ #ifdef __cplusplus
+ extern "C" {
+ #if 0
+ } /* c-mode */
+ #endif
+ #endif
+ 
+ #if 0
+ #define SWIGRUNTIME_DEBUG
+ #endif
+ 
+ 
+ SWIGRUNTIME void
+ SWIG_InitializeModule(void *clientdata) {
+   size_t i;
+   swig_module_info *module_head, *iter;
+   int found, init;
+   
+   clientdata = clientdata;
+   
+   /* check to see if the circular list has been setup, if not, set it up */
+   if (swig_module.next==0) {
+     /* Initialize the swig_module */
+     swig_module.type_initial = swig_type_initial;
+     swig_module.cast_initial = swig_cast_initial;
+     swig_module.next = &swig_module;
+     init = 1;
+   } else {
+     init = 0;
+   }
+   
+   /* Try and load any already created modules */
+   module_head = SWIG_GetModule(clientdata);
+   if (!module_head) {
+     /* This is the first module loaded for this interpreter */
+     /* so set the swig module into the interpreter */
+     SWIG_SetModule(clientdata, &swig_module);
+     module_head = &swig_module;
+   } else {
+     /* the interpreter has loaded a SWIG module, but has it loaded this one? */
+     found=0;
+     iter=module_head;
+     do {
+       if (iter==&swig_module) {
+         found=1;
+         break;
+       }
+       iter=iter->next;
+     } while (iter!= module_head);
+     
+     /* if the is found in the list, then all is done and we may leave */
+     if (found) return;
+     /* otherwise we must add out module into the list */
+     swig_module.next = module_head->next;
+     module_head->next = &swig_module;
+   }
+   
+   /* When multiple interpeters are used, a module could have already been initialized in
+        a different interpreter, but not yet have a pointer in this interpreter.
+        In this case, we do not want to continue adding types... everything should be
+        set up already */
+   if (init == 0) return;
+   
+   /* Now work on filling in swig_module.types */
+ #ifdef SWIGRUNTIME_DEBUG
+   printf("SWIG_InitializeModule: size %d\n", swig_module.size);
+ #endif
+   for (i = 0; i < swig_module.size; ++i) {
+     swig_type_info *type = 0;
+     swig_type_info *ret;
+     swig_cast_info *cast;
+     
+ #ifdef SWIGRUNTIME_DEBUG
+     printf("SWIG_InitializeModule: type %d %s\n", i, swig_module.type_initial[i]->name);
+ #endif
+     
+     /* if there is another module already loaded */
+     if (swig_module.next != &swig_module) {
+       type = SWIG_MangledTypeQueryModule(swig_module.next, &swig_module, swig_module.type_initial[i]->name);
+     }
+     if (type) {
+       /* Overwrite clientdata field */
+ #ifdef SWIGRUNTIME_DEBUG
+       printf("SWIG_InitializeModule: found type %s\n", type->name);
+ #endif
+       if (swig_module.type_initial[i]->clientdata) {
+         type->clientdata = swig_module.type_initial[i]->clientdata;
+ #ifdef SWIGRUNTIME_DEBUG
+         printf("SWIG_InitializeModule: found and overwrite type %s \n", type->name);
+ #endif
+       }
+     } else {
+       type = swig_module.type_initial[i];
+     }
+     
+     /* Insert casting types */
+     cast = swig_module.cast_initial[i];
+     while (cast->type) {
+       /* Don't need to add information already in the list */
+       ret = 0;
+ #ifdef SWIGRUNTIME_DEBUG
+       printf("SWIG_InitializeModule: look cast %s\n", cast->type->name);
+ #endif
+       if (swig_module.next != &swig_module) {
+         ret = SWIG_MangledTypeQueryModule(swig_module.next, &swig_module, cast->type->name);
+ #ifdef SWIGRUNTIME_DEBUG
+         if (ret) printf("SWIG_InitializeModule: found cast %s\n", ret->name);
+ #endif
+       }
+       if (ret) {
+         if (type == swig_module.type_initial[i]) {
+ #ifdef SWIGRUNTIME_DEBUG
+           printf("SWIG_InitializeModule: skip old type %s\n", ret->name);
+ #endif
+           cast->type = ret;
+           ret = 0;
+         } else {
+           /* Check for casting already in the list */
+           swig_cast_info *ocast = SWIG_TypeCheck(ret->name, type);
+ #ifdef SWIGRUNTIME_DEBUG
+           if (ocast) printf("SWIG_InitializeModule: skip old cast %s\n", ret->name);
+ #endif
+           if (!ocast) ret = 0;
+         }
+       }
+       
+       if (!ret) {
+ #ifdef SWIGRUNTIME_DEBUG
+         printf("SWIG_InitializeModule: adding cast %s\n", cast->type->name);
+ #endif
+         if (type->cast) {
+           type->cast->prev = cast;
+           cast->next = type->cast;
+         }
+         type->cast = cast;
+       }
+       cast++;
+     }
+     /* Set entry in modules->types array equal to the type */
+     swig_module.types[i] = type;
+   }
+   swig_module.types[i] = 0;
+   
+ #ifdef SWIGRUNTIME_DEBUG
+   printf("**** SWIG_InitializeModule: Cast List ******\n");
+   for (i = 0; i < swig_module.size; ++i) {
+     int j = 0;
+     swig_cast_info *cast = swig_module.cast_initial[i];
+     printf("SWIG_InitializeModule: type %d %s\n", i, swig_module.type_initial[i]->name);
+     while (cast->type) {
+       printf("SWIG_InitializeModule: cast type %s\n", cast->type->name);
+       cast++;
+       ++j;
+     }
+     printf("---- Total casts: %d\n",j);
+   }
+   printf("**** SWIG_InitializeModule: Cast List ******\n");
+ #endif
+ }
+ 
+ /* This function will propagate the clientdata field of type to
+ * any new swig_type_info structures that have been added into the list
+ * of equivalent types.  It is like calling
+ * SWIG_TypeClientData(type, clientdata) a second time.
+ */
+ SWIGRUNTIME void
+ SWIG_PropagateClientData(void) {
+   size_t i;
+   swig_cast_info *equiv;
+   static int init_run = 0;
+   
+   if (init_run) return;
+   init_run = 1;
+   
+   for (i = 0; i < swig_module.size; i++) {
+     if (swig_module.types[i]->clientdata) {
+       equiv = swig_module.types[i]->cast;
+       while (equiv) {
+         if (!equiv->converter) {
+           if (equiv->type && !equiv->type->clientdata)
+           SWIG_TypeClientData(equiv->type, swig_module.types[i]->clientdata);
+         }
+         equiv = equiv->next;
+       }
+     }
+   }
+ }
+ 
+ #ifdef __cplusplus
+ #if 0
+ {
+   /* c-mode */
+ #endif
+ }
+ #endif
+ 
+ 
+ #ifdef __cplusplus
+ extern "C" {
+ #endif
+   
+   /* -----------------------------------------------------------------------------
+    * constants/methods manipulation
+    * ----------------------------------------------------------------------------- */
+   
+   /* Install Constants */
+   
+   SWIGINTERN void
+   SWIG_Tcl_InstallConstants(Tcl_Interp *interp, swig_const_info constants[]) {
+     int i;
+     Tcl_Obj *obj;
+     
+     if (!swigconstTableinit) {
+       Tcl_InitHashTable(&swigconstTable, TCL_STRING_KEYS);
+       swigconstTableinit = 1;
+     }
+     for (i = 0; constants[i].type; i++) {
+       switch(constants[i].type) {
+       case SWIG_TCL_POINTER:
+         obj = SWIG_NewPointerObj(constants[i].pvalue, *(constants[i]).ptype,0);
+         break;
+       case SWIG_TCL_BINARY:
+         obj = SWIG_NewPackedObj(constants[i].pvalue, constants[i].lvalue, *(constants[i].ptype));
+         break;
+       default:
+         obj = 0;
+         break;
+       }
+       if (obj) {
+         SWIG_Tcl_SetConstantObj(interp, constants[i].name, obj);
+       }
+     }
+   }
+   
+ #ifdef __cplusplus
+ }
+ #endif
+ 
+ /* -----------------------------------------------------------------------------*
+  *  Partial Init method
+  * -----------------------------------------------------------------------------*/
+ 
+ SWIGEXPORT int SWIG_init(Tcl_Interp *interp) {
+   int i;
+   if (interp == 0) return TCL_ERROR;
+ #ifdef USE_TCL_STUBS
+   if (Tcl_InitStubs(interp, (char*)"8.1", 0) == NULL) {
+     return TCL_ERROR;
+   }
+ #endif  
+   Tcl_PkgProvide(interp, (char*)SWIG_name, (char*)SWIG_version);
+   
+ #ifdef SWIG_namespace
+   Tcl_Eval(interp, "namespace eval " SWIG_namespace " { }");
+ #endif
+   
+   SWIG_InitializeModule((void *) interp);
+   SWIG_PropagateClientData();
+   
+   for (i = 0; swig_commands[i].name; i++) {
+     Tcl_CreateObjCommand(interp, (char *) swig_commands[i].name, (swig_wrapper_func) swig_commands[i].wrapper,
+       swig_commands[i].clientdata, NULL);
+   }
+   for (i = 0; swig_variables[i].name; i++) {
+     Tcl_SetVar(interp, (char *) swig_variables[i].name, (char *) "", TCL_GLOBAL_ONLY);
+     Tcl_TraceVar(interp, (char *) swig_variables[i].name, TCL_TRACE_READS | TCL_GLOBAL_ONLY, 
+       (Tcl_VarTraceProc *) swig_variables[i].get, (ClientData) swig_variables[i].addr);
+     Tcl_TraceVar(interp, (char *) swig_variables[i].name, TCL_TRACE_WRITES | TCL_GLOBAL_ONLY, 
+       (Tcl_VarTraceProc *) swig_variables[i].set, (ClientData) swig_variables[i].addr);
+   }
+   
+   SWIG_Tcl_InstallConstants(interp, swig_constants);
+   
+   
+   SWIG_Tcl_SetConstantObj(interp, "osgeo::SRS_PT_ALBERS_CONIC_EQUAL_AREA", SWIG_FromCharPtr(SRS_PT_ALBERS_CONIC_EQUAL_AREA));
+   SWIG_Tcl_SetConstantObj(interp, "osgeo::SRS_PT_AZIMUTHAL_EQUIDISTANT", SWIG_FromCharPtr(SRS_PT_AZIMUTHAL_EQUIDISTANT));
+   SWIG_Tcl_SetConstantObj(interp, "osgeo::SRS_PT_CASSINI_SOLDNER", SWIG_FromCharPtr(SRS_PT_CASSINI_SOLDNER));
+   SWIG_Tcl_SetConstantObj(interp, "osgeo::SRS_PT_CYLINDRICAL_EQUAL_AREA", SWIG_FromCharPtr(SRS_PT_CYLINDRICAL_EQUAL_AREA));
+   SWIG_Tcl_SetConstantObj(interp, "osgeo::SRS_PT_ECKERT_IV", SWIG_FromCharPtr(SRS_PT_ECKERT_IV));
+   SWIG_Tcl_SetConstantObj(interp, "osgeo::SRS_PT_ECKERT_VI", SWIG_FromCharPtr(SRS_PT_ECKERT_VI));
+   SWIG_Tcl_SetConstantObj(interp, "osgeo::SRS_PT_EQUIDISTANT_CONIC", SWIG_FromCharPtr(SRS_PT_EQUIDISTANT_CONIC));
+   SWIG_Tcl_SetConstantObj(interp, "osgeo::SRS_PT_EQUIRECTANGULAR", SWIG_FromCharPtr(SRS_PT_EQUIRECTANGULAR));
+   SWIG_Tcl_SetConstantObj(interp, "osgeo::SRS_PT_GALL_STEREOGRAPHIC", SWIG_FromCharPtr(SRS_PT_GALL_STEREOGRAPHIC));
+   SWIG_Tcl_SetConstantObj(interp, "osgeo::SRS_PT_GAUSSSCHREIBERTMERCATOR", SWIG_FromCharPtr(SRS_PT_GAUSSSCHREIBERTMERCATOR));
+   SWIG_Tcl_SetConstantObj(interp, "osgeo::SRS_PT_GNOMONIC", SWIG_FromCharPtr(SRS_PT_GNOMONIC));
+   SWIG_Tcl_SetConstantObj(interp, "osgeo::SRS_PT_GOODE_HOMOLOSINE", SWIG_FromCharPtr(SRS_PT_GOODE_HOMOLOSINE));
+   SWIG_Tcl_SetConstantObj(interp, "osgeo::SRS_PT_HOTINE_OBLIQUE_MERCATOR", SWIG_FromCharPtr(SRS_PT_HOTINE_OBLIQUE_MERCATOR));
+   SWIG_Tcl_SetConstantObj(interp, "osgeo::SRS_PT_HOTINE_OBLIQUE_MERCATOR_TWO_POINT_NATURAL_ORIGIN", SWIG_FromCharPtr(SRS_PT_HOTINE_OBLIQUE_MERCATOR_TWO_POINT_NATURAL_ORIGIN));
+   SWIG_Tcl_SetConstantObj(interp, "osgeo::SRS_PT_LABORDE_OBLIQUE_MERCATOR", SWIG_FromCharPtr(SRS_PT_LABORDE_OBLIQUE_MERCATOR));
+   SWIG_Tcl_SetConstantObj(interp, "osgeo::SRS_PT_LAMBERT_CONFORMAL_CONIC_1SP", SWIG_FromCharPtr(SRS_PT_LAMBERT_CONFORMAL_CONIC_1SP));
+   SWIG_Tcl_SetConstantObj(interp, "osgeo::SRS_PT_LAMBERT_CONFORMAL_CONIC_2SP", SWIG_FromCharPtr(SRS_PT_LAMBERT_CONFORMAL_CONIC_2SP));
+   SWIG_Tcl_SetConstantObj(interp, "osgeo::SRS_PT_LAMBERT_CONFORMAL_CONIC_2SP_BELGIUM", SWIG_FromCharPtr(SRS_PT_LAMBERT_CONFORMAL_CONIC_2SP_BELGIUM));
+   SWIG_Tcl_SetConstantObj(interp, "osgeo::SRS_PT_LAMBERT_AZIMUTHAL_EQUAL_AREA", SWIG_FromCharPtr(SRS_PT_LAMBERT_AZIMUTHAL_EQUAL_AREA));
+   SWIG_Tcl_SetConstantObj(interp, "osgeo::SRS_PT_MERCATOR_1SP", SWIG_FromCharPtr(SRS_PT_MERCATOR_1SP));
+   SWIG_Tcl_SetConstantObj(interp, "osgeo::SRS_PT_MERCATOR_2SP", SWIG_FromCharPtr(SRS_PT_MERCATOR_2SP));
+   SWIG_Tcl_SetConstantObj(interp, "osgeo::SRS_PT_MILLER_CYLINDRICAL", SWIG_FromCharPtr(SRS_PT_MILLER_CYLINDRICAL));
+   SWIG_Tcl_SetConstantObj(interp, "osgeo::SRS_PT_MOLLWEIDE", SWIG_FromCharPtr(SRS_PT_MOLLWEIDE));
+   SWIG_Tcl_SetConstantObj(interp, "osgeo::SRS_PT_NEW_ZEALAND_MAP_GRID", SWIG_FromCharPtr(SRS_PT_NEW_ZEALAND_MAP_GRID));
+   SWIG_Tcl_SetConstantObj(interp, "osgeo::SRS_PT_OBLIQUE_STEREOGRAPHIC", SWIG_FromCharPtr(SRS_PT_OBLIQUE_STEREOGRAPHIC));
+   SWIG_Tcl_SetConstantObj(interp, "osgeo::SRS_PT_ORTHOGRAPHIC", SWIG_FromCharPtr(SRS_PT_ORTHOGRAPHIC));
+   SWIG_Tcl_SetConstantObj(interp, "osgeo::SRS_PT_POLAR_STEREOGRAPHIC", SWIG_FromCharPtr(SRS_PT_POLAR_STEREOGRAPHIC));
+   SWIG_Tcl_SetConstantObj(interp, "osgeo::SRS_PT_POLYCONIC", SWIG_FromCharPtr(SRS_PT_POLYCONIC));
+   SWIG_Tcl_SetConstantObj(interp, "osgeo::SRS_PT_ROBINSON", SWIG_FromCharPtr(SRS_PT_ROBINSON));
+   SWIG_Tcl_SetConstantObj(interp, "osgeo::SRS_PT_SINUSOIDAL", SWIG_FromCharPtr(SRS_PT_SINUSOIDAL));
+   SWIG_Tcl_SetConstantObj(interp, "osgeo::SRS_PT_STEREOGRAPHIC", SWIG_FromCharPtr(SRS_PT_STEREOGRAPHIC));
+   SWIG_Tcl_SetConstantObj(interp, "osgeo::SRS_PT_SWISS_OBLIQUE_CYLINDRICAL", SWIG_FromCharPtr(SRS_PT_SWISS_OBLIQUE_CYLINDRICAL));
+   SWIG_Tcl_SetConstantObj(interp, "osgeo::SRS_PT_TRANSVERSE_MERCATOR", SWIG_FromCharPtr(SRS_PT_TRANSVERSE_MERCATOR));
+   SWIG_Tcl_SetConstantObj(interp, "osgeo::SRS_PT_TRANSVERSE_MERCATOR_SOUTH_ORIENTED", SWIG_FromCharPtr(SRS_PT_TRANSVERSE_MERCATOR_SOUTH_ORIENTED));
+   SWIG_Tcl_SetConstantObj(interp, "osgeo::SRS_PT_TRANSVERSE_MERCATOR_MI_22", SWIG_FromCharPtr(SRS_PT_TRANSVERSE_MERCATOR_MI_22));
+   SWIG_Tcl_SetConstantObj(interp, "osgeo::SRS_PT_TRANSVERSE_MERCATOR_MI_23", SWIG_FromCharPtr(SRS_PT_TRANSVERSE_MERCATOR_MI_23));
+   SWIG_Tcl_SetConstantObj(interp, "osgeo::SRS_PT_TRANSVERSE_MERCATOR_MI_24", SWIG_FromCharPtr(SRS_PT_TRANSVERSE_MERCATOR_MI_24));
+   SWIG_Tcl_SetConstantObj(interp, "osgeo::SRS_PT_TRANSVERSE_MERCATOR_MI_25", SWIG_FromCharPtr(SRS_PT_TRANSVERSE_MERCATOR_MI_25));
+   SWIG_Tcl_SetConstantObj(interp, "osgeo::SRS_PT_TUNISIA_MINING_GRID", SWIG_FromCharPtr(SRS_PT_TUNISIA_MINING_GRID));
+   SWIG_Tcl_SetConstantObj(interp, "osgeo::SRS_PT_VANDERGRINTEN", SWIG_FromCharPtr(SRS_PT_VANDERGRINTEN));
+   SWIG_Tcl_SetConstantObj(interp, "osgeo::SRS_PT_KROVAK", SWIG_FromCharPtr(SRS_PT_KROVAK));
+   SWIG_Tcl_SetConstantObj(interp, "osgeo::SRS_PP_CENTRAL_MERIDIAN", SWIG_FromCharPtr(SRS_PP_CENTRAL_MERIDIAN));
+   SWIG_Tcl_SetConstantObj(interp, "osgeo::SRS_PP_SCALE_FACTOR", SWIG_FromCharPtr(SRS_PP_SCALE_FACTOR));
+   SWIG_Tcl_SetConstantObj(interp, "osgeo::SRS_PP_STANDARD_PARALLEL_1", SWIG_FromCharPtr(SRS_PP_STANDARD_PARALLEL_1));
+   SWIG_Tcl_SetConstantObj(interp, "osgeo::SRS_PP_STANDARD_PARALLEL_2", SWIG_FromCharPtr(SRS_PP_STANDARD_PARALLEL_2));
+   SWIG_Tcl_SetConstantObj(interp, "osgeo::SRS_PP_PSEUDO_STD_PARALLEL_1", SWIG_FromCharPtr(SRS_PP_PSEUDO_STD_PARALLEL_1));
+   SWIG_Tcl_SetConstantObj(interp, "osgeo::SRS_PP_LONGITUDE_OF_CENTER", SWIG_FromCharPtr(SRS_PP_LONGITUDE_OF_CENTER));
+   SWIG_Tcl_SetConstantObj(interp, "osgeo::SRS_PP_LATITUDE_OF_CENTER", SWIG_FromCharPtr(SRS_PP_LATITUDE_OF_CENTER));
+   SWIG_Tcl_SetConstantObj(interp, "osgeo::SRS_PP_LONGITUDE_OF_ORIGIN", SWIG_FromCharPtr(SRS_PP_LONGITUDE_OF_ORIGIN));
+   SWIG_Tcl_SetConstantObj(interp, "osgeo::SRS_PP_LATITUDE_OF_ORIGIN", SWIG_FromCharPtr(SRS_PP_LATITUDE_OF_ORIGIN));
+   SWIG_Tcl_SetConstantObj(interp, "osgeo::SRS_PP_FALSE_EASTING", SWIG_FromCharPtr(SRS_PP_FALSE_EASTING));
+   SWIG_Tcl_SetConstantObj(interp, "osgeo::SRS_PP_FALSE_NORTHING", SWIG_FromCharPtr(SRS_PP_FALSE_NORTHING));
+   SWIG_Tcl_SetConstantObj(interp, "osgeo::SRS_PP_AZIMUTH", SWIG_FromCharPtr(SRS_PP_AZIMUTH));
+   SWIG_Tcl_SetConstantObj(interp, "osgeo::SRS_PP_LONGITUDE_OF_POINT_1", SWIG_FromCharPtr(SRS_PP_LONGITUDE_OF_POINT_1));
+   SWIG_Tcl_SetConstantObj(interp, "osgeo::SRS_PP_LATITUDE_OF_POINT_1", SWIG_FromCharPtr(SRS_PP_LATITUDE_OF_POINT_1));
+   SWIG_Tcl_SetConstantObj(interp, "osgeo::SRS_PP_LONGITUDE_OF_POINT_2", SWIG_FromCharPtr(SRS_PP_LONGITUDE_OF_POINT_2));
+   SWIG_Tcl_SetConstantObj(interp, "osgeo::SRS_PP_LATITUDE_OF_POINT_2", SWIG_FromCharPtr(SRS_PP_LATITUDE_OF_POINT_2));
+   SWIG_Tcl_SetConstantObj(interp, "osgeo::SRS_PP_LONGITUDE_OF_POINT_3", SWIG_FromCharPtr(SRS_PP_LONGITUDE_OF_POINT_3));
+   SWIG_Tcl_SetConstantObj(interp, "osgeo::SRS_PP_LATITUDE_OF_POINT_3", SWIG_FromCharPtr(SRS_PP_LATITUDE_OF_POINT_3));
+   SWIG_Tcl_SetConstantObj(interp, "osgeo::SRS_PP_RECTIFIED_GRID_ANGLE", SWIG_FromCharPtr(SRS_PP_RECTIFIED_GRID_ANGLE));
+   SWIG_Tcl_SetConstantObj(interp, "osgeo::SRS_PP_LANDSAT_NUMBER", SWIG_FromCharPtr(SRS_PP_LANDSAT_NUMBER));
+   SWIG_Tcl_SetConstantObj(interp, "osgeo::SRS_PP_PATH_NUMBER", SWIG_FromCharPtr(SRS_PP_PATH_NUMBER));
+   SWIG_Tcl_SetConstantObj(interp, "osgeo::SRS_PP_PERSPECTIVE_POINT_HEIGHT", SWIG_FromCharPtr(SRS_PP_PERSPECTIVE_POINT_HEIGHT));
+   SWIG_Tcl_SetConstantObj(interp, "osgeo::SRS_PP_FIPSZONE", SWIG_FromCharPtr(SRS_PP_FIPSZONE));
+   SWIG_Tcl_SetConstantObj(interp, "osgeo::SRS_PP_ZONE", SWIG_FromCharPtr(SRS_PP_ZONE));
+   SWIG_Tcl_SetConstantObj(interp, "osgeo::SRS_UL_METER", SWIG_FromCharPtr(SRS_UL_METER));
+   SWIG_Tcl_SetConstantObj(interp, "osgeo::SRS_UL_FOOT", SWIG_FromCharPtr(SRS_UL_FOOT));
+   SWIG_Tcl_SetConstantObj(interp, "osgeo::SRS_UL_FOOT_CONV", SWIG_FromCharPtr(SRS_UL_FOOT_CONV));
+   SWIG_Tcl_SetConstantObj(interp, "osgeo::SRS_UL_US_FOOT", SWIG_FromCharPtr(SRS_UL_US_FOOT));
+   SWIG_Tcl_SetConstantObj(interp, "osgeo::SRS_UL_US_FOOT_CONV", SWIG_FromCharPtr(SRS_UL_US_FOOT_CONV));
+   SWIG_Tcl_SetConstantObj(interp, "osgeo::SRS_UL_NAUTICAL_MILE", SWIG_FromCharPtr(SRS_UL_NAUTICAL_MILE));
+   SWIG_Tcl_SetConstantObj(interp, "osgeo::SRS_UL_NAUTICAL_MILE_CONV", SWIG_FromCharPtr(SRS_UL_NAUTICAL_MILE_CONV));
+   SWIG_Tcl_SetConstantObj(interp, "osgeo::SRS_UL_LINK", SWIG_FromCharPtr(SRS_UL_LINK));
+   SWIG_Tcl_SetConstantObj(interp, "osgeo::SRS_UL_LINK_CONV", SWIG_FromCharPtr(SRS_UL_LINK_CONV));
+   SWIG_Tcl_SetConstantObj(interp, "osgeo::SRS_UL_CHAIN", SWIG_FromCharPtr(SRS_UL_CHAIN));
+   SWIG_Tcl_SetConstantObj(interp, "osgeo::SRS_UL_CHAIN_CONV", SWIG_FromCharPtr(SRS_UL_CHAIN_CONV));
+   SWIG_Tcl_SetConstantObj(interp, "osgeo::SRS_UL_ROD", SWIG_FromCharPtr(SRS_UL_ROD));
+   SWIG_Tcl_SetConstantObj(interp, "osgeo::SRS_UL_ROD_CONV", SWIG_FromCharPtr(SRS_UL_ROD_CONV));
+   SWIG_Tcl_SetConstantObj(interp, "osgeo::SRS_DN_NAD27", SWIG_FromCharPtr(SRS_DN_NAD27));
+   SWIG_Tcl_SetConstantObj(interp, "osgeo::SRS_DN_NAD83", SWIG_FromCharPtr(SRS_DN_NAD83));
+   SWIG_Tcl_SetConstantObj(interp, "osgeo::SRS_DN_WGS72", SWIG_FromCharPtr(SRS_DN_WGS72));
+   SWIG_Tcl_SetConstantObj(interp, "osgeo::SRS_DN_WGS84", SWIG_FromCharPtr(SRS_DN_WGS84));
+   SWIG_Tcl_SetConstantObj(interp, "osgeo::SRS_WGS84_SEMIMAJOR", SWIG_From_double(static_cast< double >(SRS_WGS84_SEMIMAJOR)));
+   SWIG_Tcl_SetConstantObj(interp, "osgeo::SRS_WGS84_INVFLATTENING", SWIG_From_double(static_cast< double >(SRS_WGS84_INVFLATTENING)));
+   return TCL_OK;
+ }
+ SWIGEXPORT int Osr_SafeInit(Tcl_Interp *interp) {
+   return SWIG_init(interp);
+ }
+ 
Files gdal-1.6.1/swig/tcl/tests/data/DTU_logo.gif and gdal-1.6.1-patched/swig/tcl/tests/data/DTU_logo.gif differ
Files gdal-1.6.1/swig/tcl/tests/data/gdalicon.png and gdal-1.6.1-patched/swig/tcl/tests/data/gdalicon.png differ
diff -rNc gdal-1.6.1/swig/tcl/tests/gdal-cmds-vars.tcl gdal-1.6.1-patched/swig/tcl/tests/gdal-cmds-vars.tcl
*** gdal-1.6.1/swig/tcl/tests/gdal-cmds-vars.tcl	1970-01-01 02:00:00.000000000 +0200
--- gdal-1.6.1-patched/swig/tcl/tests/gdal-cmds-vars.tcl	2009-06-28 23:03:10.000000000 +0300
***************
*** 0 ****
--- 1,12 ----
+ #!/usr/local/bin/tclsh8.5
+ load ../gdal.so
+ 
+ foreach a [lsort [info commands osgeo::*]] {
+     puts "Command: $a"
+ }
+ foreach a [lsort [info procs osgeo::*]] {
+     puts "Proc: $a {[info args $a]}"
+ }
+ foreach a [lsort [info vars osgeo::*]] {
+     puts "Var: $a = [set $a]"
+ }
diff -rNc gdal-1.6.1/swig/tcl/tests/gdal-commands.txt gdal-1.6.1-patched/swig/tcl/tests/gdal-commands.txt
*** gdal-1.6.1/swig/tcl/tests/gdal-commands.txt	1970-01-01 02:00:00.000000000 +0200
--- gdal-1.6.1-patched/swig/tcl/tests/gdal-commands.txt	2009-06-29 17:19:28.000000000 +0300
***************
*** 0 ****
--- 1 ----
+ ::osgeo::AllRegister ::osgeo::AutoCreateWarpedVRT ::osgeo::Band ::osgeo::Band_Checksum ::osgeo::Band_ComputeBandStats ::osgeo::Band_ComputeRasterMinMax ::osgeo::Band_CreateMaskBand ::osgeo::Band_DataType_get ::osgeo::Band_Fill ::osgeo::Band_FlushCache ::osgeo::Band_GetBlockSize ::osgeo::Band_GetColorTable ::osgeo::Band_GetDefaultHistogram ::osgeo::Band_GetDefaultRAT ::osgeo::Band_GetHistogram ::osgeo::Band_GetMaskBand ::osgeo::Band_GetMaskFlags ::osgeo::Band_GetMaximum ::osgeo::Band_GetMinimum ::osgeo::Band_GetNoDataValue ::osgeo::Band_GetOffset ::osgeo::Band_GetOverview ::osgeo::Band_GetOverviewCount ::osgeo::Band_GetRasterCategoryNames ::osgeo::Band_GetRasterColorInterpretation ::osgeo::Band_GetRasterColorTable ::osgeo::Band_GetScale ::osgeo::Band_GetStatistics ::osgeo::Band_ReadRaster ::osgeo::Band_SetColorTable ::osgeo::Band_SetDefaultHistogram ::osgeo::Band_SetDefaultRAT ::osgeo::Band_SetNoDataValue ::osgeo::Band_SetRasterCategoryNames ::osgeo::Band_SetRasterColorInterpretation ::osgeo::Band_SetRasterColorTable ::osgeo::Band_SetStatistics ::osgeo::Band_WriteRaster ::osgeo::Band_XSize_get ::osgeo::Band_YSize_get ::osgeo::CPLBinaryToHex ::osgeo::CPLHexToBinary ::osgeo::ColorEntry ::osgeo::ColorEntry_c1_get ::osgeo::ColorEntry_c1_set ::osgeo::ColorEntry_c2_get ::osgeo::ColorEntry_c2_set ::osgeo::ColorEntry_c3_get ::osgeo::ColorEntry_c3_set ::osgeo::ColorEntry_c4_get ::osgeo::ColorEntry_c4_set ::osgeo::ColorTable ::osgeo::ColorTable_Clone ::osgeo::ColorTable_CreateColorRamp ::osgeo::ColorTable_GetColorEntry ::osgeo::ColorTable_GetColorEntryAsRGB ::osgeo::ColorTable_GetCount ::osgeo::ColorTable_GetPaletteInterpretation ::osgeo::ColorTable_SetColorEntry ::osgeo::ComputeMedianCutPCT ::osgeo::ComputeProximity ::osgeo::DataTypeIsComplex ::osgeo::DataTypeUnion ::osgeo::Dataset ::osgeo::Dataset_AddBand ::osgeo::Dataset_BuildOverviews ::osgeo::Dataset_CreateMaskBand ::osgeo::Dataset_FlushCache ::osgeo::Dataset_GetDriver ::osgeo::Dataset_GetFileList ::osgeo::Dataset_GetGCPCount ::osgeo::Dataset_GetGCPProjection ::osgeo::Dataset_GetGCPs ::osgeo::Dataset_GetGeoTransform ::osgeo::Dataset_GetProjection ::osgeo::Dataset_GetProjectionRef ::osgeo::Dataset_GetRasterBand ::osgeo::Dataset_RasterCount_get ::osgeo::Dataset_RasterXSize_get ::osgeo::Dataset_RasterYSize_get ::osgeo::Dataset_ReadRaster ::osgeo::Dataset_SetGCPs ::osgeo::Dataset_SetGeoTransform ::osgeo::Dataset_SetProjection ::osgeo::Dataset_WriteRaster ::osgeo::Debug ::osgeo::DecToDMS ::osgeo::DecToPackedDMS ::osgeo::DitherRGB2PCT ::osgeo::DontUseExceptions ::osgeo::Driver ::osgeo::Driver_Create ::osgeo::Driver_CreateCopy ::osgeo::Driver_Delete ::osgeo::Driver_Deregister ::osgeo::Driver_HelpTopic_get ::osgeo::Driver_LongName_get ::osgeo::Driver_Register ::osgeo::Driver_Rename ::osgeo::Driver_ShortName_get ::osgeo::Error ::osgeo::ErrorReset ::osgeo::EscapeString ::osgeo::FindFile ::osgeo::FinderClean ::osgeo::GCP ::osgeo::GCP_GCPLine_get ::osgeo::GCP_GCPLine_set ::osgeo::GCP_GCPPixel_get ::osgeo::GCP_GCPPixel_set ::osgeo::GCP_GCPX_get ::osgeo::GCP_GCPX_set ::osgeo::GCP_GCPY_get ::osgeo::GCP_GCPY_set ::osgeo::GCP_GCPZ_get ::osgeo::GCP_GCPZ_set ::osgeo::GCP_Id_get ::osgeo::GCP_Id_set ::osgeo::GCP_Info_get ::osgeo::GCP_Info_set ::osgeo::GCPsToGeoTransform ::osgeo::GDALDestroyDriverManager ::osgeo::GDAL_GCP_GCPLine_get ::osgeo::GDAL_GCP_GCPLine_set ::osgeo::GDAL_GCP_GCPPixel_get ::osgeo::GDAL_GCP_GCPPixel_set ::osgeo::GDAL_GCP_GCPX_get ::osgeo::GDAL_GCP_GCPX_set ::osgeo::GDAL_GCP_GCPY_get ::osgeo::GDAL_GCP_GCPY_set ::osgeo::GDAL_GCP_GCPZ_get ::osgeo::GDAL_GCP_GCPZ_set ::osgeo::GDAL_GCP_Id_get ::osgeo::GDAL_GCP_Id_set ::osgeo::GDAL_GCP_Info_get ::osgeo::GDAL_GCP_Info_set ::osgeo::GDAL_GCP_get_GCPLine ::osgeo::GDAL_GCP_get_GCPPixel ::osgeo::GDAL_GCP_get_GCPX ::osgeo::GDAL_GCP_get_GCPY ::osgeo::GDAL_GCP_get_GCPZ ::osgeo::GDAL_GCP_get_Id ::osgeo::GDAL_GCP_get_Info ::osgeo::GDAL_GCP_set_GCPLine ::osgeo::GDAL_GCP_set_GCPPixel ::osgeo::GDAL_GCP_set_GCPX ::osgeo::GDAL_GCP_set_GCPY ::osgeo::GDAL_GCP_set_GCPZ ::osgeo::GDAL_GCP_set_Id ::osgeo::GDAL_GCP_set_Info ::osgeo::GeneralCmdLineProcessor ::osgeo::GetCacheMax ::osgeo::GetCacheUsed ::osgeo::GetColorInterpretationName ::osgeo::GetConfigOption ::osgeo::GetDataTypeByName ::osgeo::GetDataTypeName ::osgeo::GetDataTypeSize ::osgeo::GetDriver ::osgeo::GetDriverByName ::osgeo::GetDriverCount ::osgeo::GetLastErrorMsg ::osgeo::GetLastErrorNo ::osgeo::GetLastErrorType ::osgeo::GetPaletteInterpretationName ::osgeo::IdentifyDriver ::osgeo::MajorObject ::osgeo::MajorObject_GetDescription ::osgeo::MajorObject_GetMetadataItem ::osgeo::MajorObject_GetMetadata_Dict ::osgeo::MajorObject_GetMetadata_List ::osgeo::MajorObject_SetDescription ::osgeo::MajorObject_SetMetadata ::osgeo::MajorObject_SetMetadataItem ::osgeo::Open ::osgeo::OpenShared ::osgeo::PackedDMSToDec ::osgeo::ParseXMLString ::osgeo::Polygonize ::osgeo::PopErrorHandler ::osgeo::PopFinderLocation ::osgeo::PushErrorHandler ::osgeo::PushFinderLocation ::osgeo::RasterAttributeTable ::osgeo::RasterAttributeTable_Clone ::osgeo::RasterAttributeTable_CreateColumn ::osgeo::RasterAttributeTable_GetColOfUsage ::osgeo::RasterAttributeTable_GetColumnCount ::osgeo::RasterAttributeTable_GetNameOfCol ::osgeo::RasterAttributeTable_GetRowCount ::osgeo::RasterAttributeTable_GetRowOfValue ::osgeo::RasterAttributeTable_GetTypeOfCol ::osgeo::RasterAttributeTable_GetUsageOfCol ::osgeo::RasterAttributeTable_GetValueAsDouble ::osgeo::RasterAttributeTable_GetValueAsInt ::osgeo::RasterAttributeTable_GetValueAsString ::osgeo::RasterAttributeTable_SetRowCount ::osgeo::RasterAttributeTable_SetValueAsDouble ::osgeo::RasterAttributeTable_SetValueAsInt ::osgeo::RasterAttributeTable_SetValueAsString ::osgeo::RasterizeLayer ::osgeo::ReadDir ::osgeo::RegenerateOverview ::osgeo::RegenerateOverviews ::osgeo::ReprojectImage ::osgeo::SerializeXMLTree ::osgeo::SetCacheMax ::osgeo::SetConfigOption ::osgeo::SieveFilter ::osgeo::TermProgress_nocb ::osgeo::Transformer ::osgeo::Transformer_TransformPoint ::osgeo::Transformer_TransformPoints ::osgeo::UseExceptions ::osgeo::VersionInfo ::osgeo::delete_ColorEntry ::osgeo::delete_ColorTable ::osgeo::delete_Dataset ::osgeo::delete_GCP ::osgeo::delete_RasterAttributeTable ::osgeo::delete_Transformer ::osgeo::new_ColorEntry ::osgeo::new_ColorTable ::osgeo::new_GCP ::osgeo::new_RasterAttributeTable ::osgeo::new_Transformer
diff -rNc gdal-1.6.1/swig/tcl/tests/gdal.tcl gdal-1.6.1-patched/swig/tcl/tests/gdal.tcl
*** gdal-1.6.1/swig/tcl/tests/gdal.tcl	1970-01-01 02:00:00.000000000 +0200
--- gdal-1.6.1-patched/swig/tcl/tests/gdal.tcl	2009-06-30 00:02:21.000000000 +0300
***************
*** 0 ****
--- 1,208 ----
+ #!/usr/local/bin/tclsh8.5
+ package require tcltest
+ namespace import tcltest::*
+ configure -verbose {body error pass skip}
+ 
+ load ../gdalconst.so
+ load ../gdal.so
+ 
+ set PNG [file join data gdalicon.png]
+ set GIF [file join data DTU_logo.gif]
+ 
+ # Driver: configure cget -acquire -disown -delete Create CreateCopy Delete Rename Register Deregister GetDescription SetDescription GetMetadata_Dict GetMetadata_List SetMetadata GetMetadataItem SetMetadataItem
+ 
+ # Dataset: configure cget -acquire -disown -delete GetDriver GetRasterBand GetProjection GetProjectionRef SetProjection GetGeoTransform SetGeoTransform BuildOverviews GetGCPCount GetGCPProjection GetGCPs SetGCPs FlushCache AddBand CreateMaskBand GetFileList WriteRaster ReadRaster GetDescription SetDescription GetMetadata_Dict GetMetadata_List SetMetadata GetMetadataItem SetMetadataItem
+ 
+ proc intersect3 {lista listb} {
+     lassign {} L C R
+ 
+     foreach a $lista {
+         if {$a ni $listb} {
+             # $a unique in lista
+             lappend L $a
+         } else {
+             # $a is in the intersection
+             lappend C $a
+         }
+     }
+ 
+     foreach a $listb {
+         if {$a ni $lista} {
+             # $a unique in listb
+             lappend R $a
+         } else {
+             # $a is in the intersection
+             lappend C $a
+         }
+     }
+ 
+     return [list $L $C $R]
+ }
+ 
+ ### Checks that there are no more or less commands and variables than expected ###
+ 
+ test Commands {Test the existance of all available GDAL Tcl commands} -body {
+     set fd [open gdal-commands.txt r]
+     lassign [intersect3 [read $fd] [info commands osgeo::*]] L C R
+     close $fd
+     concat $L $R
+ }
+ 
+ test Variables {Test the existance of all available GDAL Tcl variables/constants} -body {
+     set fd [open gdal-variables.txt r]
+     lassign [intersect3 [read $fd] [info vars osgeo::*]] L C R
+     close $fd
+     concat $L $R
+ }
+ 
+ ### GDAL Datatypes ###
+ 
+ test GDALGetDataTypeSize {::osgeo::GetDataTypeSize} -body {
+     ::osgeo::GetDataTypeSize $::osgeo::GDT_Float64
+ } -result 64
+ 
+ test GDALGetDataTypeName {::osgeo::GetDataTypeName} -body {
+     ::osgeo::GetDataTypeName $::osgeo::GDT_UInt16
+ } -result UInt16
+ 
+ test GDALGetDataTypeByName {::osgeo::GetDataTypeByName} -body {
+     ::osgeo::GetDataTypeByName Byte
+ } -result $::osgeo::GDT_Byte
+ 
+ test GDALDataTypeIsComplex {::osgeo::DataTypeIsComplex} -body {
+     ::osgeo::DataTypeIsComplex $::osgeo::GDT_CInt32
+ } -result 1
+ 
+ test GDALDataTypeUnion {::osgeo::DataTypeUnion} -body {
+     ::osgeo::DataTypeUnion $::osgeo::GDT_CFloat32 $::osgeo::GDT_Int32
+ } -result $::osgeo::GDT_CFloat32
+ 
+ ### Init ###
+ 
+ test GDALAllRegister {::osgeo::AllRegister} -body {
+     ::osgeo::AllRegister
+ }
+ 
+ ### Driver ###
+ 
+ test GDALIdentifyDriver {::osgeo::IdentifyDriver} -body {
+     set driver [::osgeo::IdentifyDriver $PNG]
+     set {} {}
+ }
+ 
+ test GDALGetMetada(GDALDriver) {$driver GetMetadata_Dict} -body {
+     $driver GetMetadata_Dict
+ } -result [dict create DMD_LONGNAME {Portable Network Graphics} DMD_HELPTOPIC frmt_various.html#PNG DMD_EXTENSION png DMD_MIMETYPE image/png DMD_CREATIONDATATYPES {Byte UInt16} DMD_CREATIONOPTIONLIST {<CreationOptionList>
+    <Option name='WORLDFILE' type='boolean' description='Create world file'/>
+ </CreationOptionList>
+ } DCAP_VIRTUALIO YES DCAP_CREATECOPY YES]
+ 
+ test GDALGetMetada(GDALDriver) {$driver GetMetadata_List} -body {
+     $driver GetMetadata_List
+ } -result [list {DMD_LONGNAME=Portable Network Graphics} DMD_HELPTOPIC=frmt_various.html#PNG DMD_EXTENSION=png DMD_MIMETYPE=image/png {DMD_CREATIONDATATYPES=Byte UInt16} {DMD_CREATIONOPTIONLIST=<CreationOptionList>
+    <Option name='WORLDFILE' type='boolean' description='Create world file'/>
+ </CreationOptionList>
+ } DCAP_VIRTUALIO=YES DCAP_CREATECOPY=YES]
+ 
+ test GDALGetDriverShortName {$driver cget -ShortName} -body {
+     $driver cget -ShortName
+ } -result {PNG}
+ 
+ test GDALGetDriverLongName {$driver cget -LongName} -body {
+     $driver cget -LongName
+ } -result {Portable Network Graphics}
+ 
+ test GDALGetDriverHelpTopic {$driver cget -HelpTopic} -body {
+     $driver cget -HelpTopic
+ } -result {frmt_various.html#PNG}
+ 
+ test GDALGetDescription(GDALDriver) {$driver GetDescription} -body {
+     $driver GetDescription
+ } -result {PNG}
+ 
+ test GDALSetDescription(GDALDriver) {$driver SetDescription} -body {
+     $driver SetDescription PNG2
+     $driver GetDescription
+ } -result {PNG2}
+ 
+ if 0 { 
+ #XXX
+ test GDALCopyDatasetFiles {$driver CreateCopy} -body {
+     $driver CreateCopy ${PNG}_new $PNG
+ }
+ 
+ test GDALRenameDataset {$driver Rename} -body {
+     $driver Rename ${PNG}_renamed ${PNG}_new
+ }
+ 
+ test GDALDeleteDataset {$driver Delete} -body {
+     $driver Delete ${PNG}_renamed
+ }
+ }
+ 
+ test GDALDestroyDriver {$driver -delete} -body {
+     $driver -delete
+     catch { $driver GetDescription }
+ } -result 1
+ 
+ ### Dataset ###
+ 
+ test GDALOpen {::osgeo::Open} -body {
+     set dataset [::osgeo::Open $PNG $::osgeo::GA_ReadOnly]
+     set {} {}
+ }
+ 
+ test GDALGetDatasetDriver {$dataset GetDriver} -body {
+     set driver [$dataset GetDriver]
+     set {} {}
+ }
+ 
+ test GDALGetRasterXSize {$dataset cget -RasterXSize} -body {
+     $dataset cget -RasterXSize
+ } -result {32}
+ 
+ test GDALGetRasterYSize {$dataset cget -RasterYSize} -body {
+     $dataset cget -RasterYSize
+ } -result {32}
+ 
+ test GDALGetRasterCount {$dataset cget -RasterCount} -body {
+     $dataset cget -RasterCount
+ } -result {4}
+ 
+ test GDALClose {$dataset -delete} -body {
+     $dataset -delete
+     catch { $dataset GetDescription }
+ } -result 1
+ 
+ test GDALOpenShared {::osgeo::OpenShared} -body {
+     set dataset [::osgeo::OpenShared $PNG $::osgeo::GA_ReadOnly]
+     set {} {}
+ } -returnCodes ok
+ 
+ # Note: If you SetDescription GetFileList returns {} then.
+ test GDALGetFileList {$dataset GetFileList} -body {
+     $dataset GetFileList
+ } -result {data/gdalicon.png}
+ 
+ test GDALGetDescription(GDALDataset) {$dataset GetDescription} -body {
+     $dataset GetDescription
+ } -result {data/gdalicon.png}
+ 
+ test GDALSetDescription(GDALDataset) {$dataset SetDescription} -body {
+     $dataset SetDescription data/gdalicon.png2
+     $dataset GetDescription
+ } -result {data/gdalicon.png2}
+ 
+ test GDALGetMetada(GDALDataset) {$dataset GetMetadata_Dict} -body {
+     $dataset GetMetadata_Dict
+ } -result [dict create]
+ 
+ test GDALGetMetada(GDALDataset) {$dataset GetMetadata_List} -body {
+     $dataset GetMetadata_List
+ } -result [list]
+ 
+ ### Band ###
+ 
+ #ZZZ
+ 
+ cleanupTests
diff -rNc gdal-1.6.1/swig/tcl/tests/gdal-variables.txt gdal-1.6.1-patched/swig/tcl/tests/gdal-variables.txt
*** gdal-1.6.1/swig/tcl/tests/gdal-variables.txt	1970-01-01 02:00:00.000000000 +0200
--- gdal-1.6.1-patched/swig/tcl/tests/gdal-variables.txt	2009-06-29 17:19:12.000000000 +0300
***************
*** 0 ****
--- 1 ----
+ ::osgeo::CE_Debug ::osgeo::CE_Failure ::osgeo::CE_Fatal ::osgeo::CE_None ::osgeo::CE_Warning ::osgeo::CPLES_BackslashQuotable ::osgeo::CPLES_CSV ::osgeo::CPLES_SQL ::osgeo::CPLES_URL ::osgeo::CPLES_XML ::osgeo::CPLE_AppDefined ::osgeo::CPLE_AssertionFailed ::osgeo::CPLE_FileIO ::osgeo::CPLE_IllegalArg ::osgeo::CPLE_NoWriteAccess ::osgeo::CPLE_None ::osgeo::CPLE_NotSupported ::osgeo::CPLE_OpenFailed ::osgeo::CPLE_OutOfMemory ::osgeo::CPLE_UserInterrupt ::osgeo::CXT_Attribute ::osgeo::CXT_Comment ::osgeo::CXT_Element ::osgeo::CXT_Literal ::osgeo::CXT_Text ::osgeo::DCAP_CREATE ::osgeo::DCAP_CREATECOPY ::osgeo::DMD_CREATIONDATATYPES ::osgeo::DMD_CREATIONOPTIONLIST ::osgeo::DMD_EXTENSION ::osgeo::DMD_HELPTOPIC ::osgeo::DMD_LONGNAME ::osgeo::DMD_MIMETYPE ::osgeo::GA_ReadOnly ::osgeo::GA_Update ::osgeo::GCI_AlphaBand ::osgeo::GCI_BlackBand ::osgeo::GCI_BlueBand ::osgeo::GCI_CyanBand ::osgeo::GCI_GrayIndex ::osgeo::GCI_GreenBand ::osgeo::GCI_HueBand ::osgeo::GCI_LightnessBand ::osgeo::GCI_MagentaBand ::osgeo::GCI_PaletteIndex ::osgeo::GCI_RedBand ::osgeo::GCI_SaturationBand ::osgeo::GCI_Undefined ::osgeo::GCI_YellowBand ::osgeo::GDT_Byte ::osgeo::GDT_CFloat32 ::osgeo::GDT_CFloat64 ::osgeo::GDT_CInt16 ::osgeo::GDT_CInt32 ::osgeo::GDT_Float32 ::osgeo::GDT_Float64 ::osgeo::GDT_Int16 ::osgeo::GDT_Int32 ::osgeo::GDT_TypeCount ::osgeo::GDT_UInt16 ::osgeo::GDT_UInt32 ::osgeo::GDT_Unknown ::osgeo::GFT_Integer ::osgeo::GFT_Real ::osgeo::GFT_String ::osgeo::GFU_Alpha ::osgeo::GFU_AlphaMax ::osgeo::GFU_AlphaMin ::osgeo::GFU_Blue ::osgeo::GFU_BlueMax ::osgeo::GFU_BlueMin ::osgeo::GFU_Generic ::osgeo::GFU_Green ::osgeo::GFU_GreenMax ::osgeo::GFU_GreenMin ::osgeo::GFU_Max ::osgeo::GFU_MaxCount ::osgeo::GFU_Min ::osgeo::GFU_MinMax ::osgeo::GFU_Name ::osgeo::GFU_PixelCount ::osgeo::GFU_Red ::osgeo::GFU_RedMax ::osgeo::GFU_RedMin ::osgeo::GF_Read ::osgeo::GF_Write ::osgeo::GMF_ALL_VALID ::osgeo::GMF_ALPHA ::osgeo::GMF_NODATA ::osgeo::GMF_PER_DATASET ::osgeo::GPI_CMYK ::osgeo::GPI_Gray ::osgeo::GPI_HLS ::osgeo::GPI_RGB ::osgeo::GRA_Bilinear ::osgeo::GRA_Cubic ::osgeo::GRA_CubicSpline ::osgeo::GRA_Lanczos ::osgeo::GRA_NearestNeighbour ::osgeo::TermProgress
diff -rNc gdal-1.6.1/swig/tcl/tests/ogr-cmds-vars.tcl gdal-1.6.1-patched/swig/tcl/tests/ogr-cmds-vars.tcl
*** gdal-1.6.1/swig/tcl/tests/ogr-cmds-vars.tcl	1970-01-01 02:00:00.000000000 +0200
--- gdal-1.6.1-patched/swig/tcl/tests/ogr-cmds-vars.tcl	2009-06-28 22:56:28.000000000 +0300
***************
*** 0 ****
--- 1,12 ----
+ #!/usr/local/bin/tclsh8.5
+ load ../ogr.so
+ 
+ foreach a [lsort [info commands osgeo::*]] {
+     puts "Command: $a"
+ }
+ foreach a [lsort [info procs osgeo::*]] {
+     puts "Proc: $a {[info args $a]}"
+ }
+ foreach a [lsort [info vars osgeo::*]] {
+     puts "Var: $a = [set $a]"
+ }
