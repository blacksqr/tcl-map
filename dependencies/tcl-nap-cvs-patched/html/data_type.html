<?xml version="1.0" encoding="iso-8859-1"?>
<!-- $Id: data_type.html,v 1.10 2006/03/01 00:36:20 dav480 Exp $ -->
<html>
  <head>
    <meta name="generator"
    content="HTML Tidy for Windows (vers 1 September 2005), see www.w3.org" />
    <title>Data Types</title>
  </head>
  <body>
  <center>
    <h2>Data Types</h2>
  </center>
  <h3>Table of Contents</h3>
  <ol>
    <li>
      <a href="#data-types">NAP Data-types</a>
    </li>
    <li>
      <a href="#constant">Data-type of Constants</a>
    </li>
    <li>
      <a href="#functions">Data-type Conversion Functions</a>
    </li>
    <li>
      <a href="#result">Data-type of result of operation</a>
    </li>
  </ol>
  <h3>
    <a name="data-types">NAP Data-types</a>
  </h3>A NAO can have any of the following data-types:
  <table border="1">
    <tr>
      <th align="center">Name</th>
      <th align="center">Description</th>
    </tr>
    <tr>
      <td>
        <code>c8</code>
      </td>
      <td>8-bit character</td>
    </tr>
    <tr>
      <td>
        <code>i8</code>
      </td>
      <td>8-bit signed integer</td>
    </tr>
    <tr>
      <td>
        <code>i16</code>
      </td>
      <td>16-bit signed integer</td>
    </tr>
    <tr>
      <td>
        <code>i32</code>
      </td>
      <td>32-bit signed integer</td>
    </tr>
    <tr>
      <td>
        <code>u8</code>
      </td>
      <td>8-bit unsigned integer</td>
    </tr>
    <tr>
      <td>
        <code>u16</code>
      </td>
      <td>16-bit unsigned integer</td>
    </tr>
    <tr>
      <td>
        <code>u32</code>
      </td>
      <td>32-bit unsigned integer</td>
    </tr>
    <tr>
      <td>
        <code>f32</code>
      </td>
      <td>32-bit floating-point</td>
    </tr>
    <tr>
      <td>
        <code>f64</code>
      </td>
      <td>64-bit floating-point</td>
    </tr>
    <tr>
      <td>
        <code>ragged</code>
      </td>
      <td>compressed</td>
    </tr>
    <tr>
      <td>
        <code>boxed</code>
      </td>
      <td>slot numbers</td>
    </tr>
  </table>
  <p>The 
  <code>ragged</code> type provides an efficient way of storing arrays
  with many missing values around the edges.</p>
  <p>A 
  <code>boxed</code> NAO contains slot numbers pointing to other NAOs.
  This allows one to construct arrays (normally vectors) of arrays.
  Boxed vectors are generated by the 
  <a href="op.html#Link">Link Operators &quot;<code>...</code>&quot; and &quot;<code>,</code>&quot;</a>. Boxed vectors are used</p>
  <ul>
    <li>to pass multiple arguments to a function</li>
    <li>to return multiple results from a function</li>
    <li>in 
    <em>cross-product indexing</em></li>
    <li>to generate 
    <em>arithmetic progressions</em> with step sizes other than 1 and
    -1</li>
  </ul>Boxed vectors can be unpacked using function 
  <code>open_box(</code> 
  <var>x</var> 
  <code>)</code>, which is described in 
  <a href="function.html#Special_Data_types">Functions related to Special Data-types</a>.
  <h3>
    <a name="constant">Data-type of Constants</a>
  </h3>
  <p>A scalar constant can contain a data-type suffix, as in:</p>
  <pre>
% [nap &quot;3.7f32&quot;] all
::NAP::53-53  f32  MissingValue: NaN  References: 0
Value:
3.7
% [nap &quot;123u8&quot;] all
::NAP::55-55  u8  MissingValue: (NULL)  References: 0
Value:
123
</pre>
The following examples show that if there is no such suffix then
floating-point values are treated as 
  <code>f64</code> while integer values are treated as 
  <code>i32</code>:
  <pre>
% [nap &quot;3.7&quot;] all
::NAP::57-57  f64  MissingValue: NaN  References: 0
Value:
3.7
% [nap &quot;123&quot;] all
::NAP::58-58  i32  MissingValue: -2147483648  References: 0
Value:
123
</pre>
  <h3>
    <a name="functions">Data-type Conversion Functions</a>
  </h3>There is a function with the name of each data-type except 
  <code>ragged</code> and 
  <code>boxed</code>. Each such function converts its argument to that
  data-type. For example:
  <pre>
% [nap &quot;f64(123)&quot;] all
::NAP::62-62  f64  MissingValue: NaN  References: 0
Value:
123
% [nap &quot;c8(123)&quot;] all; # ascii character 123
::NAP::66-66  c8  MissingValue: (NULL)  References: 0
Value:
{
% [nap &quot;f32({123 -1.2 0})&quot;] all; # vector with 3 elements
::NAP::70-70  f32  MissingValue: NaN  References: 0
Dimension 0   Size: 3      Name: (NULL)    Coordinate-variable: (NULL)
Value:
123 -1.2 0
</pre>
  <p>The parentheses 
  <code>()</code> in these three examples are not needed. Deleting
  them:</p>
  <pre>
% [nap &quot;f64 123&quot;] all
::NAP::26-26  f64  MissingValue: NaN  References: 0
Value:
123
% [nap &quot;c8 123&quot;] all
::NAP::29-29  c8  MissingValue: (NULL)  References: 0
Value:
{
% [nap &quot;f32{123 -1.2 0}&quot;] all
::NAP::33-33  f32  MissingValue: NaN  References: 0
Dimension 0   Size: 3      Name: (NULL)    Coordinate-variable: (NULL)
Value:
123 -1.2 0
</pre>
  <h3>
    <a name="result">Data-type of result of operation</a>
  </h3>
  <p>Many operations (defined by an operator or a function) produce a
  result whose data-type matches that of their operands/arguments (if
  these all have the same data-type). The following examples illustrate
  this for the 
  <em>subtract</em> operator:</p>
  <pre>
% [nap &quot;3 - 1&quot;] all
::NAP::57-57  i32  MissingValue: -2147483648  References: 0  Unit:
(NULL)
Value:
2
% [nap &quot;3f32 - 1f32&quot;] all
::NAP::61-61  f32  MissingValue: NaN  References: 0  Unit: (NULL)
Value:
2
% [nap &quot;3u8 - 1u8&quot;] all
::NAP::65-65  u8  MissingValue: 255  References: 0  Unit: (NULL)
Value:
2
</pre>
  <p>What happens if the operands differ in data-type? Let&#39;s try
  adding 
  <code>f32</code> and 
  <code>f64</code> values:</p>
  <pre>
% [nap &quot;234f32 + 3.5f64&quot;] all
::NAP::40-40  f64  MissingValue: NaN  References: 0
Value:
237.5
</pre>
The result is of type 
  <code>f64</code>, so there is no loss of precision. Next let&#39;s
  try adding 
  <code>i32</code> and 
  <code>f32</code> values:
  <pre>
% [nap &quot;234 + 3.5f32&quot;] all
::NAP::54-54  f64  MissingValue: NaN  References: 0  Unit: (NULL)
Value:
237.5
</pre>
  <p>Why is the result 
  <code>f64</code> rather than 
  <code>f32</code>? This prevents possible loss of precision, as
  in:</p>
  <pre>
% [nap &quot;f32(123456789) + 5f32&quot;] all -format %d
::NAP::48-48  f32  MissingValue: NaN  References: 0  Unit: (NULL)
Value:
123456800
</pre>
This is due to the fact that an 
  <code>i32</code> value has 31 bits (9.3 digits) of precision, whereas
  an 
  <code>f32</code> value has only 24 bits (7.2 digits) of precision. So
  both operands must be converted to 
  <code>f64</code> before the addition takes place. This is shown by:
  <pre>
% [nap &quot;123456789 + 5f32&quot;] all -format %d
::NAP::43-43  f64  MissingValue: NaN  References: 0  Unit: (NULL)
Value:
123456794
</pre>
  <p>Some operations produce a result whose data-type is independent of
  the types of the operands. In particular, relational and logical
  operators always produce an 
  <code>i8</code> result with value 1 for true and 0 for false. The
  following illustrates the &quot;<code>&gt;</code>&quot; operator:</p>
  <pre>
% [nap &quot;9 &gt; 8&quot;] all
::NAP::43-43  i8  MissingValue: (NULL)  References: 0
Value:
1
</pre>
  <table width="100%" border="0" cellspacing="0" cellpadding="2"
  bgcolor="#737B9C">
    <tr>
      <td align="center">
        <font color="#FFFFFF" size="-2">
          <span class="titlebar">
          <b>Author:</b> 
          <a href="http://sourceforge.net/users/dav480/">Harvey
          Davies</a> &#160; &#160; &#160; © 2002, CSIRO Australia.
          &#160; &#160; &#160; 
          <a href="http://www.csiro.au/legalnotices/disclaimer.html">Legal
          Notice and Disclaimer</a>
          <br />
          <b>CVS Version Details:</b> $Id: data_type.html,v 1.5
          2005/02/02 00:41:43 dav480 Exp $</span>
        </font>
      </td>
    </tr>
  </table></body>
</html>
